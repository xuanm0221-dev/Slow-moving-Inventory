/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snowflake-sdk";
exports.ids = ["vendor-chunks/snowflake-sdk"];
exports.modules = {

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./lib/snowflake */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/snowflake.js\");\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdUhBQTJDO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2luZGV4LmpzP2VkMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3Nub3dmbGFrZScpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*\n * This software is licensed under the MIT License.\n *\n * Copyright Fedor Indutny, 2015.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst process = __webpack_require__(/*! process */ \"process\");\nconst ocsp = __webpack_require__(/*! @techteamer/ocsp */ \"(rsc)/./node_modules/@techteamer/ocsp/lib/ocsp.js\");\nconst rfc2560 = __webpack_require__(/*! asn1.js-rfc2560 */ \"(rsc)/./node_modules/asn1.js-rfc2560/index.js\");\nconst rfc5280 = __webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst bn = __webpack_require__(/*! bn.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst TOLERABLE_VALIDITY_RANGE_RATIO = 0.01;\nconst MAX_CLOCK_SKEW_IN_MILLISECONDS = 900000;\nconst MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS = 18000000;\n/**\n * Builds the certificate id for a given certificate.\n *\n * @param cert\n * @returns {*}\n */\nexports.buildCertId = function (cert) {\n    let issuer = cert.issuerCertificate;\n    cert = cert.raw;\n    try {\n        cert = rfc5280.Certificate.decode(cert, 'der');\n        if (issuer) {\n            issuer = issuer.raw;\n            issuer = rfc5280.Certificate.decode(issuer, 'der');\n        }\n    }\n    catch (e) {\n        return null; // if we encountered an error during decoding, return null\n    }\n    const tbsCert = cert.tbsCertificate;\n    const tbsIssuer = issuer.tbsCertificate;\n    const certID = {\n        hashAlgorithm: {\n            // algorithm: [ 2, 16, 840, 1, 101, 3, 4, 2, 1 ]  // sha256\n            algorithm: [1, 3, 14, 3, 2, 26], // sha1\n        },\n        issuerNameHash: sha1(rfc5280.Name.encode(tbsCert.issuer, 'der')),\n        issuerKeyHash: sha1(tbsIssuer.subjectPublicKeyInfo.subjectPublicKey.data),\n        serialNumber: tbsCert.serialNumber,\n    };\n    const certIDDer = rfc2560.CertID.encode(certID, 'der');\n    return encodeKey(certIDDer.toString('BASE64'));\n};\nfunction sha1(data) {\n    return crypto.createHash('sha1').update(data).digest();\n}\n/**\n * Parses a certificate and returns an object that contains decoded versions\n * of the certificate and its issuer.\n *\n * Note: this method might throw an error, so use a try-catch when calling it.\n *\n * @param cert\n * @returns {{cert: *, issuer: *}}\n */\nexports.decode = function (cert) {\n    let issuer = cert.issuerCertificate;\n    cert = cert.raw;\n    // note: this block might throw an error\n    cert = rfc5280.Certificate.decode(cert, 'der');\n    if (issuer) {\n        issuer = issuer.raw;\n        issuer = rfc5280.Certificate.decode(issuer, 'der');\n    }\n    return {\n        cert: cert,\n        issuer: issuer,\n    };\n};\n/**\n * Encode certID to a cache key\n * @param base64Key {Object}\n * @return cache key {string}\n */\nconst encodeKey = function (base64Key) {\n    const buff = Buffer.from(base64Key, 'base64');\n    const certID = rfc2560.CertID.decode(buff, 'der');\n    return (certID.issuerNameHash.toString('BASE64') +\n        '#' +\n        certID.issuerKeyHash.toString('BASE64') +\n        '#' +\n        certID.serialNumber.toString(10));\n};\nexports.encodeKey = encodeKey;\n/**\n * Encode certID to a cache key\n * @param cacheKey {Object}\n */\nconst decodeKey = function (cacheKey) {\n    // serialNumber.eq(certID.serialNumber)\n    const keys = cacheKey.split('#');\n    const issuerNameHash = Buffer.from(keys[0], 'base64');\n    const issuerKeyHash = Buffer.from(keys[1], 'base64');\n    const serialNumber = new bn(keys[2], 10);\n    const certID = {\n        hashAlgorithm: {\n            // algorithm: [ 2, 16, 840, 1, 101, 3, 4, 2, 1 ]  // sha256\n            algorithm: [1, 3, 14, 3, 2, 26], // sha1\n        },\n        issuerNameHash: issuerNameHash,\n        issuerKeyHash: issuerKeyHash,\n        serialNumber: serialNumber,\n    };\n    const certIDDer = rfc2560.CertID.encode(certID, 'der');\n    return certIDDer.toString('BASE64');\n};\nexports.decodeKey = decodeKey;\n/**\n * Calculates Tolerable validity\n * @param thisUpdate last update\n * @param nextUpdate next update\n * @returns {number}\n */\nconst calculateTolerableVadility = function (thisUpdate, nextUpdate) {\n    const currentRange = (nextUpdate - thisUpdate) * TOLERABLE_VALIDITY_RANGE_RATIO;\n    return currentRange > MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS\n        ? currentRange\n        : MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS;\n};\n/**\n * Checks the validity\n * @param currentTime current time\n * @param thisUpdate last update\n * @param nextUpdate next update\n * @return {boolean}\n */\nconst isValidityRange = function (currentTime, thisUpdate, nextUpdate) {\n    const tolerableValidity = calculateTolerableVadility(thisUpdate, nextUpdate);\n    return (thisUpdate - MAX_CLOCK_SKEW_IN_MILLISECONDS <= currentTime &&\n        currentTime <= nextUpdate + tolerableValidity);\n};\nexports.isValidityRange = isValidityRange;\n/**\n * Converts a epoch time in milliseconds to a UTC datetime string\n * @param epochInMilliSeconds\n * @returns {Date}\n */\nconst toUTCString = function (epochInMilliSeconds) {\n    return new Date(epochInMilliSeconds);\n};\n/**\n * Return issuer certificate or signing certificate\n * @param issuer issuer certificate\n * @param certs\n * @param raws\n */\nconst findResponder = function (issuer, certs, raws) {\n    let issuerKey = issuer.tbsCertificate.subjectPublicKeyInfo;\n    issuerKey = ocsp.utils.toPEM(rfc5280.SubjectPublicKeyInfo.encode(issuerKey, 'der'), 'PUBLIC KEY');\n    if (certs.length > 0) {\n        const currentTime = Date.now();\n        const cert = certs[0];\n        const certValidity = cert.tbsCertificate.validity;\n        if (certValidity.notAfter.value < currentTime || certValidity.notBefore.value > currentTime) {\n            return {\n                err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_CERTIFICATE_VALIDITY, 'Valid from:', toUTCString(certValidity.notBefore.value), ', Valid to:', toUTCString(certValidity.notAfter.value)),\n                responderKey: null,\n            };\n        }\n        const signAlg = ocsp.utils.sign[cert.signatureAlgorithm.algorithm.join('.')];\n        if (!signAlg) {\n            return {\n                err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_SIGNATURE_ALGORITHM),\n                responderKey: null,\n            };\n        }\n        const verify = crypto.createVerify(signAlg);\n        verify.update(raws[0]);\n        if (!verify.verify(issuerKey, cert.signature.data)) {\n            return {\n                err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_SIGNATURE),\n                responderKey: null,\n            };\n        }\n        let certKey = cert.tbsCertificate.subjectPublicKeyInfo;\n        certKey = ocsp.utils.toPEM(rfc5280.SubjectPublicKeyInfo.encode(certKey, 'der'), 'PUBLIC KEY');\n        return { err: null, responderKey: certKey };\n    }\n    return { err: null, responderKey: issuerKey };\n};\n/**\n * Verify OCSP response. If issuer is not specified, the signature will not be\n * verified.\n * @param issuer issuer certificate\n * @param rawRes OCSP Response\n * @returns {{success, error, revoked}|{res, success, error}}\n */\nconst verifyOCSPResponse = function (issuer, rawRes) {\n    function done(err) {\n        return {\n            err: err,\n            res: rawRes,\n        };\n    }\n    let res;\n    try {\n        res = ocsp.utils.parseResponse(rawRes);\n    }\n    catch (e) {\n        return done(e);\n    }\n    const value = res.value;\n    if (issuer) {\n        // verify signature only if issuer is given\n        const certs = res.certs;\n        const rawTBS = rawRes.slice(res.start, res.end);\n        const raws = res.certsTbs.map(function (tbs) {\n            return rawRes.slice(tbs.start, tbs.end);\n        });\n        const signAlg = ocsp.utils.sign[value.signatureAlgorithm.algorithm.join('.')];\n        if (!signAlg) {\n            return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_SIGNATURE_ALGORITHM));\n        }\n        const responderStatus = findResponder(issuer, certs, raws);\n        if (responderStatus.err) {\n            return done(responderStatus.err);\n        }\n        const responderKey = responderStatus.responderKey;\n        const v = crypto.createVerify(signAlg);\n        const signature = value.signature.data;\n        v.update(rawTBS);\n        if (!v.verify(responderKey, signature)) {\n            return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_SIGNATURE));\n        }\n    }\n    const tbs = value.tbsResponseData;\n    if (tbs.responses.length < 1) {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_RESPONSE));\n    }\n    const sd = tbs.responses[0];\n    if (sd.certStatus.type === 'revoked') {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_REVOKED));\n    }\n    const currentTime = Date.now();\n    const isInjectValidity = process.env.SF_OCSP_TEST_INJECT_VALIDITY_ERROR || '';\n    if (isInjectValidity.toLowerCase() === 'true' ||\n        !isValidityRange(currentTime, sd.thisUpdate, sd.nextUpdate)) {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_VALIDITY, 'Valid from:', toUTCString(sd.thisUpdate), ', Valid to:', toUTCString(sd.nextUpdate)));\n    }\n    const isInjectUnknown = process.env.SF_OCSP_TEST_INJECT_UNKNOWN_STATUS || '';\n    if (isInjectUnknown.toLowerCase() === 'true' || sd.certStatus.type === 'unknown') {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_UNKNOWN));\n    }\n    if (sd.certStatus.type === 'good') {\n        return done(null);\n    }\n    return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_UNKNOWN_STATE));\n};\nexports.verifyOCSPResponse = verifyOCSPResponse;\n//# sourceMappingURL=cert_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jZXJ0X3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsd0JBQVM7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDJFQUFrQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsOEVBQU87QUFDMUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixFQUFFO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYWdlbnQvY2VydF91dGlsLmpzPzJlZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCBGZWRvciBJbmR1dG55LCAyMDE1LlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbid1c2Ugc3RyaWN0JztcbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG5jb25zdCBvY3NwID0gcmVxdWlyZSgnQHRlY2h0ZWFtZXIvb2NzcCcpO1xuY29uc3QgcmZjMjU2MCA9IHJlcXVpcmUoJ2FzbjEuanMtcmZjMjU2MCcpO1xuY29uc3QgcmZjNTI4MCA9IHJlcXVpcmUoJ2FzbjEuanMtcmZjNTI4MCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBUT0xFUkFCTEVfVkFMSURJVFlfUkFOR0VfUkFUSU8gPSAwLjAxO1xuY29uc3QgTUFYX0NMT0NLX1NLRVdfSU5fTUlMTElTRUNPTkRTID0gOTAwMDAwO1xuY29uc3QgTUlOX0NBQ0hFX1dBUk1VUF9USU1FX0lOX01JTExJU0VDT05EUyA9IDE4MDAwMDAwO1xuLyoqXG4gKiBCdWlsZHMgdGhlIGNlcnRpZmljYXRlIGlkIGZvciBhIGdpdmVuIGNlcnRpZmljYXRlLlxuICpcbiAqIEBwYXJhbSBjZXJ0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5idWlsZENlcnRJZCA9IGZ1bmN0aW9uIChjZXJ0KSB7XG4gICAgbGV0IGlzc3VlciA9IGNlcnQuaXNzdWVyQ2VydGlmaWNhdGU7XG4gICAgY2VydCA9IGNlcnQucmF3O1xuICAgIHRyeSB7XG4gICAgICAgIGNlcnQgPSByZmM1MjgwLkNlcnRpZmljYXRlLmRlY29kZShjZXJ0LCAnZGVyJyk7XG4gICAgICAgIGlmIChpc3N1ZXIpIHtcbiAgICAgICAgICAgIGlzc3VlciA9IGlzc3Vlci5yYXc7XG4gICAgICAgICAgICBpc3N1ZXIgPSByZmM1MjgwLkNlcnRpZmljYXRlLmRlY29kZShpc3N1ZXIsICdkZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gaWYgd2UgZW5jb3VudGVyZWQgYW4gZXJyb3IgZHVyaW5nIGRlY29kaW5nLCByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBjb25zdCB0YnNDZXJ0ID0gY2VydC50YnNDZXJ0aWZpY2F0ZTtcbiAgICBjb25zdCB0YnNJc3N1ZXIgPSBpc3N1ZXIudGJzQ2VydGlmaWNhdGU7XG4gICAgY29uc3QgY2VydElEID0ge1xuICAgICAgICBoYXNoQWxnb3JpdGhtOiB7XG4gICAgICAgICAgICAvLyBhbGdvcml0aG06IFsgMiwgMTYsIDg0MCwgMSwgMTAxLCAzLCA0LCAyLCAxIF0gIC8vIHNoYTI1NlxuICAgICAgICAgICAgYWxnb3JpdGhtOiBbMSwgMywgMTQsIDMsIDIsIDI2XSwgLy8gc2hhMVxuICAgICAgICB9LFxuICAgICAgICBpc3N1ZXJOYW1lSGFzaDogc2hhMShyZmM1MjgwLk5hbWUuZW5jb2RlKHRic0NlcnQuaXNzdWVyLCAnZGVyJykpLFxuICAgICAgICBpc3N1ZXJLZXlIYXNoOiBzaGExKHRic0lzc3Vlci5zdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LmRhdGEpLFxuICAgICAgICBzZXJpYWxOdW1iZXI6IHRic0NlcnQuc2VyaWFsTnVtYmVyLFxuICAgIH07XG4gICAgY29uc3QgY2VydElERGVyID0gcmZjMjU2MC5DZXJ0SUQuZW5jb2RlKGNlcnRJRCwgJ2RlcicpO1xuICAgIHJldHVybiBlbmNvZGVLZXkoY2VydElERGVyLnRvU3RyaW5nKCdCQVNFNjQnKSk7XG59O1xuZnVuY3Rpb24gc2hhMShkYXRhKSB7XG4gICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBjZXJ0aWZpY2F0ZSBhbmQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWNvZGVkIHZlcnNpb25zXG4gKiBvZiB0aGUgY2VydGlmaWNhdGUgYW5kIGl0cyBpc3N1ZXIuXG4gKlxuICogTm90ZTogdGhpcyBtZXRob2QgbWlnaHQgdGhyb3cgYW4gZXJyb3IsIHNvIHVzZSBhIHRyeS1jYXRjaCB3aGVuIGNhbGxpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNlcnRcbiAqIEByZXR1cm5zIHt7Y2VydDogKiwgaXNzdWVyOiAqfX1cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2VydCkge1xuICAgIGxldCBpc3N1ZXIgPSBjZXJ0Lmlzc3VlckNlcnRpZmljYXRlO1xuICAgIGNlcnQgPSBjZXJ0LnJhdztcbiAgICAvLyBub3RlOiB0aGlzIGJsb2NrIG1pZ2h0IHRocm93IGFuIGVycm9yXG4gICAgY2VydCA9IHJmYzUyODAuQ2VydGlmaWNhdGUuZGVjb2RlKGNlcnQsICdkZXInKTtcbiAgICBpZiAoaXNzdWVyKSB7XG4gICAgICAgIGlzc3VlciA9IGlzc3Vlci5yYXc7XG4gICAgICAgIGlzc3VlciA9IHJmYzUyODAuQ2VydGlmaWNhdGUuZGVjb2RlKGlzc3VlciwgJ2RlcicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjZXJ0OiBjZXJ0LFxuICAgICAgICBpc3N1ZXI6IGlzc3VlcixcbiAgICB9O1xufTtcbi8qKlxuICogRW5jb2RlIGNlcnRJRCB0byBhIGNhY2hlIGtleVxuICogQHBhcmFtIGJhc2U2NEtleSB7T2JqZWN0fVxuICogQHJldHVybiBjYWNoZSBrZXkge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlS2V5ID0gZnVuY3Rpb24gKGJhc2U2NEtleSkge1xuICAgIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuZnJvbShiYXNlNjRLZXksICdiYXNlNjQnKTtcbiAgICBjb25zdCBjZXJ0SUQgPSByZmMyNTYwLkNlcnRJRC5kZWNvZGUoYnVmZiwgJ2RlcicpO1xuICAgIHJldHVybiAoY2VydElELmlzc3Vlck5hbWVIYXNoLnRvU3RyaW5nKCdCQVNFNjQnKSArXG4gICAgICAgICcjJyArXG4gICAgICAgIGNlcnRJRC5pc3N1ZXJLZXlIYXNoLnRvU3RyaW5nKCdCQVNFNjQnKSArXG4gICAgICAgICcjJyArXG4gICAgICAgIGNlcnRJRC5zZXJpYWxOdW1iZXIudG9TdHJpbmcoMTApKTtcbn07XG5leHBvcnRzLmVuY29kZUtleSA9IGVuY29kZUtleTtcbi8qKlxuICogRW5jb2RlIGNlcnRJRCB0byBhIGNhY2hlIGtleVxuICogQHBhcmFtIGNhY2hlS2V5IHtPYmplY3R9XG4gKi9cbmNvbnN0IGRlY29kZUtleSA9IGZ1bmN0aW9uIChjYWNoZUtleSkge1xuICAgIC8vIHNlcmlhbE51bWJlci5lcShjZXJ0SUQuc2VyaWFsTnVtYmVyKVxuICAgIGNvbnN0IGtleXMgPSBjYWNoZUtleS5zcGxpdCgnIycpO1xuICAgIGNvbnN0IGlzc3Vlck5hbWVIYXNoID0gQnVmZmVyLmZyb20oa2V5c1swXSwgJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGlzc3VlcktleUhhc2ggPSBCdWZmZXIuZnJvbShrZXlzWzFdLCAnYmFzZTY0Jyk7XG4gICAgY29uc3Qgc2VyaWFsTnVtYmVyID0gbmV3IGJuKGtleXNbMl0sIDEwKTtcbiAgICBjb25zdCBjZXJ0SUQgPSB7XG4gICAgICAgIGhhc2hBbGdvcml0aG06IHtcbiAgICAgICAgICAgIC8vIGFsZ29yaXRobTogWyAyLCAxNiwgODQwLCAxLCAxMDEsIDMsIDQsIDIsIDEgXSAgLy8gc2hhMjU2XG4gICAgICAgICAgICBhbGdvcml0aG06IFsxLCAzLCAxNCwgMywgMiwgMjZdLCAvLyBzaGExXG4gICAgICAgIH0sXG4gICAgICAgIGlzc3Vlck5hbWVIYXNoOiBpc3N1ZXJOYW1lSGFzaCxcbiAgICAgICAgaXNzdWVyS2V5SGFzaDogaXNzdWVyS2V5SGFzaCxcbiAgICAgICAgc2VyaWFsTnVtYmVyOiBzZXJpYWxOdW1iZXIsXG4gICAgfTtcbiAgICBjb25zdCBjZXJ0SUREZXIgPSByZmMyNTYwLkNlcnRJRC5lbmNvZGUoY2VydElELCAnZGVyJyk7XG4gICAgcmV0dXJuIGNlcnRJRERlci50b1N0cmluZygnQkFTRTY0Jyk7XG59O1xuZXhwb3J0cy5kZWNvZGVLZXkgPSBkZWNvZGVLZXk7XG4vKipcbiAqIENhbGN1bGF0ZXMgVG9sZXJhYmxlIHZhbGlkaXR5XG4gKiBAcGFyYW0gdGhpc1VwZGF0ZSBsYXN0IHVwZGF0ZVxuICogQHBhcmFtIG5leHRVcGRhdGUgbmV4dCB1cGRhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVRvbGVyYWJsZVZhZGlsaXR5ID0gZnVuY3Rpb24gKHRoaXNVcGRhdGUsIG5leHRVcGRhdGUpIHtcbiAgICBjb25zdCBjdXJyZW50UmFuZ2UgPSAobmV4dFVwZGF0ZSAtIHRoaXNVcGRhdGUpICogVE9MRVJBQkxFX1ZBTElESVRZX1JBTkdFX1JBVElPO1xuICAgIHJldHVybiBjdXJyZW50UmFuZ2UgPiBNSU5fQ0FDSEVfV0FSTVVQX1RJTUVfSU5fTUlMTElTRUNPTkRTXG4gICAgICAgID8gY3VycmVudFJhbmdlXG4gICAgICAgIDogTUlOX0NBQ0hFX1dBUk1VUF9USU1FX0lOX01JTExJU0VDT05EUztcbn07XG4vKipcbiAqIENoZWNrcyB0aGUgdmFsaWRpdHlcbiAqIEBwYXJhbSBjdXJyZW50VGltZSBjdXJyZW50IHRpbWVcbiAqIEBwYXJhbSB0aGlzVXBkYXRlIGxhc3QgdXBkYXRlXG4gKiBAcGFyYW0gbmV4dFVwZGF0ZSBuZXh0IHVwZGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNWYWxpZGl0eVJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCB0aGlzVXBkYXRlLCBuZXh0VXBkYXRlKSB7XG4gICAgY29uc3QgdG9sZXJhYmxlVmFsaWRpdHkgPSBjYWxjdWxhdGVUb2xlcmFibGVWYWRpbGl0eSh0aGlzVXBkYXRlLCBuZXh0VXBkYXRlKTtcbiAgICByZXR1cm4gKHRoaXNVcGRhdGUgLSBNQVhfQ0xPQ0tfU0tFV19JTl9NSUxMSVNFQ09ORFMgPD0gY3VycmVudFRpbWUgJiZcbiAgICAgICAgY3VycmVudFRpbWUgPD0gbmV4dFVwZGF0ZSArIHRvbGVyYWJsZVZhbGlkaXR5KTtcbn07XG5leHBvcnRzLmlzVmFsaWRpdHlSYW5nZSA9IGlzVmFsaWRpdHlSYW5nZTtcbi8qKlxuICogQ29udmVydHMgYSBlcG9jaCB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBhIFVUQyBkYXRldGltZSBzdHJpbmdcbiAqIEBwYXJhbSBlcG9jaEluTWlsbGlTZWNvbmRzXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuY29uc3QgdG9VVENTdHJpbmcgPSBmdW5jdGlvbiAoZXBvY2hJbk1pbGxpU2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgRGF0ZShlcG9jaEluTWlsbGlTZWNvbmRzKTtcbn07XG4vKipcbiAqIFJldHVybiBpc3N1ZXIgY2VydGlmaWNhdGUgb3Igc2lnbmluZyBjZXJ0aWZpY2F0ZVxuICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgY2VydGlmaWNhdGVcbiAqIEBwYXJhbSBjZXJ0c1xuICogQHBhcmFtIHJhd3NcbiAqL1xuY29uc3QgZmluZFJlc3BvbmRlciA9IGZ1bmN0aW9uIChpc3N1ZXIsIGNlcnRzLCByYXdzKSB7XG4gICAgbGV0IGlzc3VlcktleSA9IGlzc3Vlci50YnNDZXJ0aWZpY2F0ZS5zdWJqZWN0UHVibGljS2V5SW5mbztcbiAgICBpc3N1ZXJLZXkgPSBvY3NwLnV0aWxzLnRvUEVNKHJmYzUyODAuU3ViamVjdFB1YmxpY0tleUluZm8uZW5jb2RlKGlzc3VlcktleSwgJ2RlcicpLCAnUFVCTElDIEtFWScpO1xuICAgIGlmIChjZXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgY2VydCA9IGNlcnRzWzBdO1xuICAgICAgICBjb25zdCBjZXJ0VmFsaWRpdHkgPSBjZXJ0LnRic0NlcnRpZmljYXRlLnZhbGlkaXR5O1xuICAgICAgICBpZiAoY2VydFZhbGlkaXR5Lm5vdEFmdGVyLnZhbHVlIDwgY3VycmVudFRpbWUgfHwgY2VydFZhbGlkaXR5Lm5vdEJlZm9yZS52YWx1ZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycjogRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0lOVkFMSURfQ0VSVElGSUNBVEVfVkFMSURJVFksICdWYWxpZCBmcm9tOicsIHRvVVRDU3RyaW5nKGNlcnRWYWxpZGl0eS5ub3RCZWZvcmUudmFsdWUpLCAnLCBWYWxpZCB0bzonLCB0b1VUQ1N0cmluZyhjZXJ0VmFsaWRpdHkubm90QWZ0ZXIudmFsdWUpKSxcbiAgICAgICAgICAgICAgICByZXNwb25kZXJLZXk6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25BbGcgPSBvY3NwLnV0aWxzLnNpZ25bY2VydC5zaWduYXR1cmVBbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKV07XG4gICAgICAgIGlmICghc2lnbkFsZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnI6IEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9OT19TSUdOQVRVUkVfQUxHT1JJVEhNKSxcbiAgICAgICAgICAgICAgICByZXNwb25kZXJLZXk6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcmlmeSA9IGNyeXB0by5jcmVhdGVWZXJpZnkoc2lnbkFsZyk7XG4gICAgICAgIHZlcmlmeS51cGRhdGUocmF3c1swXSk7XG4gICAgICAgIGlmICghdmVyaWZ5LnZlcmlmeShpc3N1ZXJLZXksIGNlcnQuc2lnbmF0dXJlLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycjogRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0lOVkFMSURfU0lHTkFUVVJFKSxcbiAgICAgICAgICAgICAgICByZXNwb25kZXJLZXk6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjZXJ0S2V5ID0gY2VydC50YnNDZXJ0aWZpY2F0ZS5zdWJqZWN0UHVibGljS2V5SW5mbztcbiAgICAgICAgY2VydEtleSA9IG9jc3AudXRpbHMudG9QRU0ocmZjNTI4MC5TdWJqZWN0UHVibGljS2V5SW5mby5lbmNvZGUoY2VydEtleSwgJ2RlcicpLCAnUFVCTElDIEtFWScpO1xuICAgICAgICByZXR1cm4geyBlcnI6IG51bGwsIHJlc3BvbmRlcktleTogY2VydEtleSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlcnI6IG51bGwsIHJlc3BvbmRlcktleTogaXNzdWVyS2V5IH07XG59O1xuLyoqXG4gKiBWZXJpZnkgT0NTUCByZXNwb25zZS4gSWYgaXNzdWVyIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBzaWduYXR1cmUgd2lsbCBub3QgYmVcbiAqIHZlcmlmaWVkLlxuICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgY2VydGlmaWNhdGVcbiAqIEBwYXJhbSByYXdSZXMgT0NTUCBSZXNwb25zZVxuICogQHJldHVybnMge3tzdWNjZXNzLCBlcnJvciwgcmV2b2tlZH18e3Jlcywgc3VjY2VzcywgZXJyb3J9fVxuICovXG5jb25zdCB2ZXJpZnlPQ1NQUmVzcG9uc2UgPSBmdW5jdGlvbiAoaXNzdWVyLCByYXdSZXMpIHtcbiAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyOiBlcnIsXG4gICAgICAgICAgICByZXM6IHJhd1JlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgICByZXMgPSBvY3NwLnV0aWxzLnBhcnNlUmVzcG9uc2UocmF3UmVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcmVzLnZhbHVlO1xuICAgIGlmIChpc3N1ZXIpIHtcbiAgICAgICAgLy8gdmVyaWZ5IHNpZ25hdHVyZSBvbmx5IGlmIGlzc3VlciBpcyBnaXZlblxuICAgICAgICBjb25zdCBjZXJ0cyA9IHJlcy5jZXJ0cztcbiAgICAgICAgY29uc3QgcmF3VEJTID0gcmF3UmVzLnNsaWNlKHJlcy5zdGFydCwgcmVzLmVuZCk7XG4gICAgICAgIGNvbnN0IHJhd3MgPSByZXMuY2VydHNUYnMubWFwKGZ1bmN0aW9uICh0YnMpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdSZXMuc2xpY2UodGJzLnN0YXJ0LCB0YnMuZW5kKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25BbGcgPSBvY3NwLnV0aWxzLnNpZ25bdmFsdWUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJyldO1xuICAgICAgICBpZiAoIXNpZ25BbGcpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9OT19TSUdOQVRVUkVfQUxHT1JJVEhNKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uZGVyU3RhdHVzID0gZmluZFJlc3BvbmRlcihpc3N1ZXIsIGNlcnRzLCByYXdzKTtcbiAgICAgICAgaWYgKHJlc3BvbmRlclN0YXR1cy5lcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKHJlc3BvbmRlclN0YXR1cy5lcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbmRlcktleSA9IHJlc3BvbmRlclN0YXR1cy5yZXNwb25kZXJLZXk7XG4gICAgICAgIGNvbnN0IHYgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KHNpZ25BbGcpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWx1ZS5zaWduYXR1cmUuZGF0YTtcbiAgICAgICAgdi51cGRhdGUocmF3VEJTKTtcbiAgICAgICAgaWYgKCF2LnZlcmlmeShyZXNwb25kZXJLZXksIHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9JTlZBTElEX1NJR05BVFVSRSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRicyA9IHZhbHVlLnRic1Jlc3BvbnNlRGF0YTtcbiAgICBpZiAodGJzLnJlc3BvbnNlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9OT19SRVNQT05TRSkpO1xuICAgIH1cbiAgICBjb25zdCBzZCA9IHRicy5yZXNwb25zZXNbMF07XG4gICAgaWYgKHNkLmNlcnRTdGF0dXMudHlwZSA9PT0gJ3Jldm9rZWQnKSB7XG4gICAgICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9SRVZPS0VEKSk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBpc0luamVjdFZhbGlkaXR5ID0gcHJvY2Vzcy5lbnYuU0ZfT0NTUF9URVNUX0lOSkVDVF9WQUxJRElUWV9FUlJPUiB8fCAnJztcbiAgICBpZiAoaXNJbmplY3RWYWxpZGl0eS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScgfHxcbiAgICAgICAgIWlzVmFsaWRpdHlSYW5nZShjdXJyZW50VGltZSwgc2QudGhpc1VwZGF0ZSwgc2QubmV4dFVwZGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0lOVkFMSURfVkFMSURJVFksICdWYWxpZCBmcm9tOicsIHRvVVRDU3RyaW5nKHNkLnRoaXNVcGRhdGUpLCAnLCBWYWxpZCB0bzonLCB0b1VUQ1N0cmluZyhzZC5uZXh0VXBkYXRlKSkpO1xuICAgIH1cbiAgICBjb25zdCBpc0luamVjdFVua25vd24gPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1RFU1RfSU5KRUNUX1VOS05PV05fU1RBVFVTIHx8ICcnO1xuICAgIGlmIChpc0luamVjdFVua25vd24udG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnIHx8IHNkLmNlcnRTdGF0dXMudHlwZSA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9VTktOT1dOKSk7XG4gICAgfVxuICAgIGlmIChzZC5jZXJ0U3RhdHVzLnR5cGUgPT09ICdnb29kJykge1xuICAgICAgICByZXR1cm4gZG9uZShudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbmUoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX1VOS05PV05fU1RBVEUpKTtcbn07XG5leHBvcnRzLnZlcmlmeU9DU1BSZXNwb25zZSA9IHZlcmlmeU9DU1BSZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlcnRfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/check.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/check.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * This software is licensed under the MIT License.\n *\n * Copyright Fedor Indutny, 2015.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst ocsp = __webpack_require__(/*! @techteamer/ocsp */ \"(rsc)/./node_modules/@techteamer/ocsp/lib/ocsp.js\");\nconst rfc2560 = __webpack_require__(/*! asn1.js-rfc2560 */ \"(rsc)/./node_modules/asn1.js-rfc2560/index.js\");\nconst SnowflakeUtil = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * OCSP specific HTTP retryable errors\n * @param statusCode\n * @returns {boolean}\n */\nconst isRetryableHttpError = function (statusCode) {\n    return ((statusCode >= 500 && statusCode < 600) ||\n        statusCode === 404 ||\n        statusCode === 403 ||\n        statusCode === 408);\n};\nfunction getResponse(uri, req, cb) {\n    uri = url.parse(uri);\n    const timeout = process.env.SF_OCSP_TEST_OCSP_RESPONDER_TIMEOUT || 10000;\n    const options = Object.assign({\n        timeout: Number(timeout),\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/ocsp-request',\n            'Content-Length': req.length,\n        },\n    }, uri);\n    function done(err, response) {\n        if (cb) {\n            cb(err, response);\n        }\n        cb = null;\n    }\n    function onResponse(response) {\n        if (response.statusCode < 200 || response.statusCode >= 400) {\n            return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE, response.statusCode), response);\n        }\n        const chunks = [];\n        response.on('readable', function () {\n            const chunk = response.read();\n            if (!chunk) {\n                return;\n            }\n            chunks.push(chunk);\n        });\n        response.on('end', function () {\n            Logger.getInstance().debug('Finish OCSP responder: %s', uri.host);\n            const ocsp = Buffer.concat(chunks);\n            done(null, ocsp);\n        });\n    }\n    const httpRequest = http.request(options, onResponse);\n    httpRequest.on('error', function (e) {\n        if (cb) {\n            cb(e);\n        }\n        cb = null;\n    });\n    httpRequest.on('timeout', function () {\n        httpRequest.abort();\n        Logger.getInstance().debug('Timeout OCSP responder: %s', uri.host);\n        if (cb) {\n            cb(Errors.createOCSPError(ErrorCodes.ERR_OCSP_RESPONDER_TIMEOUT));\n        }\n        cb = null;\n    });\n    httpRequest.end(req);\n}\nmodule.exports = function check(options, cb, mock) {\n    let sync = true;\n    const isFailClosed = GlobalConfig.getOcspMode() === GlobalConfig.ocspModes.FAIL_CLOSED;\n    const maxNumRetries = isFailClosed ? 2 : 1;\n    function done(err, data) {\n        if (sync) {\n            sync = false;\n            process.nextTick(function () {\n                cb(err, data);\n            });\n            return;\n        }\n        cb(err, data);\n    }\n    let req;\n    try {\n        req = mock ? mock.req : ocsp.request.generate(options.cert, options.issuer);\n    }\n    catch (e) {\n        return done(e);\n    }\n    const ocspMethod = rfc2560['id-pkix-ocsp'].join('.');\n    let numRetries = 1;\n    let sleep = 1;\n    function ocspResponseVerify(err, raw) {\n        let retry = false;\n        if (err) {\n            if (Object.prototype.hasOwnProperty.call(err, 'code') &&\n                err.code === ErrorCodes.ERR_OCSP_RESPONDER_TIMEOUT) {\n                retry = true;\n            }\n            else if (Object.prototype.hasOwnProperty.call(err, 'message')) {\n                const errorMessage = err.message.split(' ');\n                if (errorMessage.length === 0) {\n                    return done(err);\n                }\n                try {\n                    const statusCode = parseInt(errorMessage[errorMessage.length - 1], 10);\n                    retry = isRetryableHttpError(statusCode);\n                }\n                catch (e) {\n                    // ignore\n                }\n            }\n            if (numRetries < maxNumRetries && retry) {\n                numRetries++;\n                sleep = SnowflakeUtil.nextSleepTime(1, 10, sleep);\n                setTimeout(ocspRequestSend, sleep * 1000);\n            }\n            else {\n                Logger.getInstance().debug('Failed to all retries to OCSP responder.');\n                return done(err);\n            }\n        }\n        else {\n            const status = CertUtil.verifyOCSPResponse(req.issuer, raw);\n            done(status.err, status);\n        }\n    }\n    function setOcspResponderUrl(uri) {\n        let parsedUrl = (__webpack_require__(/*! url */ \"url\").parse)(process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL);\n        let targetUrl;\n        if (parsedUrl.port) {\n            targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}:${parsedUrl.port}/retry`;\n        }\n        else {\n            targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}/retry`;\n        }\n        const b64data = req.data.toString('base64');\n        parsedUrl = (__webpack_require__(/*! url */ \"url\").parse)(uri);\n        process.env.SF_OCSP_RESPONDER_URL = targetUrl + '/' + parsedUrl.hostname + '/' + b64data;\n    }\n    function ocspRequestCallback(err, uri) {\n        if (err) {\n            //This error message is from @techteamer/ocsp (ocsp.utils.getAuthorityInfo)\n            if (err.message === 'AuthorityInfoAccess not found in extensions') {\n                if (!isFailClosed) {\n                    Logger.getInstance().debug('OCSP Responder URL is missing from the certificate.');\n                    return done(null);\n                }\n                else {\n                    Logger.getInstance().error('OCSP Responder URL is missing from the certificate, so cannot verify with OCSP. Aborting connection attempt due to OCSP being set to FAIL_CLOSE https://docs.snowflake.com/en/user-guide/ocsp#fail-close');\n                }\n            }\n            return done(err);\n        }\n        if (process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL &&\n            process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL.includes('ocsp_response_cache.json')) {\n            setOcspResponderUrl(uri);\n        }\n        const responderUrl = process.env.SF_OCSP_RESPONDER_URL;\n        if (responderUrl) {\n            uri = responderUrl;\n        }\n        Logger.getInstance().trace('Contact OCSP responder: %s, (%s/%s)', uri, numRetries, maxNumRetries);\n        if (!mock) {\n            getResponse(uri, req.data, ocspResponseVerify);\n        }\n    }\n    function ocspRequestSend() {\n        if (!mock) {\n            ocsp.utils.getAuthorityInfo(req.cert, ocspMethod, ocspRequestCallback);\n        }\n        else {\n            ocspRequestCallback(null, mock.uri);\n        }\n    }\n    ocspRequestSend();\n    sync = false;\n};\n//# sourceMappingURL=check.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jaGVjay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQywyRUFBa0I7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFTO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLHNGQUFrQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBb0I7QUFDNUM7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUIsSUFBSSxtQkFBbUIsR0FBRyxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CLElBQUksbUJBQW1CO0FBQ3JFO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NoZWNrLmpzP2VhNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCBGZWRvciBJbmR1dG55LCAyMDE1LlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbid1c2Ugc3RyaWN0JztcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IG9jc3AgPSByZXF1aXJlKCdAdGVjaHRlYW1lci9vY3NwJyk7XG5jb25zdCByZmMyNTYwID0gcmVxdWlyZSgnYXNuMS5qcy1yZmMyNTYwJyk7XG5jb25zdCBTbm93Zmxha2VVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgQ2VydFV0aWwgPSByZXF1aXJlKCcuL2NlcnRfdXRpbCcpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG4vKipcbiAqIE9DU1Agc3BlY2lmaWMgSFRUUCByZXRyeWFibGUgZXJyb3JzXG4gKiBAcGFyYW0gc3RhdHVzQ29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzUmV0cnlhYmxlSHR0cEVycm9yID0gZnVuY3Rpb24gKHN0YXR1c0NvZGUpIHtcbiAgICByZXR1cm4gKChzdGF0dXNDb2RlID49IDUwMCAmJiBzdGF0dXNDb2RlIDwgNjAwKSB8fFxuICAgICAgICBzdGF0dXNDb2RlID09PSA0MDQgfHxcbiAgICAgICAgc3RhdHVzQ29kZSA9PT0gNDAzIHx8XG4gICAgICAgIHN0YXR1c0NvZGUgPT09IDQwOCk7XG59O1xuZnVuY3Rpb24gZ2V0UmVzcG9uc2UodXJpLCByZXEsIGNiKSB7XG4gICAgdXJpID0gdXJsLnBhcnNlKHVyaSk7XG4gICAgY29uc3QgdGltZW91dCA9IHByb2Nlc3MuZW52LlNGX09DU1BfVEVTVF9PQ1NQX1JFU1BPTkRFUl9USU1FT1VUIHx8IDEwMDAwO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdGltZW91dDogTnVtYmVyKHRpbWVvdXQpLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3NwLXJlcXVlc3QnLFxuICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogcmVxLmxlbmd0aCxcbiAgICAgICAgfSxcbiAgICB9LCB1cmkpO1xuICAgIGZ1bmN0aW9uIGRvbmUoZXJyLCByZXNwb25zZSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGVyciwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNiID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0ZBSUxFRF9PQlRBSU5fT0NTUF9SRVNQT05TRSwgcmVzcG9uc2Uuc3RhdHVzQ29kZSksIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgcmVzcG9uc2Uub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSByZXNwb25zZS5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoIWNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGaW5pc2ggT0NTUCByZXNwb25kZXI6ICVzJywgdXJpLmhvc3QpO1xuICAgICAgICAgICAgY29uc3Qgb2NzcCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcbiAgICAgICAgICAgIGRvbmUobnVsbCwgb2NzcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBodHRwUmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zLCBvblJlc3BvbnNlKTtcbiAgICBodHRwUmVxdWVzdC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGUpO1xuICAgICAgICB9XG4gICAgICAgIGNiID0gbnVsbDtcbiAgICB9KTtcbiAgICBodHRwUmVxdWVzdC5vbigndGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1RpbWVvdXQgT0NTUCByZXNwb25kZXI6ICVzJywgdXJpLmhvc3QpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9SRVNQT05ERVJfVElNRU9VVCkpO1xuICAgICAgICB9XG4gICAgICAgIGNiID0gbnVsbDtcbiAgICB9KTtcbiAgICBodHRwUmVxdWVzdC5lbmQocmVxKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2hlY2sob3B0aW9ucywgY2IsIG1vY2spIHtcbiAgICBsZXQgc3luYyA9IHRydWU7XG4gICAgY29uc3QgaXNGYWlsQ2xvc2VkID0gR2xvYmFsQ29uZmlnLmdldE9jc3BNb2RlKCkgPT09IEdsb2JhbENvbmZpZy5vY3NwTW9kZXMuRkFJTF9DTE9TRUQ7XG4gICAgY29uc3QgbWF4TnVtUmV0cmllcyA9IGlzRmFpbENsb3NlZCA/IDIgOiAxO1xuICAgIGZ1bmN0aW9uIGRvbmUoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYihlcnIsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2IoZXJyLCBkYXRhKTtcbiAgICB9XG4gICAgbGV0IHJlcTtcbiAgICB0cnkge1xuICAgICAgICByZXEgPSBtb2NrID8gbW9jay5yZXEgOiBvY3NwLnJlcXVlc3QuZ2VuZXJhdGUob3B0aW9ucy5jZXJ0LCBvcHRpb25zLmlzc3Vlcik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkb25lKGUpO1xuICAgIH1cbiAgICBjb25zdCBvY3NwTWV0aG9kID0gcmZjMjU2MFsnaWQtcGtpeC1vY3NwJ10uam9pbignLicpO1xuICAgIGxldCBudW1SZXRyaWVzID0gMTtcbiAgICBsZXQgc2xlZXAgPSAxO1xuICAgIGZ1bmN0aW9uIG9jc3BSZXNwb25zZVZlcmlmeShlcnIsIHJhdykge1xuICAgICAgICBsZXQgcmV0cnkgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsICdjb2RlJykgJiZcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9PT0gRXJyb3JDb2Rlcy5FUlJfT0NTUF9SRVNQT05ERVJfVElNRU9VVCkge1xuICAgICAgICAgICAgICAgIHJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsICdtZXNzYWdlJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIubWVzc2FnZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBwYXJzZUludChlcnJvck1lc3NhZ2VbZXJyb3JNZXNzYWdlLmxlbmd0aCAtIDFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5ID0gaXNSZXRyeWFibGVIdHRwRXJyb3Ioc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1SZXRyaWVzIDwgbWF4TnVtUmV0cmllcyAmJiByZXRyeSkge1xuICAgICAgICAgICAgICAgIG51bVJldHJpZXMrKztcbiAgICAgICAgICAgICAgICBzbGVlcCA9IFNub3dmbGFrZVV0aWwubmV4dFNsZWVwVGltZSgxLCAxMCwgc2xlZXApO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQob2NzcFJlcXVlc3RTZW5kLCBzbGVlcCAqIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBhbGwgcmV0cmllcyB0byBPQ1NQIHJlc3BvbmRlci4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gQ2VydFV0aWwudmVyaWZ5T0NTUFJlc3BvbnNlKHJlcS5pc3N1ZXIsIHJhdyk7XG4gICAgICAgICAgICBkb25lKHN0YXR1cy5lcnIsIHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0T2NzcFJlc3BvbmRlclVybCh1cmkpIHtcbiAgICAgICAgbGV0IHBhcnNlZFVybCA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlKHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX1VSTCk7XG4gICAgICAgIGxldCB0YXJnZXRVcmw7XG4gICAgICAgIGlmIChwYXJzZWRVcmwucG9ydCkge1xuICAgICAgICAgICAgdGFyZ2V0VXJsID0gYCR7cGFyc2VkVXJsLnByb3RvY29sfS8vJHtwYXJzZWRVcmwuaG9zdG5hbWV9OiR7cGFyc2VkVXJsLnBvcnR9L3JldHJ5YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFVybCA9IGAke3BhcnNlZFVybC5wcm90b2NvbH0vLyR7cGFyc2VkVXJsLmhvc3RuYW1lfS9yZXRyeWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYjY0ZGF0YSA9IHJlcS5kYXRhLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgcGFyc2VkVXJsID0gcmVxdWlyZSgndXJsJykucGFyc2UodXJpKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05ERVJfVVJMID0gdGFyZ2V0VXJsICsgJy8nICsgcGFyc2VkVXJsLmhvc3RuYW1lICsgJy8nICsgYjY0ZGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2NzcFJlcXVlc3RDYWxsYmFjayhlcnIsIHVyaSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAvL1RoaXMgZXJyb3IgbWVzc2FnZSBpcyBmcm9tIEB0ZWNodGVhbWVyL29jc3AgKG9jc3AudXRpbHMuZ2V0QXV0aG9yaXR5SW5mbylcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ0F1dGhvcml0eUluZm9BY2Nlc3Mgbm90IGZvdW5kIGluIGV4dGVuc2lvbnMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZhaWxDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ09DU1AgUmVzcG9uZGVyIFVSTCBpcyBtaXNzaW5nIGZyb20gdGhlIGNlcnRpZmljYXRlLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdPQ1NQIFJlc3BvbmRlciBVUkwgaXMgbWlzc2luZyBmcm9tIHRoZSBjZXJ0aWZpY2F0ZSwgc28gY2Fubm90IHZlcmlmeSB3aXRoIE9DU1AuIEFib3J0aW5nIGNvbm5lY3Rpb24gYXR0ZW1wdCBkdWUgdG8gT0NTUCBiZWluZyBzZXQgdG8gRkFJTF9DTE9TRSBodHRwczovL2RvY3Muc25vd2ZsYWtlLmNvbS9lbi91c2VyLWd1aWRlL29jc3AjZmFpbC1jbG9zZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX1VSTCAmJlxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfVVJMLmluY2x1ZGVzKCdvY3NwX3Jlc3BvbnNlX2NhY2hlLmpzb24nKSkge1xuICAgICAgICAgICAgc2V0T2NzcFJlc3BvbmRlclVybCh1cmkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbmRlclVybCA9IHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OREVSX1VSTDtcbiAgICAgICAgaWYgKHJlc3BvbmRlclVybCkge1xuICAgICAgICAgICAgdXJpID0gcmVzcG9uZGVyVXJsO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb250YWN0IE9DU1AgcmVzcG9uZGVyOiAlcywgKCVzLyVzKScsIHVyaSwgbnVtUmV0cmllcywgbWF4TnVtUmV0cmllcyk7XG4gICAgICAgIGlmICghbW9jaykge1xuICAgICAgICAgICAgZ2V0UmVzcG9uc2UodXJpLCByZXEuZGF0YSwgb2NzcFJlc3BvbnNlVmVyaWZ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvY3NwUmVxdWVzdFNlbmQoKSB7XG4gICAgICAgIGlmICghbW9jaykge1xuICAgICAgICAgICAgb2NzcC51dGlscy5nZXRBdXRob3JpdHlJbmZvKHJlcS5jZXJ0LCBvY3NwTWV0aG9kLCBvY3NwUmVxdWVzdENhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9jc3BSZXF1ZXN0Q2FsbGJhY2sobnVsbCwgbW9jay51cmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9jc3BSZXF1ZXN0U2VuZCgpO1xuICAgIHN5bmMgPSBmYWxzZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVjay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/check.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CRL_MEMORY_CACHE = void 0;\nexports.getCrlFromMemory = getCrlFromMemory;\nexports.setCrlInMemory = setCrlInMemory;\nexports.clearExpiredCrlFromMemoryCache = clearExpiredCrlFromMemoryCache;\nexports.clearExpiredCrlFromDiskCache = clearExpiredCrlFromDiskCache;\nexports.getCrlFromDisk = getCrlFromDisk;\nexports.writeCrlToDisk = writeCrlToDisk;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst promises_1 = __importDefault(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst disk_cache_1 = __webpack_require__(/*! ../disk_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js\");\nconst global_config_typed_1 = __importDefault(__webpack_require__(/*! ../global_config_typed */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nexports.CRL_MEMORY_CACHE = new Map();\nfunction getCrlFromMemory(url) {\n    const cachedEntry = exports.CRL_MEMORY_CACHE.get(url);\n    if (cachedEntry) {\n        if (cachedEntry.expireAt > Date.now()) {\n            return cachedEntry.crl;\n        }\n        else {\n            exports.CRL_MEMORY_CACHE.delete(url);\n            return null;\n        }\n    }\n    else {\n        return null;\n    }\n}\nfunction setCrlInMemory(url, crl) {\n    exports.CRL_MEMORY_CACHE.set(url, {\n        expireAt: Math.min(Date.now() + global_config_typed_1.default.getValue('crlCacheValidityTime'), crl.tbsCertList.nextUpdate.value),\n        crl,\n    });\n}\nfunction clearExpiredCrlFromMemoryCache() {\n    exports.CRL_MEMORY_CACHE.forEach((entry, key) => {\n        if (entry.expireAt < Date.now()) {\n            exports.CRL_MEMORY_CACHE.delete(key);\n        }\n    });\n}\nasync function clearExpiredCrlFromDiskCache() {\n    try {\n        const cacheDir = global_config_typed_1.default.getValue('crlCacheDir');\n        for (const fileName of await promises_1.default.readdir(cacheDir)) {\n            const filePath = path_1.default.join(cacheDir, fileName);\n            const stats = await promises_1.default.stat(filePath);\n            const thirtyDaysAgo = Date.now() - 1000 * 60 * 60 * 24 * 30;\n            // NOTE:\n            // Keeping expired CRLs on disk for 30 days for debugging purposes\n            if (stats.mtime.getTime() < thirtyDaysAgo) {\n                (0, logger_1.default)().debug(`Deleting CRL file ${fileName} older than 30 days.`);\n                await promises_1.default.rm(filePath);\n            }\n        }\n    }\n    catch (error) {\n        if ((0, disk_cache_1.isFileNotFoundError)(error)) {\n            (0, logger_1.default)().debug('CRL cache directory does not exist, skipping cleanup.');\n        }\n        else {\n            (0, logger_1.default)().warn(`Failed to clear expired CRL entries from disk cache: ${error}.`);\n        }\n    }\n}\nasync function getCrlFromDisk(url) {\n    const filePath = path_1.default.join(global_config_typed_1.default.getValue('crlCacheDir'), encodeURIComponent(url));\n    try {\n        const stats = await promises_1.default.stat(filePath);\n        if (Date.now() - stats.mtime.getTime() > global_config_typed_1.default.getValue('crlCacheValidityTime')) {\n            (0, logger_1.default)().debug(`CRL ${filePath} is older than crlCacheValidityTime, ignoring.`);\n            return null;\n        }\n        const rawCrl = await promises_1.default.readFile(filePath);\n        const decodedCrl = asn1_js_rfc5280_1.default.CertificateList.decode(rawCrl, 'der');\n        if (decodedCrl.tbsCertList.nextUpdate.value > Date.now()) {\n            return decodedCrl;\n        }\n        else {\n            (0, logger_1.default)().debug(`CRL ${filePath} is expired, ignoring.`);\n            return null;\n        }\n    }\n    catch (error) {\n        if ((0, disk_cache_1.isFileNotFoundError)(error)) {\n            (0, logger_1.default)().debug(`CRL ${url} not found on disk cache.`);\n        }\n        else {\n            (0, logger_1.default)().warn(`Failed to read CRL ${filePath} from disk cache: ${error}.`);\n        }\n    }\n    return null;\n}\nasync function writeCrlToDisk(url, rawCrl) {\n    const filePath = path_1.default.join(global_config_typed_1.default.getValue('crlCacheDir'), encodeURIComponent(url));\n    try {\n        return (0, disk_cache_1.writeCacheFile)(filePath, rawCrl);\n    }\n    catch (error) {\n        (0, logger_1.default)().warn(`Failed to write CRL ${filePath} to disk cache: ${error}.`);\n    }\n}\n//# sourceMappingURL=crl_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsK0JBQStCLG1CQUFPLENBQUMsa0JBQU07QUFDN0MsbUNBQW1DLG1CQUFPLENBQUMsZ0NBQWE7QUFDeEQsMENBQTBDLG1CQUFPLENBQUMsc0VBQWlCO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFlO0FBQzVDLDhDQUE4QyxtQkFBTyxDQUFDLGtHQUF3QjtBQUM5RSxpQ0FBaUMsbUJBQU8sQ0FBQyx3RUFBVztBQUNwRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsTUFBTTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0EsK0RBQStELFVBQVUsbUJBQW1CLE1BQU07QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVSxpQkFBaUIsTUFBTTtBQUM3RjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NybF9jYWNoZS5qcz81YWRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DUkxfTUVNT1JZX0NBQ0hFID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRDcmxGcm9tTWVtb3J5ID0gZ2V0Q3JsRnJvbU1lbW9yeTtcbmV4cG9ydHMuc2V0Q3JsSW5NZW1vcnkgPSBzZXRDcmxJbk1lbW9yeTtcbmV4cG9ydHMuY2xlYXJFeHBpcmVkQ3JsRnJvbU1lbW9yeUNhY2hlID0gY2xlYXJFeHBpcmVkQ3JsRnJvbU1lbW9yeUNhY2hlO1xuZXhwb3J0cy5jbGVhckV4cGlyZWRDcmxGcm9tRGlza0NhY2hlID0gY2xlYXJFeHBpcmVkQ3JsRnJvbURpc2tDYWNoZTtcbmV4cG9ydHMuZ2V0Q3JsRnJvbURpc2sgPSBnZXRDcmxGcm9tRGlzaztcbmV4cG9ydHMud3JpdGVDcmxUb0Rpc2sgPSB3cml0ZUNybFRvRGlzaztcbmNvbnN0IHBhdGhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGF0aFwiKSk7XG5jb25zdCBwcm9taXNlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmcy9wcm9taXNlc1wiKSk7XG5jb25zdCBhc24xX2pzX3JmYzUyODBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNuMS5qcy1yZmM1MjgwXCIpKTtcbmNvbnN0IGRpc2tfY2FjaGVfMSA9IHJlcXVpcmUoXCIuLi9kaXNrX2NhY2hlXCIpO1xuY29uc3QgZ2xvYmFsX2NvbmZpZ190eXBlZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9nbG9iYWxfY29uZmlnX3R5cGVkXCIpKTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9sb2dnZXJcIikpO1xuZXhwb3J0cy5DUkxfTUVNT1JZX0NBQ0hFID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q3JsRnJvbU1lbW9yeSh1cmwpIHtcbiAgICBjb25zdCBjYWNoZWRFbnRyeSA9IGV4cG9ydHMuQ1JMX01FTU9SWV9DQUNIRS5nZXQodXJsKTtcbiAgICBpZiAoY2FjaGVkRW50cnkpIHtcbiAgICAgICAgaWYgKGNhY2hlZEVudHJ5LmV4cGlyZUF0ID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEVudHJ5LmNybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQ1JMX01FTU9SWV9DQUNIRS5kZWxldGUodXJsKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRDcmxJbk1lbW9yeSh1cmwsIGNybCkge1xuICAgIGV4cG9ydHMuQ1JMX01FTU9SWV9DQUNIRS5zZXQodXJsLCB7XG4gICAgICAgIGV4cGlyZUF0OiBNYXRoLm1pbihEYXRlLm5vdygpICsgZ2xvYmFsX2NvbmZpZ190eXBlZF8xLmRlZmF1bHQuZ2V0VmFsdWUoJ2NybENhY2hlVmFsaWRpdHlUaW1lJyksIGNybC50YnNDZXJ0TGlzdC5uZXh0VXBkYXRlLnZhbHVlKSxcbiAgICAgICAgY3JsLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJFeHBpcmVkQ3JsRnJvbU1lbW9yeUNhY2hlKCkge1xuICAgIGV4cG9ydHMuQ1JMX01FTU9SWV9DQUNIRS5mb3JFYWNoKChlbnRyeSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChlbnRyeS5leHBpcmVBdCA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQ1JMX01FTU9SWV9DQUNIRS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gY2xlYXJFeHBpcmVkQ3JsRnJvbURpc2tDYWNoZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWNoZURpciA9IGdsb2JhbF9jb25maWdfdHlwZWRfMS5kZWZhdWx0LmdldFZhbHVlKCdjcmxDYWNoZURpcicpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIGF3YWl0IHByb21pc2VzXzEuZGVmYXVsdC5yZWFkZGlyKGNhY2hlRGlyKSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoXzEuZGVmYXVsdC5qb2luKGNhY2hlRGlyLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHByb21pc2VzXzEuZGVmYXVsdC5zdGF0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHRoaXJ0eURheXNBZ28gPSBEYXRlLm5vdygpIC0gMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwO1xuICAgICAgICAgICAgLy8gTk9URTpcbiAgICAgICAgICAgIC8vIEtlZXBpbmcgZXhwaXJlZCBDUkxzIG9uIGRpc2sgZm9yIDMwIGRheXMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgICAgaWYgKHN0YXRzLm10aW1lLmdldFRpbWUoKSA8IHRoaXJ0eURheXNBZ28pIHtcbiAgICAgICAgICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZyhgRGVsZXRpbmcgQ1JMIGZpbGUgJHtmaWxlTmFtZX0gb2xkZXIgdGhhbiAzMCBkYXlzLmApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2VzXzEuZGVmYXVsdC5ybShmaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICgoMCwgZGlza19jYWNoZV8xLmlzRmlsZU5vdEZvdW5kRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoJ0NSTCBjYWNoZSBkaXJlY3RvcnkgZG9lcyBub3QgZXhpc3QsIHNraXBwaW5nIGNsZWFudXAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS53YXJuKGBGYWlsZWQgdG8gY2xlYXIgZXhwaXJlZCBDUkwgZW50cmllcyBmcm9tIGRpc2sgY2FjaGU6ICR7ZXJyb3J9LmApO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3JsRnJvbURpc2sodXJsKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoXzEuZGVmYXVsdC5qb2luKGdsb2JhbF9jb25maWdfdHlwZWRfMS5kZWZhdWx0LmdldFZhbHVlKCdjcmxDYWNoZURpcicpLCBlbmNvZGVVUklDb21wb25lbnQodXJsKSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQuc3RhdChmaWxlUGF0aCk7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhdHMubXRpbWUuZ2V0VGltZSgpID4gZ2xvYmFsX2NvbmZpZ190eXBlZF8xLmRlZmF1bHQuZ2V0VmFsdWUoJ2NybENhY2hlVmFsaWRpdHlUaW1lJykpIHtcbiAgICAgICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBDUkwgJHtmaWxlUGF0aH0gaXMgb2xkZXIgdGhhbiBjcmxDYWNoZVZhbGlkaXR5VGltZSwgaWdub3JpbmcuYCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdDcmwgPSBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQucmVhZEZpbGUoZmlsZVBhdGgpO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ3JsID0gYXNuMV9qc19yZmM1MjgwXzEuZGVmYXVsdC5DZXJ0aWZpY2F0ZUxpc3QuZGVjb2RlKHJhd0NybCwgJ2RlcicpO1xuICAgICAgICBpZiAoZGVjb2RlZENybC50YnNDZXJ0TGlzdC5uZXh0VXBkYXRlLnZhbHVlID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZWRDcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZyhgQ1JMICR7ZmlsZVBhdGh9IGlzIGV4cGlyZWQsIGlnbm9yaW5nLmApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICgoMCwgZGlza19jYWNoZV8xLmlzRmlsZU5vdEZvdW5kRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYENSTCAke3VybH0gbm90IGZvdW5kIG9uIGRpc2sgY2FjaGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS53YXJuKGBGYWlsZWQgdG8gcmVhZCBDUkwgJHtmaWxlUGF0aH0gZnJvbSBkaXNrIGNhY2hlOiAke2Vycm9yfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQ3JsVG9EaXNrKHVybCwgcmF3Q3JsKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoXzEuZGVmYXVsdC5qb2luKGdsb2JhbF9jb25maWdfdHlwZWRfMS5kZWZhdWx0LmdldFZhbHVlKCdjcmxDYWNoZURpcicpLCBlbmNvZGVVUklDb21wb25lbnQodXJsKSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBkaXNrX2NhY2hlXzEud3JpdGVDYWNoZUZpbGUpKGZpbGVQYXRoLCByYXdDcmwpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkud2FybihgRmFpbGVkIHRvIHdyaXRlIENSTCAke2ZpbGVQYXRofSB0byBkaXNrIGNhY2hlOiAke2Vycm9yfS5gKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmxfY2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PENDING_FETCH_REQUESTS = void 0;\nexports.getCrl = getCrl;\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst global_config_typed_1 = __importDefault(__webpack_require__(/*! ../global_config_typed */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\"));\nconst crl_cache_1 = __webpack_require__(/*! ./crl_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js\");\nexports.PENDING_FETCH_REQUESTS = new Map();\nlet crlCacheCleanerCreated = false;\nasync function getCrl(url, options) {\n    const logDebug = (msg) => (0, logger_1.default)().debug(`getCrl[${url}]: ${msg}`);\n    if (!crlCacheCleanerCreated) {\n        crlCacheCleanerCreated = true;\n        const oneHour = 1000 * 60 * 60;\n        logDebug('Starting periodic memory cache cleaner');\n        setInterval(crl_cache_1.clearExpiredCrlFromMemoryCache, oneHour).unref();\n        logDebug('Starting periodic disk cache cleaner');\n        (0, crl_cache_1.clearExpiredCrlFromDiskCache)();\n        setInterval(crl_cache_1.clearExpiredCrlFromDiskCache, oneHour).unref();\n    }\n    const pendingFetchRequest = exports.PENDING_FETCH_REQUESTS.get(url);\n    if (pendingFetchRequest) {\n        logDebug(`Returning pending fetch request`);\n        return pendingFetchRequest;\n    }\n    if (options.inMemoryCache) {\n        logDebug(`Checking in-memory cache`);\n        const cachedCrl = (0, crl_cache_1.getCrlFromMemory)(url);\n        if (cachedCrl) {\n            logDebug(`Returning from in-memory cache`);\n            return cachedCrl;\n        }\n    }\n    if (options.onDiskCache) {\n        logDebug(`Checking on-disk cache`);\n        const cachedCrl = await (0, crl_cache_1.getCrlFromDisk)(url);\n        if (cachedCrl) {\n            if (options.inMemoryCache) {\n                (0, crl_cache_1.setCrlInMemory)(url, cachedCrl);\n            }\n            logDebug(`Returning from disk cache`);\n            return cachedCrl;\n        }\n    }\n    const fetchPromise = new Promise(async (resolve, reject) => {\n        try {\n            logDebug(`Downloading CRL`);\n            const { data } = await axios_1.default.get(url, {\n                timeout: global_config_typed_1.default.getValue('crlDownloadTimeout'),\n                responseType: 'arraybuffer',\n            });\n            logDebug(`Parsing CRL`);\n            const parsedCrl = asn1_js_rfc5280_1.default.CertificateList.decode(data, 'der');\n            if (options.inMemoryCache) {\n                logDebug('Saving to memory cache');\n                (0, crl_cache_1.setCrlInMemory)(url, parsedCrl);\n            }\n            if (options.onDiskCache) {\n                logDebug('Saving to disk cache');\n                await (0, crl_cache_1.writeCrlToDisk)(url, data);\n            }\n            exports.PENDING_FETCH_REQUESTS.delete(url);\n            return resolve(parsedCrl);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n    exports.PENDING_FETCH_REQUESTS.set(url, fetchPromise);\n    return fetchPromise;\n}\n//# sourceMappingURL=crl_fetcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfZmV0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjO0FBQ2QsMENBQTBDLG1CQUFPLENBQUMsc0VBQWlCO0FBQ25FLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DLGlDQUFpQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3BELDhDQUE4QyxtQkFBTyxDQUFDLGtHQUF3QjtBQUM5RSxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBYTtBQUN6Qyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHNFQUFzRSxJQUFJLEtBQUssSUFBSTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfZmV0Y2hlci5qcz8xMjk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QRU5ESU5HX0ZFVENIX1JFUVVFU1RTID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRDcmwgPSBnZXRDcmw7XG5jb25zdCBhc24xX2pzX3JmYzUyODBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNuMS5qcy1yZmM1MjgwXCIpKTtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9sb2dnZXJcIikpO1xuY29uc3QgZ2xvYmFsX2NvbmZpZ190eXBlZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9nbG9iYWxfY29uZmlnX3R5cGVkXCIpKTtcbmNvbnN0IGNybF9jYWNoZV8xID0gcmVxdWlyZShcIi4vY3JsX2NhY2hlXCIpO1xuZXhwb3J0cy5QRU5ESU5HX0ZFVENIX1JFUVVFU1RTID0gbmV3IE1hcCgpO1xubGV0IGNybENhY2hlQ2xlYW5lckNyZWF0ZWQgPSBmYWxzZTtcbmFzeW5jIGZ1bmN0aW9uIGdldENybCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2dEZWJ1ZyA9IChtc2cpID0+ICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBnZXRDcmxbJHt1cmx9XTogJHttc2d9YCk7XG4gICAgaWYgKCFjcmxDYWNoZUNsZWFuZXJDcmVhdGVkKSB7XG4gICAgICAgIGNybENhY2hlQ2xlYW5lckNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBvbmVIb3VyID0gMTAwMCAqIDYwICogNjA7XG4gICAgICAgIGxvZ0RlYnVnKCdTdGFydGluZyBwZXJpb2RpYyBtZW1vcnkgY2FjaGUgY2xlYW5lcicpO1xuICAgICAgICBzZXRJbnRlcnZhbChjcmxfY2FjaGVfMS5jbGVhckV4cGlyZWRDcmxGcm9tTWVtb3J5Q2FjaGUsIG9uZUhvdXIpLnVucmVmKCk7XG4gICAgICAgIGxvZ0RlYnVnKCdTdGFydGluZyBwZXJpb2RpYyBkaXNrIGNhY2hlIGNsZWFuZXInKTtcbiAgICAgICAgKDAsIGNybF9jYWNoZV8xLmNsZWFyRXhwaXJlZENybEZyb21EaXNrQ2FjaGUpKCk7XG4gICAgICAgIHNldEludGVydmFsKGNybF9jYWNoZV8xLmNsZWFyRXhwaXJlZENybEZyb21EaXNrQ2FjaGUsIG9uZUhvdXIpLnVucmVmKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdGZXRjaFJlcXVlc3QgPSBleHBvcnRzLlBFTkRJTkdfRkVUQ0hfUkVRVUVTVFMuZ2V0KHVybCk7XG4gICAgaWYgKHBlbmRpbmdGZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgbG9nRGVidWcoYFJldHVybmluZyBwZW5kaW5nIGZldGNoIHJlcXVlc3RgKTtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdGZXRjaFJlcXVlc3Q7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluTWVtb3J5Q2FjaGUpIHtcbiAgICAgICAgbG9nRGVidWcoYENoZWNraW5nIGluLW1lbW9yeSBjYWNoZWApO1xuICAgICAgICBjb25zdCBjYWNoZWRDcmwgPSAoMCwgY3JsX2NhY2hlXzEuZ2V0Q3JsRnJvbU1lbW9yeSkodXJsKTtcbiAgICAgICAgaWYgKGNhY2hlZENybCkge1xuICAgICAgICAgICAgbG9nRGVidWcoYFJldHVybmluZyBmcm9tIGluLW1lbW9yeSBjYWNoZWApO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vbkRpc2tDYWNoZSkge1xuICAgICAgICBsb2dEZWJ1ZyhgQ2hlY2tpbmcgb24tZGlzayBjYWNoZWApO1xuICAgICAgICBjb25zdCBjYWNoZWRDcmwgPSBhd2FpdCAoMCwgY3JsX2NhY2hlXzEuZ2V0Q3JsRnJvbURpc2spKHVybCk7XG4gICAgICAgIGlmIChjYWNoZWRDcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluTWVtb3J5Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICAoMCwgY3JsX2NhY2hlXzEuc2V0Q3JsSW5NZW1vcnkpKHVybCwgY2FjaGVkQ3JsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ0RlYnVnKGBSZXR1cm5pbmcgZnJvbSBkaXNrIGNhY2hlYCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ3JsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKGBEb3dubG9hZGluZyBDUkxgKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3NfMS5kZWZhdWx0LmdldCh1cmwsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBnbG9iYWxfY29uZmlnX3R5cGVkXzEuZGVmYXVsdC5nZXRWYWx1ZSgnY3JsRG93bmxvYWRUaW1lb3V0JyksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhgUGFyc2luZyBDUkxgKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZENybCA9IGFzbjFfanNfcmZjNTI4MF8xLmRlZmF1bHQuQ2VydGlmaWNhdGVMaXN0LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbk1lbW9yeUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1NhdmluZyB0byBtZW1vcnkgY2FjaGUnKTtcbiAgICAgICAgICAgICAgICAoMCwgY3JsX2NhY2hlXzEuc2V0Q3JsSW5NZW1vcnkpKHVybCwgcGFyc2VkQ3JsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uRGlza0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1NhdmluZyB0byBkaXNrIGNhY2hlJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKDAsIGNybF9jYWNoZV8xLndyaXRlQ3JsVG9EaXNrKSh1cmwsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy5QRU5ESU5HX0ZFVENIX1JFUVVFU1RTLmRlbGV0ZSh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocGFyc2VkQ3JsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBleHBvcnRzLlBFTkRJTkdfRkVUQ0hfUkVRVUVTVFMuc2V0KHVybCwgZmV0Y2hQcm9taXNlKTtcbiAgICByZXR1cm4gZmV0Y2hQcm9taXNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JsX2ZldGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getCertificateCrlUrls = exports.CRL_SIGNATURE_OID_TO_CRYPTO_DIGEST_ALGORITHM = void 0;\nexports.getCertificateDebugName = getCertificateDebugName;\nexports.isShortLivedCertificate = isShortLivedCertificate;\nexports.isCrlSignatureValid = isCrlSignatureValid;\nexports.isCertificateRevoked = isCertificateRevoked;\nexports.isIssuingDistributionPointExtensionValid = isIssuingDistributionPointExtensionValid;\nconst crypto_1 = __importDefault(__webpack_require__(/*! crypto */ \"crypto\"));\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\n// TODO:\n// Implement RSASSA-PSS signature verification\n// https://snowflakecomputing.atlassian.net/browse/SNOW-2333028\nexports.CRL_SIGNATURE_OID_TO_CRYPTO_DIGEST_ALGORITHM = {\n    '1.2.840.113549.1.1.11': 'sha256',\n    '1.2.840.113549.1.1.12': 'sha384',\n    '1.2.840.113549.1.1.13': 'sha512',\n    '1.2.840.10045.4.3.2': 'sha256',\n    '1.2.840.10045.4.3.3': 'sha384',\n    '1.2.840.10045.4.3.4': 'sha512',\n};\nfunction getCertificateDebugName(certificate) {\n    return [\n        `O:${certificate.subject.O}`,\n        `CN:${certificate.subject.CN}`,\n        `SN:${certificate.serialNumber}`,\n    ].join(',');\n}\nconst getCertificateCrlUrls = (certificateName, decodedCertificate) => {\n    const logDebug = (msg, ...msgArgs) => (0, logger_1.default)().debug(`getCertificateCrlUrls[${certificateName}]: ${msg}`, ...msgArgs);\n    const crlExtension = decodedCertificate.tbsCertificate.extensions?.find((ext) => ext.extnID === 'cRLDistributionPoints');\n    if (!crlExtension) {\n        logDebug('certificate doesnt have cRLDistributionPoints extension');\n        return null;\n    }\n    const result = [];\n    for (const entry of crlExtension.extnValue) {\n        if (!entry.distributionPoint) {\n            logDebug('skipping entry without distributionPoint %j', entry);\n            continue;\n        }\n        for (const fullNameEntry of entry.distributionPoint.value) {\n            if (fullNameEntry.type !== 'uniformResourceIdentifier') {\n                logDebug('skipping non-uniformResourceIdentifier entry %j', fullNameEntry);\n                continue;\n            }\n            if (fullNameEntry.value.startsWith('http')) {\n                // Even though the spec allows multiple http urls, we only pick first one and don't handle redundancy\n                result.push(fullNameEntry.value);\n                break;\n            }\n            else {\n                logDebug('skipping non-http value %j', fullNameEntry);\n            }\n        }\n    }\n    logDebug(`found URLs: ${result.join(',')}`);\n    return result.length > 0 ? result : null;\n};\nexports.getCertificateCrlUrls = getCertificateCrlUrls;\n/**\n * See Short-lived Subscriber Certificate section\\\n * https://cabforum.org/working-groups/server/baseline-requirements/requirements/\n */\nfunction isShortLivedCertificate(decodedCertificate) {\n    const notBefore = new Date(decodedCertificate.tbsCertificate.validity.notBefore.value);\n    const notAfter = new Date(decodedCertificate.tbsCertificate.validity.notAfter.value);\n    let maximumValidityPeriod = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n    if (notBefore < new Date('2026-03-15T00:00:00.000Z')) {\n        maximumValidityPeriod = 10 * 24 * 60 * 60 * 1000; // 10 days in milliseconds\n    }\n    maximumValidityPeriod += 60 * 1000; // Fix inclusion start and end time (1 minute)\n    const certValidityPeriod = notAfter.getTime() - notBefore.getTime();\n    return maximumValidityPeriod > certValidityPeriod;\n}\nfunction isCrlSignatureValid(crl, issuerPublicKey) {\n    const signatureAlgOid = crl.signatureAlgorithm.algorithm.join('.');\n    const digestAlg = exports.CRL_SIGNATURE_OID_TO_CRYPTO_DIGEST_ALGORITHM[signatureAlgOid];\n    if (!digestAlg) {\n        throw new Error(`Unsupported signature algorithm: ${signatureAlgOid}`);\n    }\n    const verify = crypto_1.default.createVerify(digestAlg);\n    const tbsEncoded = asn1_js_rfc5280_1.default.TBSCertList.encode(crl.tbsCertList, 'der');\n    verify.update(tbsEncoded);\n    return verify.verify(issuerPublicKey, crl.signature.data);\n}\nfunction isCertificateRevoked(decodedCertificate, crl) {\n    for (const revokedCert of crl.tbsCertList.revokedCertificates) {\n        if (revokedCert.userCertificate.eq(decodedCertificate.tbsCertificate.serialNumber)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isIssuingDistributionPointExtensionValid(crl, expectedCrlUrl) {\n    const issuingDistributionPointExtension = crl.tbsCertList.crlExtensions?.find((ext) => ext.extnID === 'issuingDistributionPoint');\n    if (!issuingDistributionPointExtension) {\n        (0, logger_1.default)().debug(`CRL ${expectedCrlUrl} doesnt have issuingDistributionPoint extension, ignoring`);\n        return true;\n    }\n    for (const fullNameEntry of issuingDistributionPointExtension.extnValue.distributionPoint.value) {\n        if (fullNameEntry.type === 'uniformResourceIdentifier' &&\n            fullNameEntry.value === expectedCrlUrl) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=crl_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxvREFBb0Q7QUFDcEYsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLGdEQUFnRDtBQUNoRCxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCwwQ0FBMEMsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDbkUsaUNBQWlDLG1CQUFPLENBQUMsd0VBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxnQkFBZ0IsS0FBSyxJQUFJO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NybF91dGlscy5qcz8yZGMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDZXJ0aWZpY2F0ZUNybFVybHMgPSBleHBvcnRzLkNSTF9TSUdOQVRVUkVfT0lEX1RPX0NSWVBUT19ESUdFU1RfQUxHT1JJVEhNID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRDZXJ0aWZpY2F0ZURlYnVnTmFtZSA9IGdldENlcnRpZmljYXRlRGVidWdOYW1lO1xuZXhwb3J0cy5pc1Nob3J0TGl2ZWRDZXJ0aWZpY2F0ZSA9IGlzU2hvcnRMaXZlZENlcnRpZmljYXRlO1xuZXhwb3J0cy5pc0NybFNpZ25hdHVyZVZhbGlkID0gaXNDcmxTaWduYXR1cmVWYWxpZDtcbmV4cG9ydHMuaXNDZXJ0aWZpY2F0ZVJldm9rZWQgPSBpc0NlcnRpZmljYXRlUmV2b2tlZDtcbmV4cG9ydHMuaXNJc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnRFeHRlbnNpb25WYWxpZCA9IGlzSXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50RXh0ZW5zaW9uVmFsaWQ7XG5jb25zdCBjcnlwdG9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNvbnN0IGFzbjFfanNfcmZjNTI4MF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc24xLmpzLXJmYzUyODBcIikpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xvZ2dlclwiKSk7XG4vLyBUT0RPOlxuLy8gSW1wbGVtZW50IFJTQVNTQS1QU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuLy8gaHR0cHM6Ly9zbm93Zmxha2Vjb21wdXRpbmcuYXRsYXNzaWFuLm5ldC9icm93c2UvU05PVy0yMzMzMDI4XG5leHBvcnRzLkNSTF9TSUdOQVRVUkVfT0lEX1RPX0NSWVBUT19ESUdFU1RfQUxHT1JJVEhNID0ge1xuICAgICcxLjIuODQwLjExMzU0OS4xLjEuMTEnOiAnc2hhMjU2JyxcbiAgICAnMS4yLjg0MC4xMTM1NDkuMS4xLjEyJzogJ3NoYTM4NCcsXG4gICAgJzEuMi44NDAuMTEzNTQ5LjEuMS4xMyc6ICdzaGE1MTInLFxuICAgICcxLjIuODQwLjEwMDQ1LjQuMy4yJzogJ3NoYTI1NicsXG4gICAgJzEuMi44NDAuMTAwNDUuNC4zLjMnOiAnc2hhMzg0JyxcbiAgICAnMS4yLjg0MC4xMDA0NS40LjMuNCc6ICdzaGE1MTInLFxufTtcbmZ1bmN0aW9uIGdldENlcnRpZmljYXRlRGVidWdOYW1lKGNlcnRpZmljYXRlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE86JHtjZXJ0aWZpY2F0ZS5zdWJqZWN0Lk99YCxcbiAgICAgICAgYENOOiR7Y2VydGlmaWNhdGUuc3ViamVjdC5DTn1gLFxuICAgICAgICBgU046JHtjZXJ0aWZpY2F0ZS5zZXJpYWxOdW1iZXJ9YCxcbiAgICBdLmpvaW4oJywnKTtcbn1cbmNvbnN0IGdldENlcnRpZmljYXRlQ3JsVXJscyA9IChjZXJ0aWZpY2F0ZU5hbWUsIGRlY29kZWRDZXJ0aWZpY2F0ZSkgPT4ge1xuICAgIGNvbnN0IGxvZ0RlYnVnID0gKG1zZywgLi4ubXNnQXJncykgPT4gKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYGdldENlcnRpZmljYXRlQ3JsVXJsc1ske2NlcnRpZmljYXRlTmFtZX1dOiAke21zZ31gLCAuLi5tc2dBcmdzKTtcbiAgICBjb25zdCBjcmxFeHRlbnNpb24gPSBkZWNvZGVkQ2VydGlmaWNhdGUudGJzQ2VydGlmaWNhdGUuZXh0ZW5zaW9ucz8uZmluZCgoZXh0KSA9PiBleHQuZXh0bklEID09PSAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJyk7XG4gICAgaWYgKCFjcmxFeHRlbnNpb24pIHtcbiAgICAgICAgbG9nRGVidWcoJ2NlcnRpZmljYXRlIGRvZXNudCBoYXZlIGNSTERpc3RyaWJ1dGlvblBvaW50cyBleHRlbnNpb24nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgY3JsRXh0ZW5zaW9uLmV4dG5WYWx1ZSkge1xuICAgICAgICBpZiAoIWVudHJ5LmRpc3RyaWJ1dGlvblBvaW50KSB7XG4gICAgICAgICAgICBsb2dEZWJ1Zygnc2tpcHBpbmcgZW50cnkgd2l0aG91dCBkaXN0cmlidXRpb25Qb2ludCAlaicsIGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZnVsbE5hbWVFbnRyeSBvZiBlbnRyeS5kaXN0cmlidXRpb25Qb2ludC52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGZ1bGxOYW1lRW50cnkudHlwZSAhPT0gJ3VuaWZvcm1SZXNvdXJjZUlkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ3NraXBwaW5nIG5vbi11bmlmb3JtUmVzb3VyY2VJZGVudGlmaWVyIGVudHJ5ICVqJywgZnVsbE5hbWVFbnRyeSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVsbE5hbWVFbnRyeS52YWx1ZS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgc3BlYyBhbGxvd3MgbXVsdGlwbGUgaHR0cCB1cmxzLCB3ZSBvbmx5IHBpY2sgZmlyc3Qgb25lIGFuZCBkb24ndCBoYW5kbGUgcmVkdW5kYW5jeVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZ1bGxOYW1lRW50cnkudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ3NraXBwaW5nIG5vbi1odHRwIHZhbHVlICVqJywgZnVsbE5hbWVFbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nRGVidWcoYGZvdW5kIFVSTHM6ICR7cmVzdWx0LmpvaW4oJywnKX1gKTtcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDAgPyByZXN1bHQgOiBudWxsO1xufTtcbmV4cG9ydHMuZ2V0Q2VydGlmaWNhdGVDcmxVcmxzID0gZ2V0Q2VydGlmaWNhdGVDcmxVcmxzO1xuLyoqXG4gKiBTZWUgU2hvcnQtbGl2ZWQgU3Vic2NyaWJlciBDZXJ0aWZpY2F0ZSBzZWN0aW9uXFxcbiAqIGh0dHBzOi8vY2FiZm9ydW0ub3JnL3dvcmtpbmctZ3JvdXBzL3NlcnZlci9iYXNlbGluZS1yZXF1aXJlbWVudHMvcmVxdWlyZW1lbnRzL1xuICovXG5mdW5jdGlvbiBpc1Nob3J0TGl2ZWRDZXJ0aWZpY2F0ZShkZWNvZGVkQ2VydGlmaWNhdGUpIHtcbiAgICBjb25zdCBub3RCZWZvcmUgPSBuZXcgRGF0ZShkZWNvZGVkQ2VydGlmaWNhdGUudGJzQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlLnZhbHVlKTtcbiAgICBjb25zdCBub3RBZnRlciA9IG5ldyBEYXRlKGRlY29kZWRDZXJ0aWZpY2F0ZS50YnNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlci52YWx1ZSk7XG4gICAgbGV0IG1heGltdW1WYWxpZGl0eVBlcmlvZCA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyA3IGRheXMgaW4gbWlsbGlzZWNvbmRzXG4gICAgaWYgKG5vdEJlZm9yZSA8IG5ldyBEYXRlKCcyMDI2LTAzLTE1VDAwOjAwOjAwLjAwMFonKSkge1xuICAgICAgICBtYXhpbXVtVmFsaWRpdHlQZXJpb2QgPSAxMCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIDEwIGRheXMgaW4gbWlsbGlzZWNvbmRzXG4gICAgfVxuICAgIG1heGltdW1WYWxpZGl0eVBlcmlvZCArPSA2MCAqIDEwMDA7IC8vIEZpeCBpbmNsdXNpb24gc3RhcnQgYW5kIGVuZCB0aW1lICgxIG1pbnV0ZSlcbiAgICBjb25zdCBjZXJ0VmFsaWRpdHlQZXJpb2QgPSBub3RBZnRlci5nZXRUaW1lKCkgLSBub3RCZWZvcmUuZ2V0VGltZSgpO1xuICAgIHJldHVybiBtYXhpbXVtVmFsaWRpdHlQZXJpb2QgPiBjZXJ0VmFsaWRpdHlQZXJpb2Q7XG59XG5mdW5jdGlvbiBpc0NybFNpZ25hdHVyZVZhbGlkKGNybCwgaXNzdWVyUHVibGljS2V5KSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlQWxnT2lkID0gY3JsLnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpO1xuICAgIGNvbnN0IGRpZ2VzdEFsZyA9IGV4cG9ydHMuQ1JMX1NJR05BVFVSRV9PSURfVE9fQ1JZUFRPX0RJR0VTVF9BTEdPUklUSE1bc2lnbmF0dXJlQWxnT2lkXTtcbiAgICBpZiAoIWRpZ2VzdEFsZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNpZ25hdHVyZSBhbGdvcml0aG06ICR7c2lnbmF0dXJlQWxnT2lkfWApO1xuICAgIH1cbiAgICBjb25zdCB2ZXJpZnkgPSBjcnlwdG9fMS5kZWZhdWx0LmNyZWF0ZVZlcmlmeShkaWdlc3RBbGcpO1xuICAgIGNvbnN0IHRic0VuY29kZWQgPSBhc24xX2pzX3JmYzUyODBfMS5kZWZhdWx0LlRCU0NlcnRMaXN0LmVuY29kZShjcmwudGJzQ2VydExpc3QsICdkZXInKTtcbiAgICB2ZXJpZnkudXBkYXRlKHRic0VuY29kZWQpO1xuICAgIHJldHVybiB2ZXJpZnkudmVyaWZ5KGlzc3VlclB1YmxpY0tleSwgY3JsLnNpZ25hdHVyZS5kYXRhKTtcbn1cbmZ1bmN0aW9uIGlzQ2VydGlmaWNhdGVSZXZva2VkKGRlY29kZWRDZXJ0aWZpY2F0ZSwgY3JsKSB7XG4gICAgZm9yIChjb25zdCByZXZva2VkQ2VydCBvZiBjcmwudGJzQ2VydExpc3QucmV2b2tlZENlcnRpZmljYXRlcykge1xuICAgICAgICBpZiAocmV2b2tlZENlcnQudXNlckNlcnRpZmljYXRlLmVxKGRlY29kZWRDZXJ0aWZpY2F0ZS50YnNDZXJ0aWZpY2F0ZS5zZXJpYWxOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lzc3VpbmdEaXN0cmlidXRpb25Qb2ludEV4dGVuc2lvblZhbGlkKGNybCwgZXhwZWN0ZWRDcmxVcmwpIHtcbiAgICBjb25zdCBpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnRFeHRlbnNpb24gPSBjcmwudGJzQ2VydExpc3QuY3JsRXh0ZW5zaW9ucz8uZmluZCgoZXh0KSA9PiBleHQuZXh0bklEID09PSAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7XG4gICAgaWYgKCFpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnRFeHRlbnNpb24pIHtcbiAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYENSTCAke2V4cGVjdGVkQ3JsVXJsfSBkb2VzbnQgaGF2ZSBpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQgZXh0ZW5zaW9uLCBpZ25vcmluZ2ApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmdWxsTmFtZUVudHJ5IG9mIGlzc3VpbmdEaXN0cmlidXRpb25Qb2ludEV4dGVuc2lvbi5leHRuVmFsdWUuZGlzdHJpYnV0aW9uUG9pbnQudmFsdWUpIHtcbiAgICAgICAgaWYgKGZ1bGxOYW1lRW50cnkudHlwZSA9PT0gJ3VuaWZvcm1SZXNvdXJjZUlkZW50aWZpZXInICYmXG4gICAgICAgICAgICBmdWxsTmFtZUVudHJ5LnZhbHVlID09PSBleHBlY3RlZENybFVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JsX3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CertificateRevokedError = exports.CRL_VALIDATOR_INTERNAL = void 0;\nexports.isCrlValidationEnabled = isCrlValidationEnabled;\nexports.corkSocketAndValidateCrl = corkSocketAndValidateCrl;\nexports.validateCrl = validateCrl;\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst crypto_1 = __importDefault(__webpack_require__(/*! crypto */ \"crypto\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst crl_utils_1 = __webpack_require__(/*! ./crl_utils */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js\");\nconst crl_fetcher_1 = __webpack_require__(/*! ./crl_fetcher */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n// Allows to mock/spy internal calls in tests\nexports.CRL_VALIDATOR_INTERNAL = {\n    validateCrl: (...args) => validateCrl(...args),\n};\nclass CertificateRevokedError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CertificateRevokedError';\n    }\n}\nexports.CertificateRevokedError = CertificateRevokedError;\nfunction isCrlValidationEnabled(config) {\n    return config.checkMode !== 'DISABLED';\n}\nfunction corkSocketAndValidateCrl(socket, config) {\n    socket.once('secureConnect', async () => {\n        const certChain = socket.getPeerCertificate(true);\n        try {\n            await exports.CRL_VALIDATOR_INTERNAL.validateCrl(certChain, config);\n        }\n        catch (error) {\n            if (!(error instanceof CertificateRevokedError) && config.checkMode === 'ADVISORY') {\n                (0, logger_1.default)().debug('Failed to check CRL revocation, but checkMode=ADVISORY. Allowing connection. Error: %j', error);\n            }\n            else {\n                // NOTE: Wrap error into CrlError to prevent retries\n                socket.destroy((0, errors_1.createCrlError)(error));\n            }\n        }\n        socket.uncork();\n    });\n    socket.cork();\n}\nfunction* iterateCertChain(cert) {\n    let current = cert;\n    while (current) {\n        if (current === current.issuerCertificate)\n            break; // Root is self-signed, ignoring\n        yield current;\n        current = current.issuerCertificate;\n    }\n}\n// NOTE:\n// Sticking with asn1.js-rfc5280 + custom signature validation, because popular libraries have issues:\n// - jsrsasign: has outdated crypto library with CEV issues\n// - pkijs: takes 4 seconds to parse 9Mb CRL\n// - @peculiar/x509: takes 2.5 seconds to parse 9Mb CRL\nasync function validateCrl(certChain, config) {\n    for (const certificate of iterateCertChain(certChain)) {\n        const decodedCertificate = asn1_js_rfc5280_1.default.Certificate.decode(certificate.raw, 'der');\n        const name = (0, crl_utils_1.getCertificateDebugName)(certificate);\n        const logDebug = (msg) => (0, logger_1.default)().debug(`validateCrl[${name}]: ${msg}`);\n        logDebug('starting validation');\n        if ((0, crl_utils_1.isShortLivedCertificate)(decodedCertificate)) {\n            logDebug('certificate is short-lived, skipping');\n            continue;\n        }\n        logDebug('getting CRL distribution points');\n        const crlUrls = (0, crl_utils_1.getCertificateCrlUrls)(name, decodedCertificate);\n        if (!crlUrls) {\n            if (config.allowCertificatesWithoutCrlURL) {\n                logDebug('certificate has no CRL distribution points, skipping');\n                continue;\n            }\n            throw new Error(`Certificate ${name} does not have CRL http URL. This could be disabled with allowCertificatesWithoutCrlURL`);\n        }\n        const decodedIssuerCertificate = asn1_js_rfc5280_1.default.Certificate.decode(certificate.issuerCertificate.raw, 'der');\n        const issuerSubject = JSON.stringify(decodedIssuerCertificate.tbsCertificate.subject);\n        const issuerPublicKey = crypto_1.default\n            .createPublicKey({\n            key: certificate.issuerCertificate.pubkey,\n            format: 'der',\n            type: 'spki',\n        })\n            .export({ format: 'pem', type: 'spki' });\n        for (const crlUrl of crlUrls) {\n            logDebug(`fetching ${crlUrl}`);\n            const crl = await (0, crl_fetcher_1.getCrl)(crlUrl, {\n                inMemoryCache: config.inMemoryCache,\n                onDiskCache: config.onDiskCache,\n            });\n            logDebug(`validating ${crlUrl} signature`);\n            if (!(0, crl_utils_1.isCrlSignatureValid)(crl, issuerPublicKey)) {\n                throw new Error(`CRL ${crlUrl} signature is invalid. Expected signature by ${(0, crl_utils_1.getCertificateDebugName)(certificate.issuerCertificate)}`);\n            }\n            logDebug(`validating ${crlUrl} issuingDistributionPoint extension`);\n            if (!(0, crl_utils_1.isIssuingDistributionPointExtensionValid)(crl, crlUrl)) {\n                throw new Error(`CRL ${crlUrl} issuingDistributionPoint extension is invalid`);\n            }\n            logDebug(`validating ${crlUrl} issuer`);\n            const crlIssuer = JSON.stringify(crl.tbsCertList.issuer);\n            if (issuerSubject !== crlIssuer) {\n                throw new Error(`CRL ${crlUrl} issuer is invalid. Expected ${issuerSubject} but got ${crlIssuer}`);\n            }\n            logDebug(`validating ${crlUrl} nextUpdate`);\n            if (crl.tbsCertList.nextUpdate.value < Date.now()) {\n                throw new Error(`CRL ${crlUrl} nextUpdate is expired`);\n            }\n            logDebug(`checking if certificate is revoked in ${crlUrl}`);\n            if ((0, crl_utils_1.isCertificateRevoked)(decodedCertificate, crl)) {\n                throw new CertificateRevokedError(`Certificate ${name} is revoked in ${crlUrl}`);\n            }\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=crl_validator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfdmFsaWRhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsOEJBQThCO0FBQ2hFLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsbUJBQW1CO0FBQ25CLDBDQUEwQyxtQkFBTyxDQUFDLHNFQUFpQjtBQUNuRSxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCxpQ0FBaUMsbUJBQU8sQ0FBQyx3RUFBVztBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBYTtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBZTtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVztBQUNwQztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxLQUFLLEtBQUssSUFBSTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSx1Q0FBdUMsUUFBUSw4Q0FBOEMsd0VBQXdFO0FBQ3JLO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSw4QkFBOEIsZUFBZSxVQUFVLFVBQVU7QUFDaEg7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQSxpRUFBaUUsTUFBTSxnQkFBZ0IsT0FBTztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NybF92YWxpZGF0b3IuanM/ZWY0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2VydGlmaWNhdGVSZXZva2VkRXJyb3IgPSBleHBvcnRzLkNSTF9WQUxJREFUT1JfSU5URVJOQUwgPSB2b2lkIDA7XG5leHBvcnRzLmlzQ3JsVmFsaWRhdGlvbkVuYWJsZWQgPSBpc0NybFZhbGlkYXRpb25FbmFibGVkO1xuZXhwb3J0cy5jb3JrU29ja2V0QW5kVmFsaWRhdGVDcmwgPSBjb3JrU29ja2V0QW5kVmFsaWRhdGVDcmw7XG5leHBvcnRzLnZhbGlkYXRlQ3JsID0gdmFsaWRhdGVDcmw7XG5jb25zdCBhc24xX2pzX3JmYzUyODBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNuMS5qcy1yZmM1MjgwXCIpKTtcbmNvbnN0IGNyeXB0b18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG9cIikpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xvZ2dlclwiKSk7XG5jb25zdCBjcmxfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2NybF91dGlsc1wiKTtcbmNvbnN0IGNybF9mZXRjaGVyXzEgPSByZXF1aXJlKFwiLi9jcmxfZmV0Y2hlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbi8vIEFsbG93cyB0byBtb2NrL3NweSBpbnRlcm5hbCBjYWxscyBpbiB0ZXN0c1xuZXhwb3J0cy5DUkxfVkFMSURBVE9SX0lOVEVSTkFMID0ge1xuICAgIHZhbGlkYXRlQ3JsOiAoLi4uYXJncykgPT4gdmFsaWRhdGVDcmwoLi4uYXJncyksXG59O1xuY2xhc3MgQ2VydGlmaWNhdGVSZXZva2VkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NlcnRpZmljYXRlUmV2b2tlZEVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLkNlcnRpZmljYXRlUmV2b2tlZEVycm9yID0gQ2VydGlmaWNhdGVSZXZva2VkRXJyb3I7XG5mdW5jdGlvbiBpc0NybFZhbGlkYXRpb25FbmFibGVkKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcuY2hlY2tNb2RlICE9PSAnRElTQUJMRUQnO1xufVxuZnVuY3Rpb24gY29ya1NvY2tldEFuZFZhbGlkYXRlQ3JsKHNvY2tldCwgY29uZmlnKSB7XG4gICAgc29ja2V0Lm9uY2UoJ3NlY3VyZUNvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlcnRDaGFpbiA9IHNvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUodHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBleHBvcnRzLkNSTF9WQUxJREFUT1JfSU5URVJOQUwudmFsaWRhdGVDcmwoY2VydENoYWluLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBDZXJ0aWZpY2F0ZVJldm9rZWRFcnJvcikgJiYgY29uZmlnLmNoZWNrTW9kZSA9PT0gJ0FEVklTT1JZJykge1xuICAgICAgICAgICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdGYWlsZWQgdG8gY2hlY2sgQ1JMIHJldm9jYXRpb24sIGJ1dCBjaGVja01vZGU9QURWSVNPUlkuIEFsbG93aW5nIGNvbm5lY3Rpb24uIEVycm9yOiAlaicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdyYXAgZXJyb3IgaW50byBDcmxFcnJvciB0byBwcmV2ZW50IHJldHJpZXNcbiAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgoMCwgZXJyb3JzXzEuY3JlYXRlQ3JsRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0LnVuY29yaygpO1xuICAgIH0pO1xuICAgIHNvY2tldC5jb3JrKCk7XG59XG5mdW5jdGlvbiogaXRlcmF0ZUNlcnRDaGFpbihjZXJ0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSBjZXJ0O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBjdXJyZW50Lmlzc3VlckNlcnRpZmljYXRlKVxuICAgICAgICAgICAgYnJlYWs7IC8vIFJvb3QgaXMgc2VsZi1zaWduZWQsIGlnbm9yaW5nXG4gICAgICAgIHlpZWxkIGN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lmlzc3VlckNlcnRpZmljYXRlO1xuICAgIH1cbn1cbi8vIE5PVEU6XG4vLyBTdGlja2luZyB3aXRoIGFzbjEuanMtcmZjNTI4MCArIGN1c3RvbSBzaWduYXR1cmUgdmFsaWRhdGlvbiwgYmVjYXVzZSBwb3B1bGFyIGxpYnJhcmllcyBoYXZlIGlzc3Vlczpcbi8vIC0ganNyc2FzaWduOiBoYXMgb3V0ZGF0ZWQgY3J5cHRvIGxpYnJhcnkgd2l0aCBDRVYgaXNzdWVzXG4vLyAtIHBraWpzOiB0YWtlcyA0IHNlY29uZHMgdG8gcGFyc2UgOU1iIENSTFxuLy8gLSBAcGVjdWxpYXIveDUwOTogdGFrZXMgMi41IHNlY29uZHMgdG8gcGFyc2UgOU1iIENSTFxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVDcmwoY2VydENoYWluLCBjb25maWcpIHtcbiAgICBmb3IgKGNvbnN0IGNlcnRpZmljYXRlIG9mIGl0ZXJhdGVDZXJ0Q2hhaW4oY2VydENoYWluKSkge1xuICAgICAgICBjb25zdCBkZWNvZGVkQ2VydGlmaWNhdGUgPSBhc24xX2pzX3JmYzUyODBfMS5kZWZhdWx0LkNlcnRpZmljYXRlLmRlY29kZShjZXJ0aWZpY2F0ZS5yYXcsICdkZXInKTtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgwLCBjcmxfdXRpbHNfMS5nZXRDZXJ0aWZpY2F0ZURlYnVnTmFtZSkoY2VydGlmaWNhdGUpO1xuICAgICAgICBjb25zdCBsb2dEZWJ1ZyA9IChtc2cpID0+ICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGB2YWxpZGF0ZUNybFske25hbWV9XTogJHttc2d9YCk7XG4gICAgICAgIGxvZ0RlYnVnKCdzdGFydGluZyB2YWxpZGF0aW9uJyk7XG4gICAgICAgIGlmICgoMCwgY3JsX3V0aWxzXzEuaXNTaG9ydExpdmVkQ2VydGlmaWNhdGUpKGRlY29kZWRDZXJ0aWZpY2F0ZSkpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdjZXJ0aWZpY2F0ZSBpcyBzaG9ydC1saXZlZCwgc2tpcHBpbmcnKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0RlYnVnKCdnZXR0aW5nIENSTCBkaXN0cmlidXRpb24gcG9pbnRzJyk7XG4gICAgICAgIGNvbnN0IGNybFVybHMgPSAoMCwgY3JsX3V0aWxzXzEuZ2V0Q2VydGlmaWNhdGVDcmxVcmxzKShuYW1lLCBkZWNvZGVkQ2VydGlmaWNhdGUpO1xuICAgICAgICBpZiAoIWNybFVybHMpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuYWxsb3dDZXJ0aWZpY2F0ZXNXaXRob3V0Q3JsVVJMKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ2NlcnRpZmljYXRlIGhhcyBubyBDUkwgZGlzdHJpYnV0aW9uIHBvaW50cywgc2tpcHBpbmcnKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2VydGlmaWNhdGUgJHtuYW1lfSBkb2VzIG5vdCBoYXZlIENSTCBodHRwIFVSTC4gVGhpcyBjb3VsZCBiZSBkaXNhYmxlZCB3aXRoIGFsbG93Q2VydGlmaWNhdGVzV2l0aG91dENybFVSTGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZWRJc3N1ZXJDZXJ0aWZpY2F0ZSA9IGFzbjFfanNfcmZjNTI4MF8xLmRlZmF1bHQuQ2VydGlmaWNhdGUuZGVjb2RlKGNlcnRpZmljYXRlLmlzc3VlckNlcnRpZmljYXRlLnJhdywgJ2RlcicpO1xuICAgICAgICBjb25zdCBpc3N1ZXJTdWJqZWN0ID0gSlNPTi5zdHJpbmdpZnkoZGVjb2RlZElzc3VlckNlcnRpZmljYXRlLnRic0NlcnRpZmljYXRlLnN1YmplY3QpO1xuICAgICAgICBjb25zdCBpc3N1ZXJQdWJsaWNLZXkgPSBjcnlwdG9fMS5kZWZhdWx0XG4gICAgICAgICAgICAuY3JlYXRlUHVibGljS2V5KHtcbiAgICAgICAgICAgIGtleTogY2VydGlmaWNhdGUuaXNzdWVyQ2VydGlmaWNhdGUucHVia2V5LFxuICAgICAgICAgICAgZm9ybWF0OiAnZGVyJyxcbiAgICAgICAgICAgIHR5cGU6ICdzcGtpJyxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5leHBvcnQoeyBmb3JtYXQ6ICdwZW0nLCB0eXBlOiAnc3BraScgfSk7XG4gICAgICAgIGZvciAoY29uc3QgY3JsVXJsIG9mIGNybFVybHMpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKGBmZXRjaGluZyAke2NybFVybH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGNybCA9IGF3YWl0ICgwLCBjcmxfZmV0Y2hlcl8xLmdldENybCkoY3JsVXJsLCB7XG4gICAgICAgICAgICAgICAgaW5NZW1vcnlDYWNoZTogY29uZmlnLmluTWVtb3J5Q2FjaGUsXG4gICAgICAgICAgICAgICAgb25EaXNrQ2FjaGU6IGNvbmZpZy5vbkRpc2tDYWNoZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nRGVidWcoYHZhbGlkYXRpbmcgJHtjcmxVcmx9IHNpZ25hdHVyZWApO1xuICAgICAgICAgICAgaWYgKCEoMCwgY3JsX3V0aWxzXzEuaXNDcmxTaWduYXR1cmVWYWxpZCkoY3JsLCBpc3N1ZXJQdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDUkwgJHtjcmxVcmx9IHNpZ25hdHVyZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCBzaWduYXR1cmUgYnkgJHsoMCwgY3JsX3V0aWxzXzEuZ2V0Q2VydGlmaWNhdGVEZWJ1Z05hbWUpKGNlcnRpZmljYXRlLmlzc3VlckNlcnRpZmljYXRlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ0RlYnVnKGB2YWxpZGF0aW5nICR7Y3JsVXJsfSBpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQgZXh0ZW5zaW9uYCk7XG4gICAgICAgICAgICBpZiAoISgwLCBjcmxfdXRpbHNfMS5pc0lzc3VpbmdEaXN0cmlidXRpb25Qb2ludEV4dGVuc2lvblZhbGlkKShjcmwsIGNybFVybCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENSTCAke2NybFVybH0gaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50IGV4dGVuc2lvbiBpcyBpbnZhbGlkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dEZWJ1ZyhgdmFsaWRhdGluZyAke2NybFVybH0gaXNzdWVyYCk7XG4gICAgICAgICAgICBjb25zdCBjcmxJc3N1ZXIgPSBKU09OLnN0cmluZ2lmeShjcmwudGJzQ2VydExpc3QuaXNzdWVyKTtcbiAgICAgICAgICAgIGlmIChpc3N1ZXJTdWJqZWN0ICE9PSBjcmxJc3N1ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENSTCAke2NybFVybH0gaXNzdWVyIGlzIGludmFsaWQuIEV4cGVjdGVkICR7aXNzdWVyU3ViamVjdH0gYnV0IGdvdCAke2NybElzc3Vlcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ0RlYnVnKGB2YWxpZGF0aW5nICR7Y3JsVXJsfSBuZXh0VXBkYXRlYCk7XG4gICAgICAgICAgICBpZiAoY3JsLnRic0NlcnRMaXN0Lm5leHRVcGRhdGUudmFsdWUgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDUkwgJHtjcmxVcmx9IG5leHRVcGRhdGUgaXMgZXhwaXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoYGNoZWNraW5nIGlmIGNlcnRpZmljYXRlIGlzIHJldm9rZWQgaW4gJHtjcmxVcmx9YCk7XG4gICAgICAgICAgICBpZiAoKDAsIGNybF91dGlsc18xLmlzQ2VydGlmaWNhdGVSZXZva2VkKShkZWNvZGVkQ2VydGlmaWNhdGUsIGNybCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2VydGlmaWNhdGVSZXZva2VkRXJyb3IoYENlcnRpZmljYXRlICR7bmFtZX0gaXMgcmV2b2tlZCBpbiAke2NybFVybH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNybF92YWxpZGF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\nconst crl_validator_1 = __webpack_require__(/*! ./crl_validator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\");\n// TODO: when OCSP is removed, rename to HttpsAgent\nclass HttpsCrlAgent extends https_1.Agent {\n    crlValidatorConfig;\n    constructor(opts) {\n        const { crlValidatorConfig, ...agentOptions } = opts;\n        super(agentOptions);\n        this.crlValidatorConfig = crlValidatorConfig;\n    }\n    createConnection(...args) {\n        const createConnection = https_1.Agent.prototype.createConnection;\n        const socket = createConnection.apply(this, args);\n        (0, crl_validator_1.corkSocketAndValidateCrl)(socket, this.crlValidatorConfig);\n        return socket;\n    }\n}\nexports[\"default\"] = HttpsCrlAgent;\n//# sourceMappingURL=https_crl_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19jcmxfYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsb0JBQU87QUFDL0Isd0JBQXdCLG1CQUFPLENBQUMsMkZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2h0dHBzX2NybF9hZ2VudC5qcz85MWQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaHR0cHNfMSA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbmNvbnN0IGNybF92YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCIuL2NybF92YWxpZGF0b3JcIik7XG4vLyBUT0RPOiB3aGVuIE9DU1AgaXMgcmVtb3ZlZCwgcmVuYW1lIHRvIEh0dHBzQWdlbnRcbmNsYXNzIEh0dHBzQ3JsQWdlbnQgZXh0ZW5kcyBodHRwc18xLkFnZW50IHtcbiAgICBjcmxWYWxpZGF0b3JDb25maWc7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBjb25zdCB7IGNybFZhbGlkYXRvckNvbmZpZywgLi4uYWdlbnRPcHRpb25zIH0gPSBvcHRzO1xuICAgICAgICBzdXBlcihhZ2VudE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNybFZhbGlkYXRvckNvbmZpZyA9IGNybFZhbGlkYXRvckNvbmZpZztcbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNvbm5lY3Rpb24gPSBodHRwc18xLkFnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBjcmVhdGVDb25uZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAoMCwgY3JsX3ZhbGlkYXRvcl8xLmNvcmtTb2NrZXRBbmRWYWxpZGF0ZUNybCkoc29ja2V0LCB0aGlzLmNybFZhbGlkYXRvckNvbmZpZyk7XG4gICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cHNDcmxBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBzX2NybF9hZ2VudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst HttpsAgent = (__webpack_require__(/*! https */ \"https\").Agent);\nconst SocketUtil = __webpack_require__(/*! ./socket_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js\");\n/**\n * Creates a new HttpsOcspAgent.\n *\n * @param {Object} options\n *\n * @returns {HttpsOcspAgent}\n * @constructor\n */\nfunction HttpsOcspAgent(options) {\n    const agent = HttpsAgent.apply(this, [options]);\n    agent.createConnection = function (port, host, options) {\n        // make sure the 'options' variables references the argument that actually\n        // contains the options\n        // Note: look at the Node.js https agent to understand why this code is\n        // written this way\n        if (port !== null && typeof port === 'object') {\n            options = port;\n        }\n        else if (host !== null && typeof host === 'object') {\n            options = host;\n        }\n        else if (options === null || typeof options !== 'object') {\n            options = {};\n        }\n        if (typeof host !== 'string') {\n            host = options.host;\n        }\n        // call super\n        const socket = HttpsAgent.prototype.createConnection.apply(this, arguments);\n        // secure the socket and return it\n        return SocketUtil.secureSocket(socket, host, null);\n    };\n    return agent;\n}\nmodule.exports = HttpsOcspAgent;\n//# sourceMappingURL=https_ocsp_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19vY3NwX2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsbUJBQW1CLGlEQUFzQjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19vY3NwX2FnZW50LmpzP2I0M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBIdHRwc0FnZW50ID0gcmVxdWlyZSgnaHR0cHMnKS5BZ2VudDtcbmNvbnN0IFNvY2tldFV0aWwgPSByZXF1aXJlKCcuL3NvY2tldF91dGlsJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgSHR0cHNPY3NwQWdlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7SHR0cHNPY3NwQWdlbnR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHR0cHNPY3NwQWdlbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGFnZW50ID0gSHR0cHNBZ2VudC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIGFnZW50LmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAocG9ydCwgaG9zdCwgb3B0aW9ucykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlICdvcHRpb25zJyB2YXJpYWJsZXMgcmVmZXJlbmNlcyB0aGUgYXJndW1lbnQgdGhhdCBhY3R1YWxseVxuICAgICAgICAvLyBjb250YWlucyB0aGUgb3B0aW9uc1xuICAgICAgICAvLyBOb3RlOiBsb29rIGF0IHRoZSBOb2RlLmpzIGh0dHBzIGFnZW50IHRvIHVuZGVyc3RhbmQgd2h5IHRoaXMgY29kZSBpc1xuICAgICAgICAvLyB3cml0dGVuIHRoaXMgd2F5XG4gICAgICAgIGlmIChwb3J0ICE9PSBudWxsICYmIHR5cGVvZiBwb3J0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaG9zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaG9zdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsIHN1cGVyXG4gICAgICAgIGNvbnN0IHNvY2tldCA9IEh0dHBzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgLy8gc2VjdXJlIHRoZSBzb2NrZXQgYW5kIHJldHVybiBpdFxuICAgICAgICByZXR1cm4gU29ja2V0VXRpbC5zZWN1cmVTb2NrZXQoc29ja2V0LCBob3N0LCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBhZ2VudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gSHR0cHNPY3NwQWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwc19vY3NwX2FnZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst https_proxy_agent_1 = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\");\nconst crl_validator_1 = __webpack_require__(/*! ./crl_validator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\");\nconst socket_util_1 = __importDefault(__webpack_require__(/*! ./socket_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js\"));\nconst proxy_util_1 = __importDefault(__webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nclass SnowflakeHttpsProxyAgent extends https_proxy_agent_1.HttpsProxyAgent {\n    useForOCSP;\n    crlValidatorConfig;\n    constructor(opts) {\n        const { host, port, user, password, protocol: rawProtocol, useForOCSP, crlValidatorConfig, ...agentOptions } = opts;\n        const protocol = rawProtocol.endsWith(':') ? rawProtocol : `${rawProtocol}:`;\n        const proxyUrl = new url_1.URL(`${protocol}//${host}:${port}`);\n        proxyUrl.username = user ?? '';\n        proxyUrl.password = password ?? '';\n        super(proxyUrl, agentOptions);\n        this.useForOCSP = useForOCSP;\n        this.crlValidatorConfig = crlValidatorConfig;\n    }\n    async connect(req, opts) {\n        (0, logger_1.default)().debug('Using proxy=%s for host %s', this.proxy.hostname, opts.host);\n        const socket = await super.connect(req, opts);\n        if (socket instanceof tls.TLSSocket) {\n            if ((0, crl_validator_1.isCrlValidationEnabled)(this.crlValidatorConfig)) {\n                (0, crl_validator_1.corkSocketAndValidateCrl)(socket, this.crlValidatorConfig);\n            }\n            else {\n                const isProxyRequiredForOCSP = this.useForOCSP &&\n                    !proxy_util_1.default.isByPassProxy(this.proxy, socket_util_1.default.REGEX_SNOWFLAKE_ENDPOINT);\n                socket_util_1.default.secureSocket(socket, this.proxy.hostname, isProxyRequiredForOCSP ? this : null);\n            }\n        }\n        return socket;\n    }\n}\nmodule.exports = SnowflakeHttpsProxyAgent;\n//# sourceMappingURL=https_proxy_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19wcm94eV9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixtQkFBTyxDQUFDLGdCQUFLO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiw0QkFBNEIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDdkQsd0JBQXdCLG1CQUFPLENBQUMsMkZBQWlCO0FBQ2pELHNDQUFzQyxtQkFBTyxDQUFDLHVGQUFlO0FBQzdELHFDQUFxQyxtQkFBTyxDQUFDLGdGQUFlO0FBQzVELGlDQUFpQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFHQUFxRztBQUNySCxzRUFBc0UsWUFBWTtBQUNsRiwwQ0FBMEMsU0FBUyxJQUFJLEtBQUssR0FBRyxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYWdlbnQvaHR0cHNfcHJveHlfYWdlbnQuanM/YjI3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdGxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgaHR0cHNfcHJveHlfYWdlbnRfMSA9IHJlcXVpcmUoXCJodHRwcy1wcm94eS1hZ2VudFwiKTtcbmNvbnN0IGNybF92YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCIuL2NybF92YWxpZGF0b3JcIik7XG5jb25zdCBzb2NrZXRfdXRpbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NvY2tldF91dGlsXCIpKTtcbmNvbnN0IHByb3h5X3V0aWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vcHJveHlfdXRpbFwiKSk7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9nZ2VyXCIpKTtcbmNsYXNzIFNub3dmbGFrZUh0dHBzUHJveHlBZ2VudCBleHRlbmRzIGh0dHBzX3Byb3h5X2FnZW50XzEuSHR0cHNQcm94eUFnZW50IHtcbiAgICB1c2VGb3JPQ1NQO1xuICAgIGNybFZhbGlkYXRvckNvbmZpZztcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCwgcG9ydCwgdXNlciwgcGFzc3dvcmQsIHByb3RvY29sOiByYXdQcm90b2NvbCwgdXNlRm9yT0NTUCwgY3JsVmFsaWRhdG9yQ29uZmlnLCAuLi5hZ2VudE9wdGlvbnMgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmF3UHJvdG9jb2wuZW5kc1dpdGgoJzonKSA/IHJhd1Byb3RvY29sIDogYCR7cmF3UHJvdG9jb2x9OmA7XG4gICAgICAgIGNvbnN0IHByb3h5VXJsID0gbmV3IHVybF8xLlVSTChgJHtwcm90b2NvbH0vLyR7aG9zdH06JHtwb3J0fWApO1xuICAgICAgICBwcm94eVVybC51c2VybmFtZSA9IHVzZXIgPz8gJyc7XG4gICAgICAgIHByb3h5VXJsLnBhc3N3b3JkID0gcGFzc3dvcmQgPz8gJyc7XG4gICAgICAgIHN1cGVyKHByb3h5VXJsLCBhZ2VudE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVzZUZvck9DU1AgPSB1c2VGb3JPQ1NQO1xuICAgICAgICB0aGlzLmNybFZhbGlkYXRvckNvbmZpZyA9IGNybFZhbGlkYXRvckNvbmZpZztcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdChyZXEsIG9wdHMpIHtcbiAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoJ1VzaW5nIHByb3h5PSVzIGZvciBob3N0ICVzJywgdGhpcy5wcm94eS5ob3N0bmFtZSwgb3B0cy5ob3N0KTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gYXdhaXQgc3VwZXIuY29ubmVjdChyZXEsIG9wdHMpO1xuICAgICAgICBpZiAoc29ja2V0IGluc3RhbmNlb2YgdGxzLlRMU1NvY2tldCkge1xuICAgICAgICAgICAgaWYgKCgwLCBjcmxfdmFsaWRhdG9yXzEuaXNDcmxWYWxpZGF0aW9uRW5hYmxlZCkodGhpcy5jcmxWYWxpZGF0b3JDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgKDAsIGNybF92YWxpZGF0b3JfMS5jb3JrU29ja2V0QW5kVmFsaWRhdGVDcmwpKHNvY2tldCwgdGhpcy5jcmxWYWxpZGF0b3JDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNQcm94eVJlcXVpcmVkRm9yT0NTUCA9IHRoaXMudXNlRm9yT0NTUCAmJlxuICAgICAgICAgICAgICAgICAgICAhcHJveHlfdXRpbF8xLmRlZmF1bHQuaXNCeVBhc3NQcm94eSh0aGlzLnByb3h5LCBzb2NrZXRfdXRpbF8xLmRlZmF1bHQuUkVHRVhfU05PV0ZMQUtFX0VORFBPSU5UKTtcbiAgICAgICAgICAgICAgICBzb2NrZXRfdXRpbF8xLmRlZmF1bHQuc2VjdXJlU29ja2V0KHNvY2tldCwgdGhpcy5wcm94eS5ob3N0bmFtZSwgaXNQcm94eVJlcXVpcmVkRm9yT0NTUCA/IHRoaXMgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gU25vd2ZsYWtlSHR0cHNQcm94eUFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cHNfcHJveHlfYWdlbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst SimpleCache = __webpack_require__(/*! simple-lru-cache */ \"(rsc)/./node_modules/simple-lru-cache/index.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst status = {\n    NOT_START: 'not_start',\n    STARTED: 'started',\n    FINISHED: 'finish',\n};\n// validate input\nconst sizeLimit = GlobalConfig.getOcspResponseCacheSizeLimit();\n// ocsp cache max age in second\nlet maxAgeSec = GlobalConfig.getOcspResponseCacheMaxAge();\nErrors.assertInternal(Util.number.isPositiveInteger(sizeLimit));\nErrors.assertInternal(Util.number.isPositiveInteger(maxAgeSec));\nconst cacheDir = GlobalConfig.mkdirCacheDir();\nconst cacheFileName = path.join(cacheDir, 'ocsp_response_cache.json');\n// create a cache to store the responses, dynamically changes in size\nlet cache;\n// Cache updated time, in seconds, initialized as current time.\n// Will be updated when load from local cache file or refresh by downloading\nfunction deleteCache() {\n    try {\n        cache.reset();\n        fs.unlinkSync(cacheFileName);\n    }\n    catch (e) {\n        Logger.getInstance().debug('Failed to delete OCSP cache file: %s, err: %s', cacheFileName, e);\n    }\n}\nexports.deleteCache = deleteCache;\n/**\n * Cache for storing OCSP responses. This covers both client and server caches.\n *\n * @constructor\n */\nfunction OcspResponseCache() {\n    let downloadStatus = status.NOT_START;\n    let cacheUpdated = false;\n    let cacheInitialized = false;\n    let proxyAgent = null;\n    /**\n     * Reads OCSP cache file.\n     */\n    // Cache update time in second\n    let cacheUpdateTimeSec = Date.now() / 1000;\n    let OCSP_URL = process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL;\n    if (!OCSP_URL) {\n        OCSP_URL = 'http://ocsp.snowflakecomputing.com/ocsp_response_cache.json';\n    }\n    try {\n        Logger.getInstance().debug('Reading OCSP cache file. %s', cacheFileName);\n        const contents = fs.readFileSync(cacheFileName, 'utf-8');\n        const jsonCacheFromFile = JSON.parse(contents);\n        updateCache(jsonCacheFromFile);\n        cacheInitialized = true;\n    }\n    catch (e) {\n        Logger.getInstance().debug('Failed to read OCSP cache file: %s, err: %s', cacheFileName, e);\n    }\n    /**\n     * set proxy agent for ocsp validation\n     *\n     * @param agent\n     */\n    this.setAgent = function setAgent(agent) {\n        proxyAgent = agent;\n    };\n    /**\n     * Initializes the cache\n     *\n     * @param cert\n     * @param response\n     */\n    this.initCache = function initCache(cert, response) {\n        cache = new SimpleCache({ maxSize: 1 });\n        this.set(cert, response);\n    };\n    /**\n     * Is OCSP Cache initialized?\n     * @returns {boolean}\n     */\n    this.isInitialized = function () {\n        return cacheInitialized;\n    };\n    /**\n     * Is OCSP Cache download finished?\n     * @returns {boolean}\n     */\n    this.isDownloadFinished = function () {\n        return downloadStatus === status.FINISHED;\n    };\n    /**\n     * Forces download status to finish\n     */\n    this.forceDownloadToFinish = function () {\n        downloadStatus = status.FINISHED;\n    };\n    /**\n     * Is local OCSP Cache expired?\n     * @returns {boolean}\n     */\n    this.IsCacheExpired = function () {\n        if (!cacheInitialized) {\n            return false;\n        }\n        // Update maxAge in case it could be changed through environment variable\n        maxAgeSec = GlobalConfig.getOcspResponseCacheMaxAge();\n        // Current time in seconds\n        const currentTimeSec = Date.now() / 1000;\n        if (currentTimeSec - cacheUpdateTimeSec > maxAgeSec) {\n            Logger.getInstance().debug('OCSP local cache validity is out of range. currentTime: %s, timestamp: %s, maxAge: %s', currentTimeSec, cacheUpdateTimeSec, maxAgeSec);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Resets OCSP Cache status\n     */\n    this.resetCacheStatus = function () {\n        downloadStatus = status.NOT_START;\n        if (cacheUpdated) {\n            Logger.getInstance().debug(cacheFileName);\n            // current time in second\n            const currentTimeSec = Date.now() / 1000;\n            const cacheOutput = {};\n            cache.forEach(function (v, k) {\n                const certIdInBase64 = CertUtil.decodeKey(k);\n                const ocspResponseInBase64 = v.toString('BASE64');\n                cacheOutput[certIdInBase64] = [currentTimeSec, ocspResponseInBase64];\n            });\n            const writeContent = JSON.stringify(cacheOutput);\n            Logger.getInstance().debug('Writing OCSP cache file. %s', cacheFileName);\n            try {\n                fs.writeFileSync(cacheFileName, writeContent, 'utf-8');\n            }\n            catch (e) {\n                Logger.getInstance().debug('Failed to update OCSP cache file: %s, err: %s', cacheFileName, e);\n            }\n            cacheUpdated = false;\n        }\n    };\n    /**\n     * Adds an entry to the cache.\n     *\n     * @param cert\n     * @param response\n     */\n    this.set = function set(cert, response) {\n        try {\n            const certId = CertUtil.buildCertId(cert);\n            cache.set(certId, response);\n            cacheUpdated = true;\n        }\n        catch (e) {\n            Logger.getInstance().debug('Failed to add certificate to OCSP cache file. err: %s', e);\n        }\n    };\n    /**\n     * Returns an entry from the cache.\n     *\n     * @param cert\n     * @returns {*}\n     */\n    this.get = function get(cert) {\n        try {\n            const certId = CertUtil.buildCertId(cert);\n            return cache.get(certId);\n        }\n        catch (e) {\n            Logger.getInstance().debug('Failed to get certificate from OCSP cache. err: %s', e);\n            return null;\n        }\n    };\n    /**\n     * Downloads OCSP cache from the Snowflake OCSP cache server.\n     * @param cb callback\n     */\n    this.downloadCache = function (cb) {\n        if (downloadStatus === status.STARTED) {\n            // reschedule calling cb\n            return false;\n        }\n        else if (downloadStatus === status.FINISHED) {\n            // call cb immediately\n            cb(null, false);\n            return true;\n        }\n        downloadStatus = status.STARTED;\n        function checkOCSPResponse(err, cacheContent) {\n            if (downloadStatus === status.FINISHED) {\n                return;\n            }\n            downloadStatus = status.FINISHED;\n            Logger.getInstance().debug('Finish OCSP Cache Server: %s', OCSP_URL);\n            if (err) {\n                Logger.getInstance().debug('Failed to download OCSP cache file. %s. Ignored', err);\n                return cb(err, false);\n            }\n            try {\n                const jsonParsed = JSON.parse(cacheContent);\n                updateCache(jsonParsed);\n                cacheUpdated = true;\n                return cb(null, false);\n            }\n            catch (e) {\n                cb(e, false);\n            }\n        }\n        function onResponse(response) {\n            if (response.statusCode < 200 || response.statusCode >= 400) {\n                return checkOCSPResponse(new Error('Failed to obtain OCSP response: ' + response.statusCode), null);\n            }\n            let rawData = '';\n            // A chunk of data has been received.\n            response.on('data', function (chunk) {\n                rawData += chunk;\n            });\n            // The whole response has been received. Print out the result.\n            response.on('end', function () {\n                checkOCSPResponse(null, rawData);\n            });\n        }\n        const uri = url.parse(OCSP_URL);\n        const timeout = process.env.SF_OCSP_TEST_OCSP_RESPONSE_CACHE_SERVER_TIMEOUT || 5000;\n        const options = Object.assign({\n            timeout: Number(timeout),\n            method: 'GET',\n            agent: proxyAgent,\n        }, uri);\n        const httpRequest = http.request(options, onResponse);\n        httpRequest.on('error', function (e) {\n            downloadStatus = status.FINISHED;\n            if (cb) {\n                cb(e, false);\n            }\n            cb = null;\n        });\n        httpRequest.on('timeout', function () {\n            downloadStatus = status.FINISHED;\n            httpRequest.abort();\n            Logger.getInstance().debug('Timeout OCSP responder: %s, %ss', OCSP_URL, options.timeout);\n            if (cb) {\n                cb(Errors.createOCSPError(ErrorCodes.ERR_OCSP_CACHE_SERVER_TIMEOUT), false);\n            }\n            cb = null;\n        });\n        httpRequest.end();\n        Logger.getInstance().trace('Contact OCSP Cache Server: %s', OCSP_URL);\n        return true;\n    };\n    /**\n     * Validate cache entry\n     * @param certIdBase64 cache key\n     * @param ocspResponseBase64 cache value\n     * @returns {Object}\n     */\n    function validateCacheEntry(certIdBase64, ocspResponseBase64) {\n        let err;\n        if (ocspResponseBase64.length !== 2) {\n            Logger.getInstance().debug(\"OCSP cache value doesn't consist of two elements. Ignored.\");\n            err = Errors.createOCSPError(ErrorCodes.ERR_OCSP_NOT_TWO_ELEMENTS);\n        }\n        const cacheEntryWriteTime = ocspResponseBase64[0];\n        const currentTimeSec = Date.now() / 1000;\n        if (currentTimeSec - cacheEntryWriteTime > maxAgeSec) {\n            Logger.getInstance().debug('OCSP cache validity is out of range. currentTime: %s, timestamp: %s, maxAge: %s', currentTimeSec, cacheEntryWriteTime, maxAgeSec);\n            err = Errors.createOCSPError(ErrorCodes.ERR_OCSP_CACHE_EXPIRED);\n        }\n        try {\n            const k = CertUtil.encodeKey(certIdBase64);\n            if (err) {\n                return { err: err, key: k };\n            }\n            const cacheEntryOcspResponse = ocspResponseBase64[1];\n            const rawOCSPResponse = Buffer.from(cacheEntryOcspResponse, 'base64');\n            const status = CertUtil.verifyOCSPResponse(null, rawOCSPResponse);\n            if (!status.err) {\n                return { err: null, key: k, value: rawOCSPResponse };\n            }\n            return { err: status.err };\n        }\n        catch (e) {\n            Logger.getInstance().debug('Failed to parse OCSP response. %s. Ignored.', e);\n            return { err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_FAILED_PARSE_RESPONSE) };\n        }\n    }\n    function updateCache(jsonObject) {\n        // Get the size of cache\n        const cacheSize = Object.keys(jsonObject).length;\n        // Create cache using response cache size if it doesn't exceed the upper limit\n        cache = new SimpleCache({ maxSize: cacheSize < sizeLimit ? cacheSize : sizeLimit });\n        // Add new entries\n        setCacheEntries(jsonObject);\n        // set cache update time\n        cacheInitialized = true;\n    }\n    function setCacheEntries(jsonObject) {\n        let cacheUpdateTime = Date.now() / 1000;\n        for (const entry in jsonObject) {\n            if (Object.prototype.hasOwnProperty.call(jsonObject, entry)) {\n                const newUpdateTime = validateAndSetEntry(jsonObject, entry, cacheUpdateTime);\n                if (newUpdateTime) {\n                    cacheUpdateTime = newUpdateTime;\n                }\n            }\n        }\n        cacheUpdateTimeSec = cacheUpdateTime;\n    }\n    function validateAndSetEntry(jsonObject, entry, cacheUpdateTime) {\n        const status = validateCacheEntry(entry, jsonObject[entry]);\n        if (!status.err) {\n            // Add new entry or update existing one\n            cache.set(status.key, status.value);\n            // change cache update time if needed\n            if (jsonObject[entry][0] < cacheUpdateTime) {\n                return jsonObject[entry][0];\n            }\n        }\n        else {\n            Logger.getInstance().trace('Error when validating OCSP cache entry %s, %s', entry, status.err.toString());\n        }\n    }\n}\nexports.OcspResponseCache = OcspResponseCache;\n//# sourceMappingURL=ocsp_response_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9vY3NwX3Jlc3BvbnNlX2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWtCO0FBQzlDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBYTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0RBQXdEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L29jc3BfcmVzcG9uc2VfY2FjaGUuanM/YzZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBTaW1wbGVDYWNoZSA9IHJlcXVpcmUoJ3NpbXBsZS1scnUtY2FjaGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBDZXJ0VXRpbCA9IHJlcXVpcmUoJy4vY2VydF91dGlsJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IHN0YXR1cyA9IHtcbiAgICBOT1RfU1RBUlQ6ICdub3Rfc3RhcnQnLFxuICAgIFNUQVJURUQ6ICdzdGFydGVkJyxcbiAgICBGSU5JU0hFRDogJ2ZpbmlzaCcsXG59O1xuLy8gdmFsaWRhdGUgaW5wdXRcbmNvbnN0IHNpemVMaW1pdCA9IEdsb2JhbENvbmZpZy5nZXRPY3NwUmVzcG9uc2VDYWNoZVNpemVMaW1pdCgpO1xuLy8gb2NzcCBjYWNoZSBtYXggYWdlIGluIHNlY29uZFxubGV0IG1heEFnZVNlYyA9IEdsb2JhbENvbmZpZy5nZXRPY3NwUmVzcG9uc2VDYWNoZU1heEFnZSgpO1xuRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyKHNpemVMaW1pdCkpO1xuRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyKG1heEFnZVNlYykpO1xuY29uc3QgY2FjaGVEaXIgPSBHbG9iYWxDb25maWcubWtkaXJDYWNoZURpcigpO1xuY29uc3QgY2FjaGVGaWxlTmFtZSA9IHBhdGguam9pbihjYWNoZURpciwgJ29jc3BfcmVzcG9uc2VfY2FjaGUuanNvbicpO1xuLy8gY3JlYXRlIGEgY2FjaGUgdG8gc3RvcmUgdGhlIHJlc3BvbnNlcywgZHluYW1pY2FsbHkgY2hhbmdlcyBpbiBzaXplXG5sZXQgY2FjaGU7XG4vLyBDYWNoZSB1cGRhdGVkIHRpbWUsIGluIHNlY29uZHMsIGluaXRpYWxpemVkIGFzIGN1cnJlbnQgdGltZS5cbi8vIFdpbGwgYmUgdXBkYXRlZCB3aGVuIGxvYWQgZnJvbSBsb2NhbCBjYWNoZSBmaWxlIG9yIHJlZnJlc2ggYnkgZG93bmxvYWRpbmdcbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNhY2hlLnJlc2V0KCk7XG4gICAgICAgIGZzLnVubGlua1N5bmMoY2FjaGVGaWxlTmFtZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gZGVsZXRlIE9DU1AgY2FjaGUgZmlsZTogJXMsIGVycjogJXMnLCBjYWNoZUZpbGVOYW1lLCBlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlbGV0ZUNhY2hlID0gZGVsZXRlQ2FjaGU7XG4vKipcbiAqIENhY2hlIGZvciBzdG9yaW5nIE9DU1AgcmVzcG9uc2VzLiBUaGlzIGNvdmVycyBib3RoIGNsaWVudCBhbmQgc2VydmVyIGNhY2hlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT2NzcFJlc3BvbnNlQ2FjaGUoKSB7XG4gICAgbGV0IGRvd25sb2FkU3RhdHVzID0gc3RhdHVzLk5PVF9TVEFSVDtcbiAgICBsZXQgY2FjaGVVcGRhdGVkID0gZmFsc2U7XG4gICAgbGV0IGNhY2hlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBsZXQgcHJveHlBZ2VudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogUmVhZHMgT0NTUCBjYWNoZSBmaWxlLlxuICAgICAqL1xuICAgIC8vIENhY2hlIHVwZGF0ZSB0aW1lIGluIHNlY29uZFxuICAgIGxldCBjYWNoZVVwZGF0ZVRpbWVTZWMgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBsZXQgT0NTUF9VUkwgPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9VUkw7XG4gICAgaWYgKCFPQ1NQX1VSTCkge1xuICAgICAgICBPQ1NQX1VSTCA9ICdodHRwOi8vb2NzcC5zbm93Zmxha2Vjb21wdXRpbmcuY29tL29jc3BfcmVzcG9uc2VfY2FjaGUuanNvbic7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdSZWFkaW5nIE9DU1AgY2FjaGUgZmlsZS4gJXMnLCBjYWNoZUZpbGVOYW1lKTtcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMoY2FjaGVGaWxlTmFtZSwgJ3V0Zi04Jyk7XG4gICAgICAgIGNvbnN0IGpzb25DYWNoZUZyb21GaWxlID0gSlNPTi5wYXJzZShjb250ZW50cyk7XG4gICAgICAgIHVwZGF0ZUNhY2hlKGpzb25DYWNoZUZyb21GaWxlKTtcbiAgICAgICAgY2FjaGVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gcmVhZCBPQ1NQIGNhY2hlIGZpbGU6ICVzLCBlcnI6ICVzJywgY2FjaGVGaWxlTmFtZSwgZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCBwcm94eSBhZ2VudCBmb3Igb2NzcCB2YWxpZGF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWdlbnRcbiAgICAgKi9cbiAgICB0aGlzLnNldEFnZW50ID0gZnVuY3Rpb24gc2V0QWdlbnQoYWdlbnQpIHtcbiAgICAgICAgcHJveHlBZ2VudCA9IGFnZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNhY2hlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2VydFxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuaW5pdENhY2hlID0gZnVuY3Rpb24gaW5pdENhY2hlKGNlcnQsIHJlc3BvbnNlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IFNpbXBsZUNhY2hlKHsgbWF4U2l6ZTogMSB9KTtcbiAgICAgICAgdGhpcy5zZXQoY2VydCwgcmVzcG9uc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXMgT0NTUCBDYWNoZSBpbml0aWFsaXplZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZUluaXRpYWxpemVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXMgT0NTUCBDYWNoZSBkb3dubG9hZCBmaW5pc2hlZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRG93bmxvYWRGaW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkU3RhdHVzID09PSBzdGF0dXMuRklOSVNIRUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgZG93bmxvYWQgc3RhdHVzIHRvIGZpbmlzaFxuICAgICAqL1xuICAgIHRoaXMuZm9yY2VEb3dubG9hZFRvRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5GSU5JU0hFRDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElzIGxvY2FsIE9DU1AgQ2FjaGUgZXhwaXJlZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLklzQ2FjaGVFeHBpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNhY2hlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbWF4QWdlIGluIGNhc2UgaXQgY291bGQgYmUgY2hhbmdlZCB0aHJvdWdoIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgICAgIG1heEFnZVNlYyA9IEdsb2JhbENvbmZpZy5nZXRPY3NwUmVzcG9uc2VDYWNoZU1heEFnZSgpO1xuICAgICAgICAvLyBDdXJyZW50IHRpbWUgaW4gc2Vjb25kc1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZVNlYyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICBpZiAoY3VycmVudFRpbWVTZWMgLSBjYWNoZVVwZGF0ZVRpbWVTZWMgPiBtYXhBZ2VTZWMpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdPQ1NQIGxvY2FsIGNhY2hlIHZhbGlkaXR5IGlzIG91dCBvZiByYW5nZS4gY3VycmVudFRpbWU6ICVzLCB0aW1lc3RhbXA6ICVzLCBtYXhBZ2U6ICVzJywgY3VycmVudFRpbWVTZWMsIGNhY2hlVXBkYXRlVGltZVNlYywgbWF4QWdlU2VjKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyBPQ1NQIENhY2hlIHN0YXR1c1xuICAgICAqL1xuICAgIHRoaXMucmVzZXRDYWNoZVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG93bmxvYWRTdGF0dXMgPSBzdGF0dXMuTk9UX1NUQVJUO1xuICAgICAgICBpZiAoY2FjaGVVcGRhdGVkKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhjYWNoZUZpbGVOYW1lKTtcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lU2VjID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICBjb25zdCBjYWNoZU91dHB1dCA9IHt9O1xuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlcnRJZEluQmFzZTY0ID0gQ2VydFV0aWwuZGVjb2RlS2V5KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9jc3BSZXNwb25zZUluQmFzZTY0ID0gdi50b1N0cmluZygnQkFTRTY0Jyk7XG4gICAgICAgICAgICAgICAgY2FjaGVPdXRwdXRbY2VydElkSW5CYXNlNjRdID0gW2N1cnJlbnRUaW1lU2VjLCBvY3NwUmVzcG9uc2VJbkJhc2U2NF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KGNhY2hlT3V0cHV0KTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdXcml0aW5nIE9DU1AgY2FjaGUgZmlsZS4gJXMnLCBjYWNoZUZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhjYWNoZUZpbGVOYW1lLCB3cml0ZUNvbnRlbnQsICd1dGYtOCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIHVwZGF0ZSBPQ1NQIGNhY2hlIGZpbGU6ICVzLCBlcnI6ICVzJywgY2FjaGVGaWxlTmFtZSwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZVVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbnRyeSB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2VydFxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gc2V0KGNlcnQsIHJlc3BvbnNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjZXJ0SWQgPSBDZXJ0VXRpbC5idWlsZENlcnRJZChjZXJ0KTtcbiAgICAgICAgICAgIGNhY2hlLnNldChjZXJ0SWQsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNhY2hlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gYWRkIGNlcnRpZmljYXRlIHRvIE9DU1AgY2FjaGUgZmlsZS4gZXJyOiAlcycsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlcnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uIGdldChjZXJ0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjZXJ0SWQgPSBDZXJ0VXRpbC5idWlsZENlcnRJZChjZXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoY2VydElkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBnZXQgY2VydGlmaWNhdGUgZnJvbSBPQ1NQIGNhY2hlLiBlcnI6ICVzJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIE9DU1AgY2FjaGUgZnJvbSB0aGUgU25vd2ZsYWtlIE9DU1AgY2FjaGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSBjYiBjYWxsYmFja1xuICAgICAqL1xuICAgIHRoaXMuZG93bmxvYWRDYWNoZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICBpZiAoZG93bmxvYWRTdGF0dXMgPT09IHN0YXR1cy5TVEFSVEVEKSB7XG4gICAgICAgICAgICAvLyByZXNjaGVkdWxlIGNhbGxpbmcgY2JcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb3dubG9hZFN0YXR1cyA9PT0gc3RhdHVzLkZJTklTSEVEKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGNiIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBjYihudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5TVEFSVEVEO1xuICAgICAgICBmdW5jdGlvbiBjaGVja09DU1BSZXNwb25zZShlcnIsIGNhY2hlQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGRvd25sb2FkU3RhdHVzID09PSBzdGF0dXMuRklOSVNIRUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5GSU5JU0hFRDtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGaW5pc2ggT0NTUCBDYWNoZSBTZXJ2ZXI6ICVzJywgT0NTUF9VUkwpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gZG93bmxvYWQgT0NTUCBjYWNoZSBmaWxlLiAlcy4gSWdub3JlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyciwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uUGFyc2VkID0gSlNPTi5wYXJzZShjYWNoZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNhY2hlKGpzb25QYXJzZWQpO1xuICAgICAgICAgICAgICAgIGNhY2hlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2IoZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrT0NTUFJlc3BvbnNlKG5ldyBFcnJvcignRmFpbGVkIHRvIG9idGFpbiBPQ1NQIHJlc3BvbnNlOiAnICsgcmVzcG9uc2Uuc3RhdHVzQ29kZSksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJhd0RhdGEgPSAnJztcbiAgICAgICAgICAgIC8vIEEgY2h1bmsgb2YgZGF0YSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmF3RGF0YSArPSBjaHVuaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhlIHdob2xlIHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkLiBQcmludCBvdXQgdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tPQ1NQUmVzcG9uc2UobnVsbCwgcmF3RGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSB1cmwucGFyc2UoT0NTUF9VUkwpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gcHJvY2Vzcy5lbnYuU0ZfT0NTUF9URVNUX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX1RJTUVPVVQgfHwgNTAwMDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgdGltZW91dDogTnVtYmVyKHRpbWVvdXQpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGFnZW50OiBwcm94eUFnZW50LFxuICAgICAgICB9LCB1cmkpO1xuICAgICAgICBjb25zdCBodHRwUmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zLCBvblJlc3BvbnNlKTtcbiAgICAgICAgaHR0cFJlcXVlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRvd25sb2FkU3RhdHVzID0gc3RhdHVzLkZJTklTSEVEO1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cFJlcXVlc3Qub24oJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5GSU5JU0hFRDtcbiAgICAgICAgICAgIGh0dHBSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnVGltZW91dCBPQ1NQIHJlc3BvbmRlcjogJXMsICVzcycsIE9DU1BfVVJMLCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0NBQ0hFX1NFUlZFUl9USU1FT1VUKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cFJlcXVlc3QuZW5kKCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb250YWN0IE9DU1AgQ2FjaGUgU2VydmVyOiAlcycsIE9DU1BfVVJMKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBjYWNoZSBlbnRyeVxuICAgICAqIEBwYXJhbSBjZXJ0SWRCYXNlNjQgY2FjaGUga2V5XG4gICAgICogQHBhcmFtIG9jc3BSZXNwb25zZUJhc2U2NCBjYWNoZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDYWNoZUVudHJ5KGNlcnRJZEJhc2U2NCwgb2NzcFJlc3BvbnNlQmFzZTY0KSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmIChvY3NwUmVzcG9uc2VCYXNlNjQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhcIk9DU1AgY2FjaGUgdmFsdWUgZG9lc24ndCBjb25zaXN0IG9mIHR3byBlbGVtZW50cy4gSWdub3JlZC5cIik7XG4gICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfTk9UX1RXT19FTEVNRU5UUyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVFbnRyeVdyaXRlVGltZSA9IG9jc3BSZXNwb25zZUJhc2U2NFswXTtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVTZWMgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lU2VjIC0gY2FjaGVFbnRyeVdyaXRlVGltZSA+IG1heEFnZVNlYykge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ09DU1AgY2FjaGUgdmFsaWRpdHkgaXMgb3V0IG9mIHJhbmdlLiBjdXJyZW50VGltZTogJXMsIHRpbWVzdGFtcDogJXMsIG1heEFnZTogJXMnLCBjdXJyZW50VGltZVNlYywgY2FjaGVFbnRyeVdyaXRlVGltZSwgbWF4QWdlU2VjKTtcbiAgICAgICAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9DQUNIRV9FWFBJUkVEKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgayA9IENlcnRVdGlsLmVuY29kZUtleShjZXJ0SWRCYXNlNjQpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycjogZXJyLCBrZXk6IGsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnlPY3NwUmVzcG9uc2UgPSBvY3NwUmVzcG9uc2VCYXNlNjRbMV07XG4gICAgICAgICAgICBjb25zdCByYXdPQ1NQUmVzcG9uc2UgPSBCdWZmZXIuZnJvbShjYWNoZUVudHJ5T2NzcFJlc3BvbnNlLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBDZXJ0VXRpbC52ZXJpZnlPQ1NQUmVzcG9uc2UobnVsbCwgcmF3T0NTUFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmICghc3RhdHVzLmVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycjogbnVsbCwga2V5OiBrLCB2YWx1ZTogcmF3T0NTUFJlc3BvbnNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnI6IHN0YXR1cy5lcnIgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBwYXJzZSBPQ1NQIHJlc3BvbnNlLiAlcy4gSWdub3JlZC4nLCBlKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycjogRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0ZBSUxFRF9QQVJTRV9SRVNQT05TRSkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDYWNoZShqc29uT2JqZWN0KSB7XG4gICAgICAgIC8vIEdldCB0aGUgc2l6ZSBvZiBjYWNoZVxuICAgICAgICBjb25zdCBjYWNoZVNpemUgPSBPYmplY3Qua2V5cyhqc29uT2JqZWN0KS5sZW5ndGg7XG4gICAgICAgIC8vIENyZWF0ZSBjYWNoZSB1c2luZyByZXNwb25zZSBjYWNoZSBzaXplIGlmIGl0IGRvZXNuJ3QgZXhjZWVkIHRoZSB1cHBlciBsaW1pdFxuICAgICAgICBjYWNoZSA9IG5ldyBTaW1wbGVDYWNoZSh7IG1heFNpemU6IGNhY2hlU2l6ZSA8IHNpemVMaW1pdCA/IGNhY2hlU2l6ZSA6IHNpemVMaW1pdCB9KTtcbiAgICAgICAgLy8gQWRkIG5ldyBlbnRyaWVzXG4gICAgICAgIHNldENhY2hlRW50cmllcyhqc29uT2JqZWN0KTtcbiAgICAgICAgLy8gc2V0IGNhY2hlIHVwZGF0ZSB0aW1lXG4gICAgICAgIGNhY2hlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUVudHJpZXMoanNvbk9iamVjdCkge1xuICAgICAgICBsZXQgY2FjaGVVcGRhdGVUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgaW4ganNvbk9iamVjdCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uT2JqZWN0LCBlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdVcGRhdGVUaW1lID0gdmFsaWRhdGVBbmRTZXRFbnRyeShqc29uT2JqZWN0LCBlbnRyeSwgY2FjaGVVcGRhdGVUaW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3VXBkYXRlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVVwZGF0ZVRpbWUgPSBuZXdVcGRhdGVUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWNoZVVwZGF0ZVRpbWVTZWMgPSBjYWNoZVVwZGF0ZVRpbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQW5kU2V0RW50cnkoanNvbk9iamVjdCwgZW50cnksIGNhY2hlVXBkYXRlVGltZSkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB2YWxpZGF0ZUNhY2hlRW50cnkoZW50cnksIGpzb25PYmplY3RbZW50cnldKTtcbiAgICAgICAgaWYgKCFzdGF0dXMuZXJyKSB7XG4gICAgICAgICAgICAvLyBBZGQgbmV3IGVudHJ5IG9yIHVwZGF0ZSBleGlzdGluZyBvbmVcbiAgICAgICAgICAgIGNhY2hlLnNldChzdGF0dXMua2V5LCBzdGF0dXMudmFsdWUpO1xuICAgICAgICAgICAgLy8gY2hhbmdlIGNhY2hlIHVwZGF0ZSB0aW1lIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKGpzb25PYmplY3RbZW50cnldWzBdIDwgY2FjaGVVcGRhdGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25PYmplY3RbZW50cnldWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Vycm9yIHdoZW4gdmFsaWRhdGluZyBPQ1NQIGNhY2hlIGVudHJ5ICVzLCAlcycsIGVudHJ5LCBzdGF0dXMuZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5PY3NwUmVzcG9uc2VDYWNoZSA9IE9jc3BSZXNwb25zZUNhY2hlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2NzcF9yZXNwb25zZV9jYWNoZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Check = __webpack_require__(/*! ./check */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/check.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\");\nconst OcspResponseCache = __webpack_require__(/*! ./ocsp_response_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst ProxyAgent = __webpack_require__(/*! ../agent/https_proxy_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js\");\nconst ErrorCodes = Errors.codes;\nconst REGEX_SNOWFLAKE_ENDPOINT = /.snowflakecomputing./;\nexports.REGEX_SNOWFLAKE_ENDPOINT = REGEX_SNOWFLAKE_ENDPOINT;\nconst socketSecuredEvent = 'secureConnect';\nconst rawOcspFlag = process.env.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED;\nconst variables = {\n    SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED: !rawOcspFlag || (rawOcspFlag && rawOcspFlag.toLowerCase() !== 'false'),\n    OCSP_RESPONSE_CACHE: undefined,\n};\n/**\n * Returns the ocsp response cache.\n *\n * @returns {*}\n */\nfunction getOcspResponseCache() {\n    // initialize the ocsp response cache if needed\n    if (!variables.OCSP_RESPONSE_CACHE) {\n        variables.OCSP_RESPONSE_CACHE = new OcspResponseCache.OcspResponseCache();\n    }\n    return variables.OCSP_RESPONSE_CACHE;\n}\nexports.variables = variables;\n/**\n * Secures a given TLSSocket by blocking all writes until the certificate\n * associated with the socket has been validated.\n *\n * @param {Object} socket\n * @param {String} host\n * @param {Object|null} agent\n * @param {Object} [mock]\n *\n * @returns {Object}\n */\nexports.secureSocket = function (socket, host, agent, mock) {\n    // if ocsp validation is disabled for the given host, return the socket as is\n    if (isOcspValidationDisabled(host)) {\n        Logger.getInstance().debug('OCSP validation disabled for %s', host);\n        return socket;\n    }\n    if (agent != null) {\n        getOcspResponseCache().setAgent(agent);\n    }\n    else if (GlobalConfig.isEnvProxyActive()) {\n        const httpProxy = ProxyUtil.getProxyFromEnv(false);\n        if (httpProxy && !ProxyUtil.isByPassProxy(httpProxy, REGEX_SNOWFLAKE_ENDPOINT)) {\n            agent = ProxyAgent(httpProxy);\n            getOcspResponseCache().setAgent(agent);\n        }\n    }\n    const validate = function () {\n        // stop listening for the secure event\n        socket.removeListener(socketSecuredEvent, validate);\n        Logger.getInstance().trace('socket reused = %s', socket.isSessionReused());\n        // if the server has resumed our existing session, unblock all\n        // writes without performing any additional validation\n        if (socket.isSessionReused()) {\n            socket.uncork();\n        }\n        else {\n            if (!socket.authorized) {\n                Logger.getInstance().warn('Socket is not authorized: %s', socket.authorizationError);\n                return socket.destroy(socket.authorizationError);\n            }\n            // use ocsp to make sure the entire certificate chain can be trusted\n            const certChain = socket.getPeerCertificate(true);\n            const vcc = mock ? mock.validateCertChain : validateCertChain;\n            vcc(certChain, function (err) {\n                getOcspResponseCache().resetCacheStatus();\n                if (err) {\n                    // if there's an error, destroy the socket\n                    Logger.getInstance().error('OCSP validation failed: %s', err);\n                    return socket.destroy(err);\n                }\n                Logger.getInstance().trace('OCSP validation succeeded for %s', host);\n                // unblock all writes\n                socket.uncork();\n            });\n        }\n    };\n    // when the socket is secure, perform additional validation\n    socket.on(socketSecuredEvent, validate);\n    // block all writes until validation is complete\n    socket.cork();\n    return socket;\n};\n/**\n * Determines if ocsp validation is disabled for a given host.\n *\n * @param {String} host\n * @returns {boolean}\n */\nfunction isOcspValidationDisabled(host) {\n    // ocsp is disabled if insecure-connect is enabled, or if we've disabled ocsp\n    // for non-snowflake endpoints and the host is a non-snowflake endpoint\n    return (GlobalConfig.isOCSPChecksDisabled() ||\n        (Parameters.getValue(Parameters.names.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS) &&\n            !REGEX_SNOWFLAKE_ENDPOINT.test(host)));\n}\n/**\n * Is valid OCSP error for cache\n * @param err\n * @returns {boolean}\n */\nfunction isValidOCSPError(err) {\n    return (err && (err.code === ErrorCodes.ERR_OCSP_REVOKED || err.code === ErrorCodes.ERR_OCSP_UNKNOWN));\n}\n/**\n * Return err if any valid error is found.\n * @param errors\n * @returns {null|*}\n */\nfunction canEarlyExitForOCSP(errors) {\n    if (GlobalConfig.getOcspMode() === GlobalConfig.ocspModes.FAIL_CLOSED) {\n        for (let errorIndex = 0, length = errors.length; errorIndex < length; errorIndex++) {\n            // first error\n            const err = errors[errorIndex];\n            if (err) {\n                return Object.prototype.hasOwnProperty.call(err, 'err') ? err.err : err;\n            }\n        }\n    }\n    else {\n        let anyRevoked = null;\n        for (let errorIndex = 0, length = errors.length; errorIndex < length; errorIndex++) {\n            // first error\n            const err = errors[errorIndex];\n            if (err && !isValidOCSPError(err)) {\n                // any of the errors is NOT good/revoked/unknown\n                Logger.getInstance().debug(`OCSP responder didn't respond correctly. Assuming certificate is not revoked. Details: ${err}`);\n                return null;\n            }\n            else if (err && err.code === ErrorCodes.ERR_OCSP_REVOKED) {\n                anyRevoked = err;\n            }\n        }\n        return anyRevoked;\n    }\n}\nexports.canEarlyExitForOCSP = canEarlyExitForOCSP;\n/**\n * Validates a certificate chain using OCSP.\n *\n * @param {Object} cert a top-level cert that represents the leaf of a\n *   certificate chain.\n * @param {Function} cb the callback to invoke once the validation is complete.\n */\nfunction validateCertChain(cert, cb) {\n    // walk up the certificate chain and collect all the certificates in an array\n    const certs = [];\n    while (cert &&\n        cert.issuerCertificate &&\n        cert.fingerprint !== cert.issuerCertificate.fingerprint) {\n        certs.push(cert);\n        cert = cert.issuerCertificate;\n    }\n    // create an array to store any errors encountered\n    // while validating the certificate chain\n    const errors = new Array(certs.length);\n    /**\n     * Called for every certificate as we traverse the certificate chain and\n     * validate each one.\n     *\n     * @param certs\n     * @param index\n     */\n    const eachCallback = function (certs, index) {\n        const cert = certs[index];\n        validateCert(cert, function (err, data) {\n            completed++;\n            errors[index] = err;\n            if (err) {\n                Logger.getInstance().debug(err);\n            }\n            // if we have an ocsp response, cache it\n            if (data && (!data.err || isValidOCSPError(data.err))) {\n                // check if cache is initialized before setting entry\n                if (getOcspResponseCache().isInitialized()) {\n                    getOcspResponseCache().set(cert, data.res);\n                }\n                else {\n                    getOcspResponseCache().initCache(cert, data.res);\n                }\n                if (data.err) {\n                    err = data.err;\n                    errors[index] = err;\n                }\n            }\n            // if this is the last request to complete\n            if (completed === certs.length) {\n                const validError = canEarlyExitForOCSP(errors);\n                cb(validError);\n            }\n        });\n    };\n    // fire off requests to validate all the certificates in the chain\n    let completed = 0;\n    for (let index = 0, length = certs.length; index < length; index++) {\n        eachCallback(certs, index);\n    }\n}\n/**\n * Validates a certificate using OCSP.\n *\n * @param cert the certificate to validate.\n * @param cb the callback to invoke once the validation is complete.\n */\nfunction validateCert(cert, cb) {\n    function getOcspCache() {\n        try {\n            if (!getOcspResponseCache().downloadCache(getOcspResonseAndVerify)) {\n                setTimeout(getOcspCache, 10);\n            }\n        }\n        catch (e) {\n            process.nextTick(function () {\n                cb(e);\n            });\n        }\n    }\n    /**\n     * Gets and Verifies OCSP Response\n     * @param err {object}\n     * @param useCacheServer {boolean}\n     */\n    function getOcspResonseAndVerify(err, useCacheServer) {\n        if (!useCacheServer && !getOcspResponseCache().isDownloadFinished()) {\n            setTimeout(getOcspResonseAndVerify, 10); // ms\n            return;\n        }\n        let decoded;\n        try {\n            decoded = CertUtil.decode(cert);\n        }\n        catch (e) {\n            process.nextTick(function () {\n                cb(e);\n            });\n        }\n        let ocspResponse;\n        // check if cache is initialized before getting entry\n        if (getOcspResponseCache().isInitialized()) {\n            if (getOcspResponseCache().IsCacheExpired()) {\n                // reset cache status so it can be refreshed\n                getOcspResponseCache().resetCacheStatus();\n            }\n            else {\n                // if we already have a valid entry in the cache, use it\n                ocspResponse = getOcspResponseCache().get(cert);\n            }\n        }\n        if (ocspResponse) {\n            Logger.getInstance().trace('Returning OCSP status for certificate %s from cache', cert.serialNumber);\n            const status = CertUtil.verifyOCSPResponse(decoded.issuer, ocspResponse);\n            if (!status.err) {\n                // verification was success with the cache\n                process.nextTick(function () {\n                    cb(null, null);\n                });\n            }\n            else {\n                // verification was failure with the cache\n                process.nextTick(function () {\n                    cb(status.err, null);\n                });\n            }\n        }\n        else {\n            if (useCacheServer) {\n                process.nextTick(function () {\n                    getOcspCache();\n                });\n            }\n            else {\n                Check(decoded, cb);\n            }\n        }\n    }\n    if (!variables.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED) {\n        getOcspResponseCache().forceDownloadToFinish();\n    }\n    getOcspResonseAndVerify(null, variables.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED);\n}\n//# sourceMappingURL=socket_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9zb2NrZXRfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQywyRUFBUztBQUMvQixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3RDLDBCQUEwQixtQkFBTyxDQUFDLHVHQUF1QjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsMEdBQTRCO0FBQ3ZEO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLElBQUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L3NvY2tldF91dGlsLmpzPzU3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBDaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4uL3BhcmFtZXRlcnMnKTtcbmNvbnN0IENlcnRVdGlsID0gcmVxdWlyZSgnLi9jZXJ0X3V0aWwnKTtcbmNvbnN0IE9jc3BSZXNwb25zZUNhY2hlID0gcmVxdWlyZSgnLi9vY3NwX3Jlc3BvbnNlX2NhY2hlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFByb3h5VXRpbCA9IHJlcXVpcmUoJy4uL3Byb3h5X3V0aWwnKTtcbmNvbnN0IFByb3h5QWdlbnQgPSByZXF1aXJlKCcuLi9hZ2VudC9odHRwc19wcm94eV9hZ2VudCcpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IFJFR0VYX1NOT1dGTEFLRV9FTkRQT0lOVCA9IC8uc25vd2ZsYWtlY29tcHV0aW5nLi87XG5leHBvcnRzLlJFR0VYX1NOT1dGTEFLRV9FTkRQT0lOVCA9IFJFR0VYX1NOT1dGTEFLRV9FTkRQT0lOVDtcbmNvbnN0IHNvY2tldFNlY3VyZWRFdmVudCA9ICdzZWN1cmVDb25uZWN0JztcbmNvbnN0IHJhd09jc3BGbGFnID0gcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfRU5BQkxFRDtcbmNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICBTRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9FTkFCTEVEOiAhcmF3T2NzcEZsYWcgfHwgKHJhd09jc3BGbGFnICYmIHJhd09jc3BGbGFnLnRvTG93ZXJDYXNlKCkgIT09ICdmYWxzZScpLFxuICAgIE9DU1BfUkVTUE9OU0VfQ0FDSEU6IHVuZGVmaW5lZCxcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIG9jc3AgcmVzcG9uc2UgY2FjaGUuXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGdldE9jc3BSZXNwb25zZUNhY2hlKCkge1xuICAgIC8vIGluaXRpYWxpemUgdGhlIG9jc3AgcmVzcG9uc2UgY2FjaGUgaWYgbmVlZGVkXG4gICAgaWYgKCF2YXJpYWJsZXMuT0NTUF9SRVNQT05TRV9DQUNIRSkge1xuICAgICAgICB2YXJpYWJsZXMuT0NTUF9SRVNQT05TRV9DQUNIRSA9IG5ldyBPY3NwUmVzcG9uc2VDYWNoZS5PY3NwUmVzcG9uc2VDYWNoZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFyaWFibGVzLk9DU1BfUkVTUE9OU0VfQ0FDSEU7XG59XG5leHBvcnRzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbi8qKlxuICogU2VjdXJlcyBhIGdpdmVuIFRMU1NvY2tldCBieSBibG9ja2luZyBhbGwgd3JpdGVzIHVudGlsIHRoZSBjZXJ0aWZpY2F0ZVxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBzb2NrZXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBob3N0XG4gKiBAcGFyYW0ge09iamVjdHxudWxsfSBhZ2VudFxuICogQHBhcmFtIHtPYmplY3R9IFttb2NrXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc2VjdXJlU29ja2V0ID0gZnVuY3Rpb24gKHNvY2tldCwgaG9zdCwgYWdlbnQsIG1vY2spIHtcbiAgICAvLyBpZiBvY3NwIHZhbGlkYXRpb24gaXMgZGlzYWJsZWQgZm9yIHRoZSBnaXZlbiBob3N0LCByZXR1cm4gdGhlIHNvY2tldCBhcyBpc1xuICAgIGlmIChpc09jc3BWYWxpZGF0aW9uRGlzYWJsZWQoaG9zdCkpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ09DU1AgdmFsaWRhdGlvbiBkaXNhYmxlZCBmb3IgJXMnLCBob3N0KTtcbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgaWYgKGFnZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5zZXRBZ2VudChhZ2VudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEdsb2JhbENvbmZpZy5pc0VudlByb3h5QWN0aXZlKCkpIHtcbiAgICAgICAgY29uc3QgaHR0cFByb3h5ID0gUHJveHlVdGlsLmdldFByb3h5RnJvbUVudihmYWxzZSk7XG4gICAgICAgIGlmIChodHRwUHJveHkgJiYgIVByb3h5VXRpbC5pc0J5UGFzc1Byb3h5KGh0dHBQcm94eSwgUkVHRVhfU05PV0ZMQUtFX0VORFBPSU5UKSkge1xuICAgICAgICAgICAgYWdlbnQgPSBQcm94eUFnZW50KGh0dHBQcm94eSk7XG4gICAgICAgICAgICBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLnNldEFnZW50KGFnZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgZm9yIHRoZSBzZWN1cmUgZXZlbnRcbiAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKHNvY2tldFNlY3VyZWRFdmVudCwgdmFsaWRhdGUpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnc29ja2V0IHJldXNlZCA9ICVzJywgc29ja2V0LmlzU2Vzc2lvblJldXNlZCgpKTtcbiAgICAgICAgLy8gaWYgdGhlIHNlcnZlciBoYXMgcmVzdW1lZCBvdXIgZXhpc3Rpbmcgc2Vzc2lvbiwgdW5ibG9jayBhbGxcbiAgICAgICAgLy8gd3JpdGVzIHdpdGhvdXQgcGVyZm9ybWluZyBhbnkgYWRkaXRpb25hbCB2YWxpZGF0aW9uXG4gICAgICAgIGlmIChzb2NrZXQuaXNTZXNzaW9uUmV1c2VkKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC51bmNvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc29ja2V0LmF1dGhvcml6ZWQpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdTb2NrZXQgaXMgbm90IGF1dGhvcml6ZWQ6ICVzJywgc29ja2V0LmF1dGhvcml6YXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95KHNvY2tldC5hdXRob3JpemF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIG9jc3AgdG8gbWFrZSBzdXJlIHRoZSBlbnRpcmUgY2VydGlmaWNhdGUgY2hhaW4gY2FuIGJlIHRydXN0ZWRcbiAgICAgICAgICAgIGNvbnN0IGNlcnRDaGFpbiA9IHNvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCB2Y2MgPSBtb2NrID8gbW9jay52YWxpZGF0ZUNlcnRDaGFpbiA6IHZhbGlkYXRlQ2VydENoYWluO1xuICAgICAgICAgICAgdmNjKGNlcnRDaGFpbiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGdldE9jc3BSZXNwb25zZUNhY2hlKCkucmVzZXRDYWNoZVN0YXR1cygpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhbiBlcnJvciwgZGVzdHJveSB0aGUgc29ja2V0XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdPQ1NQIHZhbGlkYXRpb24gZmFpbGVkOiAlcycsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnT0NTUCB2YWxpZGF0aW9uIHN1Y2NlZWRlZCBmb3IgJXMnLCBob3N0KTtcbiAgICAgICAgICAgICAgICAvLyB1bmJsb2NrIGFsbCB3cml0ZXNcbiAgICAgICAgICAgICAgICBzb2NrZXQudW5jb3JrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gd2hlbiB0aGUgc29ja2V0IGlzIHNlY3VyZSwgcGVyZm9ybSBhZGRpdGlvbmFsIHZhbGlkYXRpb25cbiAgICBzb2NrZXQub24oc29ja2V0U2VjdXJlZEV2ZW50LCB2YWxpZGF0ZSk7XG4gICAgLy8gYmxvY2sgYWxsIHdyaXRlcyB1bnRpbCB2YWxpZGF0aW9uIGlzIGNvbXBsZXRlXG4gICAgc29ja2V0LmNvcmsoKTtcbiAgICByZXR1cm4gc29ja2V0O1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBvY3NwIHZhbGlkYXRpb24gaXMgZGlzYWJsZWQgZm9yIGEgZ2l2ZW4gaG9zdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaG9zdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2NzcFZhbGlkYXRpb25EaXNhYmxlZChob3N0KSB7XG4gICAgLy8gb2NzcCBpcyBkaXNhYmxlZCBpZiBpbnNlY3VyZS1jb25uZWN0IGlzIGVuYWJsZWQsIG9yIGlmIHdlJ3ZlIGRpc2FibGVkIG9jc3BcbiAgICAvLyBmb3Igbm9uLXNub3dmbGFrZSBlbmRwb2ludHMgYW5kIHRoZSBob3N0IGlzIGEgbm9uLXNub3dmbGFrZSBlbmRwb2ludFxuICAgIHJldHVybiAoR2xvYmFsQ29uZmlnLmlzT0NTUENoZWNrc0Rpc2FibGVkKCkgfHxcbiAgICAgICAgKFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5KU19EUklWRVJfRElTQUJMRV9PQ1NQX0ZPUl9OT05fU0ZfRU5EUE9JTlRTKSAmJlxuICAgICAgICAgICAgIVJFR0VYX1NOT1dGTEFLRV9FTkRQT0lOVC50ZXN0KGhvc3QpKSk7XG59XG4vKipcbiAqIElzIHZhbGlkIE9DU1AgZXJyb3IgZm9yIGNhY2hlXG4gKiBAcGFyYW0gZXJyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE9DU1BFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gKGVyciAmJiAoZXJyLmNvZGUgPT09IEVycm9yQ29kZXMuRVJSX09DU1BfUkVWT0tFRCB8fCBlcnIuY29kZSA9PT0gRXJyb3JDb2Rlcy5FUlJfT0NTUF9VTktOT1dOKSk7XG59XG4vKipcbiAqIFJldHVybiBlcnIgaWYgYW55IHZhbGlkIGVycm9yIGlzIGZvdW5kLlxuICogQHBhcmFtIGVycm9yc1xuICogQHJldHVybnMge251bGx8Kn1cbiAqL1xuZnVuY3Rpb24gY2FuRWFybHlFeGl0Rm9yT0NTUChlcnJvcnMpIHtcbiAgICBpZiAoR2xvYmFsQ29uZmlnLmdldE9jc3BNb2RlKCkgPT09IEdsb2JhbENvbmZpZy5vY3NwTW9kZXMuRkFJTF9DTE9TRUQpIHtcbiAgICAgICAgZm9yIChsZXQgZXJyb3JJbmRleCA9IDAsIGxlbmd0aCA9IGVycm9ycy5sZW5ndGg7IGVycm9ySW5kZXggPCBsZW5ndGg7IGVycm9ySW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZmlyc3QgZXJyb3JcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGVycm9yc1tlcnJvckluZGV4XTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ2VycicpID8gZXJyLmVyciA6IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGFueVJldm9rZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBlcnJvckluZGV4ID0gMCwgbGVuZ3RoID0gZXJyb3JzLmxlbmd0aDsgZXJyb3JJbmRleCA8IGxlbmd0aDsgZXJyb3JJbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBlcnJvclxuICAgICAgICAgICAgY29uc3QgZXJyID0gZXJyb3JzW2Vycm9ySW5kZXhdO1xuICAgICAgICAgICAgaWYgKGVyciAmJiAhaXNWYWxpZE9DU1BFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgLy8gYW55IG9mIHRoZSBlcnJvcnMgaXMgTk9UIGdvb2QvcmV2b2tlZC91bmtub3duXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYE9DU1AgcmVzcG9uZGVyIGRpZG4ndCByZXNwb25kIGNvcnJlY3RseS4gQXNzdW1pbmcgY2VydGlmaWNhdGUgaXMgbm90IHJldm9rZWQuIERldGFpbHM6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyICYmIGVyci5jb2RlID09PSBFcnJvckNvZGVzLkVSUl9PQ1NQX1JFVk9LRUQpIHtcbiAgICAgICAgICAgICAgICBhbnlSZXZva2VkID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnlSZXZva2VkO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FuRWFybHlFeGl0Rm9yT0NTUCA9IGNhbkVhcmx5RXhpdEZvck9DU1A7XG4vKipcbiAqIFZhbGlkYXRlcyBhIGNlcnRpZmljYXRlIGNoYWluIHVzaW5nIE9DU1AuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNlcnQgYSB0b3AtbGV2ZWwgY2VydCB0aGF0IHJlcHJlc2VudHMgdGhlIGxlYWYgb2YgYVxuICogICBjZXJ0aWZpY2F0ZSBjaGFpbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBjYWxsYmFjayB0byBpbnZva2Ugb25jZSB0aGUgdmFsaWRhdGlvbiBpcyBjb21wbGV0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDZXJ0Q2hhaW4oY2VydCwgY2IpIHtcbiAgICAvLyB3YWxrIHVwIHRoZSBjZXJ0aWZpY2F0ZSBjaGFpbiBhbmQgY29sbGVjdCBhbGwgdGhlIGNlcnRpZmljYXRlcyBpbiBhbiBhcnJheVxuICAgIGNvbnN0IGNlcnRzID0gW107XG4gICAgd2hpbGUgKGNlcnQgJiZcbiAgICAgICAgY2VydC5pc3N1ZXJDZXJ0aWZpY2F0ZSAmJlxuICAgICAgICBjZXJ0LmZpbmdlcnByaW50ICE9PSBjZXJ0Lmlzc3VlckNlcnRpZmljYXRlLmZpbmdlcnByaW50KSB7XG4gICAgICAgIGNlcnRzLnB1c2goY2VydCk7XG4gICAgICAgIGNlcnQgPSBjZXJ0Lmlzc3VlckNlcnRpZmljYXRlO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgYW55IGVycm9ycyBlbmNvdW50ZXJlZFxuICAgIC8vIHdoaWxlIHZhbGlkYXRpbmcgdGhlIGNlcnRpZmljYXRlIGNoYWluXG4gICAgY29uc3QgZXJyb3JzID0gbmV3IEFycmF5KGNlcnRzLmxlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGZvciBldmVyeSBjZXJ0aWZpY2F0ZSBhcyB3ZSB0cmF2ZXJzZSB0aGUgY2VydGlmaWNhdGUgY2hhaW4gYW5kXG4gICAgICogdmFsaWRhdGUgZWFjaCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2VydHNcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBjb25zdCBlYWNoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2VydHMsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNlcnQgPSBjZXJ0c1tpbmRleF07XG4gICAgICAgIHZhbGlkYXRlQ2VydChjZXJ0LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQrKztcbiAgICAgICAgICAgIGVycm9yc1tpbmRleF0gPSBlcnI7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYW4gb2NzcCByZXNwb25zZSwgY2FjaGUgaXRcbiAgICAgICAgICAgIGlmIChkYXRhICYmICghZGF0YS5lcnIgfHwgaXNWYWxpZE9DU1BFcnJvcihkYXRhLmVycikpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgY2FjaGUgaXMgaW5pdGlhbGl6ZWQgYmVmb3JlIHNldHRpbmcgZW50cnlcbiAgICAgICAgICAgICAgICBpZiAoZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5zZXQoY2VydCwgZGF0YS5yZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5pbml0Q2FjaGUoY2VydCwgZGF0YS5yZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZGF0YS5lcnI7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yc1tpbmRleF0gPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZXF1ZXN0IHRvIGNvbXBsZXRlXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSBjZXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZEVycm9yID0gY2FuRWFybHlFeGl0Rm9yT0NTUChlcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNiKHZhbGlkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGZpcmUgb2ZmIHJlcXVlc3RzIHRvIHZhbGlkYXRlIGFsbCB0aGUgY2VydGlmaWNhdGVzIGluIHRoZSBjaGFpblxuICAgIGxldCBjb21wbGV0ZWQgPSAwO1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gY2VydHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBlYWNoQ2FsbGJhY2soY2VydHMsIGluZGV4KTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIGNlcnRpZmljYXRlIHVzaW5nIE9DU1AuXG4gKlxuICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGNiIHRoZSBjYWxsYmFjayB0byBpbnZva2Ugb25jZSB0aGUgdmFsaWRhdGlvbiBpcyBjb21wbGV0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDZXJ0KGNlcnQsIGNiKSB7XG4gICAgZnVuY3Rpb24gZ2V0T2NzcENhY2hlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLmRvd25sb2FkQ2FjaGUoZ2V0T2NzcFJlc29uc2VBbmRWZXJpZnkpKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChnZXRPY3NwQ2FjaGUsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuZCBWZXJpZmllcyBPQ1NQIFJlc3BvbnNlXG4gICAgICogQHBhcmFtIGVyciB7b2JqZWN0fVxuICAgICAqIEBwYXJhbSB1c2VDYWNoZVNlcnZlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPY3NwUmVzb25zZUFuZFZlcmlmeShlcnIsIHVzZUNhY2hlU2VydmVyKSB7XG4gICAgICAgIGlmICghdXNlQ2FjaGVTZXJ2ZXIgJiYgIWdldE9jc3BSZXNwb25zZUNhY2hlKCkuaXNEb3dubG9hZEZpbmlzaGVkKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZ2V0T2NzcFJlc29uc2VBbmRWZXJpZnksIDEwKTsgLy8gbXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjb2RlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlY29kZWQgPSBDZXJ0VXRpbC5kZWNvZGUoY2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9jc3BSZXNwb25zZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FjaGUgaXMgaW5pdGlhbGl6ZWQgYmVmb3JlIGdldHRpbmcgZW50cnlcbiAgICAgICAgaWYgKGdldE9jc3BSZXNwb25zZUNhY2hlKCkuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICBpZiAoZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5Jc0NhY2hlRXhwaXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgY2FjaGUgc3RhdHVzIHNvIGl0IGNhbiBiZSByZWZyZXNoZWRcbiAgICAgICAgICAgICAgICBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLnJlc2V0Q2FjaGVTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHZhbGlkIGVudHJ5IGluIHRoZSBjYWNoZSwgdXNlIGl0XG4gICAgICAgICAgICAgICAgb2NzcFJlc3BvbnNlID0gZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5nZXQoY2VydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9jc3BSZXNwb25zZSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JldHVybmluZyBPQ1NQIHN0YXR1cyBmb3IgY2VydGlmaWNhdGUgJXMgZnJvbSBjYWNoZScsIGNlcnQuc2VyaWFsTnVtYmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IENlcnRVdGlsLnZlcmlmeU9DU1BSZXNwb25zZShkZWNvZGVkLmlzc3Vlciwgb2NzcFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmICghc3RhdHVzLmVycikge1xuICAgICAgICAgICAgICAgIC8vIHZlcmlmaWNhdGlvbiB3YXMgc3VjY2VzcyB3aXRoIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHZlcmlmaWNhdGlvbiB3YXMgZmFpbHVyZSB3aXRoIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYihzdGF0dXMuZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1c2VDYWNoZVNlcnZlcikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRPY3NwQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIENoZWNrKGRlY29kZWQsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZhcmlhYmxlcy5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9FTkFCTEVEKSB7XG4gICAgICAgIGdldE9jc3BSZXNwb25zZUNhY2hlKCkuZm9yY2VEb3dubG9hZFRvRmluaXNoKCk7XG4gICAgfVxuICAgIGdldE9jc3BSZXNvbnNlQW5kVmVyaWZ5KG51bGwsIHZhcmlhYmxlcy5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9FTkFCTEVEKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tldF91dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst mfaAuthenticator = (__webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\").USER_PWD_MFA_AUTHENTICATOR);\n/**\n * Creates a default authenticator.\n *\n * @param {String} password\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthDefault(connectionConfig) {\n    const password = connectionConfig.password;\n    const mfaToken = connectionConfig.mfaToken;\n    const passcode = connectionConfig.getPasscode();\n    const isPasscodeInPassword = connectionConfig.getPasscodeInPassword();\n    /**\n     * Update JSON body with password or token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['PASSWORD'] = password;\n        if (isMFAAuth()) {\n            setMFASessionParams(body);\n        }\n    };\n    function isMFAAuth() {\n        return (connectionConfig.getAuthenticator() === mfaAuthenticator ||\n            mfaToken ||\n            passcode ||\n            isPasscodeInPassword);\n    }\n    function setMFASessionParams(body) {\n        body['data']['TOKEN'] = mfaToken;\n        body['data']['AUTHENTICATOR'] = mfaAuthenticator;\n        if (isPasscodeInPassword) {\n            body['data']['EXT_AUTHN_DUO_METHOD'] = 'passcode';\n            body['data']['passcodeInPassword'] = true;\n        }\n        else if (passcode) {\n            body['data']['EXT_AUTHN_DUO_METHOD'] = 'passcode';\n            body['data']['PASSCODE'] = passcode;\n        }\n        else {\n            body['data']['EXT_AUTHN_DUO_METHOD'] = 'push';\n        }\n    }\n    this.authenticate = async function () {\n        return;\n    };\n}\nmodule.exports = AuthDefault;\n//# sourceMappingURL=auth_default.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2RlZmF1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYix5QkFBeUIsb0tBQTREO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9kZWZhdWx0LmpzPzU3ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtZmFBdXRoZW50aWNhdG9yID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbl90eXBlcycpLlVTRVJfUFdEX01GQV9BVVRIRU5USUNBVE9SO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVmYXVsdCBhdXRoZW50aWNhdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aERlZmF1bHQoY29ubmVjdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IHBhc3N3b3JkID0gY29ubmVjdGlvbkNvbmZpZy5wYXNzd29yZDtcbiAgICBjb25zdCBtZmFUb2tlbiA9IGNvbm5lY3Rpb25Db25maWcubWZhVG9rZW47XG4gICAgY29uc3QgcGFzc2NvZGUgPSBjb25uZWN0aW9uQ29uZmlnLmdldFBhc3Njb2RlKCk7XG4gICAgY29uc3QgaXNQYXNzY29kZUluUGFzc3dvcmQgPSBjb25uZWN0aW9uQ29uZmlnLmdldFBhc3Njb2RlSW5QYXNzd29yZCgpO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCBwYXNzd29yZCBvciB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgYm9keVsnZGF0YSddWydQQVNTV09SRCddID0gcGFzc3dvcmQ7XG4gICAgICAgIGlmIChpc01GQUF1dGgoKSkge1xuICAgICAgICAgICAgc2V0TUZBU2Vzc2lvblBhcmFtcyhib2R5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaXNNRkFBdXRoKCkge1xuICAgICAgICByZXR1cm4gKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpID09PSBtZmFBdXRoZW50aWNhdG9yIHx8XG4gICAgICAgICAgICBtZmFUb2tlbiB8fFxuICAgICAgICAgICAgcGFzc2NvZGUgfHxcbiAgICAgICAgICAgIGlzUGFzc2NvZGVJblBhc3N3b3JkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0TUZBU2Vzc2lvblBhcmFtcyhib2R5KSB7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnVE9LRU4nXSA9IG1mYVRva2VuO1xuICAgICAgICBib2R5WydkYXRhJ11bJ0FVVEhFTlRJQ0FUT1InXSA9IG1mYUF1dGhlbnRpY2F0b3I7XG4gICAgICAgIGlmIChpc1Bhc3Njb2RlSW5QYXNzd29yZCkge1xuICAgICAgICAgICAgYm9keVsnZGF0YSddWydFWFRfQVVUSE5fRFVPX01FVEhPRCddID0gJ3Bhc3Njb2RlJztcbiAgICAgICAgICAgIGJvZHlbJ2RhdGEnXVsncGFzc2NvZGVJblBhc3N3b3JkJ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhc3Njb2RlKSB7XG4gICAgICAgICAgICBib2R5WydkYXRhJ11bJ0VYVF9BVVRITl9EVU9fTUVUSE9EJ10gPSAncGFzc2NvZGUnO1xuICAgICAgICAgICAgYm9keVsnZGF0YSddWydQQVNTQ09ERSddID0gcGFzc2NvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5WydkYXRhJ11bJ0VYVF9BVVRITl9EVU9fTUVUSE9EJ10gPSAncHVzaCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBBdXRoRGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhfZGVmYXVsdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AuthWeb = __webpack_require__(/*! ./auth_web */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\n/**\n * Creates an ID token authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {module} webbrowser\n *\n * @returns {Object} the authenticator\n * @constructor\n */\nfunction AuthIDToken(connectionConfig, httpClient, webbrowser) {\n    this.idToken = connectionConfig.idToken;\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = this.idToken;\n        body['data']['AUTHENTICATOR'] = 'ID_TOKEN';\n    };\n    this.authenticate = async function () { };\n    this.reauthenticate = async function (body) {\n        const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n        await GlobalConfig.getCredentialManager().remove(key);\n        const auth = new AuthWeb(connectionConfig, httpClient, webbrowser);\n        await auth.authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username);\n        auth.updateBody(body);\n    };\n}\nmodule.exports = AuthIDToken;\n//# sourceMappingURL=auth_idtoken.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2lkdG9rZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBWTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsNEJBQTRCLG1CQUFPLENBQUMsa0hBQXdCO0FBQzVELHFCQUFxQixtQkFBTyxDQUFDLHNGQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9pZHRva2VuLmpzPzZlN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBdXRoV2ViID0gcmVxdWlyZSgnLi9hdXRoX3dlYicpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPSByZXF1aXJlKCcuL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG4vKipcbiAqIENyZWF0ZXMgYW4gSUQgdG9rZW4gYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IGh0dHBDbGllbnRcbiAqIEBwYXJhbSB7bW9kdWxlfSB3ZWJicm93c2VyXG4gKlxuICogQHJldHVybnMge09iamVjdH0gdGhlIGF1dGhlbnRpY2F0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBdXRoSURUb2tlbihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCB3ZWJicm93c2VyKSB7XG4gICAgdGhpcy5pZFRva2VuID0gY29ubmVjdGlvbkNvbmZpZy5pZFRva2VuO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgYm9keVsnZGF0YSddWydUT0tFTiddID0gdGhpcy5pZFRva2VuO1xuICAgICAgICBib2R5WydkYXRhJ11bJ0FVVEhFTlRJQ0FUT1InXSA9ICdJRF9UT0tFTic7XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHsgfTtcbiAgICB0aGlzLnJlYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gVXRpbC5idWlsZENyZWRlbnRpYWxDYWNoZUtleShjb25uZWN0aW9uQ29uZmlnLmhvc3QsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsIEF1dGhlbnRpY2F0aW9uVHlwZXMuSURfVE9LRU5fQVVUSEVOVElDQVRPUik7XG4gICAgICAgIGF3YWl0IEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLnJlbW92ZShrZXkpO1xuICAgICAgICBjb25zdCBhdXRoID0gbmV3IEF1dGhXZWIoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgd2ViYnJvd3Nlcik7XG4gICAgICAgIGF3YWl0IGF1dGguYXV0aGVudGljYXRlKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLCBjb25uZWN0aW9uQ29uZmlnLmdldFNlcnZpY2VOYW1lKCksIGNvbm5lY3Rpb25Db25maWcuYWNjb3VudCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSk7XG4gICAgICAgIGF1dGgudXBkYXRlQm9keShib2R5KTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBBdXRoSURUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhfaWR0b2tlbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst jwt = __webpack_require__(/*! jsonwebtoken */ \"(rsc)/./node_modules/jsonwebtoken/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\n/**\n * Creates a key-pair authenticator.\n *\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthKeypair(connectionConfig) {\n    let privateKey = connectionConfig.getPrivateKey();\n    const privateKeyPath = connectionConfig.getPrivateKeyPath();\n    const privateKeyPass = connectionConfig.getPrivateKeyPass();\n    let jwtToken;\n    const LIFETIME = 120; // seconds\n    const ALGORITHM = 'RS256';\n    const ISSUER = 'iss';\n    const SUBJECT = 'sub';\n    const EXPIRE_TIME = 'exp';\n    const ISSUE_TIME = 'iat';\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = jwtToken;\n    };\n    /**\n     * Load private key from specified file location.\n     *\n     * @param {String} privateKeyPath\n     * @param {String} privateKeyPass\n     *\n     * @returns {String} the private key.\n     */\n    function loadPrivateKey(privateKeyPath, privateKeyPass) {\n        // Load private key file\n        const privateKeyFile = fs.readFileSync(privateKeyPath);\n        let privateKeyObject;\n        // For encrypted private key\n        if (privateKeyPass) {\n            // Get private key with passphrase\n            privateKeyObject = crypto.createPrivateKey({\n                key: privateKeyFile,\n                format: 'pem',\n                passphrase: privateKeyPass,\n            });\n        }\n        else {\n            // For unencrypted private key\n            privateKeyObject = crypto.createPrivateKey({\n                key: privateKeyFile,\n                format: 'pem',\n            });\n        }\n        const privateKey = privateKeyObject.export({\n            format: 'pem',\n            type: 'pkcs8',\n        });\n        return privateKey;\n    }\n    /**\n     * Get public key fingerprint from private key.\n     *\n     * @param {String} privateKey\n     *\n     * @returns {String} the public key fingerprint.\n     */\n    function calculatePublicKeyFingerprint(privateKey) {\n        // Extract public key object from private key\n        const pubKeyObject = crypto.createPublicKey({\n            key: privateKey,\n            format: 'pem',\n        });\n        // Obtain public key string\n        const publicKey = pubKeyObject.export({\n            format: 'der',\n            type: 'spki',\n        });\n        // Generate SHA256 hash of public key and encode in base64\n        const publicKeyFingerprint = 'SHA256:' + crypto.createHash('sha256').update(publicKey, 'utf8').digest('base64');\n        return publicKeyFingerprint;\n    }\n    /**\n     * Generate JWT token using RS256 algorithm.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {null}\n     */\n    this.authenticate = async function (authenticator, serviceName, account, username) {\n        let publicKeyFingerprint;\n        // Use private key if already set in connection string, otherwise use private key file location\n        if (privateKey) {\n            // Get public key fingerprint\n            publicKeyFingerprint = calculatePublicKeyFingerprint(privateKey);\n        }\n        else if (privateKeyPath) {\n            // Extract private key and get fingerprint\n            privateKey = loadPrivateKey(privateKeyPath, privateKeyPass);\n            publicKeyFingerprint = calculatePublicKeyFingerprint(privateKey);\n        }\n        // Current time + 120 seconds\n        const currentTime = Date.now();\n        const jwtTokenExp = currentTime + LIFETIME * 1000;\n        // Create payload containing jwt token and lifetime span\n        const payload = {\n            [ISSUER]: util.format('%s.%s.%s', account.toUpperCase(), username.toUpperCase(), publicKeyFingerprint),\n            [SUBJECT]: util.format('%s.%s', account.toUpperCase(), username.toUpperCase()),\n            [ISSUE_TIME]: currentTime,\n            [EXPIRE_TIME]: jwtTokenExp,\n        };\n        // Sign payload with RS256 algorithm\n        jwtToken = jwt.sign(payload, privateKey, { algorithm: ALGORITHM });\n    };\n    this.reauthenticate = async function (body) {\n        this.authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username);\n        this.updateBody(body);\n    };\n}\nmodule.exports = AuthKeypair;\n//# sourceMappingURL=auth_keypair.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2tleXBhaXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLGdFQUFjO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2tleXBhaXIuanM/ZDMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3Qgand0ID0gcmVxdWlyZSgnanNvbndlYnRva2VuJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuLyoqXG4gKiBDcmVhdGVzIGEga2V5LXBhaXIgYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aEtleXBhaXIoY29ubmVjdGlvbkNvbmZpZykge1xuICAgIGxldCBwcml2YXRlS2V5ID0gY29ubmVjdGlvbkNvbmZpZy5nZXRQcml2YXRlS2V5KCk7XG4gICAgY29uc3QgcHJpdmF0ZUtleVBhdGggPSBjb25uZWN0aW9uQ29uZmlnLmdldFByaXZhdGVLZXlQYXRoKCk7XG4gICAgY29uc3QgcHJpdmF0ZUtleVBhc3MgPSBjb25uZWN0aW9uQ29uZmlnLmdldFByaXZhdGVLZXlQYXNzKCk7XG4gICAgbGV0IGp3dFRva2VuO1xuICAgIGNvbnN0IExJRkVUSU1FID0gMTIwOyAvLyBzZWNvbmRzXG4gICAgY29uc3QgQUxHT1JJVEhNID0gJ1JTMjU2JztcbiAgICBjb25zdCBJU1NVRVIgPSAnaXNzJztcbiAgICBjb25zdCBTVUJKRUNUID0gJ3N1Yic7XG4gICAgY29uc3QgRVhQSVJFX1RJTUUgPSAnZXhwJztcbiAgICBjb25zdCBJU1NVRV9USU1FID0gJ2lhdCc7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OfSBib2R5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBib2R5WydkYXRhJ11bJ1RPS0VOJ10gPSBqd3RUb2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWQgcHJpdmF0ZSBrZXkgZnJvbSBzcGVjaWZpZWQgZmlsZSBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcml2YXRlS2V5UGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcml2YXRlS2V5UGFzc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHByaXZhdGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvYWRQcml2YXRlS2V5KHByaXZhdGVLZXlQYXRoLCBwcml2YXRlS2V5UGFzcykge1xuICAgICAgICAvLyBMb2FkIHByaXZhdGUga2V5IGZpbGVcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleUZpbGUgPSBmcy5yZWFkRmlsZVN5bmMocHJpdmF0ZUtleVBhdGgpO1xuICAgICAgICBsZXQgcHJpdmF0ZUtleU9iamVjdDtcbiAgICAgICAgLy8gRm9yIGVuY3J5cHRlZCBwcml2YXRlIGtleVxuICAgICAgICBpZiAocHJpdmF0ZUtleVBhc3MpIHtcbiAgICAgICAgICAgIC8vIEdldCBwcml2YXRlIGtleSB3aXRoIHBhc3NwaHJhc2VcbiAgICAgICAgICAgIHByaXZhdGVLZXlPYmplY3QgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleSh7XG4gICAgICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5RmlsZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdwZW0nLFxuICAgICAgICAgICAgICAgIHBhc3NwaHJhc2U6IHByaXZhdGVLZXlQYXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgdW5lbmNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAgICAgICAgICAgIHByaXZhdGVLZXlPYmplY3QgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleSh7XG4gICAgICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5RmlsZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdwZW0nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXlPYmplY3QuZXhwb3J0KHtcbiAgICAgICAgICAgIGZvcm1hdDogJ3BlbScsXG4gICAgICAgICAgICB0eXBlOiAncGtjczgnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwdWJsaWMga2V5IGZpbmdlcnByaW50IGZyb20gcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJpdmF0ZUtleVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHB1YmxpYyBrZXkgZmluZ2VycHJpbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlUHVibGljS2V5RmluZ2VycHJpbnQocHJpdmF0ZUtleSkge1xuICAgICAgICAvLyBFeHRyYWN0IHB1YmxpYyBrZXkgb2JqZWN0IGZyb20gcHJpdmF0ZSBrZXlcbiAgICAgICAgY29uc3QgcHViS2V5T2JqZWN0ID0gY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XG4gICAgICAgICAgICBrZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gT2J0YWluIHB1YmxpYyBrZXkgc3RyaW5nXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YktleU9iamVjdC5leHBvcnQoe1xuICAgICAgICAgICAgZm9ybWF0OiAnZGVyJyxcbiAgICAgICAgICAgIHR5cGU6ICdzcGtpJyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEdlbmVyYXRlIFNIQTI1NiBoYXNoIG9mIHB1YmxpYyBrZXkgYW5kIGVuY29kZSBpbiBiYXNlNjRcbiAgICAgICAgY29uc3QgcHVibGljS2V5RmluZ2VycHJpbnQgPSAnU0hBMjU2OicgKyBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHB1YmxpY0tleSwgJ3V0ZjgnKS5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgICAgICByZXR1cm4gcHVibGljS2V5RmluZ2VycHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIEpXVCB0b2tlbiB1c2luZyBSUzI1NiBhbGdvcml0aG0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChhdXRoZW50aWNhdG9yLCBzZXJ2aWNlTmFtZSwgYWNjb3VudCwgdXNlcm5hbWUpIHtcbiAgICAgICAgbGV0IHB1YmxpY0tleUZpbmdlcnByaW50O1xuICAgICAgICAvLyBVc2UgcHJpdmF0ZSBrZXkgaWYgYWxyZWFkeSBzZXQgaW4gY29ubmVjdGlvbiBzdHJpbmcsIG90aGVyd2lzZSB1c2UgcHJpdmF0ZSBrZXkgZmlsZSBsb2NhdGlvblxuICAgICAgICBpZiAocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgLy8gR2V0IHB1YmxpYyBrZXkgZmluZ2VycHJpbnRcbiAgICAgICAgICAgIHB1YmxpY0tleUZpbmdlcnByaW50ID0gY2FsY3VsYXRlUHVibGljS2V5RmluZ2VycHJpbnQocHJpdmF0ZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJpdmF0ZUtleVBhdGgpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgcHJpdmF0ZSBrZXkgYW5kIGdldCBmaW5nZXJwcmludFxuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGxvYWRQcml2YXRlS2V5KHByaXZhdGVLZXlQYXRoLCBwcml2YXRlS2V5UGFzcyk7XG4gICAgICAgICAgICBwdWJsaWNLZXlGaW5nZXJwcmludCA9IGNhbGN1bGF0ZVB1YmxpY0tleUZpbmdlcnByaW50KHByaXZhdGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEN1cnJlbnQgdGltZSArIDEyMCBzZWNvbmRzXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3Qgand0VG9rZW5FeHAgPSBjdXJyZW50VGltZSArIExJRkVUSU1FICogMTAwMDtcbiAgICAgICAgLy8gQ3JlYXRlIHBheWxvYWQgY29udGFpbmluZyBqd3QgdG9rZW4gYW5kIGxpZmV0aW1lIHNwYW5cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIFtJU1NVRVJdOiB1dGlsLmZvcm1hdCgnJXMuJXMuJXMnLCBhY2NvdW50LnRvVXBwZXJDYXNlKCksIHVzZXJuYW1lLnRvVXBwZXJDYXNlKCksIHB1YmxpY0tleUZpbmdlcnByaW50KSxcbiAgICAgICAgICAgIFtTVUJKRUNUXTogdXRpbC5mb3JtYXQoJyVzLiVzJywgYWNjb3VudC50b1VwcGVyQ2FzZSgpLCB1c2VybmFtZS50b1VwcGVyQ2FzZSgpKSxcbiAgICAgICAgICAgIFtJU1NVRV9USU1FXTogY3VycmVudFRpbWUsXG4gICAgICAgICAgICBbRVhQSVJFX1RJTUVdOiBqd3RUb2tlbkV4cCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2lnbiBwYXlsb2FkIHdpdGggUlMyNTYgYWxnb3JpdGhtXG4gICAgICAgIGp3dFRva2VuID0gand0LnNpZ24ocGF5bG9hZCwgcHJpdmF0ZUtleSwgeyBhbGdvcml0aG06IEFMR09SSVRITSB9KTtcbiAgICB9O1xuICAgIHRoaXMucmVhdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZShjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRTZXJ2aWNlTmFtZSgpLCBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aEtleXBhaXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoX2tleXBhaXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * Creates an oauth authenticator.\n *\n * @param {String} token\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOauth(token) {\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = token;\n    };\n    this.authenticate = async function () { };\n}\nmodule.exports = AuthOauth;\n//# sourceMappingURL=auth_oauth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoLmpzP2Q1MmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENyZWF0ZXMgYW4gb2F1dGggYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhPYXV0aCh0b2tlbikge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgYm9keVsnZGF0YSddWydUT0tFTiddID0gdG9rZW47XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHsgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aE9hdXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aF9vYXV0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = (__webpack_require__(/*! ./../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst authUtil = __webpack_require__(/*! ../authentication/authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst { getFreePort, format } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst { withBrowserActionTimeout, writeToCache, removeFromCache, readCache, } = __webpack_require__(/*! ./authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst open = __webpack_require__(/*! open */ \"(rsc)/./node_modules/open/index.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\n/**\n * Creates an oauth authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOauthAuthorizationCode(connectionConfig, httpClient) {\n    const DEFAULT_REDIRECT_HOST = 'http://127.0.0.1';\n    const browserActionTimeout = connectionConfig.getBrowserActionTimeout();\n    let oauth;\n    let token;\n    const clientId = connectionConfig.getOauthClientId();\n    const clientSecret = connectionConfig.getOauthClientSecret();\n    const authorizationUrl = getAuthorizationUrl(connectionConfig);\n    const tokenUrl = authUtil.getTokenUrl(connectionConfig);\n    const accessTokenKey = authUtil.buildOauthAccessTokenCacheKey(authorizationUrl.host, connectionConfig.username, AuthenticationTypes.OAUTH_AUTHORIZATION_CODE);\n    const refreshTokenKey = authUtil.buildOauthRefreshTokenCacheKey(tokenUrl.host, connectionConfig.username, AuthenticationTypes.OAUTH_AUTHORIZATION_CODE);\n    /**\n     * Update JSON body with token.\n     * @param {JSON} body\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        if (token) {\n            body.data.TOKEN = token;\n        }\n        body.data.AUTHENTICATOR = AuthenticationTypes.OAUTH_AUTHENTICATOR;\n        body.data.CLIENT_ENVIRONMENT.OAUTH_TYPE = AuthenticationTypes.OAUTH_AUTHORIZATION_CODE;\n    };\n    this.loadOauth4webapi = async function () {\n        if (!oauth) {\n            oauth = await Util.dynamicImportESMInTypescriptWithCommonJS('oauth4webapi');\n        }\n    };\n    this.authenticate = async function () {\n        globalThis.crypto ??= (__webpack_require__(/*! node:crypto */ \"node:crypto\").webcrypto);\n        //verify that there is access token in the cache\n        const accessTokenFromCache = await readCache(accessTokenKey);\n        //verify that there is refresh token in the cache\n        const refreshTokenFromCache = await readCache(refreshTokenKey);\n        if (accessTokenFromCache && connectionConfig.getClientStoreTemporaryCredential()) {\n            token = accessTokenFromCache;\n        }\n        else if (refreshTokenFromCache && connectionConfig.getClientStoreTemporaryCredential()) {\n            token = await this.getAccessTokenUsingRefreshToken(refreshTokenFromCache);\n        }\n        else {\n            token = await this.executeFullAuthorizationCodeFlow();\n        }\n    };\n    this.reauthenticate = async function (body) {\n        await removeFromCache(accessTokenKey);\n        const refreshToken = await readCache(refreshTokenKey);\n        if (refreshToken) {\n            try {\n                await this.getAccessTokenUsingRefreshToken(refreshToken);\n                this.updateBody(body);\n            }\n            catch (error) {\n                await removeFromCache(refreshTokenKey);\n                Logger().warn(format('Error while getting access token using refresh token. Message: %s. The refresh token is removed form cache - authentication must be proceed from the beginning', error.message));\n                await this.authenticate();\n                this.updateBody(body);\n            }\n        }\n        else {\n            await this.authenticate();\n            this.updateBody(body);\n        }\n    };\n    this.executeFullAuthorizationCodeFlow = async function () {\n        await this.loadOauth4webapi(); // import module using the dynamic import\n        const codeChallengeMethod = connectionConfig.getOauthChallengeMethod() || 'S256'; // TODO: should be verified with \"discovery\" response\n        //An issuer is a obligatory parameter in validation processed by oauth4webapi library, even when it isn't used\n        const issuer = connectionConfig.issuer || 'UNKNOWN';\n        const codeVerifier = oauth.generateRandomCodeVerifier();\n        const codeChallenge = await oauth.calculatePKCECodeChallenge(codeVerifier);\n        const as = { issuer: issuer };\n        // eslint-disable-next-line camelcase\n        const client = { client_id: clientId };\n        const clientAuth = oauth.ClientSecretPost(clientSecret);\n        const redirectUri = await buildRedirectUri(connectionConfig);\n        const scope = await authUtil.prepareScope(connectionConfig);\n        const authorizationUrlWithParams = await prepareAuthorizationUrl(authorizationUrl, client, redirectUri, codeChallenge, codeChallengeMethod, as, scope);\n        const authorizationCodeResponse = await requestAuthorizationCode(authorizationUrlWithParams, browserActionTimeout);\n        const params = oauth.validateAuthResponse(as, client, authorizationUrlWithParams, authorizationCodeResponse.state);\n        params.set('code', authorizationCodeResponse.code);\n        Logger().trace('Requesting token');\n        const token = await requestToken(as, tokenUrl, client, clientAuth, params, redirectUri, codeVerifier);\n        return token;\n    };\n    this.getAccessTokenUsingRefreshToken = async function (refreshToken) {\n        globalThis.crypto ??= (__webpack_require__(/*! node:crypto */ \"node:crypto\").webcrypto);\n        await this.loadOauth4webapi(); // import module using the dynamic import\n        const issuer = connectionConfig.issuer || 'UNKNOWN';\n        const as = { issuer: issuer };\n        const clientId = connectionConfig.getOauthClientId();\n        const clientSecret = connectionConfig.getOauthClientSecret();\n        // eslint-disable-next-line camelcase\n        const client = { client_id: clientId };\n        const clientAuth = oauth.ClientSecretPost(clientSecret);\n        // Refresh Token Grant Request & Response\n        const tokenUrl = authUtil.getTokenUrl(connectionConfig);\n        Logger().trace(`Receiving new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n        as['token_endpoint'] = tokenUrl.href;\n        const response = await oauth.refreshTokenGrantRequest(as, client, clientAuth, refreshToken, {\n            [oauth.allowInsecureRequests]: connectionConfig.getOauthHttpAllowed(),\n            [oauth.customFetch]: async (url, options) => await convertToResponseType(httpClient, url, options),\n        });\n        const result = await oauth.processRefreshTokenResponse(as, client, response);\n        if (result.access_token) {\n            //cache access token\n            Logger().debug(`Received new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n            await writeToCache(accessTokenKey, result.access_token);\n            //cache refreshToken if exists\n            if (result.refresh_token) {\n                //cache refresh token\n                Logger().debug(`Received new OAuth refresh token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n                await writeToCache(refreshTokenKey, result.refresh_token);\n            }\n            else {\n                Logger().warn('There is no refresh_token value to write to cache. Clearing refresh token in cache');\n                await removeFromCache(refreshTokenKey);\n            }\n        }\n        else {\n            throw Error(`Response doesn't contain OAuth access token. Requested URI: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n        }\n        return result.access_token;\n    };\n    async function prepareAuthorizationUrl(authorizationUrl, client, redirectUri, codeChallenge, codeChallengeMethod, as, scope) {\n        authorizationUrl.searchParams.set('client_id', client.client_id);\n        authorizationUrl.searchParams.set('redirect_uri', redirectUri);\n        authorizationUrl.searchParams.set('response_type', 'code');\n        authorizationUrl.searchParams.set('scope', scope);\n        authorizationUrl.searchParams.set('code_challenge', codeChallenge);\n        authorizationUrl.searchParams.set('code_challenge_method', codeChallengeMethod);\n        /**\n         * We cannot be sure PKCE is supported then the state should be used.\n         */\n        if (as.code_challenge_methods_supported?.includes('S256') !== true) {\n            const state = oauth.generateRandomState();\n            authorizationUrl.searchParams.set('state', state);\n        }\n        return authorizationUrl;\n    }\n    async function verifyPortIsAvailable(server, redirectPort) {\n        return Util.isPortOpen(redirectPort).catch((rejected) => {\n            server.close();\n            throw new Error(`Cannot run server using provided redirect url. ${rejected}`);\n        });\n    }\n    async function requestAuthorizationCode(authorizationUrl, browserActionTimeout) {\n        if (!Util.number.isPositiveInteger(browserActionTimeout)) {\n            throw new Error(`Invalid value for browser action timeout: ${browserActionTimeout}`);\n        }\n        let server;\n        const receiveData = new Promise((resolve, reject) => {\n            server = authUtil.createServer(resolve, reject);\n        }).then((result) => {\n            return result;\n        });\n        const redirectUri = new URL(authorizationUrl.searchParams.get('redirect_uri'));\n        await verifyPortIsAvailable(server, redirectUri.port);\n        server.listen(redirectUri.port || 0, 0);\n        const authorizationCodeProvider = GlobalConfig.getCustomRedirectingClient();\n        const codeProvider = authorizationCodeProvider\n            ? authorizationCodeProvider\n            : browserAuthorizationCodeProvider;\n        await codeProvider(authorizationUrl);\n        const codeResponse = await withBrowserActionTimeout(browserActionTimeout, receiveData).catch((rejected) => {\n            server.close();\n            throw new Error(rejected);\n        });\n        const autorizationCodeResponseParameters = querystring.parse(codeResponse.substring(codeResponse.indexOf('?') + 1));\n        const code = autorizationCodeResponseParameters['code'];\n        const state = autorizationCodeResponseParameters['state'].replace(new RegExp('\\\\sHTTP/.*'), '');\n        Logger().debug(`Received new OAuth authorization code from: Host: ${authorizationUrl.host} Path: ${authorizationUrl.pathname}`);\n        return { code: code, state: state };\n    }\n    async function convertToResponseType(httpClient, url, options) {\n        function asResponseType(response) {\n            return new Response(response.json, {\n                staus: response.statusCode,\n                statusText: response.statusText,\n                headers: response.headers,\n            });\n        }\n        options.url = url;\n        return asResponseType(await httpClient.requestAsync(options));\n    }\n    async function requestToken(as, tokenUrl, client, clientAuth, params, redirectUri, codeVerifier) {\n        try {\n            Logger().trace(`Receiving new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n            as['token_endpoint'] = tokenUrl.href;\n            const response = await oauth.authorizationCodeGrantRequest(as, client, clientAuth, params, redirectUri, codeVerifier, {\n                [oauth.allowInsecureRequests]: connectionConfig.getOauthHttpAllowed(),\n                [oauth.customFetch]: async (url, options) => await convertToResponseType(httpClient, url, options),\n                additionalParameters: connectionConfig.oauthEnableSingleUseRefreshTokens\n                    ? {\n                        // eslint-disable-next-line camelcase\n                        enable_single_use_refresh_tokens: 'true',\n                    }\n                    : undefined,\n            });\n            const result = await oauth.processAuthorizationCodeResponse(as, client, response);\n            if (result.access_token) {\n                //cache access token\n                Logger().debug(`Received new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n                await writeToCache(accessTokenKey, result.access_token);\n                //cache refreshToken if exists\n                if (result.refresh_token) {\n                    //cache refresh token\n                    Logger().debug(`Received new OAuth refresh token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n                    await writeToCache(refreshTokenKey, result.refresh_token);\n                }\n            }\n            else {\n                throw Error(`Response doesn't contain OAuth access token. Requested URI: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n            }\n            return result.access_token;\n        }\n        catch (error) {\n            throw new Error(format('Error while getting access token. Message: %s', error.message));\n        }\n    }\n    function getAuthorizationUrl(options) {\n        const authCodeUrl = options.getOauthAuthorizationUrl();\n        Logger().debug(`Url used for receiving authorization code: ${authCodeUrl}`);\n        return new URL(authCodeUrl);\n    }\n    async function buildRedirectUri(options) {\n        const redirectUri = options.getOauthRedirectUri() || (await createDefaultRedirectUri());\n        Logger().debug(`Authorization code redirect URL: ${redirectUri}`);\n        return redirectUri;\n    }\n    async function createDefaultRedirectUri() {\n        const redirectPort = await getFreePort();\n        return `${DEFAULT_REDIRECT_HOST}:${redirectPort}`;\n    }\n    async function browserAuthorizationCodeProvider(authorizationUrl) {\n        Logger().debug(`Opening your browser to obtain the authorization code: ${authorizationUrl}`);\n        return open(authorizationUrl.href);\n    }\n}\nmodule.exports = AuthOauthAuthorizationCode;\n//# sourceMappingURL=auth_oauth_authorization_code.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2F1dGhvcml6YXRpb25fY29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsNEdBQThCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLGdJQUF1QztBQUNoRSxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsb0VBQVM7QUFDakQsUUFBUSxzRUFBc0UsRUFBRSxtQkFBTyxDQUFDLGdIQUF1QjtBQUMvRyxvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGdEQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5Qiw0QkFBNEIsbUJBQU8sQ0FBQyxrSEFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQWdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBZ0M7QUFDOUQsdUNBQXVDO0FBQ3ZDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZUFBZSxRQUFRLGtCQUFrQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZSxRQUFRLGtCQUFrQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlLFFBQVEsa0JBQWtCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsZUFBZSxRQUFRLGtCQUFrQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxTQUFTO0FBQ3ZGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUscUJBQXFCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHVCQUF1QixRQUFRLDBCQUEwQjtBQUNySSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGVBQWUsUUFBUSxrQkFBa0I7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGVBQWUsUUFBUSxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsZUFBZSxRQUFRLGtCQUFrQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlLFFBQVEsa0JBQWtCO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCLEdBQUcsYUFBYTtBQUN4RDtBQUNBO0FBQ0EsaUZBQWlGLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2F1dGhvcml6YXRpb25fY29kZS5qcz8yNjFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi8uLi9sb2dnZXInKS5kZWZhdWx0O1xuY29uc3QgYXV0aFV0aWwgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl91dGlsJyk7XG5jb25zdCB7IGdldEZyZWVQb3J0LCBmb3JtYXQgfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IHsgd2l0aEJyb3dzZXJBY3Rpb25UaW1lb3V0LCB3cml0ZVRvQ2FjaGUsIHJlbW92ZUZyb21DYWNoZSwgcmVhZENhY2hlLCB9ID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbl91dGlsJyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBvcGVuID0gcmVxdWlyZSgnb3BlbicpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPSByZXF1aXJlKCcuL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG4vKipcbiAqIENyZWF0ZXMgYW4gb2F1dGggYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IGh0dHBDbGllbnRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhPYXV0aEF1dGhvcml6YXRpb25Db2RlKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpIHtcbiAgICBjb25zdCBERUZBVUxUX1JFRElSRUNUX0hPU1QgPSAnaHR0cDovLzEyNy4wLjAuMSc7XG4gICAgY29uc3QgYnJvd3NlckFjdGlvblRpbWVvdXQgPSBjb25uZWN0aW9uQ29uZmlnLmdldEJyb3dzZXJBY3Rpb25UaW1lb3V0KCk7XG4gICAgbGV0IG9hdXRoO1xuICAgIGxldCB0b2tlbjtcbiAgICBjb25zdCBjbGllbnRJZCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0T2F1dGhDbGllbnRJZCgpO1xuICAgIGNvbnN0IGNsaWVudFNlY3JldCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0T2F1dGhDbGllbnRTZWNyZXQoKTtcbiAgICBjb25zdCBhdXRob3JpemF0aW9uVXJsID0gZ2V0QXV0aG9yaXphdGlvblVybChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICBjb25zdCB0b2tlblVybCA9IGF1dGhVdGlsLmdldFRva2VuVXJsKGNvbm5lY3Rpb25Db25maWcpO1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuS2V5ID0gYXV0aFV0aWwuYnVpbGRPYXV0aEFjY2Vzc1Rva2VuQ2FjaGVLZXkoYXV0aG9yaXphdGlvblVybC5ob3N0LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERSk7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuS2V5ID0gYXV0aFV0aWwuYnVpbGRPYXV0aFJlZnJlc2hUb2tlbkNhY2hlS2V5KHRva2VuVXJsLmhvc3QsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsIEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSE9SSVpBVElPTl9DT0RFKTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgSlNPTiBib2R5IHdpdGggdG9rZW4uXG4gICAgICogQHBhcmFtIHtKU09OfSBib2R5XG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBib2R5LmRhdGEuVE9LRU4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBib2R5LmRhdGEuQVVUSEVOVElDQVRPUiA9IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSEVOVElDQVRPUjtcbiAgICAgICAgYm9keS5kYXRhLkNMSUVOVF9FTlZJUk9OTUVOVC5PQVVUSF9UWVBFID0gQXV0aGVudGljYXRpb25UeXBlcy5PQVVUSF9BVVRIT1JJWkFUSU9OX0NPREU7XG4gICAgfTtcbiAgICB0aGlzLmxvYWRPYXV0aDR3ZWJhcGkgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghb2F1dGgpIHtcbiAgICAgICAgICAgIG9hdXRoID0gYXdhaXQgVXRpbC5keW5hbWljSW1wb3J0RVNNSW5UeXBlc2NyaXB0V2l0aENvbW1vbkpTKCdvYXV0aDR3ZWJhcGknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuY3J5cHRvID8/PSByZXF1aXJlKCdub2RlOmNyeXB0bycpLndlYmNyeXB0bztcbiAgICAgICAgLy92ZXJpZnkgdGhhdCB0aGVyZSBpcyBhY2Nlc3MgdG9rZW4gaW4gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuRnJvbUNhY2hlID0gYXdhaXQgcmVhZENhY2hlKGFjY2Vzc1Rva2VuS2V5KTtcbiAgICAgICAgLy92ZXJpZnkgdGhhdCB0aGVyZSBpcyByZWZyZXNoIHRva2VuIGluIHRoZSBjYWNoZVxuICAgICAgICBjb25zdCByZWZyZXNoVG9rZW5Gcm9tQ2FjaGUgPSBhd2FpdCByZWFkQ2FjaGUocmVmcmVzaFRva2VuS2V5KTtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuRnJvbUNhY2hlICYmIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsKCkpIHtcbiAgICAgICAgICAgIHRva2VuID0gYWNjZXNzVG9rZW5Gcm9tQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmcmVzaFRva2VuRnJvbUNhY2hlICYmIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsKCkpIHtcbiAgICAgICAgICAgIHRva2VuID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlblVzaW5nUmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbkZyb21DYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbiA9IGF3YWl0IHRoaXMuZXhlY3V0ZUZ1bGxBdXRob3JpemF0aW9uQ29kZUZsb3coKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZWF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGF3YWl0IHJlbW92ZUZyb21DYWNoZShhY2Nlc3NUb2tlbktleSk7XG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGF3YWl0IHJlYWRDYWNoZShyZWZyZXNoVG9rZW5LZXkpO1xuICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW5Vc2luZ1JlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQm9keShib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUZyb21DYWNoZShyZWZyZXNoVG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLndhcm4oZm9ybWF0KCdFcnJvciB3aGlsZSBnZXR0aW5nIGFjY2VzcyB0b2tlbiB1c2luZyByZWZyZXNoIHRva2VuLiBNZXNzYWdlOiAlcy4gVGhlIHJlZnJlc2ggdG9rZW4gaXMgcmVtb3ZlZCBmb3JtIGNhY2hlIC0gYXV0aGVudGljYXRpb24gbXVzdCBiZSBwcm9jZWVkIGZyb20gdGhlIGJlZ2lubmluZycsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQm9keShib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aGVudGljYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZXhlY3V0ZUZ1bGxBdXRob3JpemF0aW9uQ29kZUZsb3cgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE9hdXRoNHdlYmFwaSgpOyAvLyBpbXBvcnQgbW9kdWxlIHVzaW5nIHRoZSBkeW5hbWljIGltcG9ydFxuICAgICAgICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29ubmVjdGlvbkNvbmZpZy5nZXRPYXV0aENoYWxsZW5nZU1ldGhvZCgpIHx8ICdTMjU2JzsgLy8gVE9ETzogc2hvdWxkIGJlIHZlcmlmaWVkIHdpdGggXCJkaXNjb3ZlcnlcIiByZXNwb25zZVxuICAgICAgICAvL0FuIGlzc3VlciBpcyBhIG9ibGlnYXRvcnkgcGFyYW1ldGVyIGluIHZhbGlkYXRpb24gcHJvY2Vzc2VkIGJ5IG9hdXRoNHdlYmFwaSBsaWJyYXJ5LCBldmVuIHdoZW4gaXQgaXNuJ3QgdXNlZFxuICAgICAgICBjb25zdCBpc3N1ZXIgPSBjb25uZWN0aW9uQ29uZmlnLmlzc3VlciB8fCAnVU5LTk9XTic7XG4gICAgICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IG9hdXRoLmdlbmVyYXRlUmFuZG9tQ29kZVZlcmlmaWVyKCk7XG4gICAgICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBvYXV0aC5jYWxjdWxhdGVQS0NFQ29kZUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpO1xuICAgICAgICBjb25zdCBhcyA9IHsgaXNzdWVyOiBpc3N1ZXIgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgICAgICBjb25zdCBjbGllbnQgPSB7IGNsaWVudF9pZDogY2xpZW50SWQgfTtcbiAgICAgICAgY29uc3QgY2xpZW50QXV0aCA9IG9hdXRoLkNsaWVudFNlY3JldFBvc3QoY2xpZW50U2VjcmV0KTtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RVcmkgPSBhd2FpdCBidWlsZFJlZGlyZWN0VXJpKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBjb25zdCBzY29wZSA9IGF3YWl0IGF1dGhVdGlsLnByZXBhcmVTY29wZShjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblVybFdpdGhQYXJhbXMgPSBhd2FpdCBwcmVwYXJlQXV0aG9yaXphdGlvblVybChhdXRob3JpemF0aW9uVXJsLCBjbGllbnQsIHJlZGlyZWN0VXJpLCBjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kLCBhcywgc2NvcGUpO1xuICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEF1dGhvcml6YXRpb25Db2RlKGF1dGhvcml6YXRpb25VcmxXaXRoUGFyYW1zLCBicm93c2VyQWN0aW9uVGltZW91dCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG9hdXRoLnZhbGlkYXRlQXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIGF1dGhvcml6YXRpb25VcmxXaXRoUGFyYW1zLCBhdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlLnN0YXRlKTtcbiAgICAgICAgcGFyYW1zLnNldCgnY29kZScsIGF1dGhvcml6YXRpb25Db2RlUmVzcG9uc2UuY29kZSk7XG4gICAgICAgIExvZ2dlcigpLnRyYWNlKCdSZXF1ZXN0aW5nIHRva2VuJyk7XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgcmVxdWVzdFRva2VuKGFzLCB0b2tlblVybCwgY2xpZW50LCBjbGllbnRBdXRoLCBwYXJhbXMsIHJlZGlyZWN0VXJpLCBjb2RlVmVyaWZpZXIpO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICB0aGlzLmdldEFjY2Vzc1Rva2VuVXNpbmdSZWZyZXNoVG9rZW4gPSBhc3luYyBmdW5jdGlvbiAocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuY3J5cHRvID8/PSByZXF1aXJlKCdub2RlOmNyeXB0bycpLndlYmNyeXB0bztcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkT2F1dGg0d2ViYXBpKCk7IC8vIGltcG9ydCBtb2R1bGUgdXNpbmcgdGhlIGR5bmFtaWMgaW1wb3J0XG4gICAgICAgIGNvbnN0IGlzc3VlciA9IGNvbm5lY3Rpb25Db25maWcuaXNzdWVyIHx8ICdVTktOT1dOJztcbiAgICAgICAgY29uc3QgYXMgPSB7IGlzc3VlcjogaXNzdWVyIH07XG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gY29ubmVjdGlvbkNvbmZpZy5nZXRPYXV0aENsaWVudElkKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudFNlY3JldCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0T2F1dGhDbGllbnRTZWNyZXQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgICAgICBjb25zdCBjbGllbnQgPSB7IGNsaWVudF9pZDogY2xpZW50SWQgfTtcbiAgICAgICAgY29uc3QgY2xpZW50QXV0aCA9IG9hdXRoLkNsaWVudFNlY3JldFBvc3QoY2xpZW50U2VjcmV0KTtcbiAgICAgICAgLy8gUmVmcmVzaCBUb2tlbiBHcmFudCBSZXF1ZXN0ICYgUmVzcG9uc2VcbiAgICAgICAgY29uc3QgdG9rZW5VcmwgPSBhdXRoVXRpbC5nZXRUb2tlblVybChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgTG9nZ2VyKCkudHJhY2UoYFJlY2VpdmluZyBuZXcgT0F1dGggYWNjZXNzIHRva2VuIGZyb206IEhvc3Q6ICR7dG9rZW5VcmwuaG9zdH0gUGF0aDogJHt0b2tlblVybC5wYXRobmFtZX1gKTtcbiAgICAgICAgYXNbJ3Rva2VuX2VuZHBvaW50J10gPSB0b2tlblVybC5ocmVmO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9hdXRoLnJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoLCByZWZyZXNoVG9rZW4sIHtcbiAgICAgICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiBjb25uZWN0aW9uQ29uZmlnLmdldE9hdXRoSHR0cEFsbG93ZWQoKSxcbiAgICAgICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGFzeW5jICh1cmwsIG9wdGlvbnMpID0+IGF3YWl0IGNvbnZlcnRUb1Jlc3BvbnNlVHlwZShodHRwQ2xpZW50LCB1cmwsIG9wdGlvbnMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb2F1dGgucHJvY2Vzc1JlZnJlc2hUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgIC8vY2FjaGUgYWNjZXNzIHRva2VuXG4gICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgUmVjZWl2ZWQgbmV3IE9BdXRoIGFjY2VzcyB0b2tlbiBmcm9tOiBIb3N0OiAke3Rva2VuVXJsLmhvc3R9IFBhdGg6ICR7dG9rZW5VcmwucGF0aG5hbWV9YCk7XG4gICAgICAgICAgICBhd2FpdCB3cml0ZVRvQ2FjaGUoYWNjZXNzVG9rZW5LZXksIHJlc3VsdC5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgLy9jYWNoZSByZWZyZXNoVG9rZW4gaWYgZXhpc3RzXG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvL2NhY2hlIHJlZnJlc2ggdG9rZW5cbiAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgUmVjZWl2ZWQgbmV3IE9BdXRoIHJlZnJlc2ggdG9rZW4gZnJvbTogSG9zdDogJHt0b2tlblVybC5ob3N0fSBQYXRoOiAke3Rva2VuVXJsLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlVG9DYWNoZShyZWZyZXNoVG9rZW5LZXksIHJlc3VsdC5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLndhcm4oJ1RoZXJlIGlzIG5vIHJlZnJlc2hfdG9rZW4gdmFsdWUgdG8gd3JpdGUgdG8gY2FjaGUuIENsZWFyaW5nIHJlZnJlc2ggdG9rZW4gaW4gY2FjaGUnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVGcm9tQ2FjaGUocmVmcmVzaFRva2VuS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBSZXNwb25zZSBkb2Vzbid0IGNvbnRhaW4gT0F1dGggYWNjZXNzIHRva2VuLiBSZXF1ZXN0ZWQgVVJJOiBIb3N0OiAke3Rva2VuVXJsLmhvc3R9IFBhdGg6ICR7dG9rZW5VcmwucGF0aG5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hY2Nlc3NfdG9rZW47XG4gICAgfTtcbiAgICBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQXV0aG9yaXphdGlvblVybChhdXRob3JpemF0aW9uVXJsLCBjbGllbnQsIHJlZGlyZWN0VXJpLCBjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kLCBhcywgc2NvcGUpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdyZWRpcmVjdF91cmknLCByZWRpcmVjdFVyaSk7XG4gICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgncmVzcG9uc2VfdHlwZScsICdjb2RlJyk7XG4gICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnc2NvcGUnLCBzY29wZSk7XG4gICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnY29kZV9jaGFsbGVuZ2UnLCBjb2RlQ2hhbGxlbmdlKTtcbiAgICAgICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2RlX2NoYWxsZW5nZV9tZXRob2QnLCBjb2RlQ2hhbGxlbmdlTWV0aG9kKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGNhbm5vdCBiZSBzdXJlIFBLQ0UgaXMgc3VwcG9ydGVkIHRoZW4gdGhlIHN0YXRlIHNob3VsZCBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGFzLmNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkPy5pbmNsdWRlcygnUzI1NicpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IG9hdXRoLmdlbmVyYXRlUmFuZG9tU3RhdGUoKTtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnc3RhdGUnLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25Vcmw7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBvcnRJc0F2YWlsYWJsZShzZXJ2ZXIsIHJlZGlyZWN0UG9ydCkge1xuICAgICAgICByZXR1cm4gVXRpbC5pc1BvcnRPcGVuKHJlZGlyZWN0UG9ydCkuY2F0Y2goKHJlamVjdGVkKSA9PiB7XG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJ1biBzZXJ2ZXIgdXNpbmcgcHJvdmlkZWQgcmVkaXJlY3QgdXJsLiAke3JlamVjdGVkfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEF1dGhvcml6YXRpb25Db2RlKGF1dGhvcml6YXRpb25VcmwsIGJyb3dzZXJBY3Rpb25UaW1lb3V0KSB7XG4gICAgICAgIGlmICghVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIoYnJvd3NlckFjdGlvblRpbWVvdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIGJyb3dzZXIgYWN0aW9uIHRpbWVvdXQ6ICR7YnJvd3NlckFjdGlvblRpbWVvdXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcnZlcjtcbiAgICAgICAgY29uc3QgcmVjZWl2ZURhdGEgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzZXJ2ZXIgPSBhdXRoVXRpbC5jcmVhdGVTZXJ2ZXIocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RVcmkgPSBuZXcgVVJMKGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLmdldCgncmVkaXJlY3RfdXJpJykpO1xuICAgICAgICBhd2FpdCB2ZXJpZnlQb3J0SXNBdmFpbGFibGUoc2VydmVyLCByZWRpcmVjdFVyaS5wb3J0KTtcbiAgICAgICAgc2VydmVyLmxpc3RlbihyZWRpcmVjdFVyaS5wb3J0IHx8IDAsIDApO1xuICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uQ29kZVByb3ZpZGVyID0gR2xvYmFsQ29uZmlnLmdldEN1c3RvbVJlZGlyZWN0aW5nQ2xpZW50KCk7XG4gICAgICAgIGNvbnN0IGNvZGVQcm92aWRlciA9IGF1dGhvcml6YXRpb25Db2RlUHJvdmlkZXJcbiAgICAgICAgICAgID8gYXV0aG9yaXphdGlvbkNvZGVQcm92aWRlclxuICAgICAgICAgICAgOiBicm93c2VyQXV0aG9yaXphdGlvbkNvZGVQcm92aWRlcjtcbiAgICAgICAgYXdhaXQgY29kZVByb3ZpZGVyKGF1dGhvcml6YXRpb25VcmwpO1xuICAgICAgICBjb25zdCBjb2RlUmVzcG9uc2UgPSBhd2FpdCB3aXRoQnJvd3NlckFjdGlvblRpbWVvdXQoYnJvd3NlckFjdGlvblRpbWVvdXQsIHJlY2VpdmVEYXRhKS5jYXRjaCgocmVqZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlamVjdGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGF1dG9yaXphdGlvbkNvZGVSZXNwb25zZVBhcmFtZXRlcnMgPSBxdWVyeXN0cmluZy5wYXJzZShjb2RlUmVzcG9uc2Uuc3Vic3RyaW5nKGNvZGVSZXNwb25zZS5pbmRleE9mKCc/JykgKyAxKSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhdXRvcml6YXRpb25Db2RlUmVzcG9uc2VQYXJhbWV0ZXJzWydjb2RlJ107XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXV0b3JpemF0aW9uQ29kZVJlc3BvbnNlUGFyYW1ldGVyc1snc3RhdGUnXS5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxzSFRUUC8uKicpLCAnJyk7XG4gICAgICAgIExvZ2dlcigpLmRlYnVnKGBSZWNlaXZlZCBuZXcgT0F1dGggYXV0aG9yaXphdGlvbiBjb2RlIGZyb206IEhvc3Q6ICR7YXV0aG9yaXphdGlvblVybC5ob3N0fSBQYXRoOiAke2F1dGhvcml6YXRpb25VcmwucGF0aG5hbWV9YCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUsIHN0YXRlOiBzdGF0ZSB9O1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9SZXNwb25zZVR5cGUoaHR0cENsaWVudCwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzUmVzcG9uc2VUeXBlKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmpzb24sIHtcbiAgICAgICAgICAgICAgICBzdGF1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICAgICAgcmV0dXJuIGFzUmVzcG9uc2VUeXBlKGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdEFzeW5jKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFRva2VuKGFzLCB0b2tlblVybCwgY2xpZW50LCBjbGllbnRBdXRoLCBwYXJhbXMsIHJlZGlyZWN0VXJpLCBjb2RlVmVyaWZpZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIExvZ2dlcigpLnRyYWNlKGBSZWNlaXZpbmcgbmV3IE9BdXRoIGFjY2VzcyB0b2tlbiBmcm9tOiBIb3N0OiAke3Rva2VuVXJsLmhvc3R9IFBhdGg6ICR7dG9rZW5VcmwucGF0aG5hbWV9YCk7XG4gICAgICAgICAgICBhc1sndG9rZW5fZW5kcG9pbnQnXSA9IHRva2VuVXJsLmhyZWY7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9hdXRoLmF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGgsIHBhcmFtcywgcmVkaXJlY3RVcmksIGNvZGVWZXJpZmllciwge1xuICAgICAgICAgICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiBjb25uZWN0aW9uQ29uZmlnLmdldE9hdXRoSHR0cEFsbG93ZWQoKSxcbiAgICAgICAgICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBhc3luYyAodXJsLCBvcHRpb25zKSA9PiBhd2FpdCBjb252ZXJ0VG9SZXNwb25zZVR5cGUoaHR0cENsaWVudCwgdXJsLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUGFyYW1ldGVyczogY29ubmVjdGlvbkNvbmZpZy5vYXV0aEVuYWJsZVNpbmdsZVVzZVJlZnJlc2hUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVfc2luZ2xlX3VzZV9yZWZyZXNoX3Rva2VuczogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvYXV0aC5wcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgIC8vY2FjaGUgYWNjZXNzIHRva2VuXG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFJlY2VpdmVkIG5ldyBPQXV0aCBhY2Nlc3MgdG9rZW4gZnJvbTogSG9zdDogJHt0b2tlblVybC5ob3N0fSBQYXRoOiAke3Rva2VuVXJsLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlVG9DYWNoZShhY2Nlc3NUb2tlbktleSwgcmVzdWx0LmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICAgICAgLy9jYWNoZSByZWZyZXNoVG9rZW4gaWYgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY2FjaGUgcmVmcmVzaCB0b2tlblxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgUmVjZWl2ZWQgbmV3IE9BdXRoIHJlZnJlc2ggdG9rZW4gZnJvbTogSG9zdDogJHt0b2tlblVybC5ob3N0fSBQYXRoOiAke3Rva2VuVXJsLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZVRvQ2FjaGUocmVmcmVzaFRva2VuS2V5LCByZXN1bHQucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFJlc3BvbnNlIGRvZXNuJ3QgY29udGFpbiBPQXV0aCBhY2Nlc3MgdG9rZW4uIFJlcXVlc3RlZCBVUkk6IEhvc3Q6ICR7dG9rZW5VcmwuaG9zdH0gUGF0aDogJHt0b2tlblVybC5wYXRobmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuYWNjZXNzX3Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnRXJyb3Igd2hpbGUgZ2V0dGluZyBhY2Nlc3MgdG9rZW4uIE1lc3NhZ2U6ICVzJywgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEF1dGhvcml6YXRpb25Vcmwob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhdXRoQ29kZVVybCA9IG9wdGlvbnMuZ2V0T2F1dGhBdXRob3JpemF0aW9uVXJsKCk7XG4gICAgICAgIExvZ2dlcigpLmRlYnVnKGBVcmwgdXNlZCBmb3IgcmVjZWl2aW5nIGF1dGhvcml6YXRpb24gY29kZTogJHthdXRoQ29kZVVybH1gKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwoYXV0aENvZGVVcmwpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBidWlsZFJlZGlyZWN0VXJpKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RVcmkgPSBvcHRpb25zLmdldE9hdXRoUmVkaXJlY3RVcmkoKSB8fCAoYXdhaXQgY3JlYXRlRGVmYXVsdFJlZGlyZWN0VXJpKCkpO1xuICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgQXV0aG9yaXphdGlvbiBjb2RlIHJlZGlyZWN0IFVSTDogJHtyZWRpcmVjdFVyaX1gKTtcbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0VXJpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0UmVkaXJlY3RVcmkoKSB7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0UG9ydCA9IGF3YWl0IGdldEZyZWVQb3J0KCk7XG4gICAgICAgIHJldHVybiBgJHtERUZBVUxUX1JFRElSRUNUX0hPU1R9OiR7cmVkaXJlY3RQb3J0fWA7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGJyb3dzZXJBdXRob3JpemF0aW9uQ29kZVByb3ZpZGVyKGF1dGhvcml6YXRpb25VcmwpIHtcbiAgICAgICAgTG9nZ2VyKCkuZGVidWcoYE9wZW5pbmcgeW91ciBicm93c2VyIHRvIG9idGFpbiB0aGUgYXV0aG9yaXphdGlvbiBjb2RlOiAke2F1dGhvcml6YXRpb25Vcmx9YCk7XG4gICAgICAgIHJldHVybiBvcGVuKGF1dGhvcml6YXRpb25VcmwuaHJlZik7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBBdXRoT2F1dGhBdXRob3JpemF0aW9uQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhfb2F1dGhfYXV0aG9yaXphdGlvbl9jb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst authUtil = __importStar(__webpack_require__(/*! ../authentication/authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst authentication_types_1 = __importDefault(__webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\"));\nclass AuthOauthClientCredentials {\n    connectionConfig;\n    httpClient;\n    _oauthImport;\n    token;\n    constructor(connectionConfig, httpClient) {\n        this.connectionConfig = connectionConfig;\n        this.httpClient = httpClient;\n    }\n    async getOauth4webapi() {\n        if (!this._oauthImport) {\n            this._oauthImport = await (0, util_1.dynamicImportESMInTypescriptWithCommonJS)('oauth4webapi');\n        }\n        return this._oauthImport;\n    }\n    updateBody(body) {\n        if (this.token) {\n            body.data.TOKEN = this.token;\n        }\n        body.data.AUTHENTICATOR = authentication_types_1.default.OAUTH_AUTHENTICATOR;\n        body.data.CLIENT_ENVIRONMENT.OAUTH_TYPE = authentication_types_1.default.OAUTH_CLIENT_CREDENTIALS;\n    }\n    async authenticate() {\n        const clientId = this.connectionConfig.getOauthClientId();\n        const clientSecret = this.connectionConfig.getOauthClientSecret();\n        const scope = await authUtil.prepareScope(this.connectionConfig);\n        const parameters = new URLSearchParams();\n        parameters.set('scope', scope);\n        this.token = await this.requestToken(clientId, clientSecret, parameters);\n    }\n    async requestToken(clientId, clientSecret, parameters) {\n        const oauth = await this.getOauth4webapi();\n        const tokenUrl = authUtil.getTokenUrl(this.connectionConfig);\n        const as = {\n            // An issuer is an obligatory parameter in validation processed by oauth4webapi library, even when it isn't used\n            issuer: 'UNKNOWN',\n            // eslint-disable-next-line camelcase\n            token_endpoint: tokenUrl.href,\n        };\n        const client = {\n            // eslint-disable-next-line camelcase\n            client_id: clientId,\n        };\n        try {\n            (0, logger_1.default)().debug(`Executing token request: ${tokenUrl.href}`);\n            const clientAuth = oauth.ClientSecretPost(clientSecret);\n            const response = await oauth.clientCredentialsGrantRequest(as, client, clientAuth, parameters, {\n                [oauth.allowInsecureRequests]: this.connectionConfig.getOauthHttpAllowed(),\n                [oauth.customFetch]: async (url, options) => {\n                    const response = await this.httpClient.requestAsync({ url, ...options });\n                    return new Response(response.json, {\n                        status: response.statusCode,\n                        statusText: response.statusText,\n                        headers: response.headers,\n                    });\n                },\n            });\n            const result = await oauth.processClientCredentialsResponse(as, client, response);\n            if (result.access_token) {\n                (0, logger_1.default)().debug(`Received new OAuth access token from: ${tokenUrl.href}`);\n            }\n            else {\n                throw Error(`Response doesn't contain OAuth access token. Requested URI: ${tokenUrl.href}`);\n            }\n            return result.access_token;\n        }\n        catch (error) {\n            throw new Error((0, util_1.format)('Error while getting access token. Message: %s', error.message));\n        }\n    }\n}\nexports[\"default\"] = AuthOauthClientCredentials;\n//# sourceMappingURL=auth_oauth_client_credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2NsaWVudF9jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3BELDhCQUE4QixtQkFBTyxDQUFDLGdJQUF1QztBQUM3RSxlQUFlLG1CQUFPLENBQUMsb0VBQVM7QUFDaEMsK0NBQStDLG1CQUFPLENBQUMsa0hBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsY0FBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpQkFBaUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBLDJGQUEyRixjQUFjO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2NsaWVudF9jcmVkZW50aWFscy5qcz9lN2FmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGF1dGhVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl91dGlsXCIpKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgYXV0aGVudGljYXRpb25fdHlwZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hdXRoZW50aWNhdGlvbl90eXBlc1wiKSk7XG5jbGFzcyBBdXRoT2F1dGhDbGllbnRDcmVkZW50aWFscyB7XG4gICAgY29ubmVjdGlvbkNvbmZpZztcbiAgICBodHRwQ2xpZW50O1xuICAgIF9vYXV0aEltcG9ydDtcbiAgICB0b2tlbjtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZyA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgfVxuICAgIGFzeW5jIGdldE9hdXRoNHdlYmFwaSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vYXV0aEltcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5fb2F1dGhJbXBvcnQgPSBhd2FpdCAoMCwgdXRpbF8xLmR5bmFtaWNJbXBvcnRFU01JblR5cGVzY3JpcHRXaXRoQ29tbW9uSlMpKCdvYXV0aDR3ZWJhcGknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb2F1dGhJbXBvcnQ7XG4gICAgfVxuICAgIHVwZGF0ZUJvZHkoYm9keSkge1xuICAgICAgICBpZiAodGhpcy50b2tlbikge1xuICAgICAgICAgICAgYm9keS5kYXRhLlRPS0VOID0gdGhpcy50b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBib2R5LmRhdGEuQVVUSEVOVElDQVRPUiA9IGF1dGhlbnRpY2F0aW9uX3R5cGVzXzEuZGVmYXVsdC5PQVVUSF9BVVRIRU5USUNBVE9SO1xuICAgICAgICBib2R5LmRhdGEuQ0xJRU5UX0VOVklST05NRU5ULk9BVVRIX1RZUEUgPSBhdXRoZW50aWNhdGlvbl90eXBlc18xLmRlZmF1bHQuT0FVVEhfQ0xJRU5UX0NSRURFTlRJQUxTO1xuICAgIH1cbiAgICBhc3luYyBhdXRoZW50aWNhdGUoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldE9hdXRoQ2xpZW50SWQoKTtcbiAgICAgICAgY29uc3QgY2xpZW50U2VjcmV0ID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldE9hdXRoQ2xpZW50U2VjcmV0KCk7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gYXdhaXQgYXV0aFV0aWwucHJlcGFyZVNjb3BlKHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KCdzY29wZScsIHNjb3BlKTtcbiAgICAgICAgdGhpcy50b2tlbiA9IGF3YWl0IHRoaXMucmVxdWVzdFRva2VuKGNsaWVudElkLCBjbGllbnRTZWNyZXQsIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0VG9rZW4oY2xpZW50SWQsIGNsaWVudFNlY3JldCwgcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBvYXV0aCA9IGF3YWl0IHRoaXMuZ2V0T2F1dGg0d2ViYXBpKCk7XG4gICAgICAgIGNvbnN0IHRva2VuVXJsID0gYXV0aFV0aWwuZ2V0VG9rZW5VcmwodGhpcy5jb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3QgYXMgPSB7XG4gICAgICAgICAgICAvLyBBbiBpc3N1ZXIgaXMgYW4gb2JsaWdhdG9yeSBwYXJhbWV0ZXIgaW4gdmFsaWRhdGlvbiBwcm9jZXNzZWQgYnkgb2F1dGg0d2ViYXBpIGxpYnJhcnksIGV2ZW4gd2hlbiBpdCBpc24ndCB1c2VkXG4gICAgICAgICAgICBpc3N1ZXI6ICdVTktOT1dOJyxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgIHRva2VuX2VuZHBvaW50OiB0b2tlblVybC5ocmVmLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGllbnQgPSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYEV4ZWN1dGluZyB0b2tlbiByZXF1ZXN0OiAke3Rva2VuVXJsLmhyZWZ9YCk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRBdXRoID0gb2F1dGguQ2xpZW50U2VjcmV0UG9zdChjbGllbnRTZWNyZXQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aC5jbGllbnRDcmVkZW50aWFsc0dyYW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoLCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRPYXV0aEh0dHBBbGxvd2VkKCksXG4gICAgICAgICAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogYXN5bmMgKHVybCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5yZXF1ZXN0QXN5bmMoeyB1cmwsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UocmVzcG9uc2UuanNvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9hdXRoLnByb2Nlc3NDbGllbnRDcmVkZW50aWFsc1Jlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYFJlY2VpdmVkIG5ldyBPQXV0aCBhY2Nlc3MgdG9rZW4gZnJvbTogJHt0b2tlblVybC5ocmVmfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFJlc3BvbnNlIGRvZXNuJ3QgY29udGFpbiBPQXV0aCBhY2Nlc3MgdG9rZW4uIFJlcXVlc3RlZCBVUkk6ICR7dG9rZW5VcmwuaHJlZn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuYWNjZXNzX3Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCgwLCB1dGlsXzEuZm9ybWF0KSgnRXJyb3Igd2hpbGUgZ2V0dGluZyBhY2Nlc3MgdG9rZW4uIE1lc3NhZ2U6ICVzJywgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aE9hdXRoQ2xpZW50Q3JlZGVudGlhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoX29hdXRoX2NsaWVudF9jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\n/**\n * Creates an oauth PAT  authenticator.\n *\n * @param {String} token\n * @param {String} password\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOauthPAT(token, password) {\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        if (Util.exists(token)) {\n            body['data']['TOKEN'] = token;\n        }\n        else if (Util.exists(password)) {\n            body['data']['TOKEN'] = password;\n        }\n    };\n    this.authenticate = async function () { };\n}\nmodule.exports = AuthOauthPAT;\n//# sourceMappingURL=auth_oauth_pat.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX3BhdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9vYXV0aF9wYXQuanM/ZDhiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG4vKipcbiAqIENyZWF0ZXMgYW4gb2F1dGggUEFUICBhdXRoZW50aWNhdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlblxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBdXRoT2F1dGhQQVQodG9rZW4sIHBhc3N3b3JkKSB7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OfSBib2R5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBpZiAoVXRpbC5leGlzdHModG9rZW4pKSB7XG4gICAgICAgICAgICBib2R5WydkYXRhJ11bJ1RPS0VOJ10gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVdGlsLmV4aXN0cyhwYXNzd29yZCkpIHtcbiAgICAgICAgICAgIGJvZHlbJ2RhdGEnXVsnVE9LRU4nXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHsgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aE9hdXRoUEFUO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aF9vYXV0aF9wYXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst rest = (__webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\").rest);\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * Creates an okta authenticator.\n *\n * @param {Object} connectionConfig\n * @param {HttpClient} httpClient\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOkta(connectionConfig, httpClient) {\n    const password = connectionConfig.password;\n    const region = connectionConfig.region;\n    const account = connectionConfig.account;\n    const clientAppId = connectionConfig.getClientType();\n    const clientAppVersion = connectionConfig.getClientVersion();\n    const host = util.constructHostname(region, account);\n    const port = rest.HTTPS_PORT;\n    const protocol = rest.HTTPS_PROTOCOL;\n    let user;\n    let ssoUrl;\n    let tokenUrl;\n    let samlResponse;\n    /**\n     * Update JSON body with saml response.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['RAW_SAML_RESPONSE'] = samlResponse;\n    };\n    /**\n     * Obtain saml response from Okta.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {null}\n     */\n    this.authenticate = async function (authenticator, serviceName, account, username) {\n        const response = await getAuthURLs(authenticator, serviceName, account, username);\n        const responseData = response['data'];\n        const success = responseData['success'];\n        const errorCode = responseData['code'];\n        const errorMessage = responseData['message'];\n        user = username;\n        if (typeof success === 'undefined' ||\n            errorCode === 'undefined' ||\n            errorMessage === 'undefined') {\n            throw new Error('Unable to use provided Okta address as an authenticator. Is the authenticator URL correct?');\n        }\n        if (success !== true) {\n            throw new Error(`Unable to use provided Okta address as an authenticator. Error code: ${errorCode}, error message: ${errorMessage}`);\n        }\n        ssoUrl = responseData['data']['ssoUrl'];\n        tokenUrl = responseData['data']['tokenUrl'];\n        this.validateURLs(authenticator, ssoUrl, tokenUrl);\n        const responseHtml = await getSAMLResponse(await createAccessToken(tokenUrl, username, password), ssoUrl);\n        validateSAML(responseHtml);\n    };\n    this.reauthenticate = async function (body, retryOption) {\n        const maxRetryTimeout = connectionConfig.getRetryTimeout();\n        const maxRetryCount = connectionConfig.getRetrySfMaxLoginRetries();\n        const remainingTimeout = (maxRetryTimeout - retryOption.totalElapsedTime) * 1000;\n        const startTime = Date.now();\n        const authRetryOption = {\n            maxRetryCount,\n            numRetries: retryOption.numRetries,\n            startTime,\n            remainingTimeout,\n            maxRetryTimeout,\n        };\n        let responseHtml;\n        while (util.shouldRetryOktaAuth(authRetryOption)) {\n            try {\n                responseHtml = await getSAMLResponse(await createAccessToken(tokenUrl, user, password), ssoUrl);\n                break;\n            }\n            catch (err) {\n                Logger.getInstance().debug('getSAMLResponse: refresh token for re-authentication');\n                authRetryOption.numRetries++;\n            }\n        }\n        if (remainingTimeout !== 0 && startTime + remainingTimeout < Date.now()) {\n            Logger.getInstance().warn(`getSAMLResponse: Fail to get SAML response, timeout reached: ${remainingTimeout} miliseconds`);\n            throw new Error('Reached out to the Login Timeout');\n        }\n        if (maxRetryCount < authRetryOption.numRetries) {\n            Logger.getInstance().warn(`getSAMLResponse: Fail to get SAML response, max retry reached: ${maxRetryCount} time`);\n            throw new Error('Reached out to the max retry count');\n        }\n        retryOption.totalElapsedTime += (Date.now() - startTime) / 1000;\n        retryOption.numRetries = authRetryOption.numRetries;\n        validateSAML(responseHtml);\n        this.updateBody(body);\n    };\n    /**\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {Object}\n     */\n    async function getAuthURLs(authenticator, serviceName, account, username) {\n        // Create URL to send POST request to\n        const url = protocol + '://' + host + '/session/authenticator-request';\n        let header;\n        if (serviceName) {\n            header = {\n                HTTP_HEADER_SERVICE_NAME: serviceName,\n            };\n        }\n        // JSON body to send with POST request\n        const body = {\n            data: {\n                ACCOUNT_NAME: account,\n                LOGIN_NAME: username,\n                PORT: port,\n                PROTOCOL: protocol,\n                AUTHENTICATOR: authenticator,\n                CLIENT_APP_ID: clientAppId,\n                CLIENT_APP_VERSION: clientAppVersion,\n            },\n        };\n        // POST request to get SSO URL and token URL\n        return await httpClient.post(url, body, {\n            headers: header,\n        });\n    }\n    /**\n     *\n     * @param {String} authenticator\n     * @param {String} ssoUrl\n     * @param {String} tokenUrl\n     *\n     * @returns {null}\n     */\n    this.validateURLs = function (authenticator, ssoUrl, tokenUrl) {\n        const compareUrlsByProtocolAndHost = (firstUrl, secondUrl) => firstUrl.protocol === secondUrl.protocol && firstUrl.host === secondUrl.host;\n        try {\n            const aUrl = new URL(authenticator);\n            const sUrl = new URL(ssoUrl);\n            const tUrl = new URL(tokenUrl);\n            if (!(compareUrlsByProtocolAndHost(aUrl, sUrl) && compareUrlsByProtocolAndHost(aUrl, tUrl))) {\n                throw new Error('The prefix of the SSO/token URL and the specified authenticator do not match.');\n            }\n        }\n        catch (err) {\n            // we did not get a valid URL to test\n            if (err instanceof TypeError) {\n                throw new Error('Authenticator, SSO, or token URL is invalid.');\n            }\n            else {\n                throw err;\n            }\n        }\n    };\n    /**\n     *\n     * @param {String} tokenUrl\n     * @param {String} username\n     * @param {String} password\n     *\n     * @returns {Object}\n     */\n    async function createAccessToken(tokenUrl, username, password) {\n        // JSON body to send with POST request\n        const body = {\n            username: username,\n            password: password,\n        };\n        // Query IDP token url to authenticate and retrieve access token\n        const response = await httpClient.post(tokenUrl, body);\n        const data = response['data'];\n        let oneTimeToken;\n        if (data['sessionToken']) {\n            oneTimeToken = data['sessionToken'];\n        }\n        else {\n            oneTimeToken = data['cookieToken'];\n        }\n        return oneTimeToken;\n    }\n    /**\n     *\n     * @param {String} oneTimeToken\n     * @param {String} ssoUrl\n     *\n     * @returns {Object}\n     */\n    async function getSAMLResponse(oneTimeToken, ssoUrl) {\n        // Query IDP URL to get SAML response\n        const response = await httpClient.get(ssoUrl, {\n            params: {\n                RelayState: '/some/deep/link',\n                onetimetoken: oneTimeToken,\n            },\n        });\n        return response['data'];\n    }\n    /**\n     *\n     * @param {String} responseHtml\n     *\n     * @returns {null}\n     */\n    function validateSAML(responseHtml) {\n        const postBackUrl = getPostBackUrlFromHtml(responseHtml);\n        const fullUrl = util.format('%s://%s:%s', protocol, host, port);\n        // Validate the post back url come back with the SAML response\n        // contains the same prefix as the Snowflake's server url, which is the\n        // intended destination url to Snowflake.\n        if (!connectionConfig.getDisableSamlURLCheck()) {\n            if (postBackUrl.substring(0, 20) !== fullUrl.substring(0, 20)) {\n                throw new Error(util.format('The specified authenticator and destination URL ' +\n                    'in the SAML assertion do not match: expected: %s postback: %s', fullUrl, postBackUrl));\n            }\n        }\n        samlResponse = responseHtml;\n    }\n    /**\n     * Extract the postback URL from the HTML response.\n     *\n     * @param {String} html\n     *\n     * @returns {String}\n     */\n    function getPostBackUrlFromHtml(html) {\n        const index = html.search('<form');\n        const startIndex = html.indexOf('action=\"', index);\n        const endIndex = html.indexOf('\"', startIndex + 8);\n        return unescapeHtml(html.substring(startIndex + 8, endIndex));\n    }\n    /**\n     * Unescape the HTML hex characters in the string.\n     *\n     * @param {String} html\n     *\n     * @returns {String}\n     */\n    function unescapeHtml(html) {\n        return html.replace(/&#x3a;/g, ':').replace(/&#x2f;/g, '/');\n    }\n}\nmodule.exports = AuthOkta;\n//# sourceMappingURL=auth_okta.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29rdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsYUFBYSxrSEFBZ0M7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csVUFBVSxtQkFBbUIsYUFBYTtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxrQkFBa0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGVBQWU7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9va3RhLmpzPzE4YTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgcmVzdCA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKS5yZXN0O1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG4vKipcbiAqIENyZWF0ZXMgYW4gb2t0YSBhdXRoZW50aWNhdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGh0dHBDbGllbnRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhPa3RhKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpIHtcbiAgICBjb25zdCBwYXNzd29yZCA9IGNvbm5lY3Rpb25Db25maWcucGFzc3dvcmQ7XG4gICAgY29uc3QgcmVnaW9uID0gY29ubmVjdGlvbkNvbmZpZy5yZWdpb247XG4gICAgY29uc3QgYWNjb3VudCA9IGNvbm5lY3Rpb25Db25maWcuYWNjb3VudDtcbiAgICBjb25zdCBjbGllbnRBcHBJZCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpO1xuICAgIGNvbnN0IGNsaWVudEFwcFZlcnNpb24gPSBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFZlcnNpb24oKTtcbiAgICBjb25zdCBob3N0ID0gdXRpbC5jb25zdHJ1Y3RIb3N0bmFtZShyZWdpb24sIGFjY291bnQpO1xuICAgIGNvbnN0IHBvcnQgPSByZXN0LkhUVFBTX1BPUlQ7XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXN0LkhUVFBTX1BST1RPQ09MO1xuICAgIGxldCB1c2VyO1xuICAgIGxldCBzc29Vcmw7XG4gICAgbGV0IHRva2VuVXJsO1xuICAgIGxldCBzYW1sUmVzcG9uc2U7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHNhbWwgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT059IGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnUkFXX1NBTUxfUkVTUE9OU0UnXSA9IHNhbWxSZXNwb25zZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9idGFpbiBzYW1sIHJlc3BvbnNlIGZyb20gT2t0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlcnZpY2VOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGF1dGhlbnRpY2F0b3IsIHNlcnZpY2VOYW1lLCBhY2NvdW50LCB1c2VybmFtZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldEF1dGhVUkxzKGF1dGhlbnRpY2F0b3IsIHNlcnZpY2VOYW1lLCBhY2NvdW50LCB1c2VybmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSByZXNwb25zZURhdGFbJ3N1Y2Nlc3MnXTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gcmVzcG9uc2VEYXRhWydjb2RlJ107XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlRGF0YVsnbWVzc2FnZSddO1xuICAgICAgICB1c2VyID0gdXNlcm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHVzZSBwcm92aWRlZCBPa3RhIGFkZHJlc3MgYXMgYW4gYXV0aGVudGljYXRvci4gSXMgdGhlIGF1dGhlbnRpY2F0b3IgVVJMIGNvcnJlY3Q/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Y2Nlc3MgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHVzZSBwcm92aWRlZCBPa3RhIGFkZHJlc3MgYXMgYW4gYXV0aGVudGljYXRvci4gRXJyb3IgY29kZTogJHtlcnJvckNvZGV9LCBlcnJvciBtZXNzYWdlOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBzc29VcmwgPSByZXNwb25zZURhdGFbJ2RhdGEnXVsnc3NvVXJsJ107XG4gICAgICAgIHRva2VuVXJsID0gcmVzcG9uc2VEYXRhWydkYXRhJ11bJ3Rva2VuVXJsJ107XG4gICAgICAgIHRoaXMudmFsaWRhdGVVUkxzKGF1dGhlbnRpY2F0b3IsIHNzb1VybCwgdG9rZW5VcmwpO1xuICAgICAgICBjb25zdCByZXNwb25zZUh0bWwgPSBhd2FpdCBnZXRTQU1MUmVzcG9uc2UoYXdhaXQgY3JlYXRlQWNjZXNzVG9rZW4odG9rZW5VcmwsIHVzZXJuYW1lLCBwYXNzd29yZCksIHNzb1VybCk7XG4gICAgICAgIHZhbGlkYXRlU0FNTChyZXNwb25zZUh0bWwpO1xuICAgIH07XG4gICAgdGhpcy5yZWF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChib2R5LCByZXRyeU9wdGlvbikge1xuICAgICAgICBjb25zdCBtYXhSZXRyeVRpbWVvdXQgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5VGltZW91dCgpO1xuICAgICAgICBjb25zdCBtYXhSZXRyeUNvdW50ID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmTWF4TG9naW5SZXRyaWVzKCk7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ1RpbWVvdXQgPSAobWF4UmV0cnlUaW1lb3V0IC0gcmV0cnlPcHRpb24udG90YWxFbGFwc2VkVGltZSkgKiAxMDAwO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBhdXRoUmV0cnlPcHRpb24gPSB7XG4gICAgICAgICAgICBtYXhSZXRyeUNvdW50LFxuICAgICAgICAgICAgbnVtUmV0cmllczogcmV0cnlPcHRpb24ubnVtUmV0cmllcyxcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHJlbWFpbmluZ1RpbWVvdXQsXG4gICAgICAgICAgICBtYXhSZXRyeVRpbWVvdXQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZUh0bWw7XG4gICAgICAgIHdoaWxlICh1dGlsLnNob3VsZFJldHJ5T2t0YUF1dGgoYXV0aFJldHJ5T3B0aW9uKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUh0bWwgPSBhd2FpdCBnZXRTQU1MUmVzcG9uc2UoYXdhaXQgY3JlYXRlQWNjZXNzVG9rZW4odG9rZW5VcmwsIHVzZXIsIHBhc3N3b3JkKSwgc3NvVXJsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnZ2V0U0FNTFJlc3BvbnNlOiByZWZyZXNoIHRva2VuIGZvciByZS1hdXRoZW50aWNhdGlvbicpO1xuICAgICAgICAgICAgICAgIGF1dGhSZXRyeU9wdGlvbi5udW1SZXRyaWVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbWFpbmluZ1RpbWVvdXQgIT09IDAgJiYgc3RhcnRUaW1lICsgcmVtYWluaW5nVGltZW91dCA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYGdldFNBTUxSZXNwb25zZTogRmFpbCB0byBnZXQgU0FNTCByZXNwb25zZSwgdGltZW91dCByZWFjaGVkOiAke3JlbWFpbmluZ1RpbWVvdXR9IG1pbGlzZWNvbmRzYCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWNoZWQgb3V0IHRvIHRoZSBMb2dpbiBUaW1lb3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFJldHJ5Q291bnQgPCBhdXRoUmV0cnlPcHRpb24ubnVtUmV0cmllcykge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgZ2V0U0FNTFJlc3BvbnNlOiBGYWlsIHRvIGdldCBTQU1MIHJlc3BvbnNlLCBtYXggcmV0cnkgcmVhY2hlZDogJHttYXhSZXRyeUNvdW50fSB0aW1lYCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWNoZWQgb3V0IHRvIHRoZSBtYXggcmV0cnkgY291bnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXRyeU9wdGlvbi50b3RhbEVsYXBzZWRUaW1lICs9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgICAgIHJldHJ5T3B0aW9uLm51bVJldHJpZXMgPSBhdXRoUmV0cnlPcHRpb24ubnVtUmV0cmllcztcbiAgICAgICAgdmFsaWRhdGVTQU1MKHJlc3BvbnNlSHRtbCk7XG4gICAgICAgIHRoaXMudXBkYXRlQm9keShib2R5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF1dGhlbnRpY2F0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZU5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRBdXRoVVJMcyhhdXRoZW50aWNhdG9yLCBzZXJ2aWNlTmFtZSwgYWNjb3VudCwgdXNlcm5hbWUpIHtcbiAgICAgICAgLy8gQ3JlYXRlIFVSTCB0byBzZW5kIFBPU1QgcmVxdWVzdCB0b1xuICAgICAgICBjb25zdCB1cmwgPSBwcm90b2NvbCArICc6Ly8nICsgaG9zdCArICcvc2Vzc2lvbi9hdXRoZW50aWNhdG9yLXJlcXVlc3QnO1xuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICBpZiAoc2VydmljZU5hbWUpIHtcbiAgICAgICAgICAgIGhlYWRlciA9IHtcbiAgICAgICAgICAgICAgICBIVFRQX0hFQURFUl9TRVJWSUNFX05BTUU6IHNlcnZpY2VOYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OIGJvZHkgdG8gc2VuZCB3aXRoIFBPU1QgcmVxdWVzdFxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIEFDQ09VTlRfTkFNRTogYWNjb3VudCxcbiAgICAgICAgICAgICAgICBMT0dJTl9OQU1FOiB1c2VybmFtZSxcbiAgICAgICAgICAgICAgICBQT1JUOiBwb3J0LFxuICAgICAgICAgICAgICAgIFBST1RPQ09MOiBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICBBVVRIRU5USUNBVE9SOiBhdXRoZW50aWNhdG9yLFxuICAgICAgICAgICAgICAgIENMSUVOVF9BUFBfSUQ6IGNsaWVudEFwcElkLFxuICAgICAgICAgICAgICAgIENMSUVOVF9BUFBfVkVSU0lPTjogY2xpZW50QXBwVmVyc2lvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBPU1QgcmVxdWVzdCB0byBnZXQgU1NPIFVSTCBhbmQgdG9rZW4gVVJMXG4gICAgICAgIHJldHVybiBhd2FpdCBodHRwQ2xpZW50LnBvc3QodXJsLCBib2R5LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNzb1VybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlblVybFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0ZVVSTHMgPSBmdW5jdGlvbiAoYXV0aGVudGljYXRvciwgc3NvVXJsLCB0b2tlblVybCkge1xuICAgICAgICBjb25zdCBjb21wYXJlVXJsc0J5UHJvdG9jb2xBbmRIb3N0ID0gKGZpcnN0VXJsLCBzZWNvbmRVcmwpID0+IGZpcnN0VXJsLnByb3RvY29sID09PSBzZWNvbmRVcmwucHJvdG9jb2wgJiYgZmlyc3RVcmwuaG9zdCA9PT0gc2Vjb25kVXJsLmhvc3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhVXJsID0gbmV3IFVSTChhdXRoZW50aWNhdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IHNVcmwgPSBuZXcgVVJMKHNzb1VybCk7XG4gICAgICAgICAgICBjb25zdCB0VXJsID0gbmV3IFVSTCh0b2tlblVybCk7XG4gICAgICAgICAgICBpZiAoIShjb21wYXJlVXJsc0J5UHJvdG9jb2xBbmRIb3N0KGFVcmwsIHNVcmwpICYmIGNvbXBhcmVVcmxzQnlQcm90b2NvbEFuZEhvc3QoYVVybCwgdFVybCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJlZml4IG9mIHRoZSBTU08vdG9rZW4gVVJMIGFuZCB0aGUgc3BlY2lmaWVkIGF1dGhlbnRpY2F0b3IgZG8gbm90IG1hdGNoLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHdlIGRpZCBub3QgZ2V0IGEgdmFsaWQgVVJMIHRvIHRlc3RcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0b3IsIFNTTywgb3IgdG9rZW4gVVJMIGlzIGludmFsaWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuVXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc1Rva2VuKHRva2VuVXJsLCB1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgLy8gSlNPTiBib2R5IHRvIHNlbmQgd2l0aCBQT1NUIHJlcXVlc3RcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUXVlcnkgSURQIHRva2VuIHVybCB0byBhdXRoZW50aWNhdGUgYW5kIHJldHJpZXZlIGFjY2VzcyB0b2tlblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucG9zdCh0b2tlblVybCwgYm9keSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgb25lVGltZVRva2VuO1xuICAgICAgICBpZiAoZGF0YVsnc2Vzc2lvblRva2VuJ10pIHtcbiAgICAgICAgICAgIG9uZVRpbWVUb2tlbiA9IGRhdGFbJ3Nlc3Npb25Ub2tlbiddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25lVGltZVRva2VuID0gZGF0YVsnY29va2llVG9rZW4nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb25lVGltZVRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbmVUaW1lVG9rZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3NvVXJsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFNBTUxSZXNwb25zZShvbmVUaW1lVG9rZW4sIHNzb1VybCkge1xuICAgICAgICAvLyBRdWVyeSBJRFAgVVJMIHRvIGdldCBTQU1MIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5nZXQoc3NvVXJsLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBSZWxheVN0YXRlOiAnL3NvbWUvZGVlcC9saW5rJyxcbiAgICAgICAgICAgICAgICBvbmV0aW1ldG9rZW46IG9uZVRpbWVUb2tlbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzcG9uc2VIdG1sXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVNBTUwocmVzcG9uc2VIdG1sKSB7XG4gICAgICAgIGNvbnN0IHBvc3RCYWNrVXJsID0gZ2V0UG9zdEJhY2tVcmxGcm9tSHRtbChyZXNwb25zZUh0bWwpO1xuICAgICAgICBjb25zdCBmdWxsVXJsID0gdXRpbC5mb3JtYXQoJyVzOi8vJXM6JXMnLCBwcm90b2NvbCwgaG9zdCwgcG9ydCk7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBwb3N0IGJhY2sgdXJsIGNvbWUgYmFjayB3aXRoIHRoZSBTQU1MIHJlc3BvbnNlXG4gICAgICAgIC8vIGNvbnRhaW5zIHRoZSBzYW1lIHByZWZpeCBhcyB0aGUgU25vd2ZsYWtlJ3Mgc2VydmVyIHVybCwgd2hpY2ggaXMgdGhlXG4gICAgICAgIC8vIGludGVuZGVkIGRlc3RpbmF0aW9uIHVybCB0byBTbm93Zmxha2UuXG4gICAgICAgIGlmICghY29ubmVjdGlvbkNvbmZpZy5nZXREaXNhYmxlU2FtbFVSTENoZWNrKCkpIHtcbiAgICAgICAgICAgIGlmIChwb3N0QmFja1VybC5zdWJzdHJpbmcoMCwgMjApICE9PSBmdWxsVXJsLnN1YnN0cmluZygwLCAyMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ1RoZSBzcGVjaWZpZWQgYXV0aGVudGljYXRvciBhbmQgZGVzdGluYXRpb24gVVJMICcgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gdGhlIFNBTUwgYXNzZXJ0aW9uIGRvIG5vdCBtYXRjaDogZXhwZWN0ZWQ6ICVzIHBvc3RiYWNrOiAlcycsIGZ1bGxVcmwsIHBvc3RCYWNrVXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2FtbFJlc3BvbnNlID0gcmVzcG9uc2VIdG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBwb3N0YmFjayBVUkwgZnJvbSB0aGUgSFRNTCByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBvc3RCYWNrVXJsRnJvbUh0bWwoaHRtbCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGh0bWwuc2VhcmNoKCc8Zm9ybScpO1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gaHRtbC5pbmRleE9mKCdhY3Rpb249XCInLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gaHRtbC5pbmRleE9mKCdcIicsIHN0YXJ0SW5kZXggKyA4KTtcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlSHRtbChodG1sLnN1YnN0cmluZyhzdGFydEluZGV4ICsgOCwgZW5kSW5kZXgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgdGhlIEhUTUwgaGV4IGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbChodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoLyYjeDNhOy9nLCAnOicpLnJlcGxhY2UoLyYjeDJmOy9nLCAnLycpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aE9rdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoX29rdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst URLUtil = __webpack_require__(/*! ./../../lib/url_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/url_util.js\");\nconst Util = __webpack_require__(/*! ./../../lib/util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst SsoUrlProvider = __webpack_require__(/*! ../authentication/sso_url_provider */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { rest } = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst { createServer } = __webpack_require__(/*! ./authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst { withBrowserActionTimeout } = __webpack_require__(/*! ./authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\n/**\n * Creates an external browser authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {module} webbrowser\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthWeb(connectionConfig, httpClient, webbrowser) {\n    const host = connectionConfig.host;\n    const browserActionTimeout = connectionConfig.getBrowserActionTimeout();\n    const ssoUrlProvider = new SsoUrlProvider(httpClient);\n    if (!Util.exists(host)) {\n        throw new Error(`Invalid value for host: ${host}`);\n    }\n    if (!Util.number.isPositiveInteger(browserActionTimeout)) {\n        throw new Error(`Invalid value for browser action timeout: ${browserActionTimeout}`);\n    }\n    const open = typeof webbrowser !== 'undefined' ? webbrowser : __webpack_require__(/*! open */ \"(rsc)/./node_modules/open/index.js\");\n    let proofKey;\n    let token;\n    /**\n     * Update JSON body with token and proof_key.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = token;\n        body['data']['PROOF_KEY'] = proofKey;\n        body['data']['AUTHENTICATOR'] = 'EXTERNALBROWSER';\n    };\n    /**\n     * Obtain SAML token through SSO URL.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {Promise<null>}\n     */\n    this.authenticate = async function (authenticator, serviceName, account, username) {\n        let server;\n        let loginUrl;\n        const receiveData = new Promise((resolve) => {\n            // Server to receive SAML token\n            server = createServer(resolve);\n        }).then((result) => {\n            return result;\n        });\n        // Use a free random port and set to no backlog\n        server.listen(0, 0);\n        if (connectionConfig.getDisableConsoleLogin()) {\n            // Step 1: query Snowflake to obtain SSO url\n            const ssoData = await ssoUrlProvider.getSSOURL(authenticator, serviceName, account, server.address().port, username, host);\n            proofKey = ssoData['proofKey'];\n            loginUrl = ssoData['ssoUrl'];\n        }\n        else {\n            proofKey = this.generateProofKey();\n            loginUrl = this.getLoginUrl(username, proofKey, server.address().port);\n        }\n        // Step 2: validate URL\n        if (!URLUtil.isValidURL(loginUrl)) {\n            throw new Error(util.format('Invalid SSO URL found - %s ', loginUrl));\n        }\n        // Step 3: open browser\n        open(loginUrl);\n        // Step 4: get SAML token\n        const tokenGetHttpLine = await withBrowserActionTimeout(browserActionTimeout, receiveData).catch((rejected) => {\n            server.close();\n            throw new Error(util.format('Error while getting SAML token: %s', rejected));\n        });\n        processGet(tokenGetHttpLine);\n    };\n    this.generateProofKey = function () {\n        const randomness = crypto.randomBytes(32);\n        return Buffer.from(randomness, 'utf8').toString('base64');\n    };\n    this.getLoginUrl = function (username, proofKey, port) {\n        const url = new URL(rest.HTTPS_PROTOCOL + '://' + host + '/console/login');\n        url.searchParams.append('login_name', username);\n        url.searchParams.append('proof_key', proofKey);\n        url.searchParams.append('browser_mode_redirect_port', port);\n        return url.toString();\n    };\n    /**\n     * Parse the GET request and get token parameter value.\n     *\n     * @param {String} tokenHttpGetLine\n     *\n     * @returns {null}\n     */\n    function processGet(tokenHttpGetLine) {\n        // Split the GET request line\n        const data = tokenHttpGetLine.split(' ');\n        // Get value of the \"token\" query parameter\n        token = querystring.parse(data[1])['/?token'];\n    }\n}\nmodule.exports = AuthWeb;\n//# sourceMappingURL=auth_web.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dlYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLDZFQUFrQjtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQywwSEFBb0M7QUFDbkUsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzNDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsZ0hBQXVCO0FBQ3hELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxnSEFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0EscUVBQXFFLHFCQUFxQjtBQUMxRjtBQUNBLGtFQUFrRSxtQkFBTyxDQUFDLGdEQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dlYi5qcz81ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IFVSTFV0aWwgPSByZXF1aXJlKCcuLy4uLy4uL2xpYi91cmxfdXRpbCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4vLi4vLi4vbGliL3V0aWwnKTtcbmNvbnN0IFNzb1VybFByb3ZpZGVyID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vc3NvX3VybF9wcm92aWRlcicpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IHJlc3QgfSA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IHsgY3JlYXRlU2VydmVyIH0gPSByZXF1aXJlKCcuL2F1dGhlbnRpY2F0aW9uX3V0aWwnKTtcbmNvbnN0IHsgd2l0aEJyb3dzZXJBY3Rpb25UaW1lb3V0IH0gPSByZXF1aXJlKCcuL2F1dGhlbnRpY2F0aW9uX3V0aWwnKTtcbi8qKlxuICogQ3JlYXRlcyBhbiBleHRlcm5hbCBicm93c2VyIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAcGFyYW0ge21vZHVsZX0gd2ViYnJvd3NlclxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aFdlYihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCB3ZWJicm93c2VyKSB7XG4gICAgY29uc3QgaG9zdCA9IGNvbm5lY3Rpb25Db25maWcuaG9zdDtcbiAgICBjb25zdCBicm93c2VyQWN0aW9uVGltZW91dCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0QnJvd3NlckFjdGlvblRpbWVvdXQoKTtcbiAgICBjb25zdCBzc29VcmxQcm92aWRlciA9IG5ldyBTc29VcmxQcm92aWRlcihodHRwQ2xpZW50KTtcbiAgICBpZiAoIVV0aWwuZXhpc3RzKGhvc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgaG9zdDogJHtob3N0fWApO1xuICAgIH1cbiAgICBpZiAoIVV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyKGJyb3dzZXJBY3Rpb25UaW1lb3V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIGJyb3dzZXIgYWN0aW9uIHRpbWVvdXQ6ICR7YnJvd3NlckFjdGlvblRpbWVvdXR9YCk7XG4gICAgfVxuICAgIGNvbnN0IG9wZW4gPSB0eXBlb2Ygd2ViYnJvd3NlciAhPT0gJ3VuZGVmaW5lZCcgPyB3ZWJicm93c2VyIDogcmVxdWlyZSgnb3BlbicpO1xuICAgIGxldCBwcm9vZktleTtcbiAgICBsZXQgdG9rZW47XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHRva2VuIGFuZCBwcm9vZl9rZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT059IGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnVE9LRU4nXSA9IHRva2VuO1xuICAgICAgICBib2R5WydkYXRhJ11bJ1BST09GX0tFWSddID0gcHJvb2ZLZXk7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnQVVUSEVOVElDQVRPUiddID0gJ0VYVEVSTkFMQlJPV1NFUic7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPYnRhaW4gU0FNTCB0b2tlbiB0aHJvdWdoIFNTTyBVUkwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudWxsPn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChhdXRoZW50aWNhdG9yLCBzZXJ2aWNlTmFtZSwgYWNjb3VudCwgdXNlcm5hbWUpIHtcbiAgICAgICAgbGV0IHNlcnZlcjtcbiAgICAgICAgbGV0IGxvZ2luVXJsO1xuICAgICAgICBjb25zdCByZWNlaXZlRGF0YSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAvLyBTZXJ2ZXIgdG8gcmVjZWl2ZSBTQU1MIHRva2VuXG4gICAgICAgICAgICBzZXJ2ZXIgPSBjcmVhdGVTZXJ2ZXIocmVzb2x2ZSk7XG4gICAgICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVzZSBhIGZyZWUgcmFuZG9tIHBvcnQgYW5kIHNldCB0byBubyBiYWNrbG9nXG4gICAgICAgIHNlcnZlci5saXN0ZW4oMCwgMCk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLmdldERpc2FibGVDb25zb2xlTG9naW4oKSkge1xuICAgICAgICAgICAgLy8gU3RlcCAxOiBxdWVyeSBTbm93Zmxha2UgdG8gb2J0YWluIFNTTyB1cmxcbiAgICAgICAgICAgIGNvbnN0IHNzb0RhdGEgPSBhd2FpdCBzc29VcmxQcm92aWRlci5nZXRTU09VUkwoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIHNlcnZlci5hZGRyZXNzKCkucG9ydCwgdXNlcm5hbWUsIGhvc3QpO1xuICAgICAgICAgICAgcHJvb2ZLZXkgPSBzc29EYXRhWydwcm9vZktleSddO1xuICAgICAgICAgICAgbG9naW5VcmwgPSBzc29EYXRhWydzc29VcmwnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb29mS2V5ID0gdGhpcy5nZW5lcmF0ZVByb29mS2V5KCk7XG4gICAgICAgICAgICBsb2dpblVybCA9IHRoaXMuZ2V0TG9naW5VcmwodXNlcm5hbWUsIHByb29mS2V5LCBzZXJ2ZXIuYWRkcmVzcygpLnBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMjogdmFsaWRhdGUgVVJMXG4gICAgICAgIGlmICghVVJMVXRpbC5pc1ZhbGlkVVJMKGxvZ2luVXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdJbnZhbGlkIFNTTyBVUkwgZm91bmQgLSAlcyAnLCBsb2dpblVybCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMzogb3BlbiBicm93c2VyXG4gICAgICAgIG9wZW4obG9naW5VcmwpO1xuICAgICAgICAvLyBTdGVwIDQ6IGdldCBTQU1MIHRva2VuXG4gICAgICAgIGNvbnN0IHRva2VuR2V0SHR0cExpbmUgPSBhd2FpdCB3aXRoQnJvd3NlckFjdGlvblRpbWVvdXQoYnJvd3NlckFjdGlvblRpbWVvdXQsIHJlY2VpdmVEYXRhKS5jYXRjaCgocmVqZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdFcnJvciB3aGlsZSBnZXR0aW5nIFNBTUwgdG9rZW46ICVzJywgcmVqZWN0ZWQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NHZXQodG9rZW5HZXRIdHRwTGluZSk7XG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlUHJvb2ZLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbW5lc3MgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocmFuZG9tbmVzcywgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfTtcbiAgICB0aGlzLmdldExvZ2luVXJsID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwcm9vZktleSwgcG9ydCkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlc3QuSFRUUFNfUFJPVE9DT0wgKyAnOi8vJyArIGhvc3QgKyAnL2NvbnNvbGUvbG9naW4nKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ2xvZ2luX25hbWUnLCB1c2VybmFtZSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdwcm9vZl9rZXknLCBwcm9vZktleSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdicm93c2VyX21vZGVfcmVkaXJlY3RfcG9ydCcsIHBvcnQpO1xuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgR0VUIHJlcXVlc3QgYW5kIGdldCB0b2tlbiBwYXJhbWV0ZXIgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5IdHRwR2V0TGluZVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0dldCh0b2tlbkh0dHBHZXRMaW5lKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBHRVQgcmVxdWVzdCBsaW5lXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0b2tlbkh0dHBHZXRMaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgIC8vIEdldCB2YWx1ZSBvZiB0aGUgXCJ0b2tlblwiIHF1ZXJ5IHBhcmFtZXRlclxuICAgICAgICB0b2tlbiA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRhdGFbMV0pWycvP3Rva2VuJ107XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBBdXRoV2ViO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aF93ZWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAwsCredentials = getAwsCredentials;\nexports.getAwsRegion = getAwsRegion;\nexports.getStsHostname = getStsHostname;\nexports.getAwsAttestationToken = getAwsAttestationToken;\nconst credential_provider_node_1 = __webpack_require__(/*! @aws-sdk/credential-provider-node */ \"(rsc)/./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js\");\nconst client_sts_1 = __webpack_require__(/*! @aws-sdk/client-sts */ \"(rsc)/./node_modules/@aws-sdk/client-sts/dist-es/index.js\");\nconst ec2_metadata_service_1 = __webpack_require__(/*! @aws-sdk/ec2-metadata-service */ \"(rsc)/./node_modules/@aws-sdk/ec2-metadata-service/dist-es/index.js\");\nconst protocol_http_1 = __webpack_require__(/*! @smithy/protocol-http */ \"(rsc)/./node_modules/@smithy/protocol-http/dist-es/index.js\");\nconst signature_v4_1 = __webpack_require__(/*! @smithy/signature-v4 */ \"(rsc)/./node_modules/@smithy/signature-v4/dist-es/index.js\");\nconst sha256_js_1 = __webpack_require__(/*! @aws-crypto/sha256-js */ \"(rsc)/./node_modules/@aws-crypto/sha256-js/build/module/index.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nasync function getAwsCredentials(region, impersonationPath = []) {\n    (0, logger_1.default)().debug('Getting AWS credentials from default provider');\n    let credentials = await (0, credential_provider_node_1.defaultProvider)()();\n    for (const roleArn of impersonationPath) {\n        (0, logger_1.default)().debug(`Getting AWS credentials from impersonation role: ${roleArn}`);\n        const stsClient = new client_sts_1.STSClient({\n            credentials,\n            region,\n        });\n        const command = new client_sts_1.AssumeRoleCommand({\n            RoleArn: roleArn,\n            RoleSessionName: 'identity-federation-session',\n        });\n        const { Credentials } = await stsClient.send(command);\n        if (Credentials?.AccessKeyId && Credentials?.SecretAccessKey) {\n            credentials = {\n                accessKeyId: Credentials.AccessKeyId,\n                secretAccessKey: Credentials.SecretAccessKey,\n                sessionToken: Credentials.SessionToken,\n            };\n        }\n        else {\n            throw new Error(`Failed to get credentials from impersonation role ${roleArn}`);\n        }\n    }\n    return credentials;\n}\nasync function getAwsRegion() {\n    if (process.env.AWS_REGION) {\n        (0, logger_1.default)().debug('Getting AWS region from AWS_REGION');\n        return process.env.AWS_REGION; // Lambda\n    }\n    else {\n        (0, logger_1.default)().debug('Getting AWS region from EC2 metadata service');\n        return new ec2_metadata_service_1.MetadataService().request('/latest/meta-data/placement/region', {}); // EC2\n    }\n}\nfunction getStsHostname(region) {\n    const domain = region.startsWith('cn-') ? 'amazonaws.com.cn' : 'amazonaws.com';\n    return `sts.${region}.${domain}`;\n}\nasync function getAwsAttestationToken(impersonationPath) {\n    const region = await getAwsRegion();\n    const credentials = await getAwsCredentials(region, impersonationPath);\n    const stsHostname = getStsHostname(region);\n    const request = new protocol_http_1.HttpRequest({\n        method: 'POST',\n        protocol: 'https',\n        hostname: stsHostname,\n        path: '/',\n        headers: {\n            host: stsHostname,\n            'x-snowflake-audience': 'snowflakecomputing.com',\n        },\n        query: {\n            Action: 'GetCallerIdentity',\n            Version: '2011-06-15',\n        },\n    });\n    const signedRequest = await new signature_v4_1.SignatureV4({\n        credentials,\n        applyChecksum: false,\n        region,\n        service: 'sts',\n        sha256: sha256_js_1.Sha256,\n    }).sign(request);\n    const token = {\n        url: `https://${stsHostname}/?Action=GetCallerIdentity&Version=2011-06-15`,\n        method: 'POST',\n        headers: signedRequest.headers,\n    };\n    return btoa(JSON.stringify(token));\n}\n//# sourceMappingURL=attestation_aws.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2F3cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLDhCQUE4QjtBQUM5QixtQ0FBbUMsbUJBQU8sQ0FBQyxrSEFBbUM7QUFDOUUscUJBQXFCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ2xELCtCQUErQixtQkFBTyxDQUFDLDBHQUErQjtBQUN0RSx3QkFBd0IsbUJBQU8sQ0FBQywwRkFBdUI7QUFDdkQsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLCtGQUF1QjtBQUNuRCxpQ0FBaUMsbUJBQU8sQ0FBQywyRUFBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixRQUFRO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixRQUFRO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxHQUFHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU8sR0FBRyxPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2F3cy5qcz84YmRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBd3NDcmVkZW50aWFscyA9IGdldEF3c0NyZWRlbnRpYWxzO1xuZXhwb3J0cy5nZXRBd3NSZWdpb24gPSBnZXRBd3NSZWdpb247XG5leHBvcnRzLmdldFN0c0hvc3RuYW1lID0gZ2V0U3RzSG9zdG5hbWU7XG5leHBvcnRzLmdldEF3c0F0dGVzdGF0aW9uVG9rZW4gPSBnZXRBd3NBdHRlc3RhdGlvblRva2VuO1xuY29uc3QgY3JlZGVudGlhbF9wcm92aWRlcl9ub2RlXzEgPSByZXF1aXJlKFwiQGF3cy1zZGsvY3JlZGVudGlhbC1wcm92aWRlci1ub2RlXCIpO1xuY29uc3QgY2xpZW50X3N0c18xID0gcmVxdWlyZShcIkBhd3Mtc2RrL2NsaWVudC1zdHNcIik7XG5jb25zdCBlYzJfbWV0YWRhdGFfc2VydmljZV8xID0gcmVxdWlyZShcIkBhd3Mtc2RrL2VjMi1tZXRhZGF0YS1zZXJ2aWNlXCIpO1xuY29uc3QgcHJvdG9jb2xfaHR0cF8xID0gcmVxdWlyZShcIkBzbWl0aHkvcHJvdG9jb2wtaHR0cFwiKTtcbmNvbnN0IHNpZ25hdHVyZV92NF8xID0gcmVxdWlyZShcIkBzbWl0aHkvc2lnbmF0dXJlLXY0XCIpO1xuY29uc3Qgc2hhMjU2X2pzXzEgPSByZXF1aXJlKFwiQGF3cy1jcnlwdG8vc2hhMjU2LWpzXCIpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2xvZ2dlclwiKSk7XG5hc3luYyBmdW5jdGlvbiBnZXRBd3NDcmVkZW50aWFscyhyZWdpb24sIGltcGVyc29uYXRpb25QYXRoID0gW10pIHtcbiAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZygnR2V0dGluZyBBV1MgY3JlZGVudGlhbHMgZnJvbSBkZWZhdWx0IHByb3ZpZGVyJyk7XG4gICAgbGV0IGNyZWRlbnRpYWxzID0gYXdhaXQgKDAsIGNyZWRlbnRpYWxfcHJvdmlkZXJfbm9kZV8xLmRlZmF1bHRQcm92aWRlcikoKSgpO1xuICAgIGZvciAoY29uc3Qgcm9sZUFybiBvZiBpbXBlcnNvbmF0aW9uUGF0aCkge1xuICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZyhgR2V0dGluZyBBV1MgY3JlZGVudGlhbHMgZnJvbSBpbXBlcnNvbmF0aW9uIHJvbGU6ICR7cm9sZUFybn1gKTtcbiAgICAgICAgY29uc3Qgc3RzQ2xpZW50ID0gbmV3IGNsaWVudF9zdHNfMS5TVFNDbGllbnQoe1xuICAgICAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICAgICAgICByZWdpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb21tYW5kID0gbmV3IGNsaWVudF9zdHNfMS5Bc3N1bWVSb2xlQ29tbWFuZCh7XG4gICAgICAgICAgICBSb2xlQXJuOiByb2xlQXJuLFxuICAgICAgICAgICAgUm9sZVNlc3Npb25OYW1lOiAnaWRlbnRpdHktZmVkZXJhdGlvbi1zZXNzaW9uJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgQ3JlZGVudGlhbHMgfSA9IGF3YWl0IHN0c0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuICAgICAgICBpZiAoQ3JlZGVudGlhbHM/LkFjY2Vzc0tleUlkICYmIENyZWRlbnRpYWxzPy5TZWNyZXRBY2Nlc3NLZXkpIHtcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0tleUlkOiBDcmVkZW50aWFscy5BY2Nlc3NLZXlJZCxcbiAgICAgICAgICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6IENyZWRlbnRpYWxzLlNlY3JldEFjY2Vzc0tleSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uVG9rZW46IENyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgY3JlZGVudGlhbHMgZnJvbSBpbXBlcnNvbmF0aW9uIHJvbGUgJHtyb2xlQXJufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVkZW50aWFscztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEF3c1JlZ2lvbigpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuQVdTX1JFR0lPTikge1xuICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZygnR2V0dGluZyBBV1MgcmVnaW9uIGZyb20gQVdTX1JFR0lPTicpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTjsgLy8gTGFtYmRhXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZygnR2V0dGluZyBBV1MgcmVnaW9uIGZyb20gRUMyIG1ldGFkYXRhIHNlcnZpY2UnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBlYzJfbWV0YWRhdGFfc2VydmljZV8xLk1ldGFkYXRhU2VydmljZSgpLnJlcXVlc3QoJy9sYXRlc3QvbWV0YS1kYXRhL3BsYWNlbWVudC9yZWdpb24nLCB7fSk7IC8vIEVDMlxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFN0c0hvc3RuYW1lKHJlZ2lvbikge1xuICAgIGNvbnN0IGRvbWFpbiA9IHJlZ2lvbi5zdGFydHNXaXRoKCdjbi0nKSA/ICdhbWF6b25hd3MuY29tLmNuJyA6ICdhbWF6b25hd3MuY29tJztcbiAgICByZXR1cm4gYHN0cy4ke3JlZ2lvbn0uJHtkb21haW59YDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEF3c0F0dGVzdGF0aW9uVG9rZW4oaW1wZXJzb25hdGlvblBhdGgpIHtcbiAgICBjb25zdCByZWdpb24gPSBhd2FpdCBnZXRBd3NSZWdpb24oKTtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGF3YWl0IGdldEF3c0NyZWRlbnRpYWxzKHJlZ2lvbiwgaW1wZXJzb25hdGlvblBhdGgpO1xuICAgIGNvbnN0IHN0c0hvc3RuYW1lID0gZ2V0U3RzSG9zdG5hbWUocmVnaW9uKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IHByb3RvY29sX2h0dHBfMS5IdHRwUmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBwcm90b2NvbDogJ2h0dHBzJyxcbiAgICAgICAgaG9zdG5hbWU6IHN0c0hvc3RuYW1lLFxuICAgICAgICBwYXRoOiAnLycsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIGhvc3Q6IHN0c0hvc3RuYW1lLFxuICAgICAgICAgICAgJ3gtc25vd2ZsYWtlLWF1ZGllbmNlJzogJ3Nub3dmbGFrZWNvbXB1dGluZy5jb20nLFxuICAgICAgICB9LFxuICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgQWN0aW9uOiAnR2V0Q2FsbGVySWRlbnRpdHknLFxuICAgICAgICAgICAgVmVyc2lvbjogJzIwMTEtMDYtMTUnLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25lZFJlcXVlc3QgPSBhd2FpdCBuZXcgc2lnbmF0dXJlX3Y0XzEuU2lnbmF0dXJlVjQoe1xuICAgICAgICBjcmVkZW50aWFscyxcbiAgICAgICAgYXBwbHlDaGVja3N1bTogZmFsc2UsXG4gICAgICAgIHJlZ2lvbixcbiAgICAgICAgc2VydmljZTogJ3N0cycsXG4gICAgICAgIHNoYTI1Njogc2hhMjU2X2pzXzEuU2hhMjU2LFxuICAgIH0pLnNpZ24ocmVxdWVzdCk7XG4gICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgIHVybDogYGh0dHBzOi8vJHtzdHNIb3N0bmFtZX0vP0FjdGlvbj1HZXRDYWxsZXJJZGVudGl0eSZWZXJzaW9uPTIwMTEtMDYtMTVgLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogc2lnbmVkUmVxdWVzdC5oZWFkZXJzLFxuICAgIH07XG4gICAgcmV0dXJuIGJ0b2EoSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dGVzdGF0aW9uX2F3cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_AZURE_ENTRA_ID_RESOURCE = void 0;\nexports.getAzureAttestationToken = getAzureAttestationToken;\nconst identity_1 = __webpack_require__(/*! @azure/identity */ \"(rsc)/./node_modules/@azure/identity/dist/commonjs/index.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nexports.DEFAULT_AZURE_ENTRA_ID_RESOURCE = 'api://fd3f753b-eed3-462c-b6a7-a4b5bb650aad';\nasync function getAzureAttestationToken(options = {}) {\n    const credential = new identity_1.DefaultAzureCredential({\n        managedIdentityClientId: options.managedIdentityClientId,\n    });\n    (0, logger_1.default)().debug('Getting Azure auth token');\n    const token = await credential.getToken(options.entraIdResource ?? exports.DEFAULT_AZURE_ENTRA_ID_RESOURCE);\n    return token.token;\n}\n//# sourceMappingURL=attestation_azure.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2F6dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDO0FBQ3ZDLGdDQUFnQztBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDNUMsaUNBQWlDLG1CQUFPLENBQUMsMkVBQWM7QUFDdkQsdUNBQXVDO0FBQ3ZDLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhfd29ya2xvYWRfaWRlbnRpdHkvYXR0ZXN0YXRpb25fYXp1cmUuanM/MWEzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9BWlVSRV9FTlRSQV9JRF9SRVNPVVJDRSA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0QXp1cmVBdHRlc3RhdGlvblRva2VuID0gZ2V0QXp1cmVBdHRlc3RhdGlvblRva2VuO1xuY29uc3QgaWRlbnRpdHlfMSA9IHJlcXVpcmUoXCJAYXp1cmUvaWRlbnRpdHlcIik7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpKTtcbmV4cG9ydHMuREVGQVVMVF9BWlVSRV9FTlRSQV9JRF9SRVNPVVJDRSA9ICdhcGk6Ly9mZDNmNzUzYi1lZWQzLTQ2MmMtYjZhNy1hNGI1YmI2NTBhYWQnO1xuYXN5bmMgZnVuY3Rpb24gZ2V0QXp1cmVBdHRlc3RhdGlvblRva2VuKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBuZXcgaWRlbnRpdHlfMS5EZWZhdWx0QXp1cmVDcmVkZW50aWFsKHtcbiAgICAgICAgbWFuYWdlZElkZW50aXR5Q2xpZW50SWQ6IG9wdGlvbnMubWFuYWdlZElkZW50aXR5Q2xpZW50SWQsXG4gICAgfSk7XG4gICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoJ0dldHRpbmcgQXp1cmUgYXV0aCB0b2tlbicpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3JlZGVudGlhbC5nZXRUb2tlbihvcHRpb25zLmVudHJhSWRSZXNvdXJjZSA/PyBleHBvcnRzLkRFRkFVTFRfQVpVUkVfRU5UUkFfSURfUkVTT1VSQ0UpO1xuICAgIHJldHVybiB0b2tlbi50b2tlbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dGVzdGF0aW9uX2F6dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SNOWFLAKE_AUDIENCE = void 0;\nexports.getGcpAttestationToken = getGcpAttestationToken;\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nexports.SNOWFLAKE_AUDIENCE = 'snowflakecomputing.com';\nasync function getGcpAttestationToken(impersonationPath) {\n    const auth = new google_auth_library_1.GoogleAuth();\n    if (impersonationPath) {\n        (0, logger_1.default)().debug(`Getting GCP auth token from impersonation path: ${impersonationPath.join(', ')}`);\n        const impersonated = new google_auth_library_1.Impersonated({\n            sourceClient: await auth.getClient(),\n            targetPrincipal: impersonationPath[impersonationPath.length - 1],\n            delegates: impersonationPath.slice(0, -1),\n        });\n        return await impersonated.fetchIdToken(exports.SNOWFLAKE_AUDIENCE);\n    }\n    (0, logger_1.default)().debug('Getting GCP auth token from default credentials');\n    const client = await auth.getIdTokenClient(exports.SNOWFLAKE_AUDIENCE);\n    return await client.idTokenProvider.fetchIdToken(exports.SNOWFLAKE_AUDIENCE);\n}\n//# sourceMappingURL=attestation_gcp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2djcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsOEJBQThCLG1CQUFPLENBQUMsd0ZBQXFCO0FBQzNELGlDQUFpQyxtQkFBTyxDQUFDLDJFQUFjO0FBQ3ZELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsNkJBQTZCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2djcC5qcz9jMWE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TTk9XRkxBS0VfQVVESUVOQ0UgPSB2b2lkIDA7XG5leHBvcnRzLmdldEdjcEF0dGVzdGF0aW9uVG9rZW4gPSBnZXRHY3BBdHRlc3RhdGlvblRva2VuO1xuY29uc3QgZ29vZ2xlX2F1dGhfbGlicmFyeV8xID0gcmVxdWlyZShcImdvb2dsZS1hdXRoLWxpYnJhcnlcIik7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpKTtcbmV4cG9ydHMuU05PV0ZMQUtFX0FVRElFTkNFID0gJ3Nub3dmbGFrZWNvbXB1dGluZy5jb20nO1xuYXN5bmMgZnVuY3Rpb24gZ2V0R2NwQXR0ZXN0YXRpb25Ub2tlbihpbXBlcnNvbmF0aW9uUGF0aCkge1xuICAgIGNvbnN0IGF1dGggPSBuZXcgZ29vZ2xlX2F1dGhfbGlicmFyeV8xLkdvb2dsZUF1dGgoKTtcbiAgICBpZiAoaW1wZXJzb25hdGlvblBhdGgpIHtcbiAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYEdldHRpbmcgR0NQIGF1dGggdG9rZW4gZnJvbSBpbXBlcnNvbmF0aW9uIHBhdGg6ICR7aW1wZXJzb25hdGlvblBhdGguam9pbignLCAnKX1gKTtcbiAgICAgICAgY29uc3QgaW1wZXJzb25hdGVkID0gbmV3IGdvb2dsZV9hdXRoX2xpYnJhcnlfMS5JbXBlcnNvbmF0ZWQoe1xuICAgICAgICAgICAgc291cmNlQ2xpZW50OiBhd2FpdCBhdXRoLmdldENsaWVudCgpLFxuICAgICAgICAgICAgdGFyZ2V0UHJpbmNpcGFsOiBpbXBlcnNvbmF0aW9uUGF0aFtpbXBlcnNvbmF0aW9uUGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGRlbGVnYXRlczogaW1wZXJzb25hdGlvblBhdGguc2xpY2UoMCwgLTEpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGltcGVyc29uYXRlZC5mZXRjaElkVG9rZW4oZXhwb3J0cy5TTk9XRkxBS0VfQVVESUVOQ0UpO1xuICAgIH1cbiAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZygnR2V0dGluZyBHQ1AgYXV0aCB0b2tlbiBmcm9tIGRlZmF1bHQgY3JlZGVudGlhbHMnKTtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBhdXRoLmdldElkVG9rZW5DbGllbnQoZXhwb3J0cy5TTk9XRkxBS0VfQVVESUVOQ0UpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuaWRUb2tlblByb3ZpZGVyLmZldGNoSWRUb2tlbihleHBvcnRzLlNOT1dGTEFLRV9BVURJRU5DRSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRlc3RhdGlvbl9nY3AuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst attestation_aws_1 = __webpack_require__(/*! ./attestation_aws */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js\");\nconst errors_1 = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst attestation_azure_1 = __webpack_require__(/*! ./attestation_azure */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js\");\nconst attestation_gcp_1 = __webpack_require__(/*! ./attestation_gcp */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js\");\nconst authentication_types_1 = __importDefault(__webpack_require__(/*! ../authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\"));\nclass AuthWorkloadIdentity {\n    connectionConfig;\n    tokenProvider;\n    token;\n    constructor(connectionConfig) {\n        this.connectionConfig = connectionConfig;\n    }\n    updateBody(body) {\n        body.data['AUTHENTICATOR'] = authentication_types_1.default.WORKLOAD_IDENTITY;\n        body.data['PROVIDER'] = this.tokenProvider;\n        body.data['TOKEN'] = this.token;\n    }\n    async authenticate() {\n        const { workloadIdentityProvider: provider, workloadIdentityImpersonationPath: impersonationPath, } = this.connectionConfig;\n        let token;\n        if (impersonationPath &&\n            provider !== types_1.WorkloadIdentityProvider.AWS &&\n            provider !== types_1.WorkloadIdentityProvider.GCP) {\n            throw new Error(`workloadIdentityImpersonationPath for ${provider} is not supported`);\n        }\n        if (provider === types_1.WorkloadIdentityProvider.AWS) {\n            token = await (0, attestation_aws_1.getAwsAttestationToken)(impersonationPath);\n        }\n        else if (provider === types_1.WorkloadIdentityProvider.AZURE) {\n            token = await (0, attestation_azure_1.getAzureAttestationToken)({\n                managedIdentityClientId: this.connectionConfig.workloadIdentityAzureClientId,\n                entraIdResource: this.connectionConfig.workloadIdentityAzureEntraIdResource,\n            });\n        }\n        else if (provider === types_1.WorkloadIdentityProvider.GCP) {\n            token = await (0, attestation_gcp_1.getGcpAttestationToken)(impersonationPath);\n        }\n        else if (provider === types_1.WorkloadIdentityProvider.OIDC) {\n            if (this.connectionConfig.token) {\n                token = this.connectionConfig.token;\n            }\n            else {\n                throw (0, errors_1.createInvalidParameterError)(errors_1.ErrorCode.ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS, `workloadIdentityProvider: OIDC requires token in connection options`);\n            }\n        }\n        else {\n            throw (0, errors_1.createInvalidParameterError)(errors_1.ErrorCode.ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS, `workloadIdentityProvider must be one of: ${Object.values(types_1.WorkloadIdentityProvider).join(', ')}`);\n        }\n        (0, logger_1.default)().debug(`AuthWorkloadIdentity using provider=${provider}`);\n        this.tokenProvider = provider;\n        this.token = token;\n    }\n}\nexports[\"default\"] = AuthWorkloadIdentity;\n//# sourceMappingURL=auth_workload_identity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F1dGhfd29ya2xvYWRfaWRlbnRpdHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQywrSEFBbUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsMkdBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWM7QUFDdkMsaUNBQWlDLG1CQUFPLENBQUMsMkVBQWM7QUFDdkQsNEJBQTRCLG1CQUFPLENBQUMsbUlBQXFCO0FBQ3pELDBCQUEwQixtQkFBTyxDQUFDLCtIQUFtQjtBQUNyRCwrQ0FBK0MsbUJBQU8sQ0FBQyxtSEFBeUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEZBQTRGO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlMQUFpTCwyREFBMkQ7QUFDNU87QUFDQSw2RUFBNkUsU0FBUztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhfd29ya2xvYWRfaWRlbnRpdHkvYXV0aF93b3JrbG9hZF9pZGVudGl0eS5qcz9iMTc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXR0ZXN0YXRpb25fYXdzXzEgPSByZXF1aXJlKFwiLi9hdHRlc3RhdGlvbl9hd3NcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGF0dGVzdGF0aW9uX2F6dXJlXzEgPSByZXF1aXJlKFwiLi9hdHRlc3RhdGlvbl9henVyZVwiKTtcbmNvbnN0IGF0dGVzdGF0aW9uX2djcF8xID0gcmVxdWlyZShcIi4vYXR0ZXN0YXRpb25fZ2NwXCIpO1xuY29uc3QgYXV0aGVudGljYXRpb25fdHlwZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXV0aGVudGljYXRpb25fdHlwZXNcIikpO1xuY2xhc3MgQXV0aFdvcmtsb2FkSWRlbnRpdHkge1xuICAgIGNvbm5lY3Rpb25Db25maWc7XG4gICAgdG9rZW5Qcm92aWRlcjtcbiAgICB0b2tlbjtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZyA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgfVxuICAgIHVwZGF0ZUJvZHkoYm9keSkge1xuICAgICAgICBib2R5LmRhdGFbJ0FVVEhFTlRJQ0FUT1InXSA9IGF1dGhlbnRpY2F0aW9uX3R5cGVzXzEuZGVmYXVsdC5XT1JLTE9BRF9JREVOVElUWTtcbiAgICAgICAgYm9keS5kYXRhWydQUk9WSURFUiddID0gdGhpcy50b2tlblByb3ZpZGVyO1xuICAgICAgICBib2R5LmRhdGFbJ1RPS0VOJ10gPSB0aGlzLnRva2VuO1xuICAgIH1cbiAgICBhc3luYyBhdXRoZW50aWNhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgd29ya2xvYWRJZGVudGl0eVByb3ZpZGVyOiBwcm92aWRlciwgd29ya2xvYWRJZGVudGl0eUltcGVyc29uYXRpb25QYXRoOiBpbXBlcnNvbmF0aW9uUGF0aCwgfSA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZztcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBpZiAoaW1wZXJzb25hdGlvblBhdGggJiZcbiAgICAgICAgICAgIHByb3ZpZGVyICE9PSB0eXBlc18xLldvcmtsb2FkSWRlbnRpdHlQcm92aWRlci5BV1MgJiZcbiAgICAgICAgICAgIHByb3ZpZGVyICE9PSB0eXBlc18xLldvcmtsb2FkSWRlbnRpdHlQcm92aWRlci5HQ1ApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd29ya2xvYWRJZGVudGl0eUltcGVyc29uYXRpb25QYXRoIGZvciAke3Byb3ZpZGVyfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSB0eXBlc18xLldvcmtsb2FkSWRlbnRpdHlQcm92aWRlci5BV1MpIHtcbiAgICAgICAgICAgIHRva2VuID0gYXdhaXQgKDAsIGF0dGVzdGF0aW9uX2F3c18xLmdldEF3c0F0dGVzdGF0aW9uVG9rZW4pKGltcGVyc29uYXRpb25QYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlciA9PT0gdHlwZXNfMS5Xb3JrbG9hZElkZW50aXR5UHJvdmlkZXIuQVpVUkUpIHtcbiAgICAgICAgICAgIHRva2VuID0gYXdhaXQgKDAsIGF0dGVzdGF0aW9uX2F6dXJlXzEuZ2V0QXp1cmVBdHRlc3RhdGlvblRva2VuKSh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZElkZW50aXR5Q2xpZW50SWQ6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy53b3JrbG9hZElkZW50aXR5QXp1cmVDbGllbnRJZCxcbiAgICAgICAgICAgICAgICBlbnRyYUlkUmVzb3VyY2U6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy53b3JrbG9hZElkZW50aXR5QXp1cmVFbnRyYUlkUmVzb3VyY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlciA9PT0gdHlwZXNfMS5Xb3JrbG9hZElkZW50aXR5UHJvdmlkZXIuR0NQKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGF3YWl0ICgwLCBhdHRlc3RhdGlvbl9nY3BfMS5nZXRHY3BBdHRlc3RhdGlvblRva2VuKShpbXBlcnNvbmF0aW9uUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgPT09IHR5cGVzXzEuV29ya2xvYWRJZGVudGl0eVByb3ZpZGVyLk9JREMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Db25maWcudG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZy50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcnNfMS5jcmVhdGVJbnZhbGlkUGFyYW1ldGVyRXJyb3IpKGVycm9yc18xLkVycm9yQ29kZS5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9XT1JLTE9BRF9JREVOVElUWV9QQVJBTUVURVJTLCBgd29ya2xvYWRJZGVudGl0eVByb3ZpZGVyOiBPSURDIHJlcXVpcmVzIHRva2VuIGluIGNvbm5lY3Rpb24gb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yc18xLmNyZWF0ZUludmFsaWRQYXJhbWV0ZXJFcnJvcikoZXJyb3JzXzEuRXJyb3JDb2RlLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1dPUktMT0FEX0lERU5USVRZX1BBUkFNRVRFUlMsIGB3b3JrbG9hZElkZW50aXR5UHJvdmlkZXIgbXVzdCBiZSBvbmUgb2Y6ICR7T2JqZWN0LnZhbHVlcyh0eXBlc18xLldvcmtsb2FkSWRlbnRpdHlQcm92aWRlcikuam9pbignLCAnKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZyhgQXV0aFdvcmtsb2FkSWRlbnRpdHkgdXNpbmcgcHJvdmlkZXI9JHtwcm92aWRlcn1gKTtcbiAgICAgICAgdGhpcy50b2tlblByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBdXRoV29ya2xvYWRJZGVudGl0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhfd29ya2xvYWRfaWRlbnRpdHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = void 0;\nvar auth_workload_identity_1 = __webpack_require__(/*! ./auth_workload_identity */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js\");\nObject.defineProperty(exports, \"default\", ({ enumerable: true, get: function () { return __importDefault(auth_workload_identity_1).default; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWU7QUFDZiwrQkFBK0IsbUJBQU8sQ0FBQyw2SUFBMEI7QUFDakUsMkNBQTBDLEVBQUUscUNBQXFDLDZEQUE2RCxFQUFDO0FBQy9JIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2luZGV4LmpzP2Y2NzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgYXV0aF93b3JrbG9hZF9pZGVudGl0eV8xID0gcmVxdWlyZShcIi4vYXV0aF93b3JrbG9hZF9pZGVudGl0eVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChhdXRoX3dvcmtsb2FkX2lkZW50aXR5XzEpLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WorkloadIdentityProvider = void 0;\n// NOTE:\n// Intentionally not an enum as we want users to pass strings\nexports.WorkloadIdentityProvider = {\n    AWS: 'AWS',\n    AZURE: 'AZURE',\n    GCP: 'GCP',\n    OIDC: 'OIDC',\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF93b3JrbG9hZF9pZGVudGl0eS90eXBlcy5qcz9lYTk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JrbG9hZElkZW50aXR5UHJvdmlkZXIgPSB2b2lkIDA7XG4vLyBOT1RFOlxuLy8gSW50ZW50aW9uYWxseSBub3QgYW4gZW51bSBhcyB3ZSB3YW50IHVzZXJzIHRvIHBhc3Mgc3RyaW5nc1xuZXhwb3J0cy5Xb3JrbG9hZElkZW50aXR5UHJvdmlkZXIgPSB7XG4gICAgQVdTOiAnQVdTJyxcbiAgICBBWlVSRTogJ0FaVVJFJyxcbiAgICBHQ1A6ICdHQ1AnLFxuICAgIE9JREM6ICdPSURDJyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst AuthDefault = __webpack_require__(/*! ./auth_default */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js\");\nconst AuthWeb = __webpack_require__(/*! ./auth_web */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js\");\nconst AuthKeypair = __webpack_require__(/*! ./auth_keypair */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js\");\nconst AuthOauth = __webpack_require__(/*! ./auth_oauth */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js\");\nconst AuthOauthPAT = __webpack_require__(/*! ./auth_oauth_pat */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js\");\nconst AuthOkta = __webpack_require__(/*! ./auth_okta */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js\");\nconst AuthIDToken = __webpack_require__(/*! ./auth_idtoken */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst AuthOauthAuthorizationCode = __webpack_require__(/*! ./auth_oauth_authorization_code */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js\");\nconst AuthOauthClientCredentials = (__webpack_require__(/*! ./auth_oauth_client_credentials */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js\")[\"default\"]);\nconst AuthWorkloadIdentity = (__webpack_require__(/*! ./auth_workload_identity */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js\")[\"default\"]);\n/**\n * TODO: Refactor\n * - StateConnecting.continue in sf.js and ConnectionConfig adds almost every param\n *   from this function (overwrites them)\n * - AUTHENTICATOR is implemented in almost every auth provider\n *\n * Refactor Plan:\n * - Have a single place to build CLIENT_ENVIRONMENT: ConnectionConfig or sf.js\n * - Have a single place to build common params by either:\n *  - Removing this method\n *  - Moving logic from StateConnecting.continue to this method.\n *    Options should be simplified to accept only ConnectionConfig\n * - Rename auth.updateBody to auth.buildData (as it only builds keys under body.data)\n * - Ensure AUTHENTICATOR is set in every auth provider\n * - Cleanup StateConnecting.continue so it's more clear how final body is built\n *\n * Returns the JSON body to be sent when connecting.\n *\n * @param {String} authenticator\n * @param {String} account\n * @param {String} username\n * @param {String} clientType\n * @param {String} clientVersion\n * @param {Object} clientEnv\n *\n * @returns {JSON}\n */\nexports.formAuthJSON = function formAuthJSON(authenticator, account, username, clientType, clientVersion, clientEnv) {\n    const body = {\n        data: {\n            ACCOUNT_NAME: account,\n            CLIENT_APP_ID: clientType,\n            CLIENT_APP_VERSION: clientVersion,\n            CLIENT_ENVIRONMENT: {\n                OS: clientEnv.OS,\n                OS_VERSION: clientEnv.OS_VERSION,\n                OCSP_MODE: clientEnv.OCSP_MODE,\n            },\n        },\n    };\n    if (!this.isOktaAuth(authenticator)) {\n        body['data']['AUTHENTICATOR'] = authenticator;\n        body['data']['LOGIN_NAME'] = username;\n    }\n    return body;\n};\n/**\n * Returns the authenticator to use base on the connection configuration.\n *\n * @param {Object} connectionConfig\n * @param httpClient\n *\n * @returns {Object} the authenticator.\n */\nexports.getAuthenticator = function getAuthenticator(connectionConfig, httpClient) {\n    const authType = connectionConfig.getAuthenticator();\n    const openExternalBrowserCallback = connectionConfig.openExternalBrowserCallback; // Important for SSO in the Snowflake VS Code extension\n    let auth;\n    if (authType === AuthenticationTypes.DEFAULT_AUTHENTICATOR ||\n        authType === AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR) {\n        auth = new AuthDefault(connectionConfig);\n    }\n    else if (authType === AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR) {\n        if (connectionConfig.getClientStoreTemporaryCredential() && !!connectionConfig.idToken) {\n            auth = new AuthIDToken(connectionConfig, httpClient, openExternalBrowserCallback);\n        }\n        else {\n            auth = new AuthWeb(connectionConfig, httpClient, openExternalBrowserCallback);\n        }\n    }\n    else if (authType === AuthenticationTypes.KEY_PAIR_AUTHENTICATOR) {\n        auth = new AuthKeypair(connectionConfig);\n    }\n    else if (authType === AuthenticationTypes.OAUTH_AUTHENTICATOR) {\n        auth = new AuthOauth(connectionConfig.getToken());\n    }\n    else if (authType === AuthenticationTypes.PROGRAMMATIC_ACCESS_TOKEN) {\n        auth = new AuthOauthPAT(connectionConfig.getToken(), connectionConfig.password);\n    }\n    else if (authType === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE) {\n        auth = new AuthOauthAuthorizationCode(connectionConfig, httpClient);\n    }\n    else if (authType === AuthenticationTypes.OAUTH_CLIENT_CREDENTIALS) {\n        auth = new AuthOauthClientCredentials(connectionConfig, httpClient);\n    }\n    else if (this.isOktaAuth(authType)) {\n        auth = new AuthOkta(connectionConfig, httpClient);\n    }\n    else if (authType === AuthenticationTypes.WORKLOAD_IDENTITY) {\n        auth = new AuthWorkloadIdentity(connectionConfig, httpClient);\n    }\n    else {\n        // Authenticator specified does not exist\n        Logger.getInstance().warn(`No authenticator found for '${authType}'. Using default authenticator as a fallback`);\n        auth = new AuthDefault(connectionConfig);\n    }\n    return auth;\n};\n/**\n * Returns the boolean describing if the provided authenticator is okta or not.\n *\n * @param {String} authenticator\n * @returns {boolean}\n */\nexports.isOktaAuth = function isOktaAuth(authenticator) {\n    return authenticator.toUpperCase().startsWith('HTTPS://');\n};\n//# sourceMappingURL=authentication.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9CQUFvQixtQkFBTyxDQUFDLGtHQUFnQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBWTtBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBZ0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsOEZBQWM7QUFDeEMscUJBQXFCLG1CQUFPLENBQUMsc0dBQWtCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDRGQUFhO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLGtHQUFnQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsa0hBQXdCO0FBQzVELG1DQUFtQyxtQkFBTyxDQUFDLG9JQUFpQztBQUM1RSxtQ0FBbUMsc0tBQWtEO0FBQ3JGLDZCQUE2Qiw4SkFBMkM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmpzPzhjYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBdXRoRGVmYXVsdCA9IHJlcXVpcmUoJy4vYXV0aF9kZWZhdWx0Jyk7XG5jb25zdCBBdXRoV2ViID0gcmVxdWlyZSgnLi9hdXRoX3dlYicpO1xuY29uc3QgQXV0aEtleXBhaXIgPSByZXF1aXJlKCcuL2F1dGhfa2V5cGFpcicpO1xuY29uc3QgQXV0aE9hdXRoID0gcmVxdWlyZSgnLi9hdXRoX29hdXRoJyk7XG5jb25zdCBBdXRoT2F1dGhQQVQgPSByZXF1aXJlKCcuL2F1dGhfb2F1dGhfcGF0Jyk7XG5jb25zdCBBdXRoT2t0YSA9IHJlcXVpcmUoJy4vYXV0aF9va3RhJyk7XG5jb25zdCBBdXRoSURUb2tlbiA9IHJlcXVpcmUoJy4vYXV0aF9pZHRva2VuJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPSByZXF1aXJlKCcuL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBBdXRoT2F1dGhBdXRob3JpemF0aW9uQ29kZSA9IHJlcXVpcmUoJy4vYXV0aF9vYXV0aF9hdXRob3JpemF0aW9uX2NvZGUnKTtcbmNvbnN0IEF1dGhPYXV0aENsaWVudENyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi9hdXRoX29hdXRoX2NsaWVudF9jcmVkZW50aWFscycpLmRlZmF1bHQ7XG5jb25zdCBBdXRoV29ya2xvYWRJZGVudGl0eSA9IHJlcXVpcmUoJy4vYXV0aF93b3JrbG9hZF9pZGVudGl0eScpLmRlZmF1bHQ7XG4vKipcbiAqIFRPRE86IFJlZmFjdG9yXG4gKiAtIFN0YXRlQ29ubmVjdGluZy5jb250aW51ZSBpbiBzZi5qcyBhbmQgQ29ubmVjdGlvbkNvbmZpZyBhZGRzIGFsbW9zdCBldmVyeSBwYXJhbVxuICogICBmcm9tIHRoaXMgZnVuY3Rpb24gKG92ZXJ3cml0ZXMgdGhlbSlcbiAqIC0gQVVUSEVOVElDQVRPUiBpcyBpbXBsZW1lbnRlZCBpbiBhbG1vc3QgZXZlcnkgYXV0aCBwcm92aWRlclxuICpcbiAqIFJlZmFjdG9yIFBsYW46XG4gKiAtIEhhdmUgYSBzaW5nbGUgcGxhY2UgdG8gYnVpbGQgQ0xJRU5UX0VOVklST05NRU5UOiBDb25uZWN0aW9uQ29uZmlnIG9yIHNmLmpzXG4gKiAtIEhhdmUgYSBzaW5nbGUgcGxhY2UgdG8gYnVpbGQgY29tbW9uIHBhcmFtcyBieSBlaXRoZXI6XG4gKiAgLSBSZW1vdmluZyB0aGlzIG1ldGhvZFxuICogIC0gTW92aW5nIGxvZ2ljIGZyb20gU3RhdGVDb25uZWN0aW5nLmNvbnRpbnVlIHRvIHRoaXMgbWV0aG9kLlxuICogICAgT3B0aW9ucyBzaG91bGQgYmUgc2ltcGxpZmllZCB0byBhY2NlcHQgb25seSBDb25uZWN0aW9uQ29uZmlnXG4gKiAtIFJlbmFtZSBhdXRoLnVwZGF0ZUJvZHkgdG8gYXV0aC5idWlsZERhdGEgKGFzIGl0IG9ubHkgYnVpbGRzIGtleXMgdW5kZXIgYm9keS5kYXRhKVxuICogLSBFbnN1cmUgQVVUSEVOVElDQVRPUiBpcyBzZXQgaW4gZXZlcnkgYXV0aCBwcm92aWRlclxuICogLSBDbGVhbnVwIFN0YXRlQ29ubmVjdGluZy5jb250aW51ZSBzbyBpdCdzIG1vcmUgY2xlYXIgaG93IGZpbmFsIGJvZHkgaXMgYnVpbHRcbiAqXG4gKiBSZXR1cm5zIHRoZSBKU09OIGJvZHkgdG8gYmUgc2VudCB3aGVuIGNvbm5lY3RpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGF1dGhlbnRpY2F0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50XG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGllbnRUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xpZW50VmVyc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGNsaWVudEVudlxuICpcbiAqIEByZXR1cm5zIHtKU09OfVxuICovXG5leHBvcnRzLmZvcm1BdXRoSlNPTiA9IGZ1bmN0aW9uIGZvcm1BdXRoSlNPTihhdXRoZW50aWNhdG9yLCBhY2NvdW50LCB1c2VybmFtZSwgY2xpZW50VHlwZSwgY2xpZW50VmVyc2lvbiwgY2xpZW50RW52KSB7XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgQUNDT1VOVF9OQU1FOiBhY2NvdW50LFxuICAgICAgICAgICAgQ0xJRU5UX0FQUF9JRDogY2xpZW50VHlwZSxcbiAgICAgICAgICAgIENMSUVOVF9BUFBfVkVSU0lPTjogY2xpZW50VmVyc2lvbixcbiAgICAgICAgICAgIENMSUVOVF9FTlZJUk9OTUVOVDoge1xuICAgICAgICAgICAgICAgIE9TOiBjbGllbnRFbnYuT1MsXG4gICAgICAgICAgICAgICAgT1NfVkVSU0lPTjogY2xpZW50RW52Lk9TX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgT0NTUF9NT0RFOiBjbGllbnRFbnYuT0NTUF9NT0RFLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmICghdGhpcy5pc09rdGFBdXRoKGF1dGhlbnRpY2F0b3IpKSB7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnQVVUSEVOVElDQVRPUiddID0gYXV0aGVudGljYXRvcjtcbiAgICAgICAgYm9keVsnZGF0YSddWydMT0dJTl9OQU1FJ10gPSB1c2VybmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhdXRoZW50aWNhdG9yIHRvIHVzZSBiYXNlIG9uIHRoZSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSBodHRwQ2xpZW50XG4gKlxuICogQHJldHVybnMge09iamVjdH0gdGhlIGF1dGhlbnRpY2F0b3IuXG4gKi9cbmV4cG9ydHMuZ2V0QXV0aGVudGljYXRvciA9IGZ1bmN0aW9uIGdldEF1dGhlbnRpY2F0b3IoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCkge1xuICAgIGNvbnN0IGF1dGhUeXBlID0gY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCk7XG4gICAgY29uc3Qgb3BlbkV4dGVybmFsQnJvd3NlckNhbGxiYWNrID0gY29ubmVjdGlvbkNvbmZpZy5vcGVuRXh0ZXJuYWxCcm93c2VyQ2FsbGJhY2s7IC8vIEltcG9ydGFudCBmb3IgU1NPIGluIHRoZSBTbm93Zmxha2UgVlMgQ29kZSBleHRlbnNpb25cbiAgICBsZXQgYXV0aDtcbiAgICBpZiAoYXV0aFR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuREVGQVVMVF9BVVRIRU5USUNBVE9SIHx8XG4gICAgICAgIGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLlVTRVJfUFdEX01GQV9BVVRIRU5USUNBVE9SKSB7XG4gICAgICAgIGF1dGggPSBuZXcgQXV0aERlZmF1bHQoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLkVYVEVSTkFMX0JST1dTRVJfQVVUSEVOVElDQVRPUikge1xuICAgICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKSAmJiAhIWNvbm5lY3Rpb25Db25maWcuaWRUb2tlbikge1xuICAgICAgICAgICAgYXV0aCA9IG5ldyBBdXRoSURUb2tlbihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBvcGVuRXh0ZXJuYWxCcm93c2VyQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXV0aCA9IG5ldyBBdXRoV2ViKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQsIG9wZW5FeHRlcm5hbEJyb3dzZXJDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aFR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuS0VZX1BBSVJfQVVUSEVOVElDQVRPUikge1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhLZXlwYWlyKGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoVHlwZSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5PQVVUSF9BVVRIRU5USUNBVE9SKSB7XG4gICAgICAgIGF1dGggPSBuZXcgQXV0aE9hdXRoKGNvbm5lY3Rpb25Db25maWcuZ2V0VG9rZW4oKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLlBST0dSQU1NQVRJQ19BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgYXV0aCA9IG5ldyBBdXRoT2F1dGhQQVQoY29ubmVjdGlvbkNvbmZpZy5nZXRUb2tlbigpLCBjb25uZWN0aW9uQ29uZmlnLnBhc3N3b3JkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aFR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSE9SSVpBVElPTl9DT0RFKSB7XG4gICAgICAgIGF1dGggPSBuZXcgQXV0aE9hdXRoQXV0aG9yaXphdGlvbkNvZGUoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0NMSUVOVF9DUkVERU5USUFMUykge1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhPYXV0aENsaWVudENyZWRlbnRpYWxzKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzT2t0YUF1dGgoYXV0aFR5cGUpKSB7XG4gICAgICAgIGF1dGggPSBuZXcgQXV0aE9rdGEoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLldPUktMT0FEX0lERU5USVRZKSB7XG4gICAgICAgIGF1dGggPSBuZXcgQXV0aFdvcmtsb2FkSWRlbnRpdHkoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBBdXRoZW50aWNhdG9yIHNwZWNpZmllZCBkb2VzIG5vdCBleGlzdFxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBObyBhdXRoZW50aWNhdG9yIGZvdW5kIGZvciAnJHthdXRoVHlwZX0nLiBVc2luZyBkZWZhdWx0IGF1dGhlbnRpY2F0b3IgYXMgYSBmYWxsYmFja2ApO1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhEZWZhdWx0KGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGJvb2xlYW4gZGVzY3JpYmluZyBpZiB0aGUgcHJvdmlkZWQgYXV0aGVudGljYXRvciBpcyBva3RhIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNPa3RhQXV0aCA9IGZ1bmN0aW9uIGlzT2t0YUF1dGgoYXV0aGVudGljYXRvcikge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yLnRvVXBwZXJDYXNlKCkuc3RhcnRzV2l0aCgnSFRUUFM6Ly8nKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoZW50aWNhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js":
/*!************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js ***!
  \************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AuthenticationTypes;\n(function (AuthenticationTypes) {\n    AuthenticationTypes[\"DEFAULT_AUTHENTICATOR\"] = \"SNOWFLAKE\";\n    AuthenticationTypes[\"EXTERNAL_BROWSER_AUTHENTICATOR\"] = \"EXTERNALBROWSER\";\n    AuthenticationTypes[\"KEY_PAIR_AUTHENTICATOR\"] = \"SNOWFLAKE_JWT\";\n    AuthenticationTypes[\"OAUTH_AUTHENTICATOR\"] = \"OAUTH\";\n    AuthenticationTypes[\"USER_PWD_MFA_AUTHENTICATOR\"] = \"USERNAME_PASSWORD_MFA\";\n    AuthenticationTypes[\"ID_TOKEN_AUTHENTICATOR\"] = \"ID_TOKEN\";\n    AuthenticationTypes[\"PROGRAMMATIC_ACCESS_TOKEN\"] = \"PROGRAMMATIC_ACCESS_TOKEN\";\n    AuthenticationTypes[\"OAUTH_AUTHORIZATION_CODE\"] = \"OAUTH_AUTHORIZATION_CODE\";\n    AuthenticationTypes[\"OAUTH_CLIENT_CREDENTIALS\"] = \"OAUTH_CLIENT_CREDENTIALS\";\n    AuthenticationTypes[\"WORKLOAD_IDENTITY\"] = \"WORKLOAD_IDENTITY\";\n})(AuthenticationTypes || (AuthenticationTypes = {}));\nmodule.exports = AuthenticationTypes;\nexports[\"default\"] = AuthenticationTypes;\n//# sourceMappingURL=authentication_types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzLmpzP2U4YTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQXV0aGVudGljYXRpb25UeXBlcztcbihmdW5jdGlvbiAoQXV0aGVudGljYXRpb25UeXBlcykge1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJERUZBVUxUX0FVVEhFTlRJQ0FUT1JcIl0gPSBcIlNOT1dGTEFLRVwiO1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJFWFRFUk5BTF9CUk9XU0VSX0FVVEhFTlRJQ0FUT1JcIl0gPSBcIkVYVEVSTkFMQlJPV1NFUlwiO1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJLRVlfUEFJUl9BVVRIRU5USUNBVE9SXCJdID0gXCJTTk9XRkxBS0VfSldUXCI7XG4gICAgQXV0aGVudGljYXRpb25UeXBlc1tcIk9BVVRIX0FVVEhFTlRJQ0FUT1JcIl0gPSBcIk9BVVRIXCI7XG4gICAgQXV0aGVudGljYXRpb25UeXBlc1tcIlVTRVJfUFdEX01GQV9BVVRIRU5USUNBVE9SXCJdID0gXCJVU0VSTkFNRV9QQVNTV09SRF9NRkFcIjtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiSURfVE9LRU5fQVVUSEVOVElDQVRPUlwiXSA9IFwiSURfVE9LRU5cIjtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiUFJPR1JBTU1BVElDX0FDQ0VTU19UT0tFTlwiXSA9IFwiUFJPR1JBTU1BVElDX0FDQ0VTU19UT0tFTlwiO1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJPQVVUSF9BVVRIT1JJWkFUSU9OX0NPREVcIl0gPSBcIk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERVwiO1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJPQVVUSF9DTElFTlRfQ1JFREVOVElBTFNcIl0gPSBcIk9BVVRIX0NMSUVOVF9DUkVERU5USUFMU1wiO1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJXT1JLTE9BRF9JREVOVElUWVwiXSA9IFwiV09SS0xPQURfSURFTlRJVFlcIjtcbn0pKEF1dGhlbnRpY2F0aW9uVHlwZXMgfHwgKEF1dGhlbnRpY2F0aW9uVHlwZXMgPSB7fSkpO1xubW9kdWxlLmV4cG9ydHMgPSBBdXRoZW50aWNhdGlvblR5cGVzO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aGVudGljYXRpb25UeXBlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhlbnRpY2F0aW9uX3R5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst net = __webpack_require__(/*! net */ \"net\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst { exists, format, escapeHTML, buildCredentialCacheKey } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst responseHeadersAsString = 'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nConnection: close\\r\\n\\r\\n';\nconst successResponse = 'Your identity was confirmed and propagated to Snowflake Node.js driver. You can close this window now and go back where you started from.';\nconst SNOWFLAKE_DOMAIN_REGEX = /(^|\\.)snowflakecomputing\\.(com|cn)/;\n/**\n * Create server to retrieve SAML token.\n *\n * @param {Function} resolve\n * @param {Function} reject\n *\n * @returns {Server}\n */\nfunction createServer(resolve, reject) {\n    const server = net.createServer(function (socket) {\n        socket.on('data', function (chunk) {\n            // Receive the data and split by line\n            const data = chunk.toString().split('\\r\\n');\n            if (data[0].includes('?error=')) {\n                // Error d credentials\n                const error = prepareError(data[0]);\n                socket.write(`${responseHeadersAsString} ${escapeHTML(error)}`, 'utf8');\n                socket.destroy();\n                server.close();\n                Logger.getInstance().trace(`Error during authorization: ${error}`);\n                reject(error);\n            }\n            else {\n                // User successfully entered credentials\n                socket.write(`${responseHeadersAsString} ${escapeHTML(successResponse)}`, 'utf8');\n                socket.destroy();\n                server.close();\n                Logger.getInstance().trace('User successfully entered authorization code');\n                resolve(data[0]);\n            }\n        });\n        socket.on('error', (socketErr) => {\n            if (socketErr['code'] === 'ECONNRESET') {\n                socket.end();\n            }\n            else {\n                throw socketErr;\n            }\n        });\n    });\n    return server;\n}\nconst withBrowserActionTimeout = (millis, promise) => {\n    let timeoutId;\n    const timeout = new Promise((resolve, reject) => (timeoutId = setTimeout(() => reject(`Browser action timed out after ${millis} ms.`), millis)));\n    return Promise.race([promise, timeout]).finally(() => {\n        clearTimeout(timeoutId);\n    });\n};\nfunction prepareError(rejected) {\n    const errorResponse = querystring.parse(rejected.substring(rejected.indexOf('?') + 1));\n    const error = errorResponse['error'];\n    const errorDescription = errorResponse['error_description'].replace(new RegExp('\\\\sHTTP/.*'), '');\n    return format('Error while getting oauth authorization code. ErrorCode %s. Message: %s', error, errorDescription);\n}\nfunction getTokenUrl(options) {\n    const tokenUrl = options.getOauthTokenRequestUrl();\n    Logger.getInstance().debug(`Url used for receiving token: ${tokenUrl}`);\n    return new URL(tokenUrl);\n}\nasync function prepareScope(options) {\n    const scope = exists(options.getOauthScope())\n        ? options.getOauthScope()\n        : `session:role:${options.getRole()}`;\n    Logger.getInstance().debug(`Prepared scope used for receiving authorization code: ${scope}`);\n    return scope;\n}\nconst readCache = async (key) => {\n    if (exists(GlobalConfig.getCredentialManager())) {\n        return GlobalConfig.getCredentialManager().read(key);\n    }\n    else {\n        return null;\n    }\n};\nconst writeToCache = async (key, value) => {\n    if (exists(GlobalConfig.getCredentialManager())) {\n        return GlobalConfig.getCredentialManager().write(key, value);\n    }\n};\nconst removeFromCache = async (key) => {\n    if (exists(GlobalConfig.getCredentialManager())) {\n        return GlobalConfig.getCredentialManager().remove(key);\n    }\n};\nconst buildOauthAccessTokenCacheKey = (host, username, authenticationType) => buildCredentialCacheKey(host, username, authenticationType + '_access_token');\nconst buildOauthRefreshTokenCacheKey = (host, username, authenticationType) => buildCredentialCacheKey(host, username, authenticationType + '_refresh_token');\nconst isSnowflakeHost = (url) => {\n    return SNOWFLAKE_DOMAIN_REGEX.test(url);\n};\nexports.createServer = createServer;\nexports.withBrowserActionTimeout = withBrowserActionTimeout;\nexports.getTokenUrl = getTokenUrl;\nexports.prepareScope = prepareScope;\nexports.readCache = readCache;\nexports.writeToCache = writeToCache;\nexports.removeFromCache = removeFromCache;\nexports.buildOauthAccessTokenCacheKey = buildOauthAccessTokenCacheKey;\nexports.buildOauthRefreshTokenCacheKey = buildOauthRefreshTokenCacheKey;\nexports.isSnowflakeHost = isSnowflakeHost;\n//# sourceMappingURL=authentication_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLFFBQVEsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQyxvRUFBUztBQUNqRixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QixFQUFFLGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0EsMEVBQTBFLE1BQU07QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCLEVBQUUsNEJBQTRCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILFFBQVE7QUFDcEk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1Qyx3RkFBd0YsTUFBTTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQ0FBZ0M7QUFDaEMsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QixxQ0FBcUM7QUFDckMsc0NBQXNDO0FBQ3RDLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdXRpbC5qcz8xMzIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCB7IGV4aXN0cywgZm9ybWF0LCBlc2NhcGVIVE1MLCBidWlsZENyZWRlbnRpYWxDYWNoZUtleSB9ID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCByZXNwb25zZUhlYWRlcnNBc1N0cmluZyA9ICdIVFRQLzEuMSAyMDAgT0tcXHJcXG5Db250ZW50LVR5cGU6IHRleHQvcGxhaW5cXHJcXG5Db25uZWN0aW9uOiBjbG9zZVxcclxcblxcclxcbic7XG5jb25zdCBzdWNjZXNzUmVzcG9uc2UgPSAnWW91ciBpZGVudGl0eSB3YXMgY29uZmlybWVkIGFuZCBwcm9wYWdhdGVkIHRvIFNub3dmbGFrZSBOb2RlLmpzIGRyaXZlci4gWW91IGNhbiBjbG9zZSB0aGlzIHdpbmRvdyBub3cgYW5kIGdvIGJhY2sgd2hlcmUgeW91IHN0YXJ0ZWQgZnJvbS4nO1xuY29uc3QgU05PV0ZMQUtFX0RPTUFJTl9SRUdFWCA9IC8oXnxcXC4pc25vd2ZsYWtlY29tcHV0aW5nXFwuKGNvbXxjbikvO1xuLyoqXG4gKiBDcmVhdGUgc2VydmVyIHRvIHJldHJpZXZlIFNBTUwgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0XG4gKlxuICogQHJldHVybnMge1NlcnZlcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2VydmVyKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IHNlcnZlciA9IG5ldC5jcmVhdGVTZXJ2ZXIoZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIC8vIFJlY2VpdmUgdGhlIGRhdGEgYW5kIHNwbGl0IGJ5IGxpbmVcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaHVuay50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdLmluY2x1ZGVzKCc/ZXJyb3I9JykpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBkIGNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBwcmVwYXJlRXJyb3IoZGF0YVswXSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LndyaXRlKGAke3Jlc3BvbnNlSGVhZGVyc0FzU3RyaW5nfSAke2VzY2FwZUhUTUwoZXJyb3IpfWAsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgRXJyb3IgZHVyaW5nIGF1dGhvcml6YXRpb246ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgc3VjY2Vzc2Z1bGx5IGVudGVyZWQgY3JlZGVudGlhbHNcbiAgICAgICAgICAgICAgICBzb2NrZXQud3JpdGUoYCR7cmVzcG9uc2VIZWFkZXJzQXNTdHJpbmd9ICR7ZXNjYXBlSFRNTChzdWNjZXNzUmVzcG9uc2UpfWAsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnVXNlciBzdWNjZXNzZnVsbHkgZW50ZXJlZCBhdXRob3JpemF0aW9uIGNvZGUnKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGFbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChzb2NrZXRFcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChzb2NrZXRFcnJbJ2NvZGUnXSA9PT0gJ0VDT05OUkVTRVQnKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc29ja2V0RXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VydmVyO1xufVxuY29uc3Qgd2l0aEJyb3dzZXJBY3Rpb25UaW1lb3V0ID0gKG1pbGxpcywgcHJvbWlzZSkgPT4ge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgdGltZW91dCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+ICh0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChgQnJvd3NlciBhY3Rpb24gdGltZWQgb3V0IGFmdGVyICR7bWlsbGlzfSBtcy5gKSwgbWlsbGlzKSkpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRdKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gcHJlcGFyZUVycm9yKHJlamVjdGVkKSB7XG4gICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHJlamVjdGVkLnN1YnN0cmluZyhyZWplY3RlZC5pbmRleE9mKCc/JykgKyAxKSk7XG4gICAgY29uc3QgZXJyb3IgPSBlcnJvclJlc3BvbnNlWydlcnJvciddO1xuICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBlcnJvclJlc3BvbnNlWydlcnJvcl9kZXNjcmlwdGlvbiddLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXHNIVFRQLy4qJyksICcnKTtcbiAgICByZXR1cm4gZm9ybWF0KCdFcnJvciB3aGlsZSBnZXR0aW5nIG9hdXRoIGF1dGhvcml6YXRpb24gY29kZS4gRXJyb3JDb2RlICVzLiBNZXNzYWdlOiAlcycsIGVycm9yLCBlcnJvckRlc2NyaXB0aW9uKTtcbn1cbmZ1bmN0aW9uIGdldFRva2VuVXJsKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0b2tlblVybCA9IG9wdGlvbnMuZ2V0T2F1dGhUb2tlblJlcXVlc3RVcmwoKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVXJsIHVzZWQgZm9yIHJlY2VpdmluZyB0b2tlbjogJHt0b2tlblVybH1gKTtcbiAgICByZXR1cm4gbmV3IFVSTCh0b2tlblVybCk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlU2NvcGUob3B0aW9ucykge1xuICAgIGNvbnN0IHNjb3BlID0gZXhpc3RzKG9wdGlvbnMuZ2V0T2F1dGhTY29wZSgpKVxuICAgICAgICA/IG9wdGlvbnMuZ2V0T2F1dGhTY29wZSgpXG4gICAgICAgIDogYHNlc3Npb246cm9sZToke29wdGlvbnMuZ2V0Um9sZSgpfWA7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFByZXBhcmVkIHNjb3BlIHVzZWQgZm9yIHJlY2VpdmluZyBhdXRob3JpemF0aW9uIGNvZGU6ICR7c2NvcGV9YCk7XG4gICAgcmV0dXJuIHNjb3BlO1xufVxuY29uc3QgcmVhZENhY2hlID0gYXN5bmMgKGtleSkgPT4ge1xuICAgIGlmIChleGlzdHMoR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkpKSB7XG4gICAgICAgIHJldHVybiBHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKS5yZWFkKGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuY29uc3Qgd3JpdGVUb0NhY2hlID0gYXN5bmMgKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAoZXhpc3RzKEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpKSkge1xuICAgICAgICByZXR1cm4gR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkud3JpdGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcbmNvbnN0IHJlbW92ZUZyb21DYWNoZSA9IGFzeW5jIChrZXkpID0+IHtcbiAgICBpZiAoZXhpc3RzKEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpKSkge1xuICAgICAgICByZXR1cm4gR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkucmVtb3ZlKGtleSk7XG4gICAgfVxufTtcbmNvbnN0IGJ1aWxkT2F1dGhBY2Nlc3NUb2tlbkNhY2hlS2V5ID0gKGhvc3QsIHVzZXJuYW1lLCBhdXRoZW50aWNhdGlvblR5cGUpID0+IGJ1aWxkQ3JlZGVudGlhbENhY2hlS2V5KGhvc3QsIHVzZXJuYW1lLCBhdXRoZW50aWNhdGlvblR5cGUgKyAnX2FjY2Vzc190b2tlbicpO1xuY29uc3QgYnVpbGRPYXV0aFJlZnJlc2hUb2tlbkNhY2hlS2V5ID0gKGhvc3QsIHVzZXJuYW1lLCBhdXRoZW50aWNhdGlvblR5cGUpID0+IGJ1aWxkQ3JlZGVudGlhbENhY2hlS2V5KGhvc3QsIHVzZXJuYW1lLCBhdXRoZW50aWNhdGlvblR5cGUgKyAnX3JlZnJlc2hfdG9rZW4nKTtcbmNvbnN0IGlzU25vd2ZsYWtlSG9zdCA9ICh1cmwpID0+IHtcbiAgICByZXR1cm4gU05PV0ZMQUtFX0RPTUFJTl9SRUdFWC50ZXN0KHVybCk7XG59O1xuZXhwb3J0cy5jcmVhdGVTZXJ2ZXIgPSBjcmVhdGVTZXJ2ZXI7XG5leHBvcnRzLndpdGhCcm93c2VyQWN0aW9uVGltZW91dCA9IHdpdGhCcm93c2VyQWN0aW9uVGltZW91dDtcbmV4cG9ydHMuZ2V0VG9rZW5VcmwgPSBnZXRUb2tlblVybDtcbmV4cG9ydHMucHJlcGFyZVNjb3BlID0gcHJlcGFyZVNjb3BlO1xuZXhwb3J0cy5yZWFkQ2FjaGUgPSByZWFkQ2FjaGU7XG5leHBvcnRzLndyaXRlVG9DYWNoZSA9IHdyaXRlVG9DYWNoZTtcbmV4cG9ydHMucmVtb3ZlRnJvbUNhY2hlID0gcmVtb3ZlRnJvbUNhY2hlO1xuZXhwb3J0cy5idWlsZE9hdXRoQWNjZXNzVG9rZW5DYWNoZUtleSA9IGJ1aWxkT2F1dGhBY2Nlc3NUb2tlbkNhY2hlS2V5O1xuZXhwb3J0cy5idWlsZE9hdXRoUmVmcmVzaFRva2VuQ2FjaGVLZXkgPSBidWlsZE9hdXRoUmVmcmVzaFRva2VuQ2FjaGVLZXk7XG5leHBvcnRzLmlzU25vd2ZsYWtlSG9zdCA9IGlzU25vd2ZsYWtlSG9zdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhlbnRpY2F0aW9uX3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Logger = __webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst fs = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { getSecureHandle, closeHandle } = __webpack_require__(/*! ../../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst defaultJsonTokenCachePaths = {\n    win32: ['AppData', 'Local', 'Snowflake', 'Caches'],\n    linux: ['.cache', 'snowflake'],\n    darwin: ['Library', 'Caches', 'Snowflake'],\n};\nfunction JsonCredentialManager(credentialCacheDir, timeoutMs = 60000) {\n    const tokenMapKey = 'tokens';\n    const retryInterval = 100;\n    this.hashKey = function (key) {\n        return crypto.createHash('sha256').update(key).digest('hex');\n    };\n    this.getTokenDirCandidates = function () {\n        const candidates = [];\n        candidates.push({ folder: credentialCacheDir, subfolders: [] });\n        candidates.push({ folder: process.env.SF_TEMPORARY_CREDENTIAL_CACHE_DIR, subfolders: [] });\n        switch (process.platform) {\n            case 'win32':\n                candidates.push({ folder: os.homedir(), subfolders: defaultJsonTokenCachePaths['win32'] });\n                break;\n            case 'linux':\n                candidates.push({ folder: process.env.XDG_CACHE_HOME, subfolders: ['snowflake'] });\n                candidates.push({\n                    folder: process.env.HOME,\n                    subfolders: defaultJsonTokenCachePaths['linux'],\n                });\n                break;\n            case 'darwin':\n                candidates.push({\n                    folder: process.env.HOME,\n                    subfolders: defaultJsonTokenCachePaths['darwin'],\n                });\n        }\n        return candidates;\n    };\n    this.createCacheDir = async function (cacheDir) {\n        const options = { recursive: true };\n        if (process.platform !== 'win32') {\n            options.mode = 0o755;\n        }\n        await fs.mkdir(cacheDir, options);\n        if (process.platform !== 'win32') {\n            await fs.chmod(cacheDir, 0o700);\n        }\n    };\n    this.tryTokenDir = async function (dir, subDirs) {\n        if (!Util.exists(dir)) {\n            return false;\n        }\n        const cacheDir = path.join(dir, ...subDirs);\n        try {\n            const stat = await fs.stat(dir);\n            if (!stat.isDirectory()) {\n                Logger.getInstance().info(`Path ${dir} is not a directory`);\n                return false;\n            }\n            const cacheStat = await fs.stat(cacheDir).catch(async (err) => {\n                if (err.code !== 'ENOENT') {\n                    throw err;\n                }\n                await this.createCacheDir(cacheDir);\n                return await fs.stat(cacheDir);\n            });\n            if (!cacheStat.isDirectory()) {\n                return false;\n            }\n            if (process.platform === 'win32') {\n                return true;\n            }\n            if (cacheStat.uid !== os.userInfo().uid) {\n                Logger.getInstance().warn(`Token cache directory ${cacheDir} has insecure owner.`);\n            }\n            else if ((cacheStat.mode & 0o777) !== 0o700) {\n                Logger.getInstance().warn(`Token cache directory ${cacheDir} has insecure permissions.`);\n            }\n            return true;\n        }\n        catch (err) {\n            Logger.getInstance().warn(`The location ${cacheDir} is invalid. Please check this location is accessible or existing`);\n            return false;\n        }\n    };\n    this.getTokenDir = async function () {\n        const candidates = this.getTokenDirCandidates();\n        for (const candidate of candidates) {\n            const { folder: dir, subfolders: subDirs } = candidate;\n            if (await this.tryTokenDir(dir, subDirs)) {\n                return path.join(dir, ...subDirs);\n            }\n        }\n        return null;\n    };\n    this.getTokenFilePath = async function () {\n        const tokenDir = await this.getTokenDir();\n        if (!Util.exists(tokenDir)) {\n            throw new Error(`Temporary credential cache directory is invalid, and the driver is unable to use the default location. \n      Please set 'credentialCacheDir' connection configuration option to enable the default credential manager.`);\n        }\n        return path.join(tokenDir, 'credential_cache_v1.json');\n    };\n    this.readJsonCredentialFile = async function (fileHandle) {\n        if (!Util.exists(fileHandle)) {\n            return null;\n        }\n        try {\n            const cred = await fileHandle.readFile('utf8');\n            return JSON.parse(cred);\n        }\n        catch (err) {\n            Logger.getInstance().warn('Failed to read token data from the file. Err: %s', err.message);\n            return null;\n        }\n    };\n    this.removeStale = async function (file) {\n        const stat = await fs.stat(file).catch(() => {\n            return undefined;\n        });\n        if (!Util.exists(stat)) {\n            return;\n        }\n        if (new Date().getTime() - stat.birthtimeMs > timeoutMs) {\n            try {\n                await fs.rmdir(file);\n            }\n            catch (err) {\n                Logger.getInstance().warn('Failed to remove stale file. Error: %s', err.message);\n            }\n        }\n    };\n    this.lockFile = async function (filename) {\n        const lckFile = filename + '.lck';\n        await this.removeStale(lckFile);\n        let attempts = 1;\n        let locked = false;\n        const options = {};\n        if (process.platform !== 'win32') {\n            options.mode = 0o600;\n        }\n        while (attempts <= 10) {\n            Logger.getInstance().debug('Attempting to get a lock on file %s, attempt: %d', filename, attempts);\n            attempts++;\n            await fs.mkdir(lckFile, options).then(() => {\n                locked = true;\n            }, () => { });\n            if (locked) {\n                break;\n            }\n            await new Promise((resolve) => setTimeout(resolve, retryInterval));\n        }\n        if (!locked) {\n            Logger.getInstance().warn('Could not acquire lock on cache file %s', filename);\n        }\n        return locked;\n    };\n    this.unlockFile = async function (filename) {\n        const lckFile = filename + '.lck';\n        await fs.rmdir(lckFile);\n    };\n    this.withFileLocked = async function (fun) {\n        const filename = await this.getTokenFilePath();\n        if (await this.lockFile(filename)) {\n            const res = await fun(filename);\n            await this.unlockFile(filename);\n            return res;\n        }\n        return null;\n    };\n    this.write = async function (key, token) {\n        if (!validateTokenCacheOption(key)) {\n            return null;\n        }\n        const keyHash = this.hashKey(key);\n        await this.withFileLocked(async (filename) => {\n            const fileHandle = await getSecureHandle(filename, fs.constants.O_RDWR | fs.constants.O_CREAT, fs);\n            const jsonCredential = (await this.readJsonCredentialFile(fileHandle)) || {};\n            if (!Util.exists(jsonCredential[tokenMapKey])) {\n                jsonCredential[tokenMapKey] = {};\n            }\n            jsonCredential[tokenMapKey][keyHash] = token;\n            try {\n                await fileHandle.truncate();\n                await fileHandle.write(JSON.stringify(jsonCredential), 0);\n                await closeHandle(fileHandle);\n            }\n            catch (err) {\n                Logger.getInstance().warn(`Failed to write token data in ${filename}. Please check the permission or the file format of the token. ${err.message}`);\n            }\n        });\n    };\n    this.read = async function (key) {\n        if (!validateTokenCacheOption(key)) {\n            return null;\n        }\n        const keyHash = this.hashKey(key);\n        return await this.withFileLocked(async (filename) => {\n            const fileHandle = await getSecureHandle(filename, fs.constants.O_RDWR, fs);\n            const jsonCredential = await this.readJsonCredentialFile(fileHandle);\n            await closeHandle(fileHandle);\n            if (!!jsonCredential && jsonCredential[tokenMapKey] && jsonCredential[tokenMapKey][keyHash]) {\n                return jsonCredential[tokenMapKey][keyHash];\n            }\n            else {\n                return null;\n            }\n        });\n    };\n    this.remove = async function (key) {\n        if (!validateTokenCacheOption(key)) {\n            return null;\n        }\n        const keyHash = this.hashKey(key);\n        await this.withFileLocked(async (filename) => {\n            const fileHandle = await getSecureHandle(filename, fs.constants.O_RDWR, fs);\n            const jsonCredential = await this.readJsonCredentialFile(fileHandle);\n            if (jsonCredential && jsonCredential[tokenMapKey] && jsonCredential[tokenMapKey][keyHash]) {\n                try {\n                    jsonCredential[tokenMapKey][keyHash] = null;\n                    await fileHandle.truncate();\n                    await fileHandle.write(JSON.stringify(jsonCredential), 0);\n                    await closeHandle(fileHandle);\n                }\n                catch (err) {\n                    Logger.getInstance().warn(`Failed to remove token data from the file in ${filename}. Please check the permission or the file format of the token. ${err.message}`);\n                }\n            }\n        });\n    };\n    function validateTokenCacheOption(key) {\n        return Util.checkParametersDefined(key);\n    }\n}\nmodule.exports.defaultJsonTokenCachePaths = defaultJsonTokenCachePaths;\nmodule.exports.JsonCredentialManager = JsonCredentialManager;\n//# sourceMappingURL=json_credential_manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9zZWN1cmVfc3RvcmFnZS9qc29uX2NyZWRlbnRpYWxfbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsMkVBQWM7QUFDckMsV0FBVyxtQkFBTyxDQUFDLDBDQUFrQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyxpRkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDO0FBQ3RFLDBCQUEwQix1RUFBdUU7QUFDakc7QUFDQTtBQUNBLGtDQUFrQyx1RUFBdUU7QUFDekc7QUFDQTtBQUNBLGtDQUFrQywrREFBK0Q7QUFDakc7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFVBQVU7QUFDN0U7QUFDQTtBQUNBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFNBQVMsaUVBQWlFLFlBQVk7QUFDaks7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixTQUFTLGlFQUFpRSxZQUFZO0FBQ3BMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQ0FBb0M7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL3NlY3VyZV9zdG9yYWdlL2pzb25fY3JlZGVudGlhbF9tYW5hZ2VyLmpzPzY3YjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vbG9nZ2VyJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ25vZGU6ZnMvcHJvbWlzZXMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgZ2V0U2VjdXJlSGFuZGxlLCBjbG9zZUhhbmRsZSB9ID0gcmVxdWlyZSgnLi4vLi4vZmlsZV91dGlsJyk7XG5jb25zdCBkZWZhdWx0SnNvblRva2VuQ2FjaGVQYXRocyA9IHtcbiAgICB3aW4zMjogWydBcHBEYXRhJywgJ0xvY2FsJywgJ1Nub3dmbGFrZScsICdDYWNoZXMnXSxcbiAgICBsaW51eDogWycuY2FjaGUnLCAnc25vd2ZsYWtlJ10sXG4gICAgZGFyd2luOiBbJ0xpYnJhcnknLCAnQ2FjaGVzJywgJ1Nub3dmbGFrZSddLFxufTtcbmZ1bmN0aW9uIEpzb25DcmVkZW50aWFsTWFuYWdlcihjcmVkZW50aWFsQ2FjaGVEaXIsIHRpbWVvdXRNcyA9IDYwMDAwKSB7XG4gICAgY29uc3QgdG9rZW5NYXBLZXkgPSAndG9rZW5zJztcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwO1xuICAgIHRoaXMuaGFzaEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoa2V5KS5kaWdlc3QoJ2hleCcpO1xuICAgIH07XG4gICAgdGhpcy5nZXRUb2tlbkRpckNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHsgZm9sZGVyOiBjcmVkZW50aWFsQ2FjaGVEaXIsIHN1YmZvbGRlcnM6IFtdIH0pO1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goeyBmb2xkZXI6IHByb2Nlc3MuZW52LlNGX1RFTVBPUkFSWV9DUkVERU5USUFMX0NBQ0hFX0RJUiwgc3ViZm9sZGVyczogW10gfSk7XG4gICAgICAgIHN3aXRjaCAocHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgICAgICAgICAgY2FzZSAnd2luMzInOlxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7IGZvbGRlcjogb3MuaG9tZWRpcigpLCBzdWJmb2xkZXJzOiBkZWZhdWx0SnNvblRva2VuQ2FjaGVQYXRoc1snd2luMzInXSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xpbnV4JzpcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goeyBmb2xkZXI6IHByb2Nlc3MuZW52LlhER19DQUNIRV9IT01FLCBzdWJmb2xkZXJzOiBbJ3Nub3dmbGFrZSddIH0pO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRlcjogcHJvY2Vzcy5lbnYuSE9NRSxcbiAgICAgICAgICAgICAgICAgICAgc3ViZm9sZGVyczogZGVmYXVsdEpzb25Ub2tlbkNhY2hlUGF0aHNbJ2xpbnV4J10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXJ3aW4nOlxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRlcjogcHJvY2Vzcy5lbnYuSE9NRSxcbiAgICAgICAgICAgICAgICAgICAgc3ViZm9sZGVyczogZGVmYXVsdEpzb25Ub2tlbkNhY2hlUGF0aHNbJ2RhcndpbiddLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICAgIH07XG4gICAgdGhpcy5jcmVhdGVDYWNoZURpciA9IGFzeW5jIGZ1bmN0aW9uIChjYWNoZURpcikge1xuICAgICAgICBjb25zdCBvcHRpb25zID0geyByZWN1cnNpdmU6IHRydWUgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IDBvNzU1O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZzLm1rZGlyKGNhY2hlRGlyLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIGF3YWl0IGZzLmNobW9kKGNhY2hlRGlyLCAwbzcwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudHJ5VG9rZW5EaXIgPSBhc3luYyBmdW5jdGlvbiAoZGlyLCBzdWJEaXJzKSB7XG4gICAgICAgIGlmICghVXRpbC5leGlzdHMoZGlyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlRGlyID0gcGF0aC5qb2luKGRpciwgLi4uc3ViRGlycyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgZnMuc3RhdChkaXIpO1xuICAgICAgICAgICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKGBQYXRoICR7ZGlyfSBpcyBub3QgYSBkaXJlY3RvcnlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWNoZVN0YXQgPSBhd2FpdCBmcy5zdGF0KGNhY2hlRGlyKS5jYXRjaChhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQ2FjaGVEaXIoY2FjaGVEaXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmcy5zdGF0KGNhY2hlRGlyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjYWNoZVN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FjaGVTdGF0LnVpZCAhPT0gb3MudXNlckluZm8oKS51aWQpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBUb2tlbiBjYWNoZSBkaXJlY3RvcnkgJHtjYWNoZURpcn0gaGFzIGluc2VjdXJlIG93bmVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGNhY2hlU3RhdC5tb2RlICYgMG83NzcpICE9PSAwbzcwMCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYFRva2VuIGNhY2hlIGRpcmVjdG9yeSAke2NhY2hlRGlyfSBoYXMgaW5zZWN1cmUgcGVybWlzc2lvbnMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBUaGUgbG9jYXRpb24gJHtjYWNoZURpcn0gaXMgaW52YWxpZC4gUGxlYXNlIGNoZWNrIHRoaXMgbG9jYXRpb24gaXMgYWNjZXNzaWJsZSBvciBleGlzdGluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldFRva2VuRGlyID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gdGhpcy5nZXRUb2tlbkRpckNhbmRpZGF0ZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICAgICAgY29uc3QgeyBmb2xkZXI6IGRpciwgc3ViZm9sZGVyczogc3ViRGlycyB9ID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMudHJ5VG9rZW5EaXIoZGlyLCBzdWJEaXJzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oZGlyLCAuLi5zdWJEaXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VG9rZW5GaWxlUGF0aCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgdG9rZW5EaXIgPSBhd2FpdCB0aGlzLmdldFRva2VuRGlyKCk7XG4gICAgICAgIGlmICghVXRpbC5leGlzdHModG9rZW5EaXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBvcmFyeSBjcmVkZW50aWFsIGNhY2hlIGRpcmVjdG9yeSBpcyBpbnZhbGlkLCBhbmQgdGhlIGRyaXZlciBpcyB1bmFibGUgdG8gdXNlIHRoZSBkZWZhdWx0IGxvY2F0aW9uLiBcbiAgICAgIFBsZWFzZSBzZXQgJ2NyZWRlbnRpYWxDYWNoZURpcicgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIG9wdGlvbiB0byBlbmFibGUgdGhlIGRlZmF1bHQgY3JlZGVudGlhbCBtYW5hZ2VyLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4odG9rZW5EaXIsICdjcmVkZW50aWFsX2NhY2hlX3YxLmpzb24nKTtcbiAgICB9O1xuICAgIHRoaXMucmVhZEpzb25DcmVkZW50aWFsRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlSGFuZGxlKSB7XG4gICAgICAgIGlmICghVXRpbC5leGlzdHMoZmlsZUhhbmRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkID0gYXdhaXQgZmlsZUhhbmRsZS5yZWFkRmlsZSgndXRmOCcpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY3JlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRmFpbGVkIHRvIHJlYWQgdG9rZW4gZGF0YSBmcm9tIHRoZSBmaWxlLiBFcnI6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlU3RhbGUgPSBhc3luYyBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgZnMuc3RhdChmaWxlKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFVdGlsLmV4aXN0cyhzdGF0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXQuYmlydGh0aW1lTXMgPiB0aW1lb3V0TXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZnMucm1kaXIoZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRmFpbGVkIHRvIHJlbW92ZSBzdGFsZSBmaWxlLiBFcnJvcjogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9ja0ZpbGUgPSBhc3luYyBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgbGNrRmlsZSA9IGZpbGVuYW1lICsgJy5sY2snO1xuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZVN0YWxlKGxja0ZpbGUpO1xuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAxO1xuICAgICAgICBsZXQgbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IDBvNjAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhdHRlbXB0cyA8PSAxMCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0F0dGVtcHRpbmcgdG8gZ2V0IGEgbG9jayBvbiBmaWxlICVzLCBhdHRlbXB0OiAlZCcsIGZpbGVuYW1lLCBhdHRlbXB0cyk7XG4gICAgICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICAgICAgYXdhaXQgZnMubWtkaXIobGNrRmlsZSwgb3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sICgpID0+IHsgfSk7XG4gICAgICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeUludGVydmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2NrZWQpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0NvdWxkIG5vdCBhY3F1aXJlIGxvY2sgb24gY2FjaGUgZmlsZSAlcycsIGZpbGVuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9ja2VkO1xuICAgIH07XG4gICAgdGhpcy51bmxvY2tGaWxlID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IGxja0ZpbGUgPSBmaWxlbmFtZSArICcubGNrJztcbiAgICAgICAgYXdhaXQgZnMucm1kaXIobGNrRmlsZSk7XG4gICAgfTtcbiAgICB0aGlzLndpdGhGaWxlTG9ja2VkID0gYXN5bmMgZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGF3YWl0IHRoaXMuZ2V0VG9rZW5GaWxlUGF0aCgpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5sb2NrRmlsZShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZ1bihmaWxlbmFtZSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVubG9ja0ZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMud3JpdGUgPSBhc3luYyBmdW5jdGlvbiAoa2V5LCB0b2tlbikge1xuICAgICAgICBpZiAoIXZhbGlkYXRlVG9rZW5DYWNoZU9wdGlvbihrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlIYXNoID0gdGhpcy5oYXNoS2V5KGtleSk7XG4gICAgICAgIGF3YWl0IHRoaXMud2l0aEZpbGVMb2NrZWQoYXN5bmMgKGZpbGVuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlSGFuZGxlID0gYXdhaXQgZ2V0U2VjdXJlSGFuZGxlKGZpbGVuYW1lLCBmcy5jb25zdGFudHMuT19SRFdSIHwgZnMuY29uc3RhbnRzLk9fQ1JFQVQsIGZzKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25DcmVkZW50aWFsID0gKGF3YWl0IHRoaXMucmVhZEpzb25DcmVkZW50aWFsRmlsZShmaWxlSGFuZGxlKSkgfHwge307XG4gICAgICAgICAgICBpZiAoIVV0aWwuZXhpc3RzKGpzb25DcmVkZW50aWFsW3Rva2VuTWFwS2V5XSkpIHtcbiAgICAgICAgICAgICAgICBqc29uQ3JlZGVudGlhbFt0b2tlbk1hcEtleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzb25DcmVkZW50aWFsW3Rva2VuTWFwS2V5XVtrZXlIYXNoXSA9IHRva2VuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmaWxlSGFuZGxlLnRydW5jYXRlKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS53cml0ZShKU09OLnN0cmluZ2lmeShqc29uQ3JlZGVudGlhbCksIDApO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNsb3NlSGFuZGxlKGZpbGVIYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYEZhaWxlZCB0byB3cml0ZSB0b2tlbiBkYXRhIGluICR7ZmlsZW5hbWV9LiBQbGVhc2UgY2hlY2sgdGhlIHBlcm1pc3Npb24gb3IgdGhlIGZpbGUgZm9ybWF0IG9mIHRoZSB0b2tlbi4gJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlYWQgPSBhc3luYyBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdmFsaWRhdGVUb2tlbkNhY2hlT3B0aW9uKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleUhhc2ggPSB0aGlzLmhhc2hLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud2l0aEZpbGVMb2NrZWQoYXN5bmMgKGZpbGVuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlSGFuZGxlID0gYXdhaXQgZ2V0U2VjdXJlSGFuZGxlKGZpbGVuYW1lLCBmcy5jb25zdGFudHMuT19SRFdSLCBmcyk7XG4gICAgICAgICAgICBjb25zdCBqc29uQ3JlZGVudGlhbCA9IGF3YWl0IHRoaXMucmVhZEpzb25DcmVkZW50aWFsRmlsZShmaWxlSGFuZGxlKTtcbiAgICAgICAgICAgIGF3YWl0IGNsb3NlSGFuZGxlKGZpbGVIYW5kbGUpO1xuICAgICAgICAgICAgaWYgKCEhanNvbkNyZWRlbnRpYWwgJiYganNvbkNyZWRlbnRpYWxbdG9rZW5NYXBLZXldICYmIGpzb25DcmVkZW50aWFsW3Rva2VuTWFwS2V5XVtrZXlIYXNoXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQ3JlZGVudGlhbFt0b2tlbk1hcEtleV1ba2V5SGFzaF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZSA9IGFzeW5jIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZVRva2VuQ2FjaGVPcHRpb24oa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5SGFzaCA9IHRoaXMuaGFzaEtleShrZXkpO1xuICAgICAgICBhd2FpdCB0aGlzLndpdGhGaWxlTG9ja2VkKGFzeW5jIChmaWxlbmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZUhhbmRsZSA9IGF3YWl0IGdldFNlY3VyZUhhbmRsZShmaWxlbmFtZSwgZnMuY29uc3RhbnRzLk9fUkRXUiwgZnMpO1xuICAgICAgICAgICAgY29uc3QganNvbkNyZWRlbnRpYWwgPSBhd2FpdCB0aGlzLnJlYWRKc29uQ3JlZGVudGlhbEZpbGUoZmlsZUhhbmRsZSk7XG4gICAgICAgICAgICBpZiAoanNvbkNyZWRlbnRpYWwgJiYganNvbkNyZWRlbnRpYWxbdG9rZW5NYXBLZXldICYmIGpzb25DcmVkZW50aWFsW3Rva2VuTWFwS2V5XVtrZXlIYXNoXSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb25DcmVkZW50aWFsW3Rva2VuTWFwS2V5XVtrZXlIYXNoXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGZpbGVIYW5kbGUudHJ1bmNhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS53cml0ZShKU09OLnN0cmluZ2lmeShqc29uQ3JlZGVudGlhbCksIDApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbG9zZUhhbmRsZShmaWxlSGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBGYWlsZWQgdG8gcmVtb3ZlIHRva2VuIGRhdGEgZnJvbSB0aGUgZmlsZSBpbiAke2ZpbGVuYW1lfS4gUGxlYXNlIGNoZWNrIHRoZSBwZXJtaXNzaW9uIG9yIHRoZSBmaWxlIGZvcm1hdCBvZiB0aGUgdG9rZW4uICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlVG9rZW5DYWNoZU9wdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIFV0aWwuY2hlY2tQYXJhbWV0ZXJzRGVmaW5lZChrZXkpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRKc29uVG9rZW5DYWNoZVBhdGhzID0gZGVmYXVsdEpzb25Ub2tlbkNhY2hlUGF0aHM7XG5tb2R1bGUuZXhwb3J0cy5Kc29uQ3JlZGVudGlhbE1hbmFnZXIgPSBKc29uQ3JlZGVudGlhbE1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uX2NyZWRlbnRpYWxfbWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst { rest } = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\n/**\n * Creates a new instance of an SsoUrlProvider.\n *\n * @param {Object} httpClient\n * @constructor\n */\nfunction SsoUrlProvider(httpClient) {\n    Errors.assertInternal(Util.isObject(httpClient));\n    const port = rest.HTTPS_PORT;\n    const protocol = rest.HTTPS_PROTOCOL;\n    /**\n     * Get SSO URL through POST request.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {Number} callbackPort\n     * @param {String} user\n     * @param {String} host\n     *\n     * @returns {Promise<String>} the SSO URL.\n     */\n    this.getSSOURL = async function (authenticator, serviceName, account, callbackPort, user, host) {\n        // Create URL to send POST request to\n        const url = protocol + '://' + host + '/session/authenticator-request';\n        let header;\n        if (serviceName) {\n            header = {\n                HTTP_HEADER_SERVICE_NAME: serviceName,\n            };\n        }\n        const body = {\n            data: {\n                ACCOUNT_NAME: account,\n                LOGIN_NAME: user,\n                PORT: port,\n                PROTOCOL: protocol,\n                AUTHENTICATOR: authenticator,\n                BROWSER_MODE_REDIRECT_PORT: callbackPort.toString(),\n            },\n        };\n        const requestOptions = {\n            method: 'post',\n            url: url,\n            headers: header,\n            data: body,\n            responseType: 'json',\n        };\n        // Post request to get the SSO URL\n        return httpClient\n            .requestAsync(requestOptions)\n            .then((response) => {\n            const data = response['data']['data'];\n            return data;\n        })\n            .catch((requestErr) => {\n            throw requestErr;\n        });\n    };\n}\nmodule.exports = SsoUrlProvider;\n//# sourceMappingURL=sso_url_provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9zc29fdXJsX3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNGQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL3Nzb191cmxfcHJvdmlkZXIuanM/NWQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IHsgcmVzdCB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIFNzb1VybFByb3ZpZGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3NvVXJsUHJvdmlkZXIoaHR0cENsaWVudCkge1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGh0dHBDbGllbnQpKTtcbiAgICBjb25zdCBwb3J0ID0gcmVzdC5IVFRQU19QT1JUO1xuICAgIGNvbnN0IHByb3RvY29sID0gcmVzdC5IVFRQU19QUk9UT0NPTDtcbiAgICAvKipcbiAgICAgKiBHZXQgU1NPIFVSTCB0aHJvdWdoIFBPU1QgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlcnZpY2VOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2FsbGJhY2tQb3J0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaG9zdFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3RyaW5nPn0gdGhlIFNTTyBVUkwuXG4gICAgICovXG4gICAgdGhpcy5nZXRTU09VUkwgPSBhc3luYyBmdW5jdGlvbiAoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIGNhbGxiYWNrUG9ydCwgdXNlciwgaG9zdCkge1xuICAgICAgICAvLyBDcmVhdGUgVVJMIHRvIHNlbmQgUE9TVCByZXF1ZXN0IHRvXG4gICAgICAgIGNvbnN0IHVybCA9IHByb3RvY29sICsgJzovLycgKyBob3N0ICsgJy9zZXNzaW9uL2F1dGhlbnRpY2F0b3ItcmVxdWVzdCc7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGlmIChzZXJ2aWNlTmFtZSkge1xuICAgICAgICAgICAgaGVhZGVyID0ge1xuICAgICAgICAgICAgICAgIEhUVFBfSEVBREVSX1NFUlZJQ0VfTkFNRTogc2VydmljZU5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgQUNDT1VOVF9OQU1FOiBhY2NvdW50LFxuICAgICAgICAgICAgICAgIExPR0lOX05BTUU6IHVzZXIsXG4gICAgICAgICAgICAgICAgUE9SVDogcG9ydCxcbiAgICAgICAgICAgICAgICBQUk9UT0NPTDogcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgQVVUSEVOVElDQVRPUjogYXV0aGVudGljYXRvcixcbiAgICAgICAgICAgICAgICBCUk9XU0VSX01PREVfUkVESVJFQ1RfUE9SVDogY2FsbGJhY2tQb3J0LnRvU3RyaW5nKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXIsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBvc3QgcmVxdWVzdCB0byBnZXQgdGhlIFNTTyBVUkxcbiAgICAgICAgcmV0dXJuIGh0dHBDbGllbnRcbiAgICAgICAgICAgIC5yZXF1ZXN0QXN5bmMocmVxdWVzdE9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddWydkYXRhJ107XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgocmVxdWVzdEVycikgPT4ge1xuICAgICAgICAgICAgdGhyb3cgcmVxdWVzdEVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gU3NvVXJsUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zc29fdXJsX3Byb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { isString, exists, getDriverDirectory, isWindows } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { IsFileExisted } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst clientConfigFileName = 'sf_client_config.json';\nconst Levels = Object.freeze({\n    Off: 'OFF',\n    Error: 'ERROR',\n    Warn: 'WARN',\n    Info: 'INFO',\n    Debug: 'DEBUG',\n    Trace: 'TRACE',\n});\nconst defaultDirectories = getDefaultDirectories();\nfunction getDefaultDirectories() {\n    const directories = [];\n    const driverDirectory = getDriverDirectory();\n    Logger.getInstance().debug(`Detected driver directory: ${driverDirectory}`);\n    if (driverDirectory) {\n        directories.push({\n            dir: driverDirectory,\n            dirDescription: 'driver',\n        });\n    }\n    else {\n        Logger.getInstance().warn('Driver directory is not defined');\n    }\n    const homedir = os.homedir();\n    Logger.getInstance().debug(`Detected home directory: ${homedir}`);\n    if (exists(homedir)) {\n        directories.push({\n            dir: homedir,\n            dirDescription: 'home',\n        });\n    }\n    else {\n        Logger.getInstance().warn('Home directory of the user is not defined');\n    }\n    Logger.getInstance().debug(`Detected default directories: ${driverDirectory}`);\n    return directories;\n}\nconst knownCommonEntries = ['log_level', 'log_path'];\nconst allLevels = Object.values(Levels);\nclass ClientConfig {\n    constructor(filePath, loggingConfig) {\n        this.configPath = filePath;\n        this.loggingConfig = loggingConfig;\n    }\n}\nclass ClientLoggingConfig {\n    constructor(logLevel, logPath) {\n        this.logLevel = logLevel;\n        this.logPath = logPath;\n    }\n}\nclass ConfigurationError extends Error {\n    name = 'ConfigurationError';\n    constructor(message, cause) {\n        super(message);\n        this.cause = cause;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    toString() {\n        return this.message + ': ' + this.cause.toString();\n    }\n}\n/**\n * @param value {String} Log level.\n * @return {String} normalized log level value.\n * @throws {Error} Error for unknown value.\n */\nfunction levelFromString(value) {\n    const level = value.toUpperCase();\n    if (!allLevels.includes(level)) {\n        Logger.getInstance().error(`Tried to create unsupported log level from string: ${value}`);\n        throw new Error('Unknown log level: ' + value);\n    }\n    return level;\n}\n/**\n * @param fsPromisesModule {module} filestream module\n * @param processModule {processModule} process module\n */\nfunction ConfigurationUtil(fsPromisesModule, processModule) {\n    const fsPromises = typeof fsPromisesModule !== 'undefined' ? fsPromisesModule : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n    const process = typeof processModule !== 'undefined' ? processModule : __webpack_require__(/*! process */ \"process\");\n    let configFileContents = null;\n    let fd = null;\n    /**\n     * @param configFilePath {String} A path to a client config file.\n     * @return {Promise<ClientConfig>} Client configuration.\n     */\n    this.getClientConfig = async function (configFilePath, mock = false, delay = 0) {\n        Logger.getInstance().debug('Retrieving client config');\n        const path = await findConfig(configFilePath);\n        if (!exists(path) || path === '') {\n            Logger.getInstance().info('No config file path found. Client config will not be used.');\n            return null;\n        }\n        const isFileExist = mock ? mock : IsFileExisted(path);\n        if (!isFileExist) {\n            Logger.getInstance().info(`No config file not found on ${path}. Client config will not be used.`);\n            return null;\n        }\n        try {\n            fd = await openFileSafely(path);\n            if (!isWindows()) {\n                const openStats = await fd.stat();\n                const mode = openStats.mode & 0o777;\n                if (!isFilePermissionValid(mode)) {\n                    Logger.getInstance().warn(`Config file path permissions are invalid. File: ${path} can be modified by group or others. Client config will not be used.`);\n                    throw new ConfigurationError(`Configuration file: ${path} can be modified by group or others`, 'IncorrectPerms');\n                }\n                if (!validateOwnership(openStats)) {\n                    Logger.getInstance().warn('This config file is not owned by the current user. Client config will not be used.');\n                    throw new ConfigurationError('Configuration file: not owned by the current user', 'Invalid Ownership');\n                }\n                Logger.getInstance().debug(`Config file path permissions are valid. Path: ${path}`);\n                if (mock) {\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                }\n                configFileContents = await readFileConfig(fd).catch((err) => {\n                    Logger.getInstance().debug(`Reading configuration from the file failed. Path: ${path}`);\n                    throw new ConfigurationError('Finding client configuration failed', err);\n                });\n                //Compare the modification time from the 'open' call with the modification time after reading to validate whether the file has been modified.\n                const currentStat = await fsPromises.stat(path);\n                if (!isFileModified(openStats, currentStat)) {\n                    Logger.getInstance().error('The file was modified after the driver opened the config file and can no longer be used.');\n                    throw new ConfigurationError('The config file has been modified', 'InvalidConfigFile');\n                }\n            }\n            else {\n                configFileContents = await readFileConfig(fd).catch((err) => {\n                    Logger.getInstance().debug(`Reading configuration from the file failed. Path: ${path}`);\n                    throw new ConfigurationError('Finding client configuration failed', err);\n                });\n            }\n            Logger.getInstance().info('Using client configuration from path: %s', path);\n        }\n        catch (err) {\n            if (err.syscall === 'open') {\n                Logger.getInstance().debug(`Fail to open the configuration file from. Path: ${path}. If the file is a symlink, please change the path to the real path`);\n                throw new ConfigurationError('Fail to open the configuration file', err);\n            }\n            else {\n                throw err;\n            }\n        }\n        finally {\n            await fd?.close();\n        }\n        return configFileContents == null ? null : parseConfigFile(path, configFileContents);\n    };\n    function isFilePermissionValid(mode) {\n        return (mode & (1 << 4)) === 0 && (mode & (1 << 1)) === 0;\n    }\n    function validateOwnership(stats) {\n        const currentUser = os.userInfo();\n        return stats.uid === currentUser.uid && stats.gid === currentUser.gid;\n    }\n    function isFileModified(openStat, newStat) {\n        const keys = ['uid', 'mtimeMs', 'mode', 'birthtimeMs', 'ctimeMs'];\n        return keys.every((key) => openStat[key] === newStat[key]);\n    }\n    async function openFileSafely(filePath) {\n        return fsPromises.open(filePath, fs.constants.O_NOFOLLOW | fs.constants.O_RDONLY);\n    }\n    async function readFileConfig(fd) {\n        return fd.readFile({ encoding: 'utf8' });\n    }\n    function parseConfigFile(path, configurationJson) {\n        Logger.getInstance().debug('Parsing config file: %s', path);\n        try {\n            const parsedConfiguration = JSON.parse(configurationJson);\n            Logger.getInstance().trace('Config file contains correct JSON structure. Validating the input.');\n            checkUnknownEntries(parsedConfiguration);\n            validate(parsedConfiguration);\n            Logger.getInstance().debug('Config file contains valid configuration input.');\n            const clientConfig = new ClientConfig(path, new ClientLoggingConfig(getLogLevel(parsedConfiguration), getLogPath(parsedConfiguration)));\n            Logger.getInstance().info('Client Configuration created with Log Level: %s and Log Path: %s', clientConfig.loggingConfig.logLevel, clientConfig.loggingConfig.logPath);\n            return clientConfig;\n        }\n        catch (err) {\n            Logger.getInstance().error('Parsing client configuration failed. Used config file from path: %s', path);\n            throw new ConfigurationError('Parsing client configuration failed', err);\n        }\n    }\n    function checkUnknownEntries(config) {\n        for (const key in config.common) {\n            if (!knownCommonEntries.includes(key.toLowerCase())) {\n                Logger.getInstance().warn('Unknown configuration entry: %s with value: %s', key, config.common[key]);\n            }\n        }\n    }\n    function validate(configuration) {\n        validateLogLevel(configuration);\n        validateLogPath(configuration);\n    }\n    function validateLogLevel(configuration) {\n        const logLevel = getLogLevel(configuration);\n        if (logLevel == null) {\n            Logger.getInstance().debug('Log level is not specified.');\n            return;\n        }\n        if (!isString(logLevel)) {\n            const errorMessage = 'Log level is not a string.';\n            Logger.getInstance().error(errorMessage);\n            throw new Error(errorMessage);\n        }\n        levelFromString(logLevel);\n    }\n    function validateLogPath(configuration) {\n        const logPath = getLogPath(configuration);\n        if (logPath == null) {\n            Logger.getInstance().debug('Log path is not specified');\n            return;\n        }\n        if (!isString(logPath)) {\n            const errorMessage = 'Log path is not a string.';\n            Logger.getInstance().error(errorMessage);\n            throw new Error(errorMessage);\n        }\n    }\n    function getLogLevel(configuration) {\n        return configuration.common.log_level;\n    }\n    function getLogPath(configuration) {\n        return configuration.common.log_path;\n    }\n    async function findConfig(filePathFromConnectionString) {\n        Logger.getInstance().trace(`findConfig() called with param: ${filePathFromConnectionString}`);\n        if (exists(filePathFromConnectionString)) {\n            Logger.getInstance().info('Found client configuration path in a connection string. Path: %s', filePathFromConnectionString);\n            return filePathFromConnectionString;\n        }\n        const filePathFromEnvVariable = await getFilePathFromEnvironmentVariable();\n        if (exists(filePathFromEnvVariable)) {\n            Logger.getInstance().info('Found client configuration path in an environment variable. Path: %s', filePathFromEnvVariable);\n            return filePathFromEnvVariable;\n        }\n        const fileFromDefDirs = await searchForConfigInDefaultDirectories();\n        if (exists(fileFromDefDirs)) {\n            Logger.getInstance().info('Found client configuration path in %s directory. Path: %s', fileFromDefDirs.dirDescription, fileFromDefDirs.configPath);\n            return fileFromDefDirs.configPath;\n        }\n        Logger.getInstance().info('No client config detected.');\n        return null;\n    }\n    async function verifyNotEmpty(filePath) {\n        return filePath ? filePath : null;\n    }\n    function getFilePathFromEnvironmentVariable() {\n        return verifyNotEmpty(process.env.SF_CLIENT_CONFIG_FILE);\n    }\n    async function searchForConfigInDefaultDirectories() {\n        Logger.getInstance().debug(`Searching for config in default directories: ${JSON.stringify(defaultDirectories)}`);\n        for (const directory of defaultDirectories) {\n            const configPath = await searchForConfigInDictionary(directory.dir, directory.dirDescription);\n            if (exists(configPath)) {\n                Logger.getInstance().debug(`Config found in the default directory: ${directory.dir}. Path: ${configPath}`);\n                return { configPath: configPath, dirDescription: directory.dirDescription };\n            }\n        }\n        Logger.getInstance().debug('Unable to find config in any default directory.');\n        return null;\n    }\n    async function searchForConfigInDictionary(directory, directoryDescription) {\n        try {\n            const filePath = path.join(directory, clientConfigFileName);\n            return await onlyIfFileExists(filePath);\n        }\n        catch (e) {\n            Logger.getInstance().error('Error while searching for the client config in %s directory: %s', directoryDescription, e);\n            return null;\n        }\n    }\n    async function onlyIfFileExists(filePath) {\n        return await fsPromises\n            .access(filePath, fs.constants.F_OK)\n            .then(() => filePath)\n            .catch(() => null);\n    }\n}\nexports.Levels = Levels;\nexports.levelFromString = levelFromString;\nexports.ConfigurationUtil = ConfigurationUtil;\n//# sourceMappingURL=client_configuration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25maWd1cmF0aW9uL2NsaWVudF9jb25maWd1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsa0RBQWtELEVBQUUsbUJBQU8sQ0FBQyxvRUFBUztBQUM3RSxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDhFQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLE1BQU07QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQSxvRkFBb0YsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6RywyRUFBMkUsbUJBQU8sQ0FBQyx3QkFBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxNQUFNO0FBQ3ZHLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsS0FBSztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxLQUFLO0FBQ3pHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxLQUFLO0FBQ3pHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsS0FBSztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw2QkFBNkI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG1DQUFtQztBQUN0SDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsY0FBYyxVQUFVLFdBQVc7QUFDeEgseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbmZpZ3VyYXRpb24vY2xpZW50X2NvbmZpZ3VyYXRpb24uanM/MTEyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IGlzU3RyaW5nLCBleGlzdHMsIGdldERyaXZlckRpcmVjdG9yeSwgaXNXaW5kb3dzIH0gPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IHsgSXNGaWxlRXhpc3RlZCB9ID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJyk7XG5jb25zdCBjbGllbnRDb25maWdGaWxlTmFtZSA9ICdzZl9jbGllbnRfY29uZmlnLmpzb24nO1xuY29uc3QgTGV2ZWxzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgT2ZmOiAnT0ZGJyxcbiAgICBFcnJvcjogJ0VSUk9SJyxcbiAgICBXYXJuOiAnV0FSTicsXG4gICAgSW5mbzogJ0lORk8nLFxuICAgIERlYnVnOiAnREVCVUcnLFxuICAgIFRyYWNlOiAnVFJBQ0UnLFxufSk7XG5jb25zdCBkZWZhdWx0RGlyZWN0b3JpZXMgPSBnZXREZWZhdWx0RGlyZWN0b3JpZXMoKTtcbmZ1bmN0aW9uIGdldERlZmF1bHREaXJlY3RvcmllcygpIHtcbiAgICBjb25zdCBkaXJlY3RvcmllcyA9IFtdO1xuICAgIGNvbnN0IGRyaXZlckRpcmVjdG9yeSA9IGdldERyaXZlckRpcmVjdG9yeSgpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBEZXRlY3RlZCBkcml2ZXIgZGlyZWN0b3J5OiAke2RyaXZlckRpcmVjdG9yeX1gKTtcbiAgICBpZiAoZHJpdmVyRGlyZWN0b3J5KSB7XG4gICAgICAgIGRpcmVjdG9yaWVzLnB1c2goe1xuICAgICAgICAgICAgZGlyOiBkcml2ZXJEaXJlY3RvcnksXG4gICAgICAgICAgICBkaXJEZXNjcmlwdGlvbjogJ2RyaXZlcicsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRHJpdmVyIGRpcmVjdG9yeSBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgICBjb25zdCBob21lZGlyID0gb3MuaG9tZWRpcigpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBEZXRlY3RlZCBob21lIGRpcmVjdG9yeTogJHtob21lZGlyfWApO1xuICAgIGlmIChleGlzdHMoaG9tZWRpcikpIHtcbiAgICAgICAgZGlyZWN0b3JpZXMucHVzaCh7XG4gICAgICAgICAgICBkaXI6IGhvbWVkaXIsXG4gICAgICAgICAgICBkaXJEZXNjcmlwdGlvbjogJ2hvbWUnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0hvbWUgZGlyZWN0b3J5IG9mIHRoZSB1c2VyIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBEZXRlY3RlZCBkZWZhdWx0IGRpcmVjdG9yaWVzOiAke2RyaXZlckRpcmVjdG9yeX1gKTtcbiAgICByZXR1cm4gZGlyZWN0b3JpZXM7XG59XG5jb25zdCBrbm93bkNvbW1vbkVudHJpZXMgPSBbJ2xvZ19sZXZlbCcsICdsb2dfcGF0aCddO1xuY29uc3QgYWxsTGV2ZWxzID0gT2JqZWN0LnZhbHVlcyhMZXZlbHMpO1xuY2xhc3MgQ2xpZW50Q29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihmaWxlUGF0aCwgbG9nZ2luZ0NvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZ1BhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgdGhpcy5sb2dnaW5nQ29uZmlnID0gbG9nZ2luZ0NvbmZpZztcbiAgICB9XG59XG5jbGFzcyBDbGllbnRMb2dnaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2dMZXZlbCwgbG9nUGF0aCkge1xuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgIHRoaXMubG9nUGF0aCA9IGxvZ1BhdGg7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIG5hbWUgPSAnQ29uZmlndXJhdGlvbkVycm9yJztcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyAnOiAnICsgdGhpcy5jYXVzZS50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHZhbHVlIHtTdHJpbmd9IExvZyBsZXZlbC5cbiAqIEByZXR1cm4ge1N0cmluZ30gbm9ybWFsaXplZCBsb2cgbGV2ZWwgdmFsdWUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gRXJyb3IgZm9yIHVua25vd24gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxldmVsRnJvbVN0cmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IGxldmVsID0gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoIWFsbExldmVscy5pbmNsdWRlcyhsZXZlbCkpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoYFRyaWVkIHRvIGNyZWF0ZSB1bnN1cHBvcnRlZCBsb2cgbGV2ZWwgZnJvbSBzdHJpbmc6ICR7dmFsdWV9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsb2cgbGV2ZWw6ICcgKyB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbDtcbn1cbi8qKlxuICogQHBhcmFtIGZzUHJvbWlzZXNNb2R1bGUge21vZHVsZX0gZmlsZXN0cmVhbSBtb2R1bGVcbiAqIEBwYXJhbSBwcm9jZXNzTW9kdWxlIHtwcm9jZXNzTW9kdWxlfSBwcm9jZXNzIG1vZHVsZVxuICovXG5mdW5jdGlvbiBDb25maWd1cmF0aW9uVXRpbChmc1Byb21pc2VzTW9kdWxlLCBwcm9jZXNzTW9kdWxlKSB7XG4gICAgY29uc3QgZnNQcm9taXNlcyA9IHR5cGVvZiBmc1Byb21pc2VzTW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZzUHJvbWlzZXNNb2R1bGUgOiByZXF1aXJlKCdmcy9wcm9taXNlcycpO1xuICAgIGNvbnN0IHByb2Nlc3MgPSB0eXBlb2YgcHJvY2Vzc01vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzTW9kdWxlIDogcmVxdWlyZSgncHJvY2VzcycpO1xuICAgIGxldCBjb25maWdGaWxlQ29udGVudHMgPSBudWxsO1xuICAgIGxldCBmZCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbmZpZ0ZpbGVQYXRoIHtTdHJpbmd9IEEgcGF0aCB0byBhIGNsaWVudCBjb25maWcgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENsaWVudENvbmZpZz59IENsaWVudCBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2xpZW50Q29uZmlnID0gYXN5bmMgZnVuY3Rpb24gKGNvbmZpZ0ZpbGVQYXRoLCBtb2NrID0gZmFsc2UsIGRlbGF5ID0gMCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmV0cmlldmluZyBjbGllbnQgY29uZmlnJyk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBhd2FpdCBmaW5kQ29uZmlnKGNvbmZpZ0ZpbGVQYXRoKTtcbiAgICAgICAgaWYgKCFleGlzdHMocGF0aCkgfHwgcGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ05vIGNvbmZpZyBmaWxlIHBhdGggZm91bmQuIENsaWVudCBjb25maWcgd2lsbCBub3QgYmUgdXNlZC4nKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRmlsZUV4aXN0ID0gbW9jayA/IG1vY2sgOiBJc0ZpbGVFeGlzdGVkKHBhdGgpO1xuICAgICAgICBpZiAoIWlzRmlsZUV4aXN0KSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKGBObyBjb25maWcgZmlsZSBub3QgZm91bmQgb24gJHtwYXRofS4gQ2xpZW50IGNvbmZpZyB3aWxsIG5vdCBiZSB1c2VkLmApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZkID0gYXdhaXQgb3BlbkZpbGVTYWZlbHkocGF0aCk7XG4gICAgICAgICAgICBpZiAoIWlzV2luZG93cygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlblN0YXRzID0gYXdhaXQgZmQuc3RhdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBvcGVuU3RhdHMubW9kZSAmIDBvNzc3O1xuICAgICAgICAgICAgICAgIGlmICghaXNGaWxlUGVybWlzc2lvblZhbGlkKG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYENvbmZpZyBmaWxlIHBhdGggcGVybWlzc2lvbnMgYXJlIGludmFsaWQuIEZpbGU6ICR7cGF0aH0gY2FuIGJlIG1vZGlmaWVkIGJ5IGdyb3VwIG9yIG90aGVycy4gQ2xpZW50IGNvbmZpZyB3aWxsIG5vdCBiZSB1c2VkLmApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29uZmlndXJhdGlvbkVycm9yKGBDb25maWd1cmF0aW9uIGZpbGU6ICR7cGF0aH0gY2FuIGJlIG1vZGlmaWVkIGJ5IGdyb3VwIG9yIG90aGVyc2AsICdJbmNvcnJlY3RQZXJtcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlT3duZXJzaGlwKG9wZW5TdGF0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignVGhpcyBjb25maWcgZmlsZSBpcyBub3Qgb3duZWQgYnkgdGhlIGN1cnJlbnQgdXNlci4gQ2xpZW50IGNvbmZpZyB3aWxsIG5vdCBiZSB1c2VkLicpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29uZmlndXJhdGlvbkVycm9yKCdDb25maWd1cmF0aW9uIGZpbGU6IG5vdCBvd25lZCBieSB0aGUgY3VycmVudCB1c2VyJywgJ0ludmFsaWQgT3duZXJzaGlwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBDb25maWcgZmlsZSBwYXRoIHBlcm1pc3Npb25zIGFyZSB2YWxpZC4gUGF0aDogJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIGlmIChtb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGVDb250ZW50cyA9IGF3YWl0IHJlYWRGaWxlQ29uZmlnKGZkKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBSZWFkaW5nIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZmlsZSBmYWlsZWQuIFBhdGg6ICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcignRmluZGluZyBjbGllbnQgY29uZmlndXJhdGlvbiBmYWlsZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vQ29tcGFyZSB0aGUgbW9kaWZpY2F0aW9uIHRpbWUgZnJvbSB0aGUgJ29wZW4nIGNhbGwgd2l0aCB0aGUgbW9kaWZpY2F0aW9uIHRpbWUgYWZ0ZXIgcmVhZGluZyB0byB2YWxpZGF0ZSB3aGV0aGVyIHRoZSBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ID0gYXdhaXQgZnNQcm9taXNlcy5zdGF0KHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNGaWxlTW9kaWZpZWQob3BlblN0YXRzLCBjdXJyZW50U3RhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1RoZSBmaWxlIHdhcyBtb2RpZmllZCBhZnRlciB0aGUgZHJpdmVyIG9wZW5lZCB0aGUgY29uZmlnIGZpbGUgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcignVGhlIGNvbmZpZyBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkJywgJ0ludmFsaWRDb25maWdGaWxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnRmlsZUNvbnRlbnRzID0gYXdhaXQgcmVhZEZpbGVDb25maWcoZmQpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFJlYWRpbmcgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBmaWxlIGZhaWxlZC4gUGF0aDogJHtwYXRofWApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29uZmlndXJhdGlvbkVycm9yKCdGaW5kaW5nIGNsaWVudCBjb25maWd1cmF0aW9uIGZhaWxlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdVc2luZyBjbGllbnQgY29uZmlndXJhdGlvbiBmcm9tIHBhdGg6ICVzJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5zeXNjYWxsID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgRmFpbCB0byBvcGVuIHRoZSBjb25maWd1cmF0aW9uIGZpbGUgZnJvbS4gUGF0aDogJHtwYXRofS4gSWYgdGhlIGZpbGUgaXMgYSBzeW1saW5rLCBwbGVhc2UgY2hhbmdlIHRoZSBwYXRoIHRvIHRoZSByZWFsIHBhdGhgKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29uZmlndXJhdGlvbkVycm9yKCdGYWlsIHRvIG9wZW4gdGhlIGNvbmZpZ3VyYXRpb24gZmlsZScsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBmZD8uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnRmlsZUNvbnRlbnRzID09IG51bGwgPyBudWxsIDogcGFyc2VDb25maWdGaWxlKHBhdGgsIGNvbmZpZ0ZpbGVDb250ZW50cyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc0ZpbGVQZXJtaXNzaW9uVmFsaWQobW9kZSkge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiAoMSA8PCA0KSkgPT09IDAgJiYgKG1vZGUgJiAoMSA8PCAxKSkgPT09IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlT3duZXJzaGlwKHN0YXRzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gb3MudXNlckluZm8oKTtcbiAgICAgICAgcmV0dXJuIHN0YXRzLnVpZCA9PT0gY3VycmVudFVzZXIudWlkICYmIHN0YXRzLmdpZCA9PT0gY3VycmVudFVzZXIuZ2lkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0ZpbGVNb2RpZmllZChvcGVuU3RhdCwgbmV3U3RhdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gWyd1aWQnLCAnbXRpbWVNcycsICdtb2RlJywgJ2JpcnRodGltZU1zJywgJ2N0aW1lTXMnXTtcbiAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGtleSkgPT4gb3BlblN0YXRba2V5XSA9PT0gbmV3U3RhdFtrZXldKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gb3BlbkZpbGVTYWZlbHkoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZzUHJvbWlzZXMub3BlbihmaWxlUGF0aCwgZnMuY29uc3RhbnRzLk9fTk9GT0xMT1cgfCBmcy5jb25zdGFudHMuT19SRE9OTFkpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRmlsZUNvbmZpZyhmZCkge1xuICAgICAgICByZXR1cm4gZmQucmVhZEZpbGUoeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmZpZ0ZpbGUocGF0aCwgY29uZmlndXJhdGlvbkpzb24pIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1BhcnNpbmcgY29uZmlnIGZpbGU6ICVzJywgcGF0aCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRDb25maWd1cmF0aW9uID0gSlNPTi5wYXJzZShjb25maWd1cmF0aW9uSnNvbik7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29uZmlnIGZpbGUgY29udGFpbnMgY29ycmVjdCBKU09OIHN0cnVjdHVyZS4gVmFsaWRhdGluZyB0aGUgaW5wdXQuJyk7XG4gICAgICAgICAgICBjaGVja1Vua25vd25FbnRyaWVzKHBhcnNlZENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgdmFsaWRhdGUocGFyc2VkQ29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29uZmlnIGZpbGUgY29udGFpbnMgdmFsaWQgY29uZmlndXJhdGlvbiBpbnB1dC4nKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudENvbmZpZyA9IG5ldyBDbGllbnRDb25maWcocGF0aCwgbmV3IENsaWVudExvZ2dpbmdDb25maWcoZ2V0TG9nTGV2ZWwocGFyc2VkQ29uZmlndXJhdGlvbiksIGdldExvZ1BhdGgocGFyc2VkQ29uZmlndXJhdGlvbikpKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0NsaWVudCBDb25maWd1cmF0aW9uIGNyZWF0ZWQgd2l0aCBMb2cgTGV2ZWw6ICVzIGFuZCBMb2cgUGF0aDogJXMnLCBjbGllbnRDb25maWcubG9nZ2luZ0NvbmZpZy5sb2dMZXZlbCwgY2xpZW50Q29uZmlnLmxvZ2dpbmdDb25maWcubG9nUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdQYXJzaW5nIGNsaWVudCBjb25maWd1cmF0aW9uIGZhaWxlZC4gVXNlZCBjb25maWcgZmlsZSBmcm9tIHBhdGg6ICVzJywgcGF0aCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29uZmlndXJhdGlvbkVycm9yKCdQYXJzaW5nIGNsaWVudCBjb25maWd1cmF0aW9uIGZhaWxlZCcsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tVbmtub3duRW50cmllcyhjb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlnLmNvbW1vbikge1xuICAgICAgICAgICAgaWYgKCFrbm93bkNvbW1vbkVudHJpZXMuaW5jbHVkZXMoa2V5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignVW5rbm93biBjb25maWd1cmF0aW9uIGVudHJ5OiAlcyB3aXRoIHZhbHVlOiAlcycsIGtleSwgY29uZmlnLmNvbW1vbltrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhbGlkYXRlTG9nTGV2ZWwoY29uZmlndXJhdGlvbik7XG4gICAgICAgIHZhbGlkYXRlTG9nUGF0aChjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMb2dMZXZlbChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxvZ0xldmVsID0gZ2V0TG9nTGV2ZWwoY29uZmlndXJhdGlvbik7XG4gICAgICAgIGlmIChsb2dMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnTG9nIGxldmVsIGlzIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cmluZyhsb2dMZXZlbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdMb2cgbGV2ZWwgaXMgbm90IGEgc3RyaW5nLic7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWxGcm9tU3RyaW5nKGxvZ0xldmVsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMb2dQYXRoKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgY29uc3QgbG9nUGF0aCA9IGdldExvZ1BhdGgoY29uZmlndXJhdGlvbik7XG4gICAgICAgIGlmIChsb2dQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdMb2cgcGF0aCBpcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cmluZyhsb2dQYXRoKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0xvZyBwYXRoIGlzIG5vdCBhIHN0cmluZy4nO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExvZ0xldmVsKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb24uY29tbW9uLmxvZ19sZXZlbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TG9nUGF0aChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmNvbW1vbi5sb2dfcGF0aDtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmluZENvbmZpZyhmaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBmaW5kQ29uZmlnKCkgY2FsbGVkIHdpdGggcGFyYW06ICR7ZmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZ31gKTtcbiAgICAgICAgaWYgKGV4aXN0cyhmaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnRm91bmQgY2xpZW50IGNvbmZpZ3VyYXRpb24gcGF0aCBpbiBhIGNvbm5lY3Rpb24gc3RyaW5nLiBQYXRoOiAlcycsIGZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsZVBhdGhGcm9tRW52VmFyaWFibGUgPSBhd2FpdCBnZXRGaWxlUGF0aEZyb21FbnZpcm9ubWVudFZhcmlhYmxlKCk7XG4gICAgICAgIGlmIChleGlzdHMoZmlsZVBhdGhGcm9tRW52VmFyaWFibGUpKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdGb3VuZCBjbGllbnQgY29uZmlndXJhdGlvbiBwYXRoIGluIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLiBQYXRoOiAlcycsIGZpbGVQYXRoRnJvbUVudlZhcmlhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aEZyb21FbnZWYXJpYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlRnJvbURlZkRpcnMgPSBhd2FpdCBzZWFyY2hGb3JDb25maWdJbkRlZmF1bHREaXJlY3RvcmllcygpO1xuICAgICAgICBpZiAoZXhpc3RzKGZpbGVGcm9tRGVmRGlycykpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0ZvdW5kIGNsaWVudCBjb25maWd1cmF0aW9uIHBhdGggaW4gJXMgZGlyZWN0b3J5LiBQYXRoOiAlcycsIGZpbGVGcm9tRGVmRGlycy5kaXJEZXNjcmlwdGlvbiwgZmlsZUZyb21EZWZEaXJzLmNvbmZpZ1BhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVGcm9tRGVmRGlycy5jb25maWdQYXRoO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ05vIGNsaWVudCBjb25maWcgZGV0ZWN0ZWQuJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiB2ZXJpZnlOb3RFbXB0eShmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gZmlsZVBhdGggPyBmaWxlUGF0aCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEZpbGVQYXRoRnJvbUVudmlyb25tZW50VmFyaWFibGUoKSB7XG4gICAgICAgIHJldHVybiB2ZXJpZnlOb3RFbXB0eShwcm9jZXNzLmVudi5TRl9DTElFTlRfQ09ORklHX0ZJTEUpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZWFyY2hGb3JDb25maWdJbkRlZmF1bHREaXJlY3RvcmllcygpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFNlYXJjaGluZyBmb3IgY29uZmlnIGluIGRlZmF1bHQgZGlyZWN0b3JpZXM6ICR7SlNPTi5zdHJpbmdpZnkoZGVmYXVsdERpcmVjdG9yaWVzKX1gKTtcbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgZGVmYXVsdERpcmVjdG9yaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdQYXRoID0gYXdhaXQgc2VhcmNoRm9yQ29uZmlnSW5EaWN0aW9uYXJ5KGRpcmVjdG9yeS5kaXIsIGRpcmVjdG9yeS5kaXJEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoZXhpc3RzKGNvbmZpZ1BhdGgpKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYENvbmZpZyBmb3VuZCBpbiB0aGUgZGVmYXVsdCBkaXJlY3Rvcnk6ICR7ZGlyZWN0b3J5LmRpcn0uIFBhdGg6ICR7Y29uZmlnUGF0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb25maWdQYXRoOiBjb25maWdQYXRoLCBkaXJEZXNjcmlwdGlvbjogZGlyZWN0b3J5LmRpckRlc2NyaXB0aW9uIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1VuYWJsZSB0byBmaW5kIGNvbmZpZyBpbiBhbnkgZGVmYXVsdCBkaXJlY3RvcnkuJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZWFyY2hGb3JDb25maWdJbkRpY3Rpb25hcnkoZGlyZWN0b3J5LCBkaXJlY3RvcnlEZXNjcmlwdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBjbGllbnRDb25maWdGaWxlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgb25seUlmRmlsZUV4aXN0cyhmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdFcnJvciB3aGlsZSBzZWFyY2hpbmcgZm9yIHRoZSBjbGllbnQgY29uZmlnIGluICVzIGRpcmVjdG9yeTogJXMnLCBkaXJlY3RvcnlEZXNjcmlwdGlvbiwgZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBvbmx5SWZGaWxlRXhpc3RzKGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmc1Byb21pc2VzXG4gICAgICAgICAgICAuYWNjZXNzKGZpbGVQYXRoLCBmcy5jb25zdGFudHMuRl9PSylcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGZpbGVQYXRoKVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGV2ZWxzID0gTGV2ZWxzO1xuZXhwb3J0cy5sZXZlbEZyb21TdHJpbmcgPSBsZXZlbEZyb21TdHJpbmc7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb25VdGlsID0gQ29uZmlndXJhdGlvblV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnRfY29uZmlndXJhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst toml = __webpack_require__(/*! toml */ \"(rsc)/./node_modules/toml/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { validateNoExtraPermissionsForOthersSync, generateChecksum } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nfunction defaultIfNotSet(value, defaultValue) {\n    if (value === null || typeof value === 'undefined' || value === '') {\n        return defaultValue;\n    }\n    else {\n        return value;\n    }\n}\nfunction shouldReadTokenFromFile(fixedConfiguration) {\n    return (fixedConfiguration &&\n        fixedConfiguration.authenticator &&\n        fixedConfiguration.authenticator.toUpperCase() === AuthenticationTypes.OAUTH_AUTHENTICATOR &&\n        !Util.string.isNotNullOrEmpty(fixedConfiguration.token));\n}\nfunction readTokenFromFile(fixedConfiguration) {\n    const tokenFilePath = fixedConfiguration.token_file_path\n        ? fixedConfiguration.token_file_path\n        : '/snowflake/session/token';\n    const resolvedPath = fs.realpathSync(tokenFilePath);\n    Logger().trace('Token file path is : %s', tokenFilePath);\n    validateNoExtraPermissionsForOthersSync(resolvedPath);\n    fixedConfiguration.token = fs.readFileSync(resolvedPath, 'utf-8').trim();\n    if (!fixedConfiguration.token) {\n        Logger().error('The token does not exist or has empty value.');\n        throw new Error('The token does not exist or has empty value');\n    }\n    const tokenChecksum = generateChecksum(fixedConfiguration.token);\n    Logger().info('Token used in connection has been read from file: %s. Checksum: %s', resolvedPath, tokenChecksum);\n}\nfunction loadConnectionConfiguration() {\n    Logger().trace('Loading connection configuration from the local files...');\n    const snowflakeConfigDir = defaultIfNotSet(process.env.SNOWFLAKE_HOME, path.join(os.homedir(), '.snowflake'));\n    Logger().trace('Looking for connection file in directory %s', snowflakeConfigDir);\n    const filePath = path.join(snowflakeConfigDir, 'connections.toml');\n    const resolvedPath = fs.realpathSync(filePath);\n    Logger().trace('Connection configuration file found under the path %s. Validating file access.', resolvedPath);\n    validateNoExtraPermissionsForOthersSync(resolvedPath);\n    const str = fs.readFileSync(resolvedPath, { encoding: 'utf8' });\n    const configurationChecksum = generateChecksum(str);\n    Logger().info('Connection configuration file is read from path: %s. Checksum: %s', resolvedPath, configurationChecksum);\n    Logger().trace('Trying to parse the config file');\n    const parsingResult = toml.parse(str);\n    const configurationName = defaultIfNotSet(process.env.SNOWFLAKE_DEFAULT_CONNECTION_NAME, 'default');\n    if (parsingResult[configurationName] !== undefined) {\n        const fixedConfiguration = fixUserKey(parsingResult[configurationName]);\n        if (shouldReadTokenFromFile(fixedConfiguration)) {\n            Logger().info('Trying to read token from config file.');\n            readTokenFromFile(fixedConfiguration);\n        }\n        return fixedConfiguration;\n    }\n    else {\n        Logger().error('Connection configuration with name %s does not exist in the file %s', configurationName, resolvedPath);\n        throw new Error(`Connection configuration with name ${configurationName} does not exist`);\n    }\n}\nfunction fixUserKey(parsingResult) {\n    Logger().trace(\"Empty Username field will be filled with 'User' field value.\");\n    if (parsingResult['username'] === undefined && parsingResult['user'] !== undefined) {\n        parsingResult['username'] = parsingResult['user'];\n    }\n    return parsingResult;\n}\nexports.loadConnectionConfiguration = loadConnectionConfiguration;\n//# sourceMappingURL=connection_configuration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25maWd1cmF0aW9uL2Nvbm5lY3Rpb25fY29uZmlndXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxnREFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLDREQUE0RCxFQUFFLG1CQUFPLENBQUMsOEVBQWM7QUFDNUYsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsMEdBQTRCO0FBQzNDLDRCQUE0QixtQkFBTyxDQUFDLGtJQUF3QztBQUM1RSxhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQkFBbUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25maWd1cmF0aW9uL2Nvbm5lY3Rpb25fY29uZmlndXJhdGlvbi5qcz82MGFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdG9tbCA9IHJlcXVpcmUoJ3RvbWwnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgdmFsaWRhdGVOb0V4dHJhUGVybWlzc2lvbnNGb3JPdGhlcnNTeW5jLCBnZW5lcmF0ZUNoZWNrc3VtIH0gPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKS5kZWZhdWx0O1xuY29uc3QgQXV0aGVudGljYXRpb25UeXBlcyA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuZnVuY3Rpb24gZGVmYXVsdElmTm90U2V0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaG91bGRSZWFkVG9rZW5Gcm9tRmlsZShmaXhlZENvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gKGZpeGVkQ29uZmlndXJhdGlvbiAmJlxuICAgICAgICBmaXhlZENvbmZpZ3VyYXRpb24uYXV0aGVudGljYXRvciAmJlxuICAgICAgICBmaXhlZENvbmZpZ3VyYXRpb24uYXV0aGVudGljYXRvci50b1VwcGVyQ2FzZSgpID09PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhFTlRJQ0FUT1IgJiZcbiAgICAgICAgIVV0aWwuc3RyaW5nLmlzTm90TnVsbE9yRW1wdHkoZml4ZWRDb25maWd1cmF0aW9uLnRva2VuKSk7XG59XG5mdW5jdGlvbiByZWFkVG9rZW5Gcm9tRmlsZShmaXhlZENvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCB0b2tlbkZpbGVQYXRoID0gZml4ZWRDb25maWd1cmF0aW9uLnRva2VuX2ZpbGVfcGF0aFxuICAgICAgICA/IGZpeGVkQ29uZmlndXJhdGlvbi50b2tlbl9maWxlX3BhdGhcbiAgICAgICAgOiAnL3Nub3dmbGFrZS9zZXNzaW9uL3Rva2VuJztcbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSBmcy5yZWFscGF0aFN5bmModG9rZW5GaWxlUGF0aCk7XG4gICAgTG9nZ2VyKCkudHJhY2UoJ1Rva2VuIGZpbGUgcGF0aCBpcyA6ICVzJywgdG9rZW5GaWxlUGF0aCk7XG4gICAgdmFsaWRhdGVOb0V4dHJhUGVybWlzc2lvbnNGb3JPdGhlcnNTeW5jKHJlc29sdmVkUGF0aCk7XG4gICAgZml4ZWRDb25maWd1cmF0aW9uLnRva2VuID0gZnMucmVhZEZpbGVTeW5jKHJlc29sdmVkUGF0aCwgJ3V0Zi04JykudHJpbSgpO1xuICAgIGlmICghZml4ZWRDb25maWd1cmF0aW9uLnRva2VuKSB7XG4gICAgICAgIExvZ2dlcigpLmVycm9yKCdUaGUgdG9rZW4gZG9lcyBub3QgZXhpc3Qgb3IgaGFzIGVtcHR5IHZhbHVlLicpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0b2tlbiBkb2VzIG5vdCBleGlzdCBvciBoYXMgZW1wdHkgdmFsdWUnKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5DaGVja3N1bSA9IGdlbmVyYXRlQ2hlY2tzdW0oZml4ZWRDb25maWd1cmF0aW9uLnRva2VuKTtcbiAgICBMb2dnZXIoKS5pbmZvKCdUb2tlbiB1c2VkIGluIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmVhZCBmcm9tIGZpbGU6ICVzLiBDaGVja3N1bTogJXMnLCByZXNvbHZlZFBhdGgsIHRva2VuQ2hlY2tzdW0pO1xufVxuZnVuY3Rpb24gbG9hZENvbm5lY3Rpb25Db25maWd1cmF0aW9uKCkge1xuICAgIExvZ2dlcigpLnRyYWNlKCdMb2FkaW5nIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiBmcm9tIHRoZSBsb2NhbCBmaWxlcy4uLicpO1xuICAgIGNvbnN0IHNub3dmbGFrZUNvbmZpZ0RpciA9IGRlZmF1bHRJZk5vdFNldChwcm9jZXNzLmVudi5TTk9XRkxBS0VfSE9NRSwgcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgJy5zbm93Zmxha2UnKSk7XG4gICAgTG9nZ2VyKCkudHJhY2UoJ0xvb2tpbmcgZm9yIGNvbm5lY3Rpb24gZmlsZSBpbiBkaXJlY3RvcnkgJXMnLCBzbm93Zmxha2VDb25maWdEaXIpO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHNub3dmbGFrZUNvbmZpZ0RpciwgJ2Nvbm5lY3Rpb25zLnRvbWwnKTtcbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSBmcy5yZWFscGF0aFN5bmMoZmlsZVBhdGgpO1xuICAgIExvZ2dlcigpLnRyYWNlKCdDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gZmlsZSBmb3VuZCB1bmRlciB0aGUgcGF0aCAlcy4gVmFsaWRhdGluZyBmaWxlIGFjY2Vzcy4nLCByZXNvbHZlZFBhdGgpO1xuICAgIHZhbGlkYXRlTm9FeHRyYVBlcm1pc3Npb25zRm9yT3RoZXJzU3luYyhyZXNvbHZlZFBhdGgpO1xuICAgIGNvbnN0IHN0ciA9IGZzLnJlYWRGaWxlU3luYyhyZXNvbHZlZFBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uQ2hlY2tzdW0gPSBnZW5lcmF0ZUNoZWNrc3VtKHN0cik7XG4gICAgTG9nZ2VyKCkuaW5mbygnQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIGZpbGUgaXMgcmVhZCBmcm9tIHBhdGg6ICVzLiBDaGVja3N1bTogJXMnLCByZXNvbHZlZFBhdGgsIGNvbmZpZ3VyYXRpb25DaGVja3N1bSk7XG4gICAgTG9nZ2VyKCkudHJhY2UoJ1RyeWluZyB0byBwYXJzZSB0aGUgY29uZmlnIGZpbGUnKTtcbiAgICBjb25zdCBwYXJzaW5nUmVzdWx0ID0gdG9tbC5wYXJzZShzdHIpO1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb25OYW1lID0gZGVmYXVsdElmTm90U2V0KHByb2Nlc3MuZW52LlNOT1dGTEFLRV9ERUZBVUxUX0NPTk5FQ1RJT05fTkFNRSwgJ2RlZmF1bHQnKTtcbiAgICBpZiAocGFyc2luZ1Jlc3VsdFtjb25maWd1cmF0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBmaXhlZENvbmZpZ3VyYXRpb24gPSBmaXhVc2VyS2V5KHBhcnNpbmdSZXN1bHRbY29uZmlndXJhdGlvbk5hbWVdKTtcbiAgICAgICAgaWYgKHNob3VsZFJlYWRUb2tlbkZyb21GaWxlKGZpeGVkQ29uZmlndXJhdGlvbikpIHtcbiAgICAgICAgICAgIExvZ2dlcigpLmluZm8oJ1RyeWluZyB0byByZWFkIHRva2VuIGZyb20gY29uZmlnIGZpbGUuJyk7XG4gICAgICAgICAgICByZWFkVG9rZW5Gcm9tRmlsZShmaXhlZENvbmZpZ3VyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXhlZENvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBMb2dnZXIoKS5lcnJvcignQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHdpdGggbmFtZSAlcyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZmlsZSAlcycsIGNvbmZpZ3VyYXRpb25OYW1lLCByZXNvbHZlZFBhdGgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB3aXRoIG5hbWUgJHtjb25maWd1cmF0aW9uTmFtZX0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaXhVc2VyS2V5KHBhcnNpbmdSZXN1bHQpIHtcbiAgICBMb2dnZXIoKS50cmFjZShcIkVtcHR5IFVzZXJuYW1lIGZpZWxkIHdpbGwgYmUgZmlsbGVkIHdpdGggJ1VzZXInIGZpZWxkIHZhbHVlLlwiKTtcbiAgICBpZiAocGFyc2luZ1Jlc3VsdFsndXNlcm5hbWUnXSA9PT0gdW5kZWZpbmVkICYmIHBhcnNpbmdSZXN1bHRbJ3VzZXInXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNpbmdSZXN1bHRbJ3VzZXJuYW1lJ10gPSBwYXJzaW5nUmVzdWx0Wyd1c2VyJ107XG4gICAgfVxuICAgIHJldHVybiBwYXJzaW5nUmVzdWx0O1xufVxuZXhwb3J0cy5sb2FkQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb24gPSBsb2FkQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uX2NvbmZpZ3VyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Statement = __webpack_require__(/*! ./statement */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\");\nconst { isString } = __webpack_require__(/*! util */ \"util\");\nconst STAGE_NAME = 'SYSTEM$BIND';\nconst CREATE_STAGE_STMT = 'CREATE OR REPLACE TEMPORARY STAGE ' +\n    STAGE_NAME +\n    \" file_format=( type=csv field_optionally_enclosed_by='\\\"')\";\n/**\n * Creates a new BindUploader.\n *\n * @param {Object} options\n * @param {Object} services\n * @param {Object} connectionConfig\n * @param {*} requestId\n *\n * @constructor\n */\nfunction BindUploader(options, services, connectionConfig, requestId) {\n    const MAX_BUFFER_SIZE = 1024 * 1024 * 100;\n    Logger.getInstance().debug('BindUploaders');\n    this.options = options;\n    this.services = services;\n    this.connectionConfig = connectionConfig;\n    this.requestId = requestId;\n    this.stagePath = '@' + STAGE_NAME + '/' + requestId;\n    Logger.getInstance().debug('token = %s', connectionConfig.getToken());\n    this.createStage = async function () {\n        const createStageOptions = { sqlText: GetCreateStageStmt() };\n        const newContext = Statement.createContext(createStageOptions, this.services, this.connectionConfig);\n        if (this.connectionConfig.getForceStageBindError() === 0) {\n            throw new Error('Failed to create stage');\n        }\n        const ret = await Statement.sendRequest(newContext);\n        if (ret['status'] !== 200) {\n            throw new Error('Failed to create stage');\n        }\n    };\n    this.uploadFilestream = async function (fileName, fileData) {\n        Logger.getInstance().debug('BindUploaders::uploadFilestream');\n        const stageName = this.stagePath;\n        if (stageName == null) {\n            throw new Error('Stage name is null.');\n        }\n        if (fileName == null) {\n            throw new Error('File name is null.');\n        }\n        if (this.connectionConfig.getForceStageBindError() === 1) {\n            throw new Error('Failed to upload file');\n        }\n        await new Promise((resolve, reject) => {\n            const putStmt = 'PUT file://' +\n                fileName +\n                \"'\" +\n                stageName +\n                \"' overwrite=true auto_compress=false source_compression=gzip\";\n            const uploadFileOptions = {\n                sqlText: putStmt,\n                fileStream: fileData,\n                complete: function (err, stmt) {\n                    if (err) {\n                        Logger.getInstance().debug('err ' + err);\n                        reject(err);\n                    }\n                    Logger.getInstance().debug('uploadFiles done ');\n                    resolve(stmt.streamRows());\n                },\n            };\n            Statement.createStatementPreExec(uploadFileOptions, this.services, this.connectionConfig);\n        });\n    };\n    this.Upload = async function (bindings) {\n        Logger.getInstance().debug('BindUploaders::Upload');\n        if (bindings == null) {\n            return null;\n        }\n        if (!this.services.sf.isStageCreated) {\n            await this.createStage();\n            this.services.sf.isStageCreated = true;\n        }\n        let fileCount = 0;\n        let strbuffer = '';\n        for (let i = 0; i < bindings.length; i++) {\n            for (let j = 0; j < bindings[i].length; j++) {\n                if (j > 0) {\n                    strbuffer += ',';\n                }\n                const value = this.csvData(bindings[i][j]);\n                strbuffer += value;\n            }\n            strbuffer += '\\n';\n            if (strbuffer.length >= MAX_BUFFER_SIZE || i === bindings.length - 1) {\n                const fileName = (++fileCount).toString();\n                Logger.getInstance().debug('fileName=' + fileName);\n                await this.uploadFilestream(fileName, strbuffer);\n                strbuffer = '';\n            }\n        }\n    };\n    this.csvData = function (data) {\n        if (data === null) {\n            return '';\n        }\n        if (data.toString() === '') {\n            return '\"\"';\n        }\n        if (!isString(data)) {\n            if (data instanceof Date) {\n                data = data.toJSON();\n            }\n            else {\n                data = JSON.stringify(data);\n            }\n        }\n        if (data.toString().indexOf('\"') >= 0 ||\n            data.toString().indexOf(',') >= 0 ||\n            data.toString().indexOf('\\\\') >= 0 ||\n            data.toString().indexOf('\\n') >= 0 ||\n            data.toString().indexOf('\\t') >= 0) {\n            return '\"' + data.toString().replaceAll('\"', '\"\"') + '\"';\n        }\n        else {\n            return data;\n        }\n    };\n}\nfunction GetCreateStageStmt() {\n    return CREATE_STAGE_STMT;\n}\nfunction GetStageName(requestId) {\n    return '@' + STAGE_NAME + '/' + requestId;\n}\nfunction CleanFile(fileName) {\n    try {\n        if (fs.existsSync(fileName)) {\n            fs.unlinkSync(fileName);\n        }\n    }\n    catch (err) {\n        Logger.getInstance().debug('Delete file failed: %s', fileName);\n    }\n}\nmodule.exports = { BindUploader, GetCreateStageStmt, GetStageName, CleanFile };\n//# sourceMappingURL=bind_uploader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2JpbmRfdXBsb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsa0JBQWtCLG1CQUFPLENBQUMsd0ZBQWE7QUFDdkMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3Qyw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2JpbmRfdXBsb2FkZXIuanM/NWI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgU3RhdGVtZW50ID0gcmVxdWlyZSgnLi9zdGF0ZW1lbnQnKTtcbmNvbnN0IHsgaXNTdHJpbmcgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IFNUQUdFX05BTUUgPSAnU1lTVEVNJEJJTkQnO1xuY29uc3QgQ1JFQVRFX1NUQUdFX1NUTVQgPSAnQ1JFQVRFIE9SIFJFUExBQ0UgVEVNUE9SQVJZIFNUQUdFICcgK1xuICAgIFNUQUdFX05BTUUgK1xuICAgIFwiIGZpbGVfZm9ybWF0PSggdHlwZT1jc3YgZmllbGRfb3B0aW9uYWxseV9lbmNsb3NlZF9ieT0nXFxcIicpXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQmluZFVwbG9hZGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAcGFyYW0geyp9IHJlcXVlc3RJZFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCaW5kVXBsb2FkZXIob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcsIHJlcXVlc3RJZCkge1xuICAgIGNvbnN0IE1BWF9CVUZGRVJfU0laRSA9IDEwMjQgKiAxMDI0ICogMTAwO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdCaW5kVXBsb2FkZXJzJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNlcnZpY2VzID0gc2VydmljZXM7XG4gICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICB0aGlzLnN0YWdlUGF0aCA9ICdAJyArIFNUQUdFX05BTUUgKyAnLycgKyByZXF1ZXN0SWQ7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ3Rva2VuID0gJXMnLCBjb25uZWN0aW9uQ29uZmlnLmdldFRva2VuKCkpO1xuICAgIHRoaXMuY3JlYXRlU3RhZ2UgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZVN0YWdlT3B0aW9ucyA9IHsgc3FsVGV4dDogR2V0Q3JlYXRlU3RhZ2VTdG10KCkgfTtcbiAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IFN0YXRlbWVudC5jcmVhdGVDb250ZXh0KGNyZWF0ZVN0YWdlT3B0aW9ucywgdGhpcy5zZXJ2aWNlcywgdGhpcy5jb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRGb3JjZVN0YWdlQmluZEVycm9yKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzdGFnZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGF3YWl0IFN0YXRlbWVudC5zZW5kUmVxdWVzdChuZXdDb250ZXh0KTtcbiAgICAgICAgaWYgKHJldFsnc3RhdHVzJ10gIT09IDIwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHN0YWdlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudXBsb2FkRmlsZXN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlTmFtZSwgZmlsZURhdGEpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0JpbmRVcGxvYWRlcnM6OnVwbG9hZEZpbGVzdHJlYW0nKTtcbiAgICAgICAgY29uc3Qgc3RhZ2VOYW1lID0gdGhpcy5zdGFnZVBhdGg7XG4gICAgICAgIGlmIChzdGFnZU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBuYW1lIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBuYW1lIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRGb3JjZVN0YWdlQmluZEVycm9yKCkgPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHV0U3RtdCA9ICdQVVQgZmlsZTovLycgK1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lICtcbiAgICAgICAgICAgICAgICBcIidcIiArXG4gICAgICAgICAgICAgICAgc3RhZ2VOYW1lICtcbiAgICAgICAgICAgICAgICBcIicgb3ZlcndyaXRlPXRydWUgYXV0b19jb21wcmVzcz1mYWxzZSBzb3VyY2VfY29tcHJlc3Npb249Z3ppcFwiO1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkRmlsZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgc3FsVGV4dDogcHV0U3RtdCxcbiAgICAgICAgICAgICAgICBmaWxlU3RyZWFtOiBmaWxlRGF0YSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGVyciwgc3RtdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnZXJyICcgKyBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ3VwbG9hZEZpbGVzIGRvbmUgJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RtdC5zdHJlYW1Sb3dzKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU3RhdGVtZW50LmNyZWF0ZVN0YXRlbWVudFByZUV4ZWModXBsb2FkRmlsZU9wdGlvbnMsIHRoaXMuc2VydmljZXMsIHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5VcGxvYWQgPSBhc3luYyBmdW5jdGlvbiAoYmluZGluZ3MpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0JpbmRVcGxvYWRlcnM6OlVwbG9hZCcpO1xuICAgICAgICBpZiAoYmluZGluZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2VzLnNmLmlzU3RhZ2VDcmVhdGVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVN0YWdlKCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2VzLnNmLmlzU3RhZ2VDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmlsZUNvdW50ID0gMDtcbiAgICAgICAgbGV0IHN0cmJ1ZmZlciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbmRpbmdzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmJ1ZmZlciArPSAnLCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jc3ZEYXRhKGJpbmRpbmdzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBzdHJidWZmZXIgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJidWZmZXIgKz0gJ1xcbic7XG4gICAgICAgICAgICBpZiAoc3RyYnVmZmVyLmxlbmd0aCA+PSBNQVhfQlVGRkVSX1NJWkUgfHwgaSA9PT0gYmluZGluZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gKCsrZmlsZUNvdW50KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdmaWxlTmFtZT0nICsgZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBsb2FkRmlsZXN0cmVhbShmaWxlTmFtZSwgc3RyYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBzdHJidWZmZXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jc3ZEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50b1N0cmluZygpID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICdcIlwiJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS50b0pTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50b1N0cmluZygpLmluZGV4T2YoJ1wiJykgPj0gMCB8fFxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpLmluZGV4T2YoJywnKSA+PSAwIHx8XG4gICAgICAgICAgICBkYXRhLnRvU3RyaW5nKCkuaW5kZXhPZignXFxcXCcpID49IDAgfHxcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKS5pbmRleE9mKCdcXG4nKSA+PSAwIHx8XG4gICAgICAgICAgICBkYXRhLnRvU3RyaW5nKCkuaW5kZXhPZignXFx0JykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdcIicgKyBkYXRhLnRvU3RyaW5nKCkucmVwbGFjZUFsbCgnXCInLCAnXCJcIicpICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldENyZWF0ZVN0YWdlU3RtdCgpIHtcbiAgICByZXR1cm4gQ1JFQVRFX1NUQUdFX1NUTVQ7XG59XG5mdW5jdGlvbiBHZXRTdGFnZU5hbWUocmVxdWVzdElkKSB7XG4gICAgcmV0dXJuICdAJyArIFNUQUdFX05BTUUgKyAnLycgKyByZXF1ZXN0SWQ7XG59XG5mdW5jdGlvbiBDbGVhbkZpbGUoZmlsZU5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlTmFtZSkpIHtcbiAgICAgICAgICAgIGZzLnVubGlua1N5bmMoZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0RlbGV0ZSBmaWxlIGZhaWxlZDogJXMnLCBmaWxlTmFtZSk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7IEJpbmRVcGxvYWRlciwgR2V0Q3JlYXRlU3RhZ2VTdG10LCBHZXRTdGFnZU5hbWUsIENsZWFuRmlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZF91cGxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/connection.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst QueryStatus = __webpack_require__(/*! ../constants/query_status */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/query_status.js\");\nconst LoggingUtil = __webpack_require__(/*! ../logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Statement = __webpack_require__(/*! ./statement */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst Authenticator = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { isOktaAuth } = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\");\nconst { init: initEasyLogging } = __webpack_require__(/*! ../logger/easy_logging_starter */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst { JsonCredentialManager, } = __webpack_require__(/*! ../authentication/secure_storage/json_credential_manager */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\n/**\n * Creates a new Connection instance.\n *\n * @param {ConnectionContext} context\n *\n * @returns {Object}\n */\nfunction Connection(context) {\n    // validate input\n    Logger.getInstance().trace('Connection object is being constructed');\n    Errors.assertInternal(Util.isObject(context));\n    const services = context.getServices();\n    const connectionConfig = context.getConnectionConfig();\n    // generate an id for the connection\n    const id = uuidv4();\n    Logger.getInstance().trace('Generated connection id: %s', id);\n    Logger.getInstance().info('Creating Connection[id: %s] with %s, password is %s, region: %s, ' +\n        'authenticator: %s, ocsp mode: %s, os: %s, os version: %s', id, connectionConfig.describeIdentityAttributes(), LoggingUtil.describePresence(connectionConfig.password), connectionConfig.region, connectionConfig.getAuthenticator(), connectionConfig.getClientEnvironment().OCSP_MODE, connectionConfig.getClientEnvironment().OS, connectionConfig.getClientEnvironment().OS_VERSION);\n    // Log was split due to possibility of exceeding the max message length of the logger\n    Logger.getInstance().info('Connection[id: %s] additional details: ' +\n        'passcode in password is %s, passcode is %s, private key is %s, ' +\n        'application: %s, client name: %s, client version: %s, retry timeout: %s, ' +\n        'private key path: %s, private key pass is %s, ' +\n        'client store temporary credential: %s, browser response timeout: %s', id, LoggingUtil.describePresence(connectionConfig.getPasscodeInPassword()), LoggingUtil.describePresence(connectionConfig.getPasscode()), LoggingUtil.describePresence(connectionConfig.getPrivateKey()), connectionConfig.getClientApplication(), connectionConfig.getClientName(), connectionConfig.getClientVersion(), connectionConfig.getRetryTimeout(), connectionConfig.getPrivateKeyPath(), LoggingUtil.describePresence(connectionConfig.getPrivateKeyPass()), connectionConfig.getClientStoreTemporaryCredential(), connectionConfig.getBrowserActionTimeout());\n    // async max retry and retry pattern from python connector\n    const asyncNoDataMaxRetry = 24;\n    const asyncRetryPattern = [1, 1, 2, 3, 4, 8, 10];\n    const asyncRetryInMilliseconds = 500;\n    // Custom regex based on uuid validate\n    // Unable to directly use uuid validate because the queryId returned from the server doesn't match the regex\n    const queryIdRegex = new RegExp(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n    //Make session tokens available for testing\n    this.getTokens = function () {\n        if (connectionConfig._qaMode) {\n            return services.sf.getConfig() && services.sf.getConfig().tokenInfo;\n        }\n        return {};\n    };\n    /**\n     * Returns true if the connection is active otherwise false\n     *\n     * @returns {boolean}\n     */\n    this.isUp = function () {\n        const isUp = services.sf.isConnected();\n        Logger.getInstance().trace('Connection[id: %s] - isUp called. Returning: %s', this.getId(), isUp);\n        return isUp;\n    };\n    /**\n     * Returns true if the session token and master token are valid\n     *\n     * @returns {boolean}\n     */\n    this.isTokenValid = function () {\n        Logger.getInstance().trace('Connection[id: %s] - isTokenValid called', this.getId());\n        const tokenInfo = services.sf.getConfig().tokenInfo;\n        const sessionTokenExpirationTime = tokenInfo.sessionTokenExpirationTime;\n        const isSessionValid = sessionTokenExpirationTime > Date.now();\n        Logger.getInstance().trace('Connection[id: %s] - isSessionTokenValid: %s', this.getId(), isSessionValid);\n        const masterTokenExpirationTime = tokenInfo.masterTokenExpirationTime;\n        const isMasterValid = masterTokenExpirationTime > Date.now();\n        Logger.getInstance().trace('Connection[id: %s] - isMasterTokenValid: %s', this.getId(), isMasterValid);\n        const areTokensValid = isSessionValid && isMasterValid;\n        Logger.getInstance().trace('Connection[id: %s] - isTokenValid returned: %s', this.getId(), areTokensValid);\n        return areTokensValid;\n    };\n    this.getServiceName = function () {\n        return services.sf.getServiceName();\n    };\n    this.getClientSessionKeepAlive = function () {\n        return services.sf.getClientSessionKeepAlive();\n    };\n    this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n        return services.sf.getClientSessionKeepAliveHeartbeatFrequency();\n    };\n    this.getJsTreatIntegerAsBigInt = function () {\n        return services.sf.getJsTreatIntegerAsBigInt();\n    };\n    /**\n     * Returns the connection id.\n     *\n     * @returns {String}\n     */\n    this.getId = function () {\n        return id;\n    };\n    this.heartbeat = (callback) => {\n        Logger.getInstance().trace('Issuing heartbeat call');\n        const requestId = uuidv4();\n        services.sf.request({\n            method: 'POST',\n            url: Url.format({\n                pathname: '/session/heartbeat',\n                search: QueryString.stringify({\n                    requestId: requestId,\n                }),\n            }),\n            callback: Util.isFunction(callback)\n                ? callback\n                : function (err, body) {\n                    if (err) {\n                        Logger.getInstance().error('Error issuing heartbeat call: %s', err.message);\n                    }\n                    else {\n                        Logger.getInstance().trace('Heartbeat response %s', JSON.stringify(body));\n                    }\n                },\n        });\n    };\n    this.heartbeatAsync = () => {\n        return new Promise((resolve, reject) => {\n            // previous version of driver called `select 1;` which result in `[ { '1': 1 } ]`\n            Logger.getInstance().trace('Issuing async heartbeat call');\n            this.heartbeat((err) => (err ? reject(err) : resolve([{ 1: 1 }])));\n        });\n    };\n    /**\n     * @return {Promise<boolean>}\n     */\n    this.isValidAsync = async () => {\n        Logger.getInstance().trace('Connection[id: %s] - isValidAsync called', this.getId());\n        if (!this.isUp()) {\n            return false;\n        }\n        try {\n            await this.heartbeatAsync();\n            return true;\n        }\n        catch (e) {\n            Logger.getInstance().debug('Connection[id: %s] - heartbeat failed: %s', this.getId(), JSON.stringify(e, Object.getOwnPropertyNames(e)));\n            return false;\n        }\n    };\n    /**\n     * Set the private link as the OCSP cache server's URL.\n     *\n     * @param {String} host\n     *\n     * @returns {null}\n     */\n    this.setupOcspPrivateLink = function (host) {\n        process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL = Util.createOcspResponseCacheServerUrl(host);\n    };\n    /**\n     * Method returning callback function for connect() - used to establish a connection.\n     *\n     * @param self\n     * @param {Function} callback\n     *\n     * @returns {function}\n     */\n    function connectCallback(self, callback) {\n        return function (err) {\n            if (Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE)) {\n                const SECONDS_TO_MILLISECONDS_MULTIPLIER = 1000;\n                const KEEP_ALIVE_HEARTBEAT_FREQUENCY_IN_MS = Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY) *\n                    SECONDS_TO_MILLISECONDS_MULTIPLIER;\n                self.keepalive = setInterval(self.heartbeat, KEEP_ALIVE_HEARTBEAT_FREQUENCY_IN_MS, self);\n                Logger.getInstance().trace('Connection[id: %s] - keepAlive internal created', id);\n            }\n            if (Util.isFunction(callback)) {\n                callback(Errors.externalize(err), self);\n            }\n        };\n    }\n    this.determineConnectionDomain = () => connectionConfig.accessUrl && connectionConfig.accessUrl.includes('snowflakecomputing.cn')\n        ? 'CHINA'\n        : 'GLOBAL';\n    /**\n     * Establishes a connection if we aren't in a fatal state.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Object} the connection object.\n     */\n    this.connect = function (callback) {\n        const timer = new ExecutionTimer().start();\n        const connectionDomain = this.determineConnectionDomain();\n        Logger.getInstance().info('Connection[id: %s] - connecting. Associated Snowflake domain: %s', this.getId(), connectionDomain);\n        // invalid callback\n        Errors.checkArgumentValid(!Util.exists(callback) || Util.isFunction(callback), ErrorCodes.ERR_CONN_CONNECT_INVALID_CALLBACK);\n        if (Util.exists(connectionConfig.host) && Util.isPrivateLink(connectionConfig.host)) {\n            Logger.getInstance().info('Connection[id: %s] - setting up private link', this.getId());\n            this.setupOcspPrivateLink(connectionConfig.host);\n        }\n        // connect to the snowflake service and provide our own callback so that\n        // the connection can be passed in when invoking the connection.connect()\n        // callback\n        const self = this;\n        const authenticationType = connectionConfig.getAuthenticator();\n        Logger.getInstance().debug('Connection[id: %s] - using authentication type: %s', this.getId(), authenticationType);\n        // check if authentication type is compatible with connect()\n        // external browser and okta are not compatible with connect() due to their usage of async functions\n        if (authenticationType === AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR ||\n            isOktaAuth(authenticationType)) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - connecting failed after %s milliseconds.' +\n                'Error: External browser and Okta are not compatible with connection process', this.getId(), connectingDuration);\n            throw Errors.createClientError(ErrorCodes.ERR_CONN_CREATE_INVALID_AUTH_CONNECT);\n        }\n        // Get authenticator to use\n        Logger.getInstance().debug('Connection[id: %s] - retrieving authenticator', this.getId());\n        const auth = services.sf.getAuthenticator();\n        Logger.getInstance().debug('Connection[id: %s] - trying to authenticate', this.getId());\n        auth\n            .authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username)\n            .then(() => {\n            Logger.getInstance().info('Connection[id: %s] - authentication successful using: %s', this.getId(), connectionConfig.getAuthenticator());\n            // JSON for connection\n            const body = Authenticator.formAuthJSON(connectionConfig.getAuthenticator(), connectionConfig.account, connectionConfig.username, connectionConfig.getClientType(), connectionConfig.getClientVersion(), connectionConfig.getClientEnvironment());\n            // Update JSON body with the authentication values\n            auth.updateBody(body);\n            Logger.getInstance().debug('Connection[id: %s] - initializing easyLogging', this.getId());\n            initEasyLogging(connectionConfig.clientConfigFile).then(() => {\n                Logger.getInstance().debug('Connection[id: %s] - easyLogging initialized', this.getId());\n                try {\n                    Logger.getInstance().debug('Connection[id: %s] - connecting through service', this.getId());\n                    services.sf.connect({\n                        callback: connectCallback(self, callback),\n                        json: body,\n                    });\n                    const connectingDuration = timer.getDuration();\n                    Logger.getInstance().info('Connection[id: %s] - connected successfully after %s milliseconds', this.getId(), connectingDuration);\n                    return this;\n                }\n                catch (e) {\n                    // we don't expect an error here since callback method should be called\n                    const connectingDuration = timer.getDuration();\n                    Logger.getInstance().info('Connection[id: %s] - failed to connect after %s milliseconds. ' +\n                        'Error: Unexpected error from calling connectCallback function in snowflake service - %s', this.getId(), connectingDuration, e);\n                }\n            }, () => {\n                const connectingDuration = timer.getDuration();\n                Logger.getInstance().error('Connection[id: %s] - failed to initialize easyLogging. ' +\n                    'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n                callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG, true), self);\n            });\n        }, (err) => {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - authentication failed. Error: %s. ' +\n                'Connecting failed after %s milliseconds', this.getId(), err, connectingDuration);\n            callback(err, self);\n        });\n        return this;\n    };\n    /**\n     * Establishes a connection if we aren't in a fatal state.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Object} the connection object.\n     */\n    this.connectAsync = async function (callback) {\n        const timer = new ExecutionTimer().start();\n        const connectingDomain = this.determineConnectionDomain();\n        Logger.getInstance().info('Connection[id: %s] - async connecting. Associated Snowflake domain: %s', this.getId(), connectingDomain);\n        // invalid callback\n        Errors.checkArgumentValid(!Util.exists(callback) || Util.isFunction(callback), ErrorCodes.ERR_CONN_CONNECT_INVALID_CALLBACK);\n        if (Util.isPrivateLink(connectionConfig.host)) {\n            this.setupOcspPrivateLink(connectionConfig.host);\n            Logger.getInstance().info('Connection[id: %s] - setting up private link', this.getId());\n        }\n        // connect to the snowflake service and provide our own callback so that\n        // the connection can be passed in when invoking the connection.connect()\n        // callback\n        const self = this;\n        if (connectionConfig.getClientStoreTemporaryCredential()) {\n            Logger.getInstance().debug('Connection[id: %s] - storing temporary credential of client', this.getId());\n            const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n            if (GlobalConfig.getCredentialManager() === null) {\n                Logger.getInstance().debug('Connection[id: %s] - using default json credential manager', this.getId());\n                GlobalConfig.setCustomCredentialManager(new JsonCredentialManager(connectionConfig.getCredentialCacheDir()));\n            }\n            Logger.getInstance().debug('Connection[id: %s] - reading idToken using credential manager', this.getId());\n            connectionConfig.idToken = await GlobalConfig.getCredentialManager().read(key);\n        }\n        if (connectionConfig.getClientRequestMFAToken()) {\n            Logger.getInstance().debug('Connection[id: %s] - extracting mfaToken of client', this.getId());\n            const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR);\n            if (GlobalConfig.getCredentialManager() === null) {\n                Logger.getInstance().debug('Connection[id: %s] - using default json credential manager', this.getId());\n                GlobalConfig.setCustomCredentialManager(new JsonCredentialManager(connectionConfig.getCredentialCacheDir()));\n            }\n            Logger.getInstance().debug('Connection[id: %s] - reading mfaToken using credential manager', this.getId());\n            connectionConfig.mfaToken = await GlobalConfig.getCredentialManager().read(key);\n        }\n        // Get authenticator to use\n        let auth;\n        try {\n            Logger.getInstance().debug('Connection[id: %s] - retrieving authenticator', this.getId());\n            auth = Authenticator.getAuthenticator(connectionConfig, context.getHttpClient());\n            services.sf.authenticator = auth;\n        }\n        catch (error) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - failed to initialize authenticator. ' +\n                'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n            throw Errors.createClientError(ErrorCodes.ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED, true);\n        }\n        try {\n            Logger.getInstance().debug('Connection[id: %s] - initializing easyLogging', this.getId());\n            await initEasyLogging(connectionConfig.clientConfigFile);\n        }\n        catch (err) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - failed to initialize easyLogging. ' +\n                'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n            throw Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG, true);\n        }\n        let body = null;\n        try {\n            Logger.getInstance().debug('Connection[id: %s] - using authentication type: %s', this.getId(), connectionConfig.getAuthenticator());\n            Logger.getInstance().debug('Connection[id: %s] - trying to authenticate', this.getId());\n            await auth.authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username);\n            Logger.getInstance().info('Connection[id: %s] - authentication successful using: %s', this.getId(), connectionConfig.getAuthenticator());\n            // JSON for connection\n            body = Authenticator.formAuthJSON(connectionConfig.getAuthenticator(), connectionConfig.account, connectionConfig.username, connectionConfig.getClientType(), connectionConfig.getClientVersion(), connectionConfig.getClientEnvironment());\n            // Update JSON body with the authentication values\n            auth.updateBody(body);\n        }\n        catch (authErr) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info('Connection[id: %s] - failed to connect async after %s milliseconds.' +\n                'Failed during authentication. Error: %s', this.getId(), connectingDuration, authErr);\n            Logger.getInstance().error('Connection[id: %s] - failed during authentication. Error: %s', this.getId(), authErr);\n            callback(authErr);\n            return this;\n        }\n        try {\n            // Request connection\n            Logger.getInstance().debug('Connection[id: %s] - connecting through service', this.getId());\n            services.sf.connect({\n                callback: connectCallback(self, callback),\n                json: body,\n            });\n            // return the connection to facilitate chaining\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info('Connection[id: %s] - connected successfully after %s milliseconds', this.getId(), connectingDuration);\n        }\n        catch (callbackErr) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info('Connection[id: %s] - failed to connect async after %s milliseconds.' +\n                'Error: Unexpected error from calling connectCallback function in snowflake service - %s', this.getId(), connectingDuration, callbackErr);\n            callback(callbackErr);\n            return this;\n        }\n        return this;\n    };\n    /**\n     * Executes a statement.\n     *\n     * @param {Object} options\n     *\n     * @returns {Object}\n     */\n    this.execute = function (options) {\n        Logger.getInstance().trace('Connection[id: %s] - execute called with options.', this.getId());\n        return Statement.createStatementPreExec(options, services, connectionConfig);\n    };\n    /**\n     * Fetches the result of a previously issued statement.\n     *\n     * @param {Object} options\n     *\n     * @returns {Object}\n     */\n    this.fetchResult = function (options) {\n        Logger.getInstance().trace('Connection[id: %s] - fetchResult called with options', this.getId());\n        return Statement.createStatementPostExec(options, services, connectionConfig);\n    };\n    /**\n     * Immediately terminates the connection without waiting for currently\n     * executing statements to complete.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Object} the connection object.\n     */\n    this.destroy = function (callback) {\n        // invalid callback\n        Logger.getInstance().trace('Connection[id: %s] - destroy called', this.getId());\n        Errors.checkArgumentValid(!Util.exists(callback) || Util.isFunction(callback), ErrorCodes.ERR_CONN_DESTROY_INVALID_CALLBACK);\n        // log out of the snowflake service and provide our own callback so that\n        // the connection can be passed in when invoking the connection.destroy()\n        // callback\n        Logger.getInstance().trace('Connection[id: %s] - destroying through service', this.getId());\n        const self = this;\n        services.sf.destroy({\n            callback: function (err) {\n                if (Util.exists(self.keepalive)) {\n                    clearInterval(self.keepalive);\n                    Logger.getInstance().trace('Connection[id: %s] - keepAlive interval cleared', self.getId());\n                }\n                if (Util.isFunction(callback)) {\n                    callback(Errors.externalize(err), self);\n                }\n            },\n        });\n        Logger.getInstance().trace('Connection[id: %s] - connection destroyed successfully', this.getId());\n        // return the connection to facilitate chaining\n        return this;\n    };\n    /**\n     * Gets the response containing the status of the query based on queryId.\n     *\n     * @param {String} queryId\n     *\n     * @returns {Object} the query response\n     */\n    async function getQueryResponse(queryId) {\n        Logger.getInstance().trace('Connection[id: %s] - requested query response for Query[id: %s]', id, queryId);\n        // Check if queryId exists and is valid uuid\n        Errors.checkArgumentExists(Util.exists(queryId), ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID);\n        Errors.checkArgumentValid(queryIdRegex.test(queryId), ErrorCodes.ERR_GET_RESPONSE_QUERY_INVALID_UUID, queryId);\n        Logger.getInstance().debug('Connection[id: %s] - Query[id: %s] is valid', id, queryId);\n        // Form the request options\n        const options = {\n            method: 'GET',\n            url: Url.format({\n                pathname: `/monitoring/queries/${queryId}`,\n            }),\n        };\n        Logger.getInstance().debug('Connection[id: %s] - fetching query response for Query[id: %s]', id, queryId);\n        const timer = new ExecutionTimer().start();\n        // Get the response containing the query status\n        const response = await services.sf.requestAsync(options);\n        const fetchingDuration = timer.getDuration();\n        Logger.getInstance().debug('Connection[id: %s] - query response for Query[id: %s] fetched successfully after: %s milliseconds', id, queryId, fetchingDuration);\n        return response['data'];\n    }\n    /**\n     * Extracts the status of the query from the query response.\n     *\n     * @param {Object} queryResponse\n     *\n     * @returns {String} the query status.\n     */\n    function extractQueryStatus(queryResponse) {\n        let status = QueryStatus.code.NO_QUERY_DATA; // default status\n        if (!queryResponse || !queryResponse['data'] || !queryResponse['data']['queries']) {\n            Logger.getInstance().trace('Connection[id: %s] - No query data found, returning NO_QUERY_DATA status', id);\n            return status;\n        }\n        const queries = queryResponse['data']['queries'];\n        if (queries.length > 0) {\n            status = queries[0]['status'];\n        }\n        Logger.getInstance().trace('Connection[id: %s] - Extracted query status: %s', id, status);\n        return status;\n    }\n    /**\n     * Gets the status of the query based on queryId.\n     *\n     * @param {String} queryId\n     *\n     * @returns {String} the query status.\n     */\n    this.getQueryStatus = async function (queryId) {\n        Logger.getInstance().trace('Connection[id: %s] - getQueryStatus called for Query[id: %s]', this.getId(), queryId);\n        return extractQueryStatus(await getQueryResponse(queryId));\n    };\n    /**\n     * Gets the status of the query based on queryId and throws if there's an error.\n     *\n     * @param {String} queryId\n     *\n     * @returns {String} the query status.\n     */\n    this.getQueryStatusThrowIfError = async function (queryId) {\n        Logger.getInstance().trace('Connection[id: %s] - getQueryStatusThrowIfError called for Query[id: %s]', this.getId(), queryId);\n        const response = await getQueryResponse(queryId); // returns response['data']\n        const status = extractQueryStatus(response);\n        let sqlState = null;\n        if (this.isAnError(status)) {\n            let message = response['message'] || '';\n            const code = response['code'] || -1;\n            if (response['data']) {\n                message +=\n                    response['data']['queries'].length > 0\n                        ? response['data']['queries'][0]['errorMessage']\n                        : '';\n                sqlState = response['data']['sqlState'];\n            }\n            Logger.getInstance().debug('Connection[id: %s] - query error for Query[id: %s]. Error: %s. SQLState: %s', this.getId(), queryId, message, sqlState);\n            throw Errors.createOperationFailedError(code, response, message, sqlState);\n        }\n        return status;\n    };\n    /**\n     * Gets the results from a previously ran query based on queryId\n     *\n     * @param {Object} options\n     *\n     * @returns {Object}\n     */\n    this.getResultsFromQueryId = async function (options) {\n        const queryId = options.queryId;\n        Logger.getInstance().trace('Connection[id: %s] - getResultsFromQueryId called for Query[id: %s].', this.getId(), queryId);\n        let status, noDataCounter = 0, retryPatternPos = 0;\n        // Wait until query has finished executing\n        let queryStillExecuting = true;\n        while (queryStillExecuting) {\n            Logger.getInstance().trace('Connection[id: %s] - checking if Query[id: %s] is still executing. Retries with no data count: %d', this.getId(), queryId, noDataCounter);\n            // Check if query is still running.\n            // Trigger exception if it failed or there is no query data in the server.\n            status = await this.getQueryStatusThrowIfError(queryId);\n            queryStillExecuting = this.isStillRunning(status);\n            if (!queryStillExecuting || status === QueryStatus.code.NO_QUERY_DATA) {\n                Logger.getInstance().trace('Connection[id: %s] - end of waiting for Query[id: %s] to finish executing. ' +\n                    queryStillExecuting\n                    ? 'Query is no longer executing. '\n                    : 0, this.getId(), queryId, status);\n                break;\n            }\n            // Timeout based on query status retry rules\n            await new Promise((resolve) => {\n                setTimeout(() => resolve(), asyncRetryInMilliseconds * asyncRetryPattern[retryPatternPos]);\n            });\n            // If no data, increment the no data counter\n            if (QueryStatus.code[status] === QueryStatus.code.NO_DATA) {\n                noDataCounter++;\n                Logger.getInstance().trace('Connection[id: %s] - no data returned for Query[id: %s]. Retries with no data count: %d', this.getId(), queryId, noDataCounter);\n                // Check if retry for no data is exceeded\n                if (noDataCounter > asyncNoDataMaxRetry) {\n                    Logger.getInstance().error('Connection[id: %s] - no data returned for Query[id: %s]. Retry limit: %s reached.', this.getId(), queryId, asyncNoDataMaxRetry);\n                    throw Errors.createClientError(ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NO_DATA, true, queryId);\n                }\n            }\n            if (retryPatternPos < asyncRetryPattern.length - 1) {\n                retryPatternPos++;\n            }\n        }\n        if (QueryStatus.code[status] === QueryStatus.code.NO_QUERY_DATA) {\n            Logger.getInstance().error('Connection[id: %s] - Query[id: %s] did not succeed. Final status: %s', this.getId(), queryId, status);\n            throw Errors.createClientError(ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NO_DATA, true, queryId, status);\n        }\n        if (QueryStatus.code[status] !== QueryStatus.code.SUCCESS) {\n            Logger.getInstance().error('Connection[id: %s] - Query[id: %s] did not succeed. Final status: %s', this.getId(), queryId, status);\n            throw Errors.createClientError(ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS, true, queryId, status);\n        }\n        Logger.getInstance().debug('Connection[id: %s] - Query[id: %s] succeeded. Fetching the result.', this.getId(), queryId);\n        return this.fetchResult(options);\n    };\n    /**\n     * Checks whether the given status is currently running.\n     *\n     * @param {String} status\n     *\n     * @returns {Boolean}\n     */\n    this.isStillRunning = function (status) {\n        Logger.getInstance().trace('Connection[id: %s] - checking if status %s is still running', this.getId(), status);\n        return QueryStatus.runningStatuses.includes(QueryStatus.code[status]);\n    };\n    /**\n     * Checks whether the given status means that there has been an error.\n     *\n     * @param {String} status\n     *\n     * @returns {Boolean}\n     */\n    this.isAnError = function (status) {\n        return QueryStatus.errorStatuses.includes(QueryStatus.code[status]);\n    };\n    /**\n     * Returns a serialized version of this connection.\n     *\n     * @returns {String}\n     */\n    this.serialize = function () {\n        Logger.getInstance().trace('Connection[id: %s] - serialize called', this.getId());\n        return JSON.stringify(context.getConfig());\n    };\n    EventEmitter.call(this);\n}\nUtil.inherits(Connection, EventEmitter);\nmodule.exports = Connection;\n//# sourceMappingURL=connection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDhEQUFNO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsa0dBQXdCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQSxxQkFBcUIsMERBQThCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHdGQUFhO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHNIQUFrQztBQUNoRSw0QkFBNEIsbUJBQU8sQ0FBQyxrSUFBd0M7QUFDNUUsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsc0hBQWtDO0FBQ2pFLFFBQVEsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyxrSEFBZ0M7QUFDMUUscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxzS0FBMEQ7QUFDckcsdUJBQXVCLG1CQUFPLENBQUMsd0dBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsR0FBRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdUJBQXVCLFNBQVM7QUFDM0Y7QUFDQSxvRUFBb0UsTUFBTTtBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLENBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9jb25uZWN0aW9uLmpzPzhmOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoJ3V1aWQnKTtcbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgUXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgUXVlcnlTdGF0dXMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvcXVlcnlfc3RhdHVzJyk7XG5jb25zdCBMb2dnaW5nVXRpbCA9IHJlcXVpcmUoJy4uL2xvZ2dlci9sb2dnaW5nX3V0aWwnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBTdGF0ZW1lbnQgPSByZXF1aXJlKCcuL3N0YXRlbWVudCcpO1xuY29uc3QgUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4uL3BhcmFtZXRlcnMnKTtcbmNvbnN0IEF1dGhlbnRpY2F0b3IgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbicpO1xuY29uc3QgQXV0aGVudGljYXRpb25UeXBlcyA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IHsgaXNPa3RhQXV0aCB9ID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24nKTtcbmNvbnN0IHsgaW5pdDogaW5pdEVhc3lMb2dnaW5nIH0gPSByZXF1aXJlKCcuLi9sb2dnZXIvZWFzeV9sb2dnaW5nX3N0YXJ0ZXInKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IHsgSnNvbkNyZWRlbnRpYWxNYW5hZ2VyLCB9ID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vc2VjdXJlX3N0b3JhZ2UvanNvbl9jcmVkZW50aWFsX21hbmFnZXInKTtcbmNvbnN0IEV4ZWN1dGlvblRpbWVyID0gcmVxdWlyZSgnLi4vbG9nZ2VyL2V4ZWN1dGlvbl90aW1lcicpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IENvbm5lY3Rpb24gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9uQ29udGV4dH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIENvbm5lY3Rpb24oY29udGV4dCkge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb24gb2JqZWN0IGlzIGJlaW5nIGNvbnN0cnVjdGVkJyk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29udGV4dCkpO1xuICAgIGNvbnN0IHNlcnZpY2VzID0gY29udGV4dC5nZXRTZXJ2aWNlcygpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBjb250ZXh0LmdldENvbm5lY3Rpb25Db25maWcoKTtcbiAgICAvLyBnZW5lcmF0ZSBhbiBpZCBmb3IgdGhlIGNvbm5lY3Rpb25cbiAgICBjb25zdCBpZCA9IHV1aWR2NCgpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdHZW5lcmF0ZWQgY29ubmVjdGlvbiBpZDogJXMnLCBpZCk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ3JlYXRpbmcgQ29ubmVjdGlvbltpZDogJXNdIHdpdGggJXMsIHBhc3N3b3JkIGlzICVzLCByZWdpb246ICVzLCAnICtcbiAgICAgICAgJ2F1dGhlbnRpY2F0b3I6ICVzLCBvY3NwIG1vZGU6ICVzLCBvczogJXMsIG9zIHZlcnNpb246ICVzJywgaWQsIGNvbm5lY3Rpb25Db25maWcuZGVzY3JpYmVJZGVudGl0eUF0dHJpYnV0ZXMoKSwgTG9nZ2luZ1V0aWwuZGVzY3JpYmVQcmVzZW5jZShjb25uZWN0aW9uQ29uZmlnLnBhc3N3b3JkKSwgY29ubmVjdGlvbkNvbmZpZy5yZWdpb24sIGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudEVudmlyb25tZW50KCkuT0NTUF9NT0RFLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudEVudmlyb25tZW50KCkuT1MsIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50RW52aXJvbm1lbnQoKS5PU19WRVJTSU9OKTtcbiAgICAvLyBMb2cgd2FzIHNwbGl0IGR1ZSB0byBwb3NzaWJpbGl0eSBvZiBleGNlZWRpbmcgdGhlIG1heCBtZXNzYWdlIGxlbmd0aCBvZiB0aGUgbG9nZ2VyXG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIGFkZGl0aW9uYWwgZGV0YWlsczogJyArXG4gICAgICAgICdwYXNzY29kZSBpbiBwYXNzd29yZCBpcyAlcywgcGFzc2NvZGUgaXMgJXMsIHByaXZhdGUga2V5IGlzICVzLCAnICtcbiAgICAgICAgJ2FwcGxpY2F0aW9uOiAlcywgY2xpZW50IG5hbWU6ICVzLCBjbGllbnQgdmVyc2lvbjogJXMsIHJldHJ5IHRpbWVvdXQ6ICVzLCAnICtcbiAgICAgICAgJ3ByaXZhdGUga2V5IHBhdGg6ICVzLCBwcml2YXRlIGtleSBwYXNzIGlzICVzLCAnICtcbiAgICAgICAgJ2NsaWVudCBzdG9yZSB0ZW1wb3JhcnkgY3JlZGVudGlhbDogJXMsIGJyb3dzZXIgcmVzcG9uc2UgdGltZW91dDogJXMnLCBpZCwgTG9nZ2luZ1V0aWwuZGVzY3JpYmVQcmVzZW5jZShjb25uZWN0aW9uQ29uZmlnLmdldFBhc3Njb2RlSW5QYXNzd29yZCgpKSwgTG9nZ2luZ1V0aWwuZGVzY3JpYmVQcmVzZW5jZShjb25uZWN0aW9uQ29uZmlnLmdldFBhc3Njb2RlKCkpLCBMb2dnaW5nVXRpbC5kZXNjcmliZVByZXNlbmNlKGNvbm5lY3Rpb25Db25maWcuZ2V0UHJpdmF0ZUtleSgpKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRBcHBsaWNhdGlvbigpLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudE5hbWUoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRWZXJzaW9uKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlUaW1lb3V0KCksIGNvbm5lY3Rpb25Db25maWcuZ2V0UHJpdmF0ZUtleVBhdGgoKSwgTG9nZ2luZ1V0aWwuZGVzY3JpYmVQcmVzZW5jZShjb25uZWN0aW9uQ29uZmlnLmdldFByaXZhdGVLZXlQYXNzKCkpLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCgpLCBjb25uZWN0aW9uQ29uZmlnLmdldEJyb3dzZXJBY3Rpb25UaW1lb3V0KCkpO1xuICAgIC8vIGFzeW5jIG1heCByZXRyeSBhbmQgcmV0cnkgcGF0dGVybiBmcm9tIHB5dGhvbiBjb25uZWN0b3JcbiAgICBjb25zdCBhc3luY05vRGF0YU1heFJldHJ5ID0gMjQ7XG4gICAgY29uc3QgYXN5bmNSZXRyeVBhdHRlcm4gPSBbMSwgMSwgMiwgMywgNCwgOCwgMTBdO1xuICAgIGNvbnN0IGFzeW5jUmV0cnlJbk1pbGxpc2Vjb25kcyA9IDUwMDtcbiAgICAvLyBDdXN0b20gcmVnZXggYmFzZWQgb24gdXVpZCB2YWxpZGF0ZVxuICAgIC8vIFVuYWJsZSB0byBkaXJlY3RseSB1c2UgdXVpZCB2YWxpZGF0ZSBiZWNhdXNlIHRoZSBxdWVyeUlkIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBkb2Vzbid0IG1hdGNoIHRoZSByZWdleFxuICAgIGNvbnN0IHF1ZXJ5SWRSZWdleCA9IG5ldyBSZWdFeHAoL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaSk7XG4gICAgLy9NYWtlIHNlc3Npb24gdG9rZW5zIGF2YWlsYWJsZSBmb3IgdGVzdGluZ1xuICAgIHRoaXMuZ2V0VG9rZW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5fcWFNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0Q29uZmlnKCkgJiYgc2VydmljZXMuc2YuZ2V0Q29uZmlnKCkudG9rZW5JbmZvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiBpcyBhY3RpdmUgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGlzVXAgPSBzZXJ2aWNlcy5zZi5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNVcCBjYWxsZWQuIFJldHVybmluZzogJXMnLCB0aGlzLmdldElkKCksIGlzVXApO1xuICAgICAgICByZXR1cm4gaXNVcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2Vzc2lvbiB0b2tlbiBhbmQgbWFzdGVyIHRva2VuIGFyZSB2YWxpZFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1Rva2VuVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpc1Rva2VuVmFsaWQgY2FsbGVkJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgY29uc3QgdG9rZW5JbmZvID0gc2VydmljZXMuc2YuZ2V0Q29uZmlnKCkudG9rZW5JbmZvO1xuICAgICAgICBjb25zdCBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA9IHRva2VuSW5mby5zZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICAgICAgY29uc3QgaXNTZXNzaW9uVmFsaWQgPSBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA+IERhdGUubm93KCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpc1Nlc3Npb25Ub2tlblZhbGlkOiAlcycsIHRoaXMuZ2V0SWQoKSwgaXNTZXNzaW9uVmFsaWQpO1xuICAgICAgICBjb25zdCBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lID0gdG9rZW5JbmZvLm1hc3RlclRva2VuRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGNvbnN0IGlzTWFzdGVyVmFsaWQgPSBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lID4gRGF0ZS5ub3coKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGlzTWFzdGVyVG9rZW5WYWxpZDogJXMnLCB0aGlzLmdldElkKCksIGlzTWFzdGVyVmFsaWQpO1xuICAgICAgICBjb25zdCBhcmVUb2tlbnNWYWxpZCA9IGlzU2Vzc2lvblZhbGlkICYmIGlzTWFzdGVyVmFsaWQ7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpc1Rva2VuVmFsaWQgcmV0dXJuZWQ6ICVzJywgdGhpcy5nZXRJZCgpLCBhcmVUb2tlbnNWYWxpZCk7XG4gICAgICAgIHJldHVybiBhcmVUb2tlbnNWYWxpZDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2VydmljZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlcy5zZi5nZXRTZXJ2aWNlTmFtZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRKc1RyZWF0SW50ZWdlckFzQmlnSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29ubmVjdGlvbiBpZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG4gICAgdGhpcy5oZWFydGJlYXQgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0lzc3VpbmcgaGVhcnRiZWF0IGNhbGwnKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdXVpZHY0KCk7XG4gICAgICAgIHNlcnZpY2VzLnNmLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmw6IFVybC5mb3JtYXQoe1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAnL3Nlc3Npb24vaGVhcnRiZWF0JyxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IFF1ZXJ5U3RyaW5nLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjYWxsYmFjazogVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgID8gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Vycm9yIGlzc3VpbmcgaGVhcnRiZWF0IGNhbGw6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0hlYXJ0YmVhdCByZXNwb25zZSAlcycsIEpTT04uc3RyaW5naWZ5KGJvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5oZWFydGJlYXRBc3luYyA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHZlcnNpb24gb2YgZHJpdmVyIGNhbGxlZCBgc2VsZWN0IDE7YCB3aGljaCByZXN1bHQgaW4gYFsgeyAnMSc6IDEgfSBdYFxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0lzc3VpbmcgYXN5bmMgaGVhcnRiZWF0IGNhbGwnKTtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0KChlcnIpID0+IChlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoW3sgMTogMSB9XSkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMuaXNWYWxpZEFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNWYWxpZEFzeW5jIGNhbGxlZCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIGlmICghdGhpcy5pc1VwKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5oZWFydGJlYXRBc3luYygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBoZWFydGJlYXQgZmFpbGVkOiAlcycsIHRoaXMuZ2V0SWQoKSwgSlNPTi5zdHJpbmdpZnkoZSwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZSkpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwcml2YXRlIGxpbmsgYXMgdGhlIE9DU1AgY2FjaGUgc2VydmVyJ3MgVVJMLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhvc3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc2V0dXBPY3NwUHJpdmF0ZUxpbmsgPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICBwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9VUkwgPSBVdGlsLmNyZWF0ZU9jc3BSZXNwb25zZUNhY2hlU2VydmVyVXJsKGhvc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyBjYWxsYmFjayBmdW5jdGlvbiBmb3IgY29ubmVjdCgpIC0gdXNlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGZcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbm5lY3RDYWxsYmFjayhzZWxmLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IEtFRVBfQUxJVkVfSEVBUlRCRUFUX0ZSRVFVRU5DWV9JTl9NUyA9IFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1kpICpcbiAgICAgICAgICAgICAgICAgICAgU0VDT05EU19UT19NSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcbiAgICAgICAgICAgICAgICBzZWxmLmtlZXBhbGl2ZSA9IHNldEludGVydmFsKHNlbGYuaGVhcnRiZWF0LCBLRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1lfSU5fTVMsIHNlbGYpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBrZWVwQWxpdmUgaW50ZXJuYWwgY3JlYXRlZCcsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3JzLmV4dGVybmFsaXplKGVyciksIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmRldGVybWluZUNvbm5lY3Rpb25Eb21haW4gPSAoKSA9PiBjb25uZWN0aW9uQ29uZmlnLmFjY2Vzc1VybCAmJiBjb25uZWN0aW9uQ29uZmlnLmFjY2Vzc1VybC5pbmNsdWRlcygnc25vd2ZsYWtlY29tcHV0aW5nLmNuJylcbiAgICAgICAgPyAnQ0hJTkEnXG4gICAgICAgIDogJ0dMT0JBTCc7XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIGlmIHdlIGFyZW4ndCBpbiBhIGZhdGFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBjb25uZWN0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgRXhlY3V0aW9uVGltZXIoKS5zdGFydCgpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uRG9tYWluID0gdGhpcy5kZXRlcm1pbmVDb25uZWN0aW9uRG9tYWluKCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RpbmcuIEFzc29jaWF0ZWQgU25vd2ZsYWtlIGRvbWFpbjogJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3Rpb25Eb21haW4pO1xuICAgICAgICAvLyBpbnZhbGlkIGNhbGxiYWNrXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoIVV0aWwuZXhpc3RzKGNhbGxiYWNrKSB8fCBVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spLCBFcnJvckNvZGVzLkVSUl9DT05OX0NPTk5FQ1RfSU5WQUxJRF9DQUxMQkFDSyk7XG4gICAgICAgIGlmIChVdGlsLmV4aXN0cyhjb25uZWN0aW9uQ29uZmlnLmhvc3QpICYmIFV0aWwuaXNQcml2YXRlTGluayhjb25uZWN0aW9uQ29uZmlnLmhvc3QpKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBzZXR0aW5nIHVwIHByaXZhdGUgbGluaycsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICB0aGlzLnNldHVwT2NzcFByaXZhdGVMaW5rKGNvbm5lY3Rpb25Db25maWcuaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgc25vd2ZsYWtlIHNlcnZpY2UgYW5kIHByb3ZpZGUgb3VyIG93biBjYWxsYmFjayBzbyB0aGF0XG4gICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIGNhbiBiZSBwYXNzZWQgaW4gd2hlbiBpbnZva2luZyB0aGUgY29ubmVjdGlvbi5jb25uZWN0KClcbiAgICAgICAgLy8gY2FsbGJhY2tcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGF1dGhlbnRpY2F0aW9uVHlwZSA9IGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gdXNpbmcgYXV0aGVudGljYXRpb24gdHlwZTogJXMnLCB0aGlzLmdldElkKCksIGF1dGhlbnRpY2F0aW9uVHlwZSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGF1dGhlbnRpY2F0aW9uIHR5cGUgaXMgY29tcGF0aWJsZSB3aXRoIGNvbm5lY3QoKVxuICAgICAgICAvLyBleHRlcm5hbCBicm93c2VyIGFuZCBva3RhIGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIGNvbm5lY3QoKSBkdWUgdG8gdGhlaXIgdXNhZ2Ugb2YgYXN5bmMgZnVuY3Rpb25zXG4gICAgICAgIGlmIChhdXRoZW50aWNhdGlvblR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuRVhURVJOQUxfQlJPV1NFUl9BVVRIRU5USUNBVE9SIHx8XG4gICAgICAgICAgICBpc09rdGFBdXRoKGF1dGhlbnRpY2F0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gY29ubmVjdGluZyBmYWlsZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzLicgK1xuICAgICAgICAgICAgICAgICdFcnJvcjogRXh0ZXJuYWwgYnJvd3NlciBhbmQgT2t0YSBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCBjb25uZWN0aW9uIHByb2Nlc3MnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvbik7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BVVRIX0NPTk5FQ1QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBhdXRoZW50aWNhdG9yIHRvIHVzZVxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcmV0cmlldmluZyBhdXRoZW50aWNhdG9yJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgY29uc3QgYXV0aCA9IHNlcnZpY2VzLnNmLmdldEF1dGhlbnRpY2F0b3IoKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHRyeWluZyB0byBhdXRoZW50aWNhdGUnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICBhdXRoXG4gICAgICAgICAgICAuYXV0aGVudGljYXRlKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLCBjb25uZWN0aW9uQ29uZmlnLmdldFNlcnZpY2VOYW1lKCksIGNvbm5lY3Rpb25Db25maWcuYWNjb3VudCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWwgdXNpbmc6ICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSk7XG4gICAgICAgICAgICAvLyBKU09OIGZvciBjb25uZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBib2R5ID0gQXV0aGVudGljYXRvci5mb3JtQXV0aEpTT04oY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCksIGNvbm5lY3Rpb25Db25maWcuYWNjb3VudCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRUeXBlKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VmVyc2lvbigpLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudEVudmlyb25tZW50KCkpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIEpTT04gYm9keSB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgIGF1dGgudXBkYXRlQm9keShib2R5KTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpbml0aWFsaXppbmcgZWFzeUxvZ2dpbmcnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgaW5pdEVhc3lMb2dnaW5nKGNvbm5lY3Rpb25Db25maWcuY2xpZW50Q29uZmlnRmlsZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGVhc3lMb2dnaW5nIGluaXRpYWxpemVkJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gY29ubmVjdGluZyB0aHJvdWdoIHNlcnZpY2UnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlcy5zZi5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjb25uZWN0Q2FsbGJhY2soc2VsZiwgY2FsbGJhY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbjogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RlZCBzdWNjZXNzZnVsbHkgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgZXhwZWN0IGFuIGVycm9yIGhlcmUgc2luY2UgY2FsbGJhY2sgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIC0gZmFpbGVkIHRvIGNvbm5lY3QgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdFcnJvcjogVW5leHBlY3RlZCBlcnJvciBmcm9tIGNhbGxpbmcgY29ubmVjdENhbGxiYWNrIGZ1bmN0aW9uIGluIHNub3dmbGFrZSBzZXJ2aWNlIC0gJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvbiwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCB0byBpbml0aWFsaXplIGVhc3lMb2dnaW5nLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0Nvbm5lY3RpbmcgZmFpbGVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGluZ0R1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0xJRU5UX0NPTkZJRywgdHJ1ZSksIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gYXV0aGVudGljYXRpb24gZmFpbGVkLiBFcnJvcjogJXMuICcgK1xuICAgICAgICAgICAgICAgICdDb25uZWN0aW5nIGZhaWxlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMnLCB0aGlzLmdldElkKCksIGVyciwgY29ubmVjdGluZ0R1cmF0aW9uKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2VsZik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiBpZiB3ZSBhcmVuJ3QgaW4gYSBmYXRhbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgY29ubmVjdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5jb25uZWN0QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgRXhlY3V0aW9uVGltZXIoKS5zdGFydCgpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW5nRG9tYWluID0gdGhpcy5kZXRlcm1pbmVDb25uZWN0aW9uRG9tYWluKCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGFzeW5jIGNvbm5lY3RpbmcuIEFzc29jaWF0ZWQgU25vd2ZsYWtlIGRvbWFpbjogJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEb21haW4pO1xuICAgICAgICAvLyBpbnZhbGlkIGNhbGxiYWNrXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoIVV0aWwuZXhpc3RzKGNhbGxiYWNrKSB8fCBVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spLCBFcnJvckNvZGVzLkVSUl9DT05OX0NPTk5FQ1RfSU5WQUxJRF9DQUxMQkFDSyk7XG4gICAgICAgIGlmIChVdGlsLmlzUHJpdmF0ZUxpbmsoY29ubmVjdGlvbkNvbmZpZy5ob3N0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cE9jc3BQcml2YXRlTGluayhjb25uZWN0aW9uQ29uZmlnLmhvc3QpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIC0gc2V0dGluZyB1cCBwcml2YXRlIGxpbmsnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIHNub3dmbGFrZSBzZXJ2aWNlIGFuZCBwcm92aWRlIG91ciBvd24gY2FsbGJhY2sgc28gdGhhdFxuICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiBjYW4gYmUgcGFzc2VkIGluIHdoZW4gaW52b2tpbmcgdGhlIGNvbm5lY3Rpb24uY29ubmVjdCgpXG4gICAgICAgIC8vIGNhbGxiYWNrXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHN0b3JpbmcgdGVtcG9yYXJ5IGNyZWRlbnRpYWwgb2YgY2xpZW50JywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IFV0aWwuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoY29ubmVjdGlvbkNvbmZpZy5ob3N0LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLklEX1RPS0VOX0FVVEhFTlRJQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHVzaW5nIGRlZmF1bHQganNvbiBjcmVkZW50aWFsIG1hbmFnZXInLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgICAgIEdsb2JhbENvbmZpZy5zZXRDdXN0b21DcmVkZW50aWFsTWFuYWdlcihuZXcgSnNvbkNyZWRlbnRpYWxNYW5hZ2VyKGNvbm5lY3Rpb25Db25maWcuZ2V0Q3JlZGVudGlhbENhY2hlRGlyKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSByZWFkaW5nIGlkVG9rZW4gdXNpbmcgY3JlZGVudGlhbCBtYW5hZ2VyJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Db25maWcuaWRUb2tlbiA9IGF3YWl0IEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLnJlYWQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRSZXF1ZXN0TUZBVG9rZW4oKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGV4dHJhY3RpbmcgbWZhVG9rZW4gb2YgY2xpZW50JywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IFV0aWwuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoY29ubmVjdGlvbkNvbmZpZy5ob3N0LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLlVTRVJfUFdEX01GQV9BVVRIRU5USUNBVE9SKTtcbiAgICAgICAgICAgIGlmIChHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB1c2luZyBkZWZhdWx0IGpzb24gY3JlZGVudGlhbCBtYW5hZ2VyJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxDb25maWcuc2V0Q3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIobmV3IEpzb25DcmVkZW50aWFsTWFuYWdlcihjb25uZWN0aW9uQ29uZmlnLmdldENyZWRlbnRpYWxDYWNoZURpcigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcmVhZGluZyBtZmFUb2tlbiB1c2luZyBjcmVkZW50aWFsIG1hbmFnZXInLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5tZmFUb2tlbiA9IGF3YWl0IEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLnJlYWQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgYXV0aGVudGljYXRvciB0byB1c2VcbiAgICAgICAgbGV0IGF1dGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcmV0cmlldmluZyBhdXRoZW50aWNhdG9yJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGF1dGggPSBBdXRoZW50aWNhdG9yLmdldEF1dGhlbnRpY2F0b3IoY29ubmVjdGlvbkNvbmZpZywgY29udGV4dC5nZXRIdHRwQ2xpZW50KCkpO1xuICAgICAgICAgICAgc2VydmljZXMuc2YuYXV0aGVudGljYXRvciA9IGF1dGg7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCB0byBpbml0aWFsaXplIGF1dGhlbnRpY2F0b3IuICcgK1xuICAgICAgICAgICAgICAgICdDb25uZWN0aW5nIGZhaWxlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvbik7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BVVRIX1VOU1VQUE9SVEVELCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGluaXRpYWxpemluZyBlYXN5TG9nZ2luZycsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBhd2FpdCBpbml0RWFzeUxvZ2dpbmcoY29ubmVjdGlvbkNvbmZpZy5jbGllbnRDb25maWdGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCB0byBpbml0aWFsaXplIGVhc3lMb2dnaW5nLiAnICtcbiAgICAgICAgICAgICAgICAnQ29ubmVjdGluZyBmYWlsZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24pO1xuICAgICAgICAgICAgdGhyb3cgRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9JTlZBTElEX0NMSUVOVF9DT05GSUcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB1c2luZyBhdXRoZW50aWNhdGlvbiB0eXBlOiAlcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCkpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHRyeWluZyB0byBhdXRoZW50aWNhdGUnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgYXdhaXQgYXV0aC5hdXRoZW50aWNhdGUoY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0U2VydmljZU5hbWUoKSwgY29ubmVjdGlvbkNvbmZpZy5hY2NvdW50LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWwgdXNpbmc6ICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSk7XG4gICAgICAgICAgICAvLyBKU09OIGZvciBjb25uZWN0aW9uXG4gICAgICAgICAgICBib2R5ID0gQXV0aGVudGljYXRvci5mb3JtQXV0aEpTT04oY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCksIGNvbm5lY3Rpb25Db25maWcuYWNjb3VudCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRUeXBlKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VmVyc2lvbigpLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudEVudmlyb25tZW50KCkpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIEpTT04gYm9keSB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgIGF1dGgudXBkYXRlQm9keShib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoYXV0aEVycikge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCB0byBjb25uZWN0IGFzeW5jIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4nICtcbiAgICAgICAgICAgICAgICAnRmFpbGVkIGR1cmluZyBhdXRoZW50aWNhdGlvbi4gRXJyb3I6ICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24sIGF1dGhFcnIpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCBkdXJpbmcgYXV0aGVudGljYXRpb24uIEVycm9yOiAlcycsIHRoaXMuZ2V0SWQoKSwgYXV0aEVycik7XG4gICAgICAgICAgICBjYWxsYmFjayhhdXRoRXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNvbm5lY3Rpb25cbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0aW5nIHRocm91Z2ggc2VydmljZScsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBzZXJ2aWNlcy5zZi5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY29ubmVjdENhbGxiYWNrKHNlbGYsIGNhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICBqc29uOiBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGNvbm5lY3Rpb24gdG8gZmFjaWxpdGF0ZSBjaGFpbmluZ1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RlZCBzdWNjZXNzZnVsbHkgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYWxsYmFja0Vycikge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCB0byBjb25uZWN0IGFzeW5jIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4nICtcbiAgICAgICAgICAgICAgICAnRXJyb3I6IFVuZXhwZWN0ZWQgZXJyb3IgZnJvbSBjYWxsaW5nIGNvbm5lY3RDYWxsYmFjayBmdW5jdGlvbiBpbiBzbm93Zmxha2Ugc2VydmljZSAtICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24sIGNhbGxiYWNrRXJyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGxiYWNrRXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZXhlY3V0ZSBjYWxsZWQgd2l0aCBvcHRpb25zLicsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHJldHVybiBTdGF0ZW1lbnQuY3JlYXRlU3RhdGVtZW50UHJlRXhlYyhvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSByZXN1bHQgb2YgYSBwcmV2aW91c2x5IGlzc3VlZCBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmZldGNoUmVzdWx0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZldGNoUmVzdWx0IGNhbGxlZCB3aXRoIG9wdGlvbnMnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICByZXR1cm4gU3RhdGVtZW50LmNyZWF0ZVN0YXRlbWVudFBvc3RFeGVjKG9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IHRlcm1pbmF0ZXMgdGhlIGNvbm5lY3Rpb24gd2l0aG91dCB3YWl0aW5nIGZvciBjdXJyZW50bHlcbiAgICAgKiBleGVjdXRpbmcgc3RhdGVtZW50cyB0byBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgY29ubmVjdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGludmFsaWQgY2FsbGJhY2tcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGRlc3Ryb3kgY2FsbGVkJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZCghVXRpbC5leGlzdHMoY2FsbGJhY2spIHx8IFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjayksIEVycm9yQ29kZXMuRVJSX0NPTk5fREVTVFJPWV9JTlZBTElEX0NBTExCQUNLKTtcbiAgICAgICAgLy8gbG9nIG91dCBvZiB0aGUgc25vd2ZsYWtlIHNlcnZpY2UgYW5kIHByb3ZpZGUgb3VyIG93biBjYWxsYmFjayBzbyB0aGF0XG4gICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIGNhbiBiZSBwYXNzZWQgaW4gd2hlbiBpbnZva2luZyB0aGUgY29ubmVjdGlvbi5kZXN0cm95KClcbiAgICAgICAgLy8gY2FsbGJhY2tcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGRlc3Ryb3lpbmcgdGhyb3VnaCBzZXJ2aWNlJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlcnZpY2VzLnNmLmRlc3Ryb3koe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoc2VsZi5rZWVwYWxpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5rZWVwYWxpdmUpO1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0ga2VlcEFsaXZlIGludGVydmFsIGNsZWFyZWQnLCBzZWxmLmdldElkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcnMuZXh0ZXJuYWxpemUoZXJyKSwgc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0aW9uIGRlc3Ryb3llZCBzdWNjZXNzZnVsbHknLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAvLyByZXR1cm4gdGhlIGNvbm5lY3Rpb24gdG8gZmFjaWxpdGF0ZSBjaGFpbmluZ1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIHN0YXR1cyBvZiB0aGUgcXVlcnkgYmFzZWQgb24gcXVlcnlJZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeUlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcXVlcnkgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRRdWVyeVJlc3BvbnNlKHF1ZXJ5SWQpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHJlcXVlc3RlZCBxdWVyeSByZXNwb25zZSBmb3IgUXVlcnlbaWQ6ICVzXScsIGlkLCBxdWVyeUlkKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcXVlcnlJZCBleGlzdHMgYW5kIGlzIHZhbGlkIHV1aWRcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMocXVlcnlJZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfUVVFUllfSUQpO1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKHF1ZXJ5SWRSZWdleC50ZXN0KHF1ZXJ5SWQpLCBFcnJvckNvZGVzLkVSUl9HRVRfUkVTUE9OU0VfUVVFUllfSU5WQUxJRF9VVUlELCBxdWVyeUlkKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIFF1ZXJ5W2lkOiAlc10gaXMgdmFsaWQnLCBpZCwgcXVlcnlJZCk7XG4gICAgICAgIC8vIEZvcm0gdGhlIHJlcXVlc3Qgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHVybDogVXJsLmZvcm1hdCh7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IGAvbW9uaXRvcmluZy9xdWVyaWVzLyR7cXVlcnlJZH1gLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmZXRjaGluZyBxdWVyeSByZXNwb25zZSBmb3IgUXVlcnlbaWQ6ICVzXScsIGlkLCBxdWVyeUlkKTtcbiAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgRXhlY3V0aW9uVGltZXIoKS5zdGFydCgpO1xuICAgICAgICAvLyBHZXQgdGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5IHN0YXR1c1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlcnZpY2VzLnNmLnJlcXVlc3RBc3luYyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZmV0Y2hpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBxdWVyeSByZXNwb25zZSBmb3IgUXVlcnlbaWQ6ICVzXSBmZXRjaGVkIHN1Y2Nlc3NmdWxseSBhZnRlcjogJXMgbWlsbGlzZWNvbmRzJywgaWQsIHF1ZXJ5SWQsIGZldGNoaW5nRHVyYXRpb24pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHN0YXR1cyBvZiB0aGUgcXVlcnkgZnJvbSB0aGUgcXVlcnkgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcXVlcnlSZXNwb25zZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHF1ZXJ5IHN0YXR1cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRyYWN0UXVlcnlTdGF0dXMocXVlcnlSZXNwb25zZSkge1xuICAgICAgICBsZXQgc3RhdHVzID0gUXVlcnlTdGF0dXMuY29kZS5OT19RVUVSWV9EQVRBOyAvLyBkZWZhdWx0IHN0YXR1c1xuICAgICAgICBpZiAoIXF1ZXJ5UmVzcG9uc2UgfHwgIXF1ZXJ5UmVzcG9uc2VbJ2RhdGEnXSB8fCAhcXVlcnlSZXNwb25zZVsnZGF0YSddWydxdWVyaWVzJ10pIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBObyBxdWVyeSBkYXRhIGZvdW5kLCByZXR1cm5pbmcgTk9fUVVFUllfREFUQSBzdGF0dXMnLCBpZCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBxdWVyeVJlc3BvbnNlWydkYXRhJ11bJ3F1ZXJpZXMnXTtcbiAgICAgICAgaWYgKHF1ZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdHVzID0gcXVlcmllc1swXVsnc3RhdHVzJ107XG4gICAgICAgIH1cbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIEV4dHJhY3RlZCBxdWVyeSBzdGF0dXM6ICVzJywgaWQsIHN0YXR1cyk7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXR1cyBvZiB0aGUgcXVlcnkgYmFzZWQgb24gcXVlcnlJZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeUlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcXVlcnkgc3RhdHVzLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0UXVlcnlTdGF0dXMgPSBhc3luYyBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZ2V0UXVlcnlTdGF0dXMgY2FsbGVkIGZvciBRdWVyeVtpZDogJXNdJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkKTtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RRdWVyeVN0YXR1cyhhd2FpdCBnZXRRdWVyeVJlc3BvbnNlKHF1ZXJ5SWQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXR1cyBvZiB0aGUgcXVlcnkgYmFzZWQgb24gcXVlcnlJZCBhbmQgdGhyb3dzIGlmIHRoZXJlJ3MgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlJZFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHF1ZXJ5IHN0YXR1cy5cbiAgICAgKi9cbiAgICB0aGlzLmdldFF1ZXJ5U3RhdHVzVGhyb3dJZkVycm9yID0gYXN5bmMgZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGdldFF1ZXJ5U3RhdHVzVGhyb3dJZkVycm9yIGNhbGxlZCBmb3IgUXVlcnlbaWQ6ICVzXScsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0UXVlcnlSZXNwb25zZShxdWVyeUlkKTsgLy8gcmV0dXJucyByZXNwb25zZVsnZGF0YSddXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGV4dHJhY3RRdWVyeVN0YXR1cyhyZXNwb25zZSk7XG4gICAgICAgIGxldCBzcWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzQW5FcnJvcihzdGF0dXMpKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHJlc3BvbnNlWydtZXNzYWdlJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcmVzcG9uc2VbJ2NvZGUnXSB8fCAtMTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnZGF0YSddKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVsnZGF0YSddWydxdWVyaWVzJ10ubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZVsnZGF0YSddWydxdWVyaWVzJ11bMF1bJ2Vycm9yTWVzc2FnZSddXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIHNxbFN0YXRlID0gcmVzcG9uc2VbJ2RhdGEnXVsnc3FsU3RhdGUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBxdWVyeSBlcnJvciBmb3IgUXVlcnlbaWQ6ICVzXS4gRXJyb3I6ICVzLiBTUUxTdGF0ZTogJXMnLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIG1lc3NhZ2UsIHNxbFN0YXRlKTtcbiAgICAgICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVPcGVyYXRpb25GYWlsZWRFcnJvcihjb2RlLCByZXNwb25zZSwgbWVzc2FnZSwgc3FsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZXN1bHRzIGZyb20gYSBwcmV2aW91c2x5IHJhbiBxdWVyeSBiYXNlZCBvbiBxdWVyeUlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldFJlc3VsdHNGcm9tUXVlcnlJZCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBvcHRpb25zLnF1ZXJ5SWQ7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBnZXRSZXN1bHRzRnJvbVF1ZXJ5SWQgY2FsbGVkIGZvciBRdWVyeVtpZDogJXNdLicsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCk7XG4gICAgICAgIGxldCBzdGF0dXMsIG5vRGF0YUNvdW50ZXIgPSAwLCByZXRyeVBhdHRlcm5Qb3MgPSAwO1xuICAgICAgICAvLyBXYWl0IHVudGlsIHF1ZXJ5IGhhcyBmaW5pc2hlZCBleGVjdXRpbmdcbiAgICAgICAgbGV0IHF1ZXJ5U3RpbGxFeGVjdXRpbmcgPSB0cnVlO1xuICAgICAgICB3aGlsZSAocXVlcnlTdGlsbEV4ZWN1dGluZykge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNoZWNraW5nIGlmIFF1ZXJ5W2lkOiAlc10gaXMgc3RpbGwgZXhlY3V0aW5nLiBSZXRyaWVzIHdpdGggbm8gZGF0YSBjb3VudDogJWQnLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIG5vRGF0YUNvdW50ZXIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcXVlcnkgaXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgZXhjZXB0aW9uIGlmIGl0IGZhaWxlZCBvciB0aGVyZSBpcyBubyBxdWVyeSBkYXRhIGluIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBzdGF0dXMgPSBhd2FpdCB0aGlzLmdldFF1ZXJ5U3RhdHVzVGhyb3dJZkVycm9yKHF1ZXJ5SWQpO1xuICAgICAgICAgICAgcXVlcnlTdGlsbEV4ZWN1dGluZyA9IHRoaXMuaXNTdGlsbFJ1bm5pbmcoc3RhdHVzKTtcbiAgICAgICAgICAgIGlmICghcXVlcnlTdGlsbEV4ZWN1dGluZyB8fCBzdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLmNvZGUuTk9fUVVFUllfREFUQSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBlbmQgb2Ygd2FpdGluZyBmb3IgUXVlcnlbaWQ6ICVzXSB0byBmaW5pc2ggZXhlY3V0aW5nLiAnICtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlTdGlsbEV4ZWN1dGluZ1xuICAgICAgICAgICAgICAgICAgICA/ICdRdWVyeSBpcyBubyBsb25nZXIgZXhlY3V0aW5nLiAnXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyAnUXVlcnkgc3RhdHVzOiAlcy4nLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lb3V0IGJhc2VkIG9uIHF1ZXJ5IHN0YXR1cyByZXRyeSBydWxlc1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgYXN5bmNSZXRyeUluTWlsbGlzZWNvbmRzICogYXN5bmNSZXRyeVBhdHRlcm5bcmV0cnlQYXR0ZXJuUG9zXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIG5vIGRhdGEsIGluY3JlbWVudCB0aGUgbm8gZGF0YSBjb3VudGVyXG4gICAgICAgICAgICBpZiAoUXVlcnlTdGF0dXMuY29kZVtzdGF0dXNdID09PSBRdWVyeVN0YXR1cy5jb2RlLk5PX0RBVEEpIHtcbiAgICAgICAgICAgICAgICBub0RhdGFDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIG5vIGRhdGEgcmV0dXJuZWQgZm9yIFF1ZXJ5W2lkOiAlc10uIFJldHJpZXMgd2l0aCBubyBkYXRhIGNvdW50OiAlZCcsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCwgbm9EYXRhQ291bnRlcik7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcmV0cnkgZm9yIG5vIGRhdGEgaXMgZXhjZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAobm9EYXRhQ291bnRlciA+IGFzeW5jTm9EYXRhTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIG5vIGRhdGEgcmV0dXJuZWQgZm9yIFF1ZXJ5W2lkOiAlc10uIFJldHJ5IGxpbWl0OiAlcyByZWFjaGVkLicsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCwgYXN5bmNOb0RhdGFNYXhSZXRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9HRVRfUkVTVUxUU19RVUVSWV9JRF9OT19EQVRBLCB0cnVlLCBxdWVyeUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0cnlQYXR0ZXJuUG9zIDwgYXN5bmNSZXRyeVBhdHRlcm4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHJ5UGF0dGVyblBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChRdWVyeVN0YXR1cy5jb2RlW3N0YXR1c10gPT09IFF1ZXJ5U3RhdHVzLmNvZGUuTk9fUVVFUllfREFUQSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIFF1ZXJ5W2lkOiAlc10gZGlkIG5vdCBzdWNjZWVkLiBGaW5hbCBzdGF0dXM6ICVzJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgICAgICAgdGhyb3cgRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0dFVF9SRVNVTFRTX1FVRVJZX0lEX05PX0RBVEEsIHRydWUsIHF1ZXJ5SWQsIHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFF1ZXJ5U3RhdHVzLmNvZGVbc3RhdHVzXSAhPT0gUXVlcnlTdGF0dXMuY29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gUXVlcnlbaWQ6ICVzXSBkaWQgbm90IHN1Y2NlZWQuIEZpbmFsIHN0YXR1czogJXMnLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIHN0YXR1cyk7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfR0VUX1JFU1VMVFNfUVVFUllfSURfTk9UX1NVQ0NFU1NfU1RBVFVTLCB0cnVlLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBRdWVyeVtpZDogJXNdIHN1Y2NlZWRlZC4gRmV0Y2hpbmcgdGhlIHJlc3VsdC4nLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFJlc3VsdChvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBzdGF0dXMgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzU3RpbGxSdW5uaW5nID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gY2hlY2tpbmcgaWYgc3RhdHVzICVzIGlzIHN0aWxsIHJ1bm5pbmcnLCB0aGlzLmdldElkKCksIHN0YXR1cyk7XG4gICAgICAgIHJldHVybiBRdWVyeVN0YXR1cy5ydW5uaW5nU3RhdHVzZXMuaW5jbHVkZXMoUXVlcnlTdGF0dXMuY29kZVtzdGF0dXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBzdGF0dXMgbWVhbnMgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0dXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNBbkVycm9yID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gUXVlcnlTdGF0dXMuZXJyb3JTdGF0dXNlcy5pbmNsdWRlcyhRdWVyeVN0YXR1cy5jb2RlW3N0YXR1c10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGlzIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gc2VyaWFsaXplIGNhbGxlZCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb250ZXh0LmdldENvbmZpZygpKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuVXRpbC5pbmhlcml0cyhDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ConnectionConstants = __webpack_require__(/*! ../constants/connection_constants */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst ErrorCodes = Errors.codes;\nconst NativeTypes = (__webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\").NativeTypes);\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst levenshtein = __webpack_require__(/*! fastest-levenshtein */ \"(rsc)/./node_modules/fastest-levenshtein/esm/mod.js\");\nconst RowMode = __webpack_require__(/*! ./../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\nconst DataTypes = __webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { isSnowflakeHost } = __webpack_require__(/*! ../authentication/authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst WAIT_FOR_BROWSER_ACTION_TIMEOUT = 120000;\nconst SNOWFLAKE_AUTHORIZE_ENDPOINT = '/oauth/authorize';\nconst SNOWFLAKE_TOKEN_REQUEST_ENDPOINT = '/oauth/token-request';\nconst LOCAL_APPLICATION_CLIENT_CREDENTIAL = 'LOCAL_APPLICATION';\nconst DEFAULT_PARAMS = [\n    'account',\n    'application',\n    'region',\n    'host',\n    'accessUrl',\n    'username',\n    'password',\n    'authenticator',\n    'proxyHost',\n    'proxyPort',\n    'serviceName',\n    'privateKey',\n    'privateKeyPath',\n    'privateKeyPass',\n    'token',\n    'warehouse',\n    'database',\n    'schema',\n    'role',\n    'rowMode',\n    'streamResult',\n    'fetchAsString',\n    'clientSessionKeepAlive',\n    'clientSessionKeepAliveHeartbeatFrequency',\n    'jsTreatIntegerAsBigInt',\n    'sessionToken',\n    'masterToken',\n    'sessionTokenExpirationTime',\n    'masterTokenExpirationTime',\n    'agentClass',\n    'validateDefaultParameters',\n    'arrayBindingThreshold',\n    'gcsUseDownscopedCredential',\n    'forceStageBindError',\n    'includeRetryReason',\n    'disableQueryContextCache',\n    'retryTimeout',\n    'clientRequestMFAToken',\n    'clientStoreTemporaryCredential',\n    'disableConsoleLogin',\n    'forceGCPUseDownscopedCredential',\n    'representNullAsStringNull',\n    'disableSamlURLCheck',\n    'credentialCacheDir',\n    'passcodeInPassword',\n    'passcode',\n    'oauthClientId',\n    'oauthClientSecret',\n    'oauthRedirectUri',\n    'oauthAuthorizationUrl',\n    'oauthTokenRequestUrl',\n    'oauthScope',\n    'oauthChallengeMethod',\n    'oauthHttpAllowed', //only for tests\n    'workloadIdentityProvider',\n    'workloadIdentityImpersonationPath',\n    'workloadIdentityAzureEntraIdResource',\n    'workloadIdentityAzureClientId',\n    'queryTag',\n    'certRevocationCheckMode',\n    'crlAllowCertificatesWithoutCrlURL',\n    'crlInMemoryCache',\n    'crlOnDiskCache',\n];\nfunction consolidateHostAndAccount(options) {\n    let dotPos = -1;\n    let realAccount = undefined;\n    let realRegion = undefined;\n    const protocol = options.protocol || 'https';\n    const port = Util.exists(options.port) ? Util.format(':%s', options.port) : '';\n    if (Util.exists(options.region)) {\n        Errors.checkArgumentValid(Util.isCorrectSubdomain(options.region), ErrorCodes.ERR_CONN_CREATE_INVALID_REGION_REGEX);\n        realRegion = options.region;\n    }\n    if (Util.exists(options.account)) {\n        Errors.checkArgumentValid(Util.isString(options.account), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCOUNT);\n        Errors.checkArgumentValid(Util.isCorrectSubdomain(options.account), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX);\n        dotPos = options.account.indexOf('.');\n        realAccount = options.account;\n        if (dotPos > 0) {\n            realRegion = realAccount.substring(dotPos + 1);\n            realAccount = realAccount.substring(0, dotPos);\n        }\n    }\n    if (Util.exists(options.accessUrl)) {\n        //accessUrl is set in configuration\n        try {\n            const parsedUrl = url.parse(options.accessUrl);\n            Errors.checkArgumentValid(Util.exists(parsedUrl.hostname), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCESS_URL);\n            if (!Util.exists(options.host)) {\n                options.host = parsedUrl.hostname;\n            }\n            const dotPos = parsedUrl.hostname.indexOf('.');\n            if (dotPos > 0 && !Util.exists(options.account)) {\n                realAccount = parsedUrl.hostname.substring(0, dotPos);\n            }\n        }\n        catch (e) {\n            Errors.checkArgumentValid(false, ErrorCodes.ERR_CONN_CREATE_MISSING_ACCOUNT);\n        }\n    }\n    else if (Util.exists(options.host)) {\n        //host is set in configuration\n        options.accessUrl = Util.format('%s://%s%s', protocol, options.host, port);\n        const dotPos = options.host.indexOf('.');\n        if (dotPos > 0 && !Util.exists(options.account)) {\n            realAccount = options.host.substring(0, dotPos);\n        }\n        else {\n            realAccount = options.account;\n        }\n    }\n    else if (Util.exists(options.account)) {\n        //only account() is set in configuration\n        if (options.region === 'us-west-2') {\n            options.region = '';\n        }\n        options.host = Util.constructHostname(realRegion, realAccount);\n        options.accessUrl = Util.format('%s://%s%s', protocol, options.host, port);\n    }\n    if (Util.exists(realAccount) && options.accessUrl.includes('global.snowflakecomputing')) {\n        const dashPos = realAccount.indexOf('-');\n        if (dashPos > 0) {\n            // global URL\n            realAccount = realAccount.substring(0, dashPos);\n        }\n    }\n    options.account = realAccount;\n    options.region = realRegion;\n    // check for missing accessURL\n    Errors.checkArgumentExists(Util.exists(options.account), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCOUNT);\n    // check for missing account\n    Errors.checkArgumentExists(Util.exists(options.accessUrl), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCESS_URL);\n}\n/**\n * A Connection configuration object that should be available to all stateful\n * objects in the driver.\n *\n * @param {Object} options\n * @param {Boolean} [validateCredentials]\n * @param {Boolean} [qaMode]\n * @param {Object} [clientInfo]\n *\n * @constructor\n */\nfunction ConnectionConfig(options, validateCredentials, qaMode, clientInfo) {\n    // if no value is specified for the validate credentials flag, default to true\n    if (!Util.exists(validateCredentials)) {\n        validateCredentials = true;\n    }\n    // check for missing options\n    Errors.checkArgumentExists(Util.exists(options), ErrorCodes.ERR_CONN_CREATE_MISSING_OPTIONS);\n    // check for invalid options\n    Errors.checkArgumentValid(Util.isObject(options), ErrorCodes.ERR_CONN_CREATE_INVALID_OPTIONS);\n    // only validate credentials if necessary\n    if (validateCredentials) {\n        const noUsernameRequiredFor = [\n            AuthenticationTypes.OAUTH_AUTHENTICATOR,\n            AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR,\n            AuthenticationTypes.PROGRAMMATIC_ACCESS_TOKEN,\n            AuthenticationTypes.OAUTH_CLIENT_CREDENTIALS,\n            AuthenticationTypes.OAUTH_AUTHORIZATION_CODE,\n            AuthenticationTypes.WORKLOAD_IDENTITY,\n        ];\n        if (!options.authenticator ||\n            !noUsernameRequiredFor.includes(options.authenticator.toUpperCase())) {\n            // check for missing username\n            Errors.checkArgumentExists(Util.exists(options.username), ErrorCodes.ERR_CONN_CREATE_MISSING_USERNAME);\n        }\n        if (Util.exists(options.username)) {\n            // check for invalid username\n            Errors.checkArgumentValid(Util.isString(options.username), ErrorCodes.ERR_CONN_CREATE_INVALID_USERNAME);\n        }\n        // password is only required for default authenticator\n        if (!Util.exists(options.authenticator) ||\n            options.authenticator === AuthenticationTypes.DEFAULT_AUTHENTICATOR) {\n            // check for missing password\n            Errors.checkArgumentExists(Util.exists(options.password), ErrorCodes.ERR_CONN_CREATE_MISSING_PASSWORD);\n            // check for invalid password\n            Errors.checkArgumentValid(Util.isString(options.password), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSWORD);\n        }\n        if (!Util.exists(options.authenticator) ||\n            options.authenticator === AuthenticationTypes.PROGRAMMATIC_ACCESS_TOKEN) {\n            // PASSWORD or TOKEN is needed\n            Errors.checkArgumentExists(Util.exists(options.password) || Util.exists(options.token), ErrorCodes.ERR_CONN_CREATE_MISSING_PASSWORD);\n            if (Util.exists(options.password)) {\n                // check for invalid password\n                Errors.checkArgumentValid(Util.isString(options.password), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSWORD);\n            }\n            if (Util.exists(options.token)) {\n                Errors.checkArgumentValid(Util.isString(options.token), ErrorCodes.ERR_CONN_CREATE_INVALID_OAUTH_TOKEN);\n            }\n        }\n        if (options.authenticator === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE) {\n            if (Util.exists(options.oauthAuthorizationUrl)) {\n                let parsedUrl;\n                try {\n                    parsedUrl = new URL(options.oauthAuthorizationUrl);\n                }\n                catch (error) {\n                    throw Errors.createInvalidParameterError(ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL);\n                }\n                Errors.checkArgumentValid(parsedUrl.protocol === 'https:' || parsedUrl.protocol === 'http:', ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL);\n            }\n            if ((options.oauthAuthorizationUrl && !isSnowflakeHost(options.oauthAuthorizationUrl)) ||\n                (options.oauthTokenRequestUrl && !isSnowflakeHost(options.oauthTokenRequestUrl))) {\n                Errors.checkArgumentValid(Util.isString(options.oauthClientId), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID);\n                Errors.checkArgumentValid(Util.isString(options.oauthClientSecret), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET);\n            }\n        }\n        if (options.authenticator === AuthenticationTypes.OAUTH_CLIENT_CREDENTIALS) {\n            if (Util.exists(options.oauthTokenRequestUrl)) {\n                let parsedUrl;\n                try {\n                    parsedUrl = new URL(options.oauthTokenRequestUrl);\n                }\n                catch (error) {\n                    throw Errors.createInvalidParameterError(ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL);\n                }\n                Errors.checkArgumentValid(parsedUrl.protocol === 'https:' || parsedUrl.protocol === 'http:', ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL);\n            }\n            Errors.checkArgumentValid(Util.isString(options.oauthClientId), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID);\n            Errors.checkArgumentValid(Util.isString(options.oauthClientSecret), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET);\n        }\n        consolidateHostAndAccount(options);\n    }\n    // check for missing accessUrl\n    Errors.checkArgumentExists(Util.exists(options.accessUrl), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCESS_URL);\n    // check for invalid accessUrl\n    Errors.checkArgumentValid(Util.isString(options.accessUrl), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCESS_URL);\n    const proxyHost = options.proxyHost;\n    const proxyPort = options.proxyPort;\n    const proxyUser = options.proxyUser;\n    const proxyPassword = options.proxyPassword;\n    const proxyProtocol = options.proxyProtocol || 'http';\n    const noProxy = options.noProxy;\n    const useForOCSP = options.useConnectionConfigProxyForOCSP ?? false;\n    let oauthClientId = options.oauthClientId;\n    let oauthClientSecret = options.oauthClientSecret;\n    const oauthRedirectUri = options.oauthRedirectUri;\n    const oauthAuthorizationUrl = options.oauthAuthorizationUrl;\n    const oauthTokenRequestUrl = options.oauthTokenRequestUrl;\n    const oauthChallengeMethod = options.oauthChallengeMethod;\n    const oauthScope = options.oauthScope;\n    const oauthHttpAllowed = options.oauthHttpAllowed;\n    // if we're running in node and some proxy information is specified\n    let proxy;\n    if (Util.isNode() && (Util.exists(proxyHost) || Util.exists(proxyPort))) {\n        proxy = {\n            host: proxyHost,\n            port: proxyPort,\n            user: proxyUser,\n            password: proxyPassword,\n            protocol: proxyProtocol,\n            noProxy: noProxy,\n            useForOCSP: useForOCSP,\n        };\n        ProxyUtil.validateProxy(proxy);\n    }\n    const serviceName = options.serviceName;\n    let authenticator = options.authenticator;\n    // if no value is specified for authenticator, default to Snowflake\n    if (!Util.exists(authenticator)) {\n        authenticator = AuthenticationTypes.DEFAULT_AUTHENTICATOR;\n    }\n    else {\n        authenticator = authenticator.toUpperCase();\n    }\n    let browserActionTimeout = options.browserActionTimeout;\n    if (Util.exists(options.browserActionTimeout)) {\n        Errors.checkArgumentValid(Util.number.isPositiveInteger(browserActionTimeout), ErrorCodes.ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT);\n    }\n    else {\n        browserActionTimeout = WAIT_FOR_BROWSER_ACTION_TIMEOUT;\n    }\n    const privateKey = options.privateKey;\n    if (Util.exists(options.privateKey)) {\n        Errors.checkArgumentValid(Util.isString(privateKey) && Util.isPrivateKey(privateKey), ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY);\n    }\n    const privateKeyPath = options.privateKeyPath;\n    if (Util.exists(options.privateKeyPath)) {\n        Errors.checkArgumentValid(Util.isString(privateKeyPath), ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH);\n    }\n    const privateKeyPass = options.privateKeyPass;\n    if (Util.exists(options.privateKeyPass)) {\n        Errors.checkArgumentValid(Util.isString(privateKeyPass), ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS);\n    }\n    const token = options.token;\n    if (Util.exists(token)) {\n        Errors.checkArgumentValid(Util.isString(token), ErrorCodes.ERR_CONN_CREATE_INVALID_OAUTH_TOKEN);\n    }\n    const warehouse = options.warehouse;\n    const database = options.database;\n    const schema = options.schema;\n    const role = options.role;\n    // check for invalid warehouse\n    if (Util.exists(warehouse)) {\n        Errors.checkArgumentValid(Util.isString(warehouse), ErrorCodes.ERR_CONN_CREATE_INVALID_WAREHOUSE);\n    }\n    // check for invalid database\n    if (Util.exists(database)) {\n        Errors.checkArgumentValid(Util.isString(database), ErrorCodes.ERR_CONN_CREATE_INVALID_DATABASE);\n    }\n    // check for invalid schema\n    if (Util.exists(schema)) {\n        Errors.checkArgumentValid(Util.isString(schema), ErrorCodes.ERR_CONN_CREATE_INVALID_SCHEMA);\n    }\n    // check for invalid role\n    if (Util.exists(role)) {\n        Errors.checkArgumentValid(Util.isString(role), ErrorCodes.ERR_CONN_CREATE_INVALID_ROLE);\n    }\n    // check for invalid streamResult\n    const streamResult = options.streamResult;\n    if (Util.exists(streamResult)) {\n        Errors.checkArgumentValid(Util.isBoolean(streamResult), ErrorCodes.ERR_CONN_CREATE_INVALID_STREAM_RESULT);\n    }\n    // check for invalid fetchAsString\n    const fetchAsString = options.fetchAsString;\n    if (Util.exists(fetchAsString)) {\n        // check that the value is an array\n        Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING);\n        // check that all the array elements are valid\n        const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n        Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n    }\n    // Row mode is optional, can be undefined\n    const rowMode = options.rowMode;\n    if (Util.exists(rowMode)) {\n        RowMode.checkRowModeValid(rowMode);\n    }\n    // check for invalid clientSessionKeepAlive\n    const clientSessionKeepAlive = options.clientSessionKeepAlive;\n    if (Util.exists(clientSessionKeepAlive)) {\n        Errors.checkArgumentValid(Util.isBoolean(clientSessionKeepAlive), ErrorCodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE);\n    }\n    // check for invalid clientSessionKeepAliveHeartbeatFrequency\n    let clientSessionKeepAliveHeartbeatFrequency = options.clientSessionKeepAliveHeartbeatFrequency;\n    if (Util.exists(clientSessionKeepAliveHeartbeatFrequency)) {\n        Errors.checkArgumentValid(Util.isNumber(clientSessionKeepAliveHeartbeatFrequency), ErrorCodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ);\n        clientSessionKeepAliveHeartbeatFrequency =\n            Util.validateClientSessionKeepAliveHeartbeatFrequency(clientSessionKeepAliveHeartbeatFrequency, ConnectionConstants.HEARTBEAT_FREQUENCY_MASTER_VALIDITY);\n    }\n    const jsTreatIntegerAsBigInt = options.jsTreatIntegerAsBigInt;\n    if (Util.exists(jsTreatIntegerAsBigInt)) {\n        Errors.checkArgumentValid(Util.isBoolean(jsTreatIntegerAsBigInt), ErrorCodes.ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT);\n    }\n    const gcsUseDownscopedCredential = options.gcsUseDownscopedCredential;\n    if (Util.exists(gcsUseDownscopedCredential)) {\n        Errors.checkArgumentValid(Util.isBoolean(gcsUseDownscopedCredential), ErrorCodes.ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL);\n    }\n    const clientConfigFile = options.clientConfigFile;\n    if (Util.exists(clientConfigFile)) {\n        Errors.checkArgumentValid(Util.isString(clientConfigFile), ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE);\n    }\n    // remember if we're in qa mode\n    this._qaMode = qaMode;\n    // if a client-info argument is specified, validate it\n    const clientType = 'JavaScript';\n    let clientName;\n    let clientVersion;\n    let clientEnvironment;\n    if (Util.exists(clientInfo)) {\n        Errors.assertInternal(Util.isObject(clientInfo));\n        Errors.assertInternal(Util.isString(clientInfo.version));\n        Errors.assertInternal(Util.isObject(clientInfo.environment));\n        clientName = clientInfo.name;\n        clientVersion = clientInfo.version;\n        clientEnvironment = clientInfo.environment;\n        clientEnvironment.OS = os.platform();\n        clientEnvironment.OS_VERSION = os.release();\n        clientEnvironment.OCSP_MODE = GlobalConfig.getOcspMode();\n    }\n    const clientApplication = options.application;\n    if (Util.exists(clientApplication)) {\n        Errors.checkArgumentValid(Util.isString(clientApplication), ErrorCodes.ERR_CONN_CREATE_INVALID_APPLICATION);\n        const APPLICATION_PATTERN = new RegExp(String.raw `^[A-Za-z]([A-Za-z0-9.\\-_]){1,50}$`, 'gi');\n        Errors.checkArgumentValid(APPLICATION_PATTERN.test(clientApplication), ErrorCodes.ERR_CONN_CREATE_INVALID_APPLICATION);\n    }\n    let validateDefaultParameters = false;\n    if (Util.exists(options.validateDefaultParameters)) {\n        // check for invalid validateDefaultParameters\n        Errors.checkArgumentValid(Util.isBoolean(options.validateDefaultParameters), ErrorCodes.ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS);\n        validateDefaultParameters = options.validateDefaultParameters;\n    }\n    let bindThreshold = null;\n    if (Util.exists(options.arrayBindingThreshold)) {\n        // check for invalid arrayBindingThreshold\n        Errors.checkArgumentValid(Util.isNumber(options.arrayBindingThreshold), ErrorCodes.ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD);\n        bindThreshold = options.arrayBindingThreshold;\n    }\n    let forceStageBindError = null;\n    if (Util.exists(options.forceStageBindError)) {\n        // check for invalid forceStageBindError\n        Errors.checkArgumentValid(Util.isNumber(options.forceStageBindError), ErrorCodes.ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR);\n        forceStageBindError = options.forceStageBindError;\n    }\n    let disableQueryContextCache = false;\n    if (Util.exists(options.disableQueryContextCache)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.disableQueryContextCache), ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE);\n        disableQueryContextCache = options.disableQueryContextCache;\n    }\n    let retryTimeout = 300;\n    if (Util.exists(options.retryTimeout)) {\n        Errors.checkArgumentValid(Util.isNumber(options.retryTimeout), ErrorCodes.ERR_CONN_CREATE_INVALID_MAX_RETRY_TIMEOUT);\n        retryTimeout = options.retryTimeout !== 0 ? Math.max(retryTimeout, options.retryTimeout) : 0;\n    }\n    let includeRetryReason = true;\n    if (Util.exists(options.includeRetryReason)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.includeRetryReason), ErrorCodes.ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON);\n        includeRetryReason = options.includeRetryReason;\n    }\n    let clientRequestMFAToken = false;\n    if (Util.exists(options.clientRequestMFAToken)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.clientRequestMFAToken), ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN);\n        clientRequestMFAToken = options.clientRequestMFAToken;\n    }\n    let disableConsoleLogin = true;\n    if (Util.exists(options.disableConsoleLogin)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.disableConsoleLogin), ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN);\n        disableConsoleLogin = options.disableConsoleLogin;\n    }\n    if (Util.exists(options.forceGCPUseDownscopedCredential)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.forceGCPUseDownscopedCredential), ErrorCodes.ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL);\n        process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL =\n            options.forceGCPUseDownscopedCredential;\n    }\n    else {\n        process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL = false;\n    }\n    if (Util.exists(options.representNullAsStringNull)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.representNullAsStringNull), ErrorCodes.ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL);\n        DataTypes.setIsRepresentNullAsStringNull(options.representNullAsStringNull);\n    }\n    let disableSamlURLCheck = false;\n    if (Util.exists(options.disableSamlURLCheck)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.disableSamlURLCheck), ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK);\n        disableSamlURLCheck = options.disableSamlURLCheck;\n    }\n    let clientStoreTemporaryCredential = false;\n    if (Util.exists(options.clientStoreTemporaryCredential)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.clientStoreTemporaryCredential), ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL);\n        clientStoreTemporaryCredential = options.clientStoreTemporaryCredential;\n    }\n    let credentialCacheDir = null;\n    if (Util.exists(options.credentialCacheDir)) {\n        const absolutePath = path.resolve(options.credentialCacheDir);\n        Errors.checkArgumentValid(Util.validatePath(absolutePath), ErrorCodes.ERR_CONN_CREATE_INVALID_CREDENTIAL_CACHE_DIR);\n        credentialCacheDir = absolutePath;\n    }\n    let passcodeInPassword = false;\n    if (Util.exists(options.passcodeInPassword)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.passcodeInPassword), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD);\n        passcodeInPassword = options.passcodeInPassword;\n    }\n    let passcode = null;\n    if (Util.exists(options.passcode)) {\n        Errors.checkArgumentValid(Util.isString(options.passcode), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSCODE);\n        passcode = options.passcode;\n    }\n    if (options.queryTag) {\n        Errors.checkArgumentValid(Util.isString(options.queryTag) && options.queryTag.length <= 2000, ErrorCodes.ERR_CONN_CREATE_INVALID_QUERY_TAG);\n        this.queryTag = options.queryTag;\n    }\n    if (validateDefaultParameters) {\n        for (const [key] of Object.entries(options)) {\n            if (!DEFAULT_PARAMS.includes(key)) {\n                const result = levenshtein.closest(key, DEFAULT_PARAMS);\n                Logger.getInstance().error(`'${key}' is an unknown connection parameter. Did you mean '${result}'?`);\n            }\n        }\n    }\n    /**\n     * Returns an object that contains information about the proxy hostname, port,\n     * etc. for when http requests are made.\n     *\n     * @returns {Object}\n     */\n    this.getProxy = function () {\n        return proxy;\n    };\n    /**\n     * Returns the warehouse to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getWarehouse = function () {\n        return warehouse;\n    };\n    /**\n     * Returns the database to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getDatabase = function () {\n        return database;\n    };\n    /**\n     * Returns the schema to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getSchema = function () {\n        return schema;\n    };\n    /**\n     * Returns the role to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getRole = function () {\n        return role;\n    };\n    /**\n     * Returns the service name.\n     *\n     * @returns {String}\n     */\n    this.getServiceName = function () {\n        return serviceName;\n    };\n    /**\n     * Returns the authenticator to use for establishing a connection.\n     *\n     * @returns {String}\n     */\n    this.getAuthenticator = function () {\n        return authenticator;\n    };\n    /**\n     * Returns the timeout in millis used for authentication by external browser.\n     *\n     * @returns {String}\n     */\n    this.getBrowserActionTimeout = function () {\n        return browserActionTimeout;\n    };\n    /**\n     * Returns the private key string.\n     *\n     * @returns {String}\n     */\n    this.getPrivateKey = function () {\n        return privateKey;\n    };\n    /**\n     * Returns the private key file location.\n     *\n     * @returns {String}\n     */\n    this.getPrivateKeyPath = function () {\n        return privateKeyPath;\n    };\n    /**\n     * Returns the private key passphrase.\n     *\n     * @returns {String}\n     */\n    this.getPrivateKeyPass = function () {\n        return privateKeyPass;\n    };\n    /**\n     * Returns the OAuth token.\n     *\n     * @returns {String}\n     */\n    this.getToken = function () {\n        return token;\n    };\n    /**\n     * Returns the streamResult flag.\n     *\n     * @returns {boolean}\n     */\n    this.getStreamResult = function () {\n        return streamResult;\n    };\n    /**\n     * Returns the fetchAsString array.\n     *\n     * @returns {String[]}\n     */\n    this.getFetchAsString = function () {\n        return fetchAsString;\n    };\n    /**\n     * Returns the rowMode string value ('array', 'object' or 'object_with_renamed_duplicated_columns'). Could be null or undefined.\n     *\n     * @returns  {String}\n     */\n    this.getRowMode = function () {\n        return rowMode;\n    };\n    /**\n     * Returns the client type.\n     *\n     * @returns {String}\n     */\n    this.getClientType = function () {\n        return clientType;\n    };\n    /**\n     * Returns the client name.\n     *\n     * @returns {String}\n     */\n    this.getClientName = function () {\n        return clientName;\n    };\n    /**\n     * Returns the client version.\n     *\n     * @returns {String}\n     */\n    this.getClientVersion = function () {\n        return clientVersion;\n    };\n    /**\n     * Returns the client application.\n     *\n     * @returns {String}\n     */\n    this.getClientApplication = function () {\n        return clientApplication;\n    };\n    /**\n     * Returns a JSON object containing version information for all the various\n     * components of the runtime, e.g. node, v8, openssl, etc.\n     *\n     * @returns {Object}\n     */\n    this.getClientEnvironment = function () {\n        return clientEnvironment;\n    };\n    /**\n     * Returns the client session keep alive setting.\n     *\n     * @returns {String}\n     */\n    this.getClientSessionKeepAlive = function () {\n        return clientSessionKeepAlive;\n    };\n    /**\n     * Returns the client session keep alive heartbeat frequency setting.\n     *\n     * @returns {String}\n     */\n    this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n        return clientSessionKeepAliveHeartbeatFrequency;\n    };\n    /**\n     * Returns the client treat integer as setting\n     *\n     * @returns {String}\n     */\n    this.getJsTreatIntegerAsBigInt = function () {\n        return jsTreatIntegerAsBigInt;\n    };\n    /**\n     * Returns the setting for the GCS_USE_DOWNSCOPED_CREDENTIAL session parameter\n     *\n     * @returns {String}\n     */\n    this.getGcsUseDownscopedCredential = function () {\n        return gcsUseDownscopedCredential;\n    };\n    /**\n     * Returns the bind threshold\n     *\n     * @returns {string}\n     */\n    this.getbindThreshold = function () {\n        return bindThreshold;\n    };\n    /**\n     * Returns the force stage bind error\n     *\n     * @returns {string}\n     */\n    this.getForceStageBindError = function () {\n        return forceStageBindError;\n    };\n    /**\n     * Returns whether the Retry reason is included or not in the retry url\n     *\n     * @returns {Boolean}\n     */\n    this.getIncludeRetryReason = function () {\n        return includeRetryReason;\n    };\n    /**\n     * Returns whether the Query Context Cache is enabled or not by the configuration\n     *\n     * @returns {Boolean}\n     */\n    this.getDisableQueryContextCache = function () {\n        return disableQueryContextCache;\n    };\n    /**\n     * Returns the client config file\n     *\n     * @returns {String}\n     */\n    this.getClientConfigFile = function () {\n        return clientConfigFile;\n    };\n    /**\n     * Returns the max login timeout\n     *\n     * @returns {Number}\n     */\n    this.getRetryTimeout = function () {\n        return retryTimeout;\n    };\n    this.getDisableConsoleLogin = function () {\n        return disableConsoleLogin;\n    };\n    /**\n     * Returns whether the SAML URL check is enabled or not.\n     *\n     * @returns {Boolean}\n     */\n    this.getDisableSamlURLCheck = function () {\n        return disableSamlURLCheck;\n    };\n    this.getCredentialCacheDir = function () {\n        return credentialCacheDir;\n    };\n    this.getClientRequestMFAToken = function () {\n        return clientRequestMFAToken;\n    };\n    /**\n     * Returns whether the auth token saves on the local machine or not.\n     *\n     * @returns {Boolean}\n     */\n    this.getClientStoreTemporaryCredential = function () {\n        return clientStoreTemporaryCredential;\n    };\n    this.getPasscodeInPassword = function () {\n        return passcodeInPassword;\n    };\n    this.getPasscode = function () {\n        return passcode;\n    };\n    this.getOauthClientId = function () {\n        if (!Util.isNotEmptyString(options.oauthClientId) &&\n            !Util.isNotEmptyString(options.oauthClientSecret) &&\n            authenticator === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE &&\n            isSnowflakeHost(this.getOauthAuthorizationUrl()) &&\n            isSnowflakeHost(this.getOauthTokenRequestUrl())) {\n            Logger.getInstance().debug(`Using default values for oauthClientId: ${LOCAL_APPLICATION_CLIENT_CREDENTIAL}`);\n            oauthClientId = LOCAL_APPLICATION_CLIENT_CREDENTIAL;\n        }\n        return oauthClientId;\n    };\n    this.getOauthClientSecret = function () {\n        if (!options.oauthClientId &&\n            !options.oauthClientSecret &&\n            authenticator === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE &&\n            isSnowflakeHost(this.getOauthAuthorizationUrl()) &&\n            isSnowflakeHost(this.getOauthTokenRequestUrl())) {\n            Logger.getInstance().debug(`Using default values for oauthClientSecret: ${LOCAL_APPLICATION_CLIENT_CREDENTIAL}`);\n            oauthClientSecret = LOCAL_APPLICATION_CLIENT_CREDENTIAL;\n        }\n        return oauthClientSecret;\n    };\n    this.getOauthAuthorizationUrl = function () {\n        return oauthAuthorizationUrl ?? options.accessUrl + SNOWFLAKE_AUTHORIZE_ENDPOINT;\n    };\n    this.getOauthTokenRequestUrl = function () {\n        return oauthTokenRequestUrl ?? options.accessUrl + SNOWFLAKE_TOKEN_REQUEST_ENDPOINT;\n    };\n    this.getOauthRedirectUri = function () {\n        return oauthRedirectUri;\n    };\n    this.getOauthScope = function () {\n        return oauthScope;\n    };\n    this.getOauthChallengeMethod = function () {\n        return oauthChallengeMethod;\n    };\n    this.getOauthHttpAllowed = function () {\n        return oauthHttpAllowed || false;\n    };\n    /**\n     * Returns attributes of Connection Config object that can be used to identify\n     * the connection, when ID is not available in the scope. This is not sufficient set,\n     * since multiple connections can be instantiated for the same config, but can be treated as a hint.\n     *\n     * @returns {string}\n     */\n    this.describeIdentityAttributes = function () {\n        return (`host: ${this.host}, account: ${this.account}, accessUrl: ${this.accessUrl}, ` +\n            `user: ${this.username}, role: ${this.getRole()}, database: ${this.getDatabase()}, ` +\n            `schema: ${this.getSchema()}, warehouse: ${this.getWarehouse()}, ` +\n            ProxyUtil.describeProxy(this.getProxy()));\n    };\n    // NOTE:\n    // Don't add new get* methods when implementing new options. Use this.optionName instead.\n    // If you need advanced logic in getter, use JS object getters.\n    //\n    // Future plan is to reduce complexity of this file by merging 3 objects into one context:\n    // defaults+options+custom getters = ConnectionConfig\n    this.username = options.username;\n    this.password = options.password;\n    this.accessUrl = options.accessUrl;\n    this.region = options.region;\n    this.account = options.account;\n    this.token = options.token;\n    this.host = options.host;\n    this.sessionToken = options.sessionToken;\n    this.masterToken = options.masterToken;\n    this.masterTokenExpirationTime = options.masterTokenExpirationTime;\n    this.sessionTokenExpirationTime = options.sessionTokenExpirationTime;\n    this.clientConfigFile = options.clientConfigFile;\n    this.openExternalBrowserCallback = options.openExternalBrowserCallback;\n    this.oauthEnableSingleUseRefreshTokens = options.oauthEnableSingleUseRefreshTokens;\n    this.workloadIdentityProvider = options.workloadIdentityProvider;\n    this.workloadIdentityImpersonationPath = options.workloadIdentityImpersonationPath;\n    this.workloadIdentityAzureEntraIdResource = options.workloadIdentityAzureEntraIdResource;\n    this.workloadIdentityAzureClientId = options.workloadIdentityAzureClientId;\n    this.crlValidatorConfig = {\n        checkMode: options.certRevocationCheckMode ?? 'DISABLED',\n        allowCertificatesWithoutCrlURL: options.crlAllowCertificatesWithoutCrlURL ?? false,\n        inMemoryCache: options.crlInMemoryCache ?? true,\n        onDiskCache: options.crlOnDiskCache ?? true,\n    };\n    // create the parameters array\n    const parameters = createParameters();\n    // create a map in which the keys are the parameter names and the values are\n    // the corresponding parameters\n    const mapParameters = {};\n    let index, length, parameter;\n    for (index = 0, length = parameters.length; index < length; index++) {\n        parameter = parameters[index];\n        mapParameters[parameter.name] = parameter;\n        // initialize the value to the default\n        parameter.value = parameter.defaultValue;\n    }\n    // for each property in the options object that matches a known parameter name\n    let propertyName, propertyValue;\n    for (propertyName in options) {\n        if (Object.prototype.hasOwnProperty.call(options, propertyName) &&\n            Object.prototype.hasOwnProperty.call(mapParameters, propertyName)) {\n            // if the parameter matching the property is external and the specified\n            // value is valid for the parameter, update the parameter value\n            propertyValue = options[propertyName];\n            parameter = mapParameters[propertyName];\n            if (parameter.external && parameter.validate(propertyValue)) {\n                parameter.value = propertyValue;\n            }\n        }\n    }\n    // save the parameters map\n    this._mapParameters = mapParameters;\n    // custom agent class, test only\n    this.agentClass = options.agentClass;\n}\n/**\n * Determines if qa-mode is on.\n *\n * @returns {Boolean}\n */\nConnectionConfig.prototype.isQaMode = function () {\n    return this._qaMode;\n};\n/**\n * Clears all credential-related information.\n */\nConnectionConfig.prototype.clearCredentials = function () {\n    // clear the password\n    this.password = null;\n    // TODO: clear passcode and other credential-related information as well\n};\nconst PARAM_TIMEOUT = 'timeout';\nconst PARAM_RESULT_PREFETCH = 'resultPrefetch';\nconst PARAM_RESULT_STREAM_INTERRUPTS = 'resultStreamInterrupts';\nconst PARAM_RESULT_CHUNK_CACHE_SIZE = 'resultChunkCacheSize';\nconst PARAM_RESULT_PROCESSING_BATCH_SIZE = 'resultProcessingBatchSize';\nconst PARAM_RESULT_PROCESSING_BATCH_DURATION = 'resultProcessingBatchDuration';\nconst PARAM_ROW_STREAM_HIGH_WATER_MARK = 'rowStreamHighWaterMark';\nconst PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES = 'largeResultSetRetryMaxNumRetries';\nconst PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME = 'largeResultSetRetryMaxSleepTime';\nconst PARAM_RETRY_SF_MAX_LOGIN_RETRIES = 'sfRetryMaxLoginRetries';\nconst PARAM_RETRY_SF_MAX_NUM_RETRIES = 'sfRetryMaxNumRetries';\nconst PARAM_RETRY_SF_STARTING_SLEEP_TIME = 'sfRetryStartingSleepTime';\nconst PARAM_RETRY_SF_MAX_SLEEP_TIME = 'sfRetryMaxSleepTime';\n/**\n * Creates the list of known parameters. If a parameter is marked as external,\n * its value can be overridden by adding the appropriate name-value mapping to\n * the ConnectionConfig options.\n *\n * @returns {Object[]}\n */\nfunction createParameters() {\n    const isNonNegativeInteger = Util.number.isNonNegativeInteger.bind(Util.number);\n    const isPositiveInteger = Util.number.isPositiveInteger.bind(Util.number);\n    const isNonNegativeNumber = Util.number.isNonNegative.bind(Util.number);\n    return [\n        {\n            name: PARAM_TIMEOUT,\n            defaultValue: 90 * 1000,\n            external: true,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_PREFETCH,\n            defaultValue: 2,\n            external: true,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_STREAM_INTERRUPTS,\n            defaultValue: 3,\n            validate: isPositiveInteger,\n        },\n        // for now we set chunk cache size to 1, which is same as\n        // disabling the chunk cache. Otherwise, cache will explode\n        // memory when fetching large result set\n        {\n            name: PARAM_RESULT_CHUNK_CACHE_SIZE,\n            defaultValue: 1,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_PROCESSING_BATCH_SIZE,\n            defaultValue: 1000,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_PROCESSING_BATCH_DURATION,\n            defaultValue: 100,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_ROW_STREAM_HIGH_WATER_MARK,\n            defaultValue: 10,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES,\n            defaultValue: 10,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME,\n            defaultValue: 16,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_SF_MAX_LOGIN_RETRIES,\n            defaultValue: 7,\n            external: true,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_SF_MAX_NUM_RETRIES,\n            defaultValue: 1000,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_SF_STARTING_SLEEP_TIME,\n            defaultValue: 1,\n            validate: isNonNegativeNumber,\n        },\n        {\n            name: PARAM_RETRY_SF_MAX_SLEEP_TIME,\n            defaultValue: 16,\n            validate: isNonNegativeNumber,\n        },\n    ];\n}\nConnectionConfig.prototype.getTimeout = function () {\n    return this._getParameterValue(PARAM_TIMEOUT);\n};\nConnectionConfig.prototype.getResultPrefetch = function () {\n    return this._getParameterValue(PARAM_RESULT_PREFETCH);\n};\nConnectionConfig.prototype.getResultStreamInterrupts = function () {\n    return this._getParameterValue(PARAM_RESULT_STREAM_INTERRUPTS);\n};\nConnectionConfig.prototype.getResultChunkCacheSize = function () {\n    return this._getParameterValue(PARAM_RESULT_CHUNK_CACHE_SIZE);\n};\nConnectionConfig.prototype.getResultProcessingBatchSize = function () {\n    return this._getParameterValue(PARAM_RESULT_PROCESSING_BATCH_SIZE);\n};\nConnectionConfig.prototype.getResultProcessingBatchDuration = function () {\n    return this._getParameterValue(PARAM_RESULT_PROCESSING_BATCH_DURATION);\n};\nConnectionConfig.prototype.getRowStreamHighWaterMark = function () {\n    return this._getParameterValue(PARAM_ROW_STREAM_HIGH_WATER_MARK);\n};\nConnectionConfig.prototype.getRetryLargeResultSetMaxNumRetries = function () {\n    return this._getParameterValue(PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES);\n};\nConnectionConfig.prototype.getRetryLargeResultSetMaxSleepTime = function () {\n    return this._getParameterValue(PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME);\n};\nConnectionConfig.prototype.getRetrySfMaxNumRetries = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_MAX_NUM_RETRIES);\n};\nConnectionConfig.prototype.getRetrySfMaxLoginRetries = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_MAX_LOGIN_RETRIES);\n};\nConnectionConfig.prototype.getRetrySfStartingSleepTime = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_STARTING_SLEEP_TIME);\n};\nConnectionConfig.prototype.getRetrySfMaxSleepTime = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_MAX_SLEEP_TIME);\n};\n/**\n * Returns the value of a given connection config parameter.\n *\n * @param parameterName\n *\n * @returns {Object}\n * @private\n */\nConnectionConfig.prototype._getParameterValue = function (parameterName) {\n    const parameter = this._mapParameters[parameterName];\n    return parameter ? parameter.value : undefined;\n};\nmodule.exports = ConnectionConfig;\n//# sourceMappingURL=connection_config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsd0hBQW1DO0FBQ3ZFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQjtBQUNBLG9CQUFvQiwySUFBMEM7QUFDOUQscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLGtJQUF3QztBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQXlCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLHdHQUFxQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGdJQUF1QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsS0FBSztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJLHNEQUFzRCxPQUFPO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixvQ0FBb0M7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysb0NBQW9DO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EseUJBQXlCLFVBQVUsYUFBYSxhQUFhLGVBQWUsZUFBZTtBQUMzRixxQkFBcUIsY0FBYyxVQUFVLGVBQWUsY0FBYyxtQkFBbUI7QUFDN0YsdUJBQXVCLGlCQUFpQixlQUFlLG9CQUFvQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9jb25maWcuanM/YmYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IFByb3h5VXRpbCA9IHJlcXVpcmUoJy4uL3Byb3h5X3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgQ29ubmVjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9jb25uZWN0aW9uX2NvbnN0YW50cycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBOYXRpdmVUeXBlcyA9IHJlcXVpcmUoJy4vcmVzdWx0L2RhdGFfdHlwZXMnKS5OYXRpdmVUeXBlcztcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl90eXBlcycpO1xuY29uc3QgbGV2ZW5zaHRlaW4gPSByZXF1aXJlKCdmYXN0ZXN0LWxldmVuc2h0ZWluJyk7XG5jb25zdCBSb3dNb2RlID0gcmVxdWlyZSgnLi8uLi9jb25zdGFudHMvcm93X21vZGUnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vcmVzdWx0L2RhdGFfdHlwZXMnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgeyBpc1Nub3dmbGFrZUhvc3QgfSA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3V0aWwnKTtcbmNvbnN0IFdBSVRfRk9SX0JST1dTRVJfQUNUSU9OX1RJTUVPVVQgPSAxMjAwMDA7XG5jb25zdCBTTk9XRkxBS0VfQVVUSE9SSVpFX0VORFBPSU5UID0gJy9vYXV0aC9hdXRob3JpemUnO1xuY29uc3QgU05PV0ZMQUtFX1RPS0VOX1JFUVVFU1RfRU5EUE9JTlQgPSAnL29hdXRoL3Rva2VuLXJlcXVlc3QnO1xuY29uc3QgTE9DQUxfQVBQTElDQVRJT05fQ0xJRU5UX0NSRURFTlRJQUwgPSAnTE9DQUxfQVBQTElDQVRJT04nO1xuY29uc3QgREVGQVVMVF9QQVJBTVMgPSBbXG4gICAgJ2FjY291bnQnLFxuICAgICdhcHBsaWNhdGlvbicsXG4gICAgJ3JlZ2lvbicsXG4gICAgJ2hvc3QnLFxuICAgICdhY2Nlc3NVcmwnLFxuICAgICd1c2VybmFtZScsXG4gICAgJ3Bhc3N3b3JkJyxcbiAgICAnYXV0aGVudGljYXRvcicsXG4gICAgJ3Byb3h5SG9zdCcsXG4gICAgJ3Byb3h5UG9ydCcsXG4gICAgJ3NlcnZpY2VOYW1lJyxcbiAgICAncHJpdmF0ZUtleScsXG4gICAgJ3ByaXZhdGVLZXlQYXRoJyxcbiAgICAncHJpdmF0ZUtleVBhc3MnLFxuICAgICd0b2tlbicsXG4gICAgJ3dhcmVob3VzZScsXG4gICAgJ2RhdGFiYXNlJyxcbiAgICAnc2NoZW1hJyxcbiAgICAncm9sZScsXG4gICAgJ3Jvd01vZGUnLFxuICAgICdzdHJlYW1SZXN1bHQnLFxuICAgICdmZXRjaEFzU3RyaW5nJyxcbiAgICAnY2xpZW50U2Vzc2lvbktlZXBBbGl2ZScsXG4gICAgJ2NsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3knLFxuICAgICdqc1RyZWF0SW50ZWdlckFzQmlnSW50JyxcbiAgICAnc2Vzc2lvblRva2VuJyxcbiAgICAnbWFzdGVyVG9rZW4nLFxuICAgICdzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZScsXG4gICAgJ21hc3RlclRva2VuRXhwaXJhdGlvblRpbWUnLFxuICAgICdhZ2VudENsYXNzJyxcbiAgICAndmFsaWRhdGVEZWZhdWx0UGFyYW1ldGVycycsXG4gICAgJ2FycmF5QmluZGluZ1RocmVzaG9sZCcsXG4gICAgJ2djc1VzZURvd25zY29wZWRDcmVkZW50aWFsJyxcbiAgICAnZm9yY2VTdGFnZUJpbmRFcnJvcicsXG4gICAgJ2luY2x1ZGVSZXRyeVJlYXNvbicsXG4gICAgJ2Rpc2FibGVRdWVyeUNvbnRleHRDYWNoZScsXG4gICAgJ3JldHJ5VGltZW91dCcsXG4gICAgJ2NsaWVudFJlcXVlc3RNRkFUb2tlbicsXG4gICAgJ2NsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCcsXG4gICAgJ2Rpc2FibGVDb25zb2xlTG9naW4nLFxuICAgICdmb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsJyxcbiAgICAncmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCcsXG4gICAgJ2Rpc2FibGVTYW1sVVJMQ2hlY2snLFxuICAgICdjcmVkZW50aWFsQ2FjaGVEaXInLFxuICAgICdwYXNzY29kZUluUGFzc3dvcmQnLFxuICAgICdwYXNzY29kZScsXG4gICAgJ29hdXRoQ2xpZW50SWQnLFxuICAgICdvYXV0aENsaWVudFNlY3JldCcsXG4gICAgJ29hdXRoUmVkaXJlY3RVcmknLFxuICAgICdvYXV0aEF1dGhvcml6YXRpb25VcmwnLFxuICAgICdvYXV0aFRva2VuUmVxdWVzdFVybCcsXG4gICAgJ29hdXRoU2NvcGUnLFxuICAgICdvYXV0aENoYWxsZW5nZU1ldGhvZCcsXG4gICAgJ29hdXRoSHR0cEFsbG93ZWQnLCAvL29ubHkgZm9yIHRlc3RzXG4gICAgJ3dvcmtsb2FkSWRlbnRpdHlQcm92aWRlcicsXG4gICAgJ3dvcmtsb2FkSWRlbnRpdHlJbXBlcnNvbmF0aW9uUGF0aCcsXG4gICAgJ3dvcmtsb2FkSWRlbnRpdHlBenVyZUVudHJhSWRSZXNvdXJjZScsXG4gICAgJ3dvcmtsb2FkSWRlbnRpdHlBenVyZUNsaWVudElkJyxcbiAgICAncXVlcnlUYWcnLFxuICAgICdjZXJ0UmV2b2NhdGlvbkNoZWNrTW9kZScsXG4gICAgJ2NybEFsbG93Q2VydGlmaWNhdGVzV2l0aG91dENybFVSTCcsXG4gICAgJ2NybEluTWVtb3J5Q2FjaGUnLFxuICAgICdjcmxPbkRpc2tDYWNoZScsXG5dO1xuZnVuY3Rpb24gY29uc29saWRhdGVIb3N0QW5kQWNjb3VudChvcHRpb25zKSB7XG4gICAgbGV0IGRvdFBvcyA9IC0xO1xuICAgIGxldCByZWFsQWNjb3VudCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcmVhbFJlZ2lvbiA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgfHwgJ2h0dHBzJztcbiAgICBjb25zdCBwb3J0ID0gVXRpbC5leGlzdHMob3B0aW9ucy5wb3J0KSA/IFV0aWwuZm9ybWF0KCc6JXMnLCBvcHRpb25zLnBvcnQpIDogJyc7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucmVnaW9uKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNDb3JyZWN0U3ViZG9tYWluKG9wdGlvbnMucmVnaW9uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRUdJT05fUkVHRVgpO1xuICAgICAgICByZWFsUmVnaW9uID0gb3B0aW9ucy5yZWdpb247XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLmFjY291bnQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ09VTlQpO1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNDb3JyZWN0U3ViZG9tYWluKG9wdGlvbnMuYWNjb3VudCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDT1VOVF9SRUdFWCk7XG4gICAgICAgIGRvdFBvcyA9IG9wdGlvbnMuYWNjb3VudC5pbmRleE9mKCcuJyk7XG4gICAgICAgIHJlYWxBY2NvdW50ID0gb3B0aW9ucy5hY2NvdW50O1xuICAgICAgICBpZiAoZG90UG9zID4gMCkge1xuICAgICAgICAgICAgcmVhbFJlZ2lvbiA9IHJlYWxBY2NvdW50LnN1YnN0cmluZyhkb3RQb3MgKyAxKTtcbiAgICAgICAgICAgIHJlYWxBY2NvdW50ID0gcmVhbEFjY291bnQuc3Vic3RyaW5nKDAsIGRvdFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuYWNjZXNzVXJsKSkge1xuICAgICAgICAvL2FjY2Vzc1VybCBpcyBzZXQgaW4gY29uZmlndXJhdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKG9wdGlvbnMuYWNjZXNzVXJsKTtcbiAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5leGlzdHMocGFyc2VkVXJsLmhvc3RuYW1lKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NFU1NfVVJMKTtcbiAgICAgICAgICAgIGlmICghVXRpbC5leGlzdHMob3B0aW9ucy5ob3N0KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRvdFBvcyA9IHBhcnNlZFVybC5ob3N0bmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgICBpZiAoZG90UG9zID4gMCAmJiAhVXRpbC5leGlzdHMob3B0aW9ucy5hY2NvdW50KSkge1xuICAgICAgICAgICAgICAgIHJlYWxBY2NvdW50ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN1YnN0cmluZygwLCBkb3RQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKGZhbHNlLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ09VTlQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuaG9zdCkpIHtcbiAgICAgICAgLy9ob3N0IGlzIHNldCBpbiBjb25maWd1cmF0aW9uXG4gICAgICAgIG9wdGlvbnMuYWNjZXNzVXJsID0gVXRpbC5mb3JtYXQoJyVzOi8vJXMlcycsIHByb3RvY29sLCBvcHRpb25zLmhvc3QsIHBvcnQpO1xuICAgICAgICBjb25zdCBkb3RQb3MgPSBvcHRpb25zLmhvc3QuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90UG9zID4gMCAmJiAhVXRpbC5leGlzdHMob3B0aW9ucy5hY2NvdW50KSkge1xuICAgICAgICAgICAgcmVhbEFjY291bnQgPSBvcHRpb25zLmhvc3Quc3Vic3RyaW5nKDAsIGRvdFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFsQWNjb3VudCA9IG9wdGlvbnMuYWNjb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpKSB7XG4gICAgICAgIC8vb25seSBhY2NvdW50KCkgaXMgc2V0IGluIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaW9uID09PSAndXMtd2VzdC0yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5yZWdpb24gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmhvc3QgPSBVdGlsLmNvbnN0cnVjdEhvc3RuYW1lKHJlYWxSZWdpb24sIHJlYWxBY2NvdW50KTtcbiAgICAgICAgb3B0aW9ucy5hY2Nlc3NVcmwgPSBVdGlsLmZvcm1hdCgnJXM6Ly8lcyVzJywgcHJvdG9jb2wsIG9wdGlvbnMuaG9zdCwgcG9ydCk7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyhyZWFsQWNjb3VudCkgJiYgb3B0aW9ucy5hY2Nlc3NVcmwuaW5jbHVkZXMoJ2dsb2JhbC5zbm93Zmxha2Vjb21wdXRpbmcnKSkge1xuICAgICAgICBjb25zdCBkYXNoUG9zID0gcmVhbEFjY291bnQuaW5kZXhPZignLScpO1xuICAgICAgICBpZiAoZGFzaFBvcyA+IDApIHtcbiAgICAgICAgICAgIC8vIGdsb2JhbCBVUkxcbiAgICAgICAgICAgIHJlYWxBY2NvdW50ID0gcmVhbEFjY291bnQuc3Vic3RyaW5nKDAsIGRhc2hQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMuYWNjb3VudCA9IHJlYWxBY2NvdW50O1xuICAgIG9wdGlvbnMucmVnaW9uID0gcmVhbFJlZ2lvbjtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBhY2Nlc3NVUkxcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ09VTlQpO1xuICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIGFjY291bnRcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmFjY2Vzc1VybCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfQUNDRVNTX1VSTCk7XG59XG4vKipcbiAqIEEgQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgdG8gYWxsIHN0YXRlZnVsXG4gKiBvYmplY3RzIGluIHRoZSBkcml2ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbGlkYXRlQ3JlZGVudGlhbHNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtxYU1vZGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW2NsaWVudEluZm9dXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbm5lY3Rpb25Db25maWcob3B0aW9ucywgdmFsaWRhdGVDcmVkZW50aWFscywgcWFNb2RlLCBjbGllbnRJbmZvKSB7XG4gICAgLy8gaWYgbm8gdmFsdWUgaXMgc3BlY2lmaWVkIGZvciB0aGUgdmFsaWRhdGUgY3JlZGVudGlhbHMgZmxhZywgZGVmYXVsdCB0byB0cnVlXG4gICAgaWYgKCFVdGlsLmV4aXN0cyh2YWxpZGF0ZUNyZWRlbnRpYWxzKSkge1xuICAgICAgICB2YWxpZGF0ZUNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3B0aW9uc1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKG9wdGlvbnMpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX09QVElPTlMpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3Qob3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1BUSU9OUyk7XG4gICAgLy8gb25seSB2YWxpZGF0ZSBjcmVkZW50aWFscyBpZiBuZWNlc3NhcnlcbiAgICBpZiAodmFsaWRhdGVDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBub1VzZXJuYW1lUmVxdWlyZWRGb3IgPSBbXG4gICAgICAgICAgICBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhFTlRJQ0FUT1IsXG4gICAgICAgICAgICBBdXRoZW50aWNhdGlvblR5cGVzLkVYVEVSTkFMX0JST1dTRVJfQVVUSEVOVElDQVRPUixcbiAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uVHlwZXMuUFJPR1JBTU1BVElDX0FDQ0VTU19UT0tFTixcbiAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQ0xJRU5UX0NSRURFTlRJQUxTLFxuICAgICAgICAgICAgQXV0aGVudGljYXRpb25UeXBlcy5PQVVUSF9BVVRIT1JJWkFUSU9OX0NPREUsXG4gICAgICAgICAgICBBdXRoZW50aWNhdGlvblR5cGVzLldPUktMT0FEX0lERU5USVRZLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYXV0aGVudGljYXRvciB8fFxuICAgICAgICAgICAgIW5vVXNlcm5hbWVSZXF1aXJlZEZvci5pbmNsdWRlcyhvcHRpb25zLmF1dGhlbnRpY2F0b3IudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIHVzZXJuYW1lXG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLnVzZXJuYW1lKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19VU0VSTkFNRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMudXNlcm5hbWUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCB1c2VybmFtZVxuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMudXNlcm5hbWUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1VTRVJOQU1FKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXNzd29yZCBpcyBvbmx5IHJlcXVpcmVkIGZvciBkZWZhdWx0IGF1dGhlbnRpY2F0b3JcbiAgICAgICAgaWYgKCFVdGlsLmV4aXN0cyhvcHRpb25zLmF1dGhlbnRpY2F0b3IpIHx8XG4gICAgICAgICAgICBvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuREVGQVVMVF9BVVRIRU5USUNBVE9SKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBwYXNzd29yZFxuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucy5wYXNzd29yZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUEFTU1dPUkQpO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcGFzc3dvcmRcbiAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLnBhc3N3b3JkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFVdGlsLmV4aXN0cyhvcHRpb25zLmF1dGhlbnRpY2F0b3IpIHx8XG4gICAgICAgICAgICBvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuUFJPR1JBTU1BVElDX0FDQ0VTU19UT0tFTikge1xuICAgICAgICAgICAgLy8gUEFTU1dPUkQgb3IgVE9LRU4gaXMgbmVlZGVkXG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLnBhc3N3b3JkKSB8fCBVdGlsLmV4aXN0cyhvcHRpb25zLnRva2VuKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QQVNTV09SRCk7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5wYXNzd29yZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBwYXNzd29yZFxuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLnBhc3N3b3JkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy50b2tlbikpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcob3B0aW9ucy50b2tlbiksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT0FVVEhfVE9LRU4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSE9SSVpBVElPTl9DT0RFKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5vYXV0aEF1dGhvcml6YXRpb25VcmwpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZFVybDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKG9wdGlvbnMub2F1dGhBdXRob3JpemF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVJbnZhbGlkUGFyYW1ldGVyRXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PVUFUSF9BVVRIT1JJWkFUSU9OX1VSTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwOicsIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQVVUSE9SSVpBVElPTl9VUkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvcHRpb25zLm9hdXRoQXV0aG9yaXphdGlvblVybCAmJiAhaXNTbm93Zmxha2VIb3N0KG9wdGlvbnMub2F1dGhBdXRob3JpemF0aW9uVXJsKSkgfHxcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybCAmJiAhaXNTbm93Zmxha2VIb3N0KG9wdGlvbnMub2F1dGhUb2tlblJlcXVlc3RVcmwpKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLm9hdXRoQ2xpZW50SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9JRCk7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMub2F1dGhDbGllbnRTZWNyZXQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9TRUNSRVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQ0xJRU5UX0NSRURFTlRJQUxTKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkVXJsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwob3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlSW52YWxpZFBhcmFtZXRlckVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfVE9LRU5fUkVRVUVTVF9VUkwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cDonLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX1RPS0VOX1JFUVVFU1RfVVJMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLm9hdXRoQ2xpZW50SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9JRCk7XG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcob3B0aW9ucy5vYXV0aENsaWVudFNlY3JldCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQ0xJRU5UX1NFQ1JFVCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29saWRhdGVIb3N0QW5kQWNjb3VudChvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgYWNjZXNzVXJsXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucy5hY2Nlc3NVcmwpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ0VTU19VUkwpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGFjY2Vzc1VybFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLmFjY2Vzc1VybCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDRVNTX1VSTCk7XG4gICAgY29uc3QgcHJveHlIb3N0ID0gb3B0aW9ucy5wcm94eUhvc3Q7XG4gICAgY29uc3QgcHJveHlQb3J0ID0gb3B0aW9ucy5wcm94eVBvcnQ7XG4gICAgY29uc3QgcHJveHlVc2VyID0gb3B0aW9ucy5wcm94eVVzZXI7XG4gICAgY29uc3QgcHJveHlQYXNzd29yZCA9IG9wdGlvbnMucHJveHlQYXNzd29yZDtcbiAgICBjb25zdCBwcm94eVByb3RvY29sID0gb3B0aW9ucy5wcm94eVByb3RvY29sIHx8ICdodHRwJztcbiAgICBjb25zdCBub1Byb3h5ID0gb3B0aW9ucy5ub1Byb3h5O1xuICAgIGNvbnN0IHVzZUZvck9DU1AgPSBvcHRpb25zLnVzZUNvbm5lY3Rpb25Db25maWdQcm94eUZvck9DU1AgPz8gZmFsc2U7XG4gICAgbGV0IG9hdXRoQ2xpZW50SWQgPSBvcHRpb25zLm9hdXRoQ2xpZW50SWQ7XG4gICAgbGV0IG9hdXRoQ2xpZW50U2VjcmV0ID0gb3B0aW9ucy5vYXV0aENsaWVudFNlY3JldDtcbiAgICBjb25zdCBvYXV0aFJlZGlyZWN0VXJpID0gb3B0aW9ucy5vYXV0aFJlZGlyZWN0VXJpO1xuICAgIGNvbnN0IG9hdXRoQXV0aG9yaXphdGlvblVybCA9IG9wdGlvbnMub2F1dGhBdXRob3JpemF0aW9uVXJsO1xuICAgIGNvbnN0IG9hdXRoVG9rZW5SZXF1ZXN0VXJsID0gb3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybDtcbiAgICBjb25zdCBvYXV0aENoYWxsZW5nZU1ldGhvZCA9IG9wdGlvbnMub2F1dGhDaGFsbGVuZ2VNZXRob2Q7XG4gICAgY29uc3Qgb2F1dGhTY29wZSA9IG9wdGlvbnMub2F1dGhTY29wZTtcbiAgICBjb25zdCBvYXV0aEh0dHBBbGxvd2VkID0gb3B0aW9ucy5vYXV0aEh0dHBBbGxvd2VkO1xuICAgIC8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gbm9kZSBhbmQgc29tZSBwcm94eSBpbmZvcm1hdGlvbiBpcyBzcGVjaWZpZWRcbiAgICBsZXQgcHJveHk7XG4gICAgaWYgKFV0aWwuaXNOb2RlKCkgJiYgKFV0aWwuZXhpc3RzKHByb3h5SG9zdCkgfHwgVXRpbC5leGlzdHMocHJveHlQb3J0KSkpIHtcbiAgICAgICAgcHJveHkgPSB7XG4gICAgICAgICAgICBob3N0OiBwcm94eUhvc3QsXG4gICAgICAgICAgICBwb3J0OiBwcm94eVBvcnQsXG4gICAgICAgICAgICB1c2VyOiBwcm94eVVzZXIsXG4gICAgICAgICAgICBwYXNzd29yZDogcHJveHlQYXNzd29yZCxcbiAgICAgICAgICAgIHByb3RvY29sOiBwcm94eVByb3RvY29sLFxuICAgICAgICAgICAgbm9Qcm94eTogbm9Qcm94eSxcbiAgICAgICAgICAgIHVzZUZvck9DU1A6IHVzZUZvck9DU1AsXG4gICAgICAgIH07XG4gICAgICAgIFByb3h5VXRpbC52YWxpZGF0ZVByb3h5KHByb3h5KTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmljZU5hbWUgPSBvcHRpb25zLnNlcnZpY2VOYW1lO1xuICAgIGxldCBhdXRoZW50aWNhdG9yID0gb3B0aW9ucy5hdXRoZW50aWNhdG9yO1xuICAgIC8vIGlmIG5vIHZhbHVlIGlzIHNwZWNpZmllZCBmb3IgYXV0aGVudGljYXRvciwgZGVmYXVsdCB0byBTbm93Zmxha2VcbiAgICBpZiAoIVV0aWwuZXhpc3RzKGF1dGhlbnRpY2F0b3IpKSB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3IgPSBBdXRoZW50aWNhdGlvblR5cGVzLkRFRkFVTFRfQVVUSEVOVElDQVRPUjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3IgPSBhdXRoZW50aWNhdG9yLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGxldCBicm93c2VyQWN0aW9uVGltZW91dCA9IG9wdGlvbnMuYnJvd3NlckFjdGlvblRpbWVvdXQ7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuYnJvd3NlckFjdGlvblRpbWVvdXQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIoYnJvd3NlckFjdGlvblRpbWVvdXQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0JST1dTRVJfVElNRU9VVCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBicm93c2VyQWN0aW9uVGltZW91dCA9IFdBSVRfRk9SX0JST1dTRVJfQUNUSU9OX1RJTUVPVVQ7XG4gICAgfVxuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBvcHRpb25zLnByaXZhdGVLZXk7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHByaXZhdGVLZXkpICYmIFV0aWwuaXNQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZKTtcbiAgICB9XG4gICAgY29uc3QgcHJpdmF0ZUtleVBhdGggPSBvcHRpb25zLnByaXZhdGVLZXlQYXRoO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnByaXZhdGVLZXlQYXRoKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcocHJpdmF0ZUtleVBhdGgpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZX1BBVEgpO1xuICAgIH1cbiAgICBjb25zdCBwcml2YXRlS2V5UGFzcyA9IG9wdGlvbnMucHJpdmF0ZUtleVBhc3M7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucHJpdmF0ZUtleVBhc3MpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhwcml2YXRlS2V5UGFzcyksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFTUyk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuID0gb3B0aW9ucy50b2tlbjtcbiAgICBpZiAoVXRpbC5leGlzdHModG9rZW4pKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyh0b2tlbiksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT0FVVEhfVE9LRU4pO1xuICAgIH1cbiAgICBjb25zdCB3YXJlaG91c2UgPSBvcHRpb25zLndhcmVob3VzZTtcbiAgICBjb25zdCBkYXRhYmFzZSA9IG9wdGlvbnMuZGF0YWJhc2U7XG4gICAgY29uc3Qgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gICAgY29uc3Qgcm9sZSA9IG9wdGlvbnMucm9sZTtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCB3YXJlaG91c2VcbiAgICBpZiAoVXRpbC5leGlzdHMod2FyZWhvdXNlKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcod2FyZWhvdXNlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9XQVJFSE9VU0UpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBkYXRhYmFzZVxuICAgIGlmIChVdGlsLmV4aXN0cyhkYXRhYmFzZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKGRhdGFiYXNlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9EQVRBQkFTRSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHNjaGVtYVxuICAgIGlmIChVdGlsLmV4aXN0cyhzY2hlbWEpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhzY2hlbWEpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1NDSEVNQSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHJvbGVcbiAgICBpZiAoVXRpbC5leGlzdHMocm9sZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHJvbGUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JPTEUpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBzdHJlYW1SZXN1bHRcbiAgICBjb25zdCBzdHJlYW1SZXN1bHQgPSBvcHRpb25zLnN0cmVhbVJlc3VsdDtcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RyZWFtUmVzdWx0KSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHN0cmVhbVJlc3VsdCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfU1RSRUFNX1JFU1VMVCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZldGNoQXNTdHJpbmdcbiAgICBjb25zdCBmZXRjaEFzU3RyaW5nID0gb3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgIGlmIChVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNBcnJheShmZXRjaEFzU3RyaW5nKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkcpO1xuICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCB0aGUgYXJyYXkgZWxlbWVudHMgYXJlIHZhbGlkXG4gICAgICAgIGNvbnN0IGludmFsaWRWYWx1ZUluZGV4ID0gTmF0aXZlVHlwZXMuZmluZEludmFsaWRWYWx1ZShmZXRjaEFzU3RyaW5nKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChpbnZhbGlkVmFsdWVJbmRleCA9PT0gLTEsIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUywgSlNPTi5zdHJpbmdpZnkoZmV0Y2hBc1N0cmluZ1tpbnZhbGlkVmFsdWVJbmRleF0pKTtcbiAgICB9XG4gICAgLy8gUm93IG1vZGUgaXMgb3B0aW9uYWwsIGNhbiBiZSB1bmRlZmluZWRcbiAgICBjb25zdCByb3dNb2RlID0gb3B0aW9ucy5yb3dNb2RlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhyb3dNb2RlKSkge1xuICAgICAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlXG4gICAgY29uc3QgY2xpZW50U2Vzc2lvbktlZXBBbGl2ZSA9IG9wdGlvbnMuY2xpZW50U2Vzc2lvbktlZXBBbGl2ZTtcbiAgICBpZiAoVXRpbC5leGlzdHMoY2xpZW50U2Vzc2lvbktlZXBBbGl2ZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihjbGllbnRTZXNzaW9uS2VlcEFsaXZlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeVxuICAgIGxldCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5ID0gb3B0aW9ucy5jbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5O1xuICAgIGlmIChVdGlsLmV4aXN0cyhjbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5KSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNOdW1iZXIoY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUSk7XG4gICAgICAgIGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3kgPVxuICAgICAgICAgICAgVXRpbC52YWxpZGF0ZUNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3koY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSwgQ29ubmVjdGlvbkNvbnN0YW50cy5IRUFSVEJFQVRfRlJFUVVFTkNZX01BU1RFUl9WQUxJRElUWSk7XG4gICAgfVxuICAgIGNvbnN0IGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQgPSBvcHRpb25zLmpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQ7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oanNUcmVhdEludGVnZXJBc0JpZ0ludCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQpO1xuICAgIH1cbiAgICBjb25zdCBnY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCA9IG9wdGlvbnMuZ2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWw7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKGdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9HQ1NfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudENvbmZpZ0ZpbGUgPSBvcHRpb25zLmNsaWVudENvbmZpZ0ZpbGU7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGNsaWVudENvbmZpZ0ZpbGUpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhjbGllbnRDb25maWdGaWxlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfQ09ORklHX0ZJTEUpO1xuICAgIH1cbiAgICAvLyByZW1lbWJlciBpZiB3ZSdyZSBpbiBxYSBtb2RlXG4gICAgdGhpcy5fcWFNb2RlID0gcWFNb2RlO1xuICAgIC8vIGlmIGEgY2xpZW50LWluZm8gYXJndW1lbnQgaXMgc3BlY2lmaWVkLCB2YWxpZGF0ZSBpdFxuICAgIGNvbnN0IGNsaWVudFR5cGUgPSAnSmF2YVNjcmlwdCc7XG4gICAgbGV0IGNsaWVudE5hbWU7XG4gICAgbGV0IGNsaWVudFZlcnNpb247XG4gICAgbGV0IGNsaWVudEVudmlyb25tZW50O1xuICAgIGlmIChVdGlsLmV4aXN0cyhjbGllbnRJbmZvKSkge1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjbGllbnRJbmZvKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzU3RyaW5nKGNsaWVudEluZm8udmVyc2lvbikpO1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjbGllbnRJbmZvLmVudmlyb25tZW50KSk7XG4gICAgICAgIGNsaWVudE5hbWUgPSBjbGllbnRJbmZvLm5hbWU7XG4gICAgICAgIGNsaWVudFZlcnNpb24gPSBjbGllbnRJbmZvLnZlcnNpb247XG4gICAgICAgIGNsaWVudEVudmlyb25tZW50ID0gY2xpZW50SW5mby5lbnZpcm9ubWVudDtcbiAgICAgICAgY2xpZW50RW52aXJvbm1lbnQuT1MgPSBvcy5wbGF0Zm9ybSgpO1xuICAgICAgICBjbGllbnRFbnZpcm9ubWVudC5PU19WRVJTSU9OID0gb3MucmVsZWFzZSgpO1xuICAgICAgICBjbGllbnRFbnZpcm9ubWVudC5PQ1NQX01PREUgPSBHbG9iYWxDb25maWcuZ2V0T2NzcE1vZGUoKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50QXBwbGljYXRpb24gPSBvcHRpb25zLmFwcGxpY2F0aW9uO1xuICAgIGlmIChVdGlsLmV4aXN0cyhjbGllbnRBcHBsaWNhdGlvbikpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKGNsaWVudEFwcGxpY2F0aW9uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUFBMSUNBVElPTik7XG4gICAgICAgIGNvbnN0IEFQUExJQ0FUSU9OX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYF5bQS1aYS16XShbQS1aYS16MC05LlxcLV9dKXsxLDUwfSRgLCAnZ2knKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChBUFBMSUNBVElPTl9QQVRURVJOLnRlc3QoY2xpZW50QXBwbGljYXRpb24pLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FQUExJQ0FUSU9OKTtcbiAgICB9XG4gICAgbGV0IHZhbGlkYXRlRGVmYXVsdFBhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy52YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzKSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCB2YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy52YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9WQUxJREFURV9ERUZBVUxUX1BBUkFNRVRFUlMpO1xuICAgICAgICB2YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzID0gb3B0aW9ucy52YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICBsZXQgYmluZFRocmVzaG9sZCA9IG51bGw7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuYXJyYXlCaW5kaW5nVGhyZXNob2xkKSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBhcnJheUJpbmRpbmdUaHJlc2hvbGRcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuYXJyYXlCaW5kaW5nVGhyZXNob2xkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCk7XG4gICAgICAgIGJpbmRUaHJlc2hvbGQgPSBvcHRpb25zLmFycmF5QmluZGluZ1RocmVzaG9sZDtcbiAgICB9XG4gICAgbGV0IGZvcmNlU3RhZ2VCaW5kRXJyb3IgPSBudWxsO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmZvcmNlU3RhZ2VCaW5kRXJyb3IpKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZvcmNlU3RhZ2VCaW5kRXJyb3JcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuZm9yY2VTdGFnZUJpbmRFcnJvciksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfU1RBR0VfQklORF9FUlJPUik7XG4gICAgICAgIGZvcmNlU3RhZ2VCaW5kRXJyb3IgPSBvcHRpb25zLmZvcmNlU3RhZ2VCaW5kRXJyb3I7XG4gICAgfVxuICAgIGxldCBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5kaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVEX1FVRVJZX0NPTlRFWFRfQ0FDSEUpO1xuICAgICAgICBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUgPSBvcHRpb25zLmRpc2FibGVRdWVyeUNvbnRleHRDYWNoZTtcbiAgICB9XG4gICAgbGV0IHJldHJ5VGltZW91dCA9IDMwMDtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5yZXRyeVRpbWVvdXQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc051bWJlcihvcHRpb25zLnJldHJ5VGltZW91dCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfTUFYX1JFVFJZX1RJTUVPVVQpO1xuICAgICAgICByZXRyeVRpbWVvdXQgPSBvcHRpb25zLnJldHJ5VGltZW91dCAhPT0gMCA/IE1hdGgubWF4KHJldHJ5VGltZW91dCwgb3B0aW9ucy5yZXRyeVRpbWVvdXQpIDogMDtcbiAgICB9XG4gICAgbGV0IGluY2x1ZGVSZXRyeVJlYXNvbiA9IHRydWU7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuaW5jbHVkZVJldHJ5UmVhc29uKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuaW5jbHVkZVJldHJ5UmVhc29uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9JTkNMVURFX1JFVFJZX1JFQVNPTik7XG4gICAgICAgIGluY2x1ZGVSZXRyeVJlYXNvbiA9IG9wdGlvbnMuaW5jbHVkZVJldHJ5UmVhc29uO1xuICAgIH1cbiAgICBsZXQgY2xpZW50UmVxdWVzdE1GQVRva2VuID0gZmFsc2U7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuY2xpZW50UmVxdWVzdE1GQVRva2VuKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuY2xpZW50UmVxdWVzdE1GQVRva2VuKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfUkVRVUVTVF9NRkFfVE9LRU4pO1xuICAgICAgICBjbGllbnRSZXF1ZXN0TUZBVG9rZW4gPSBvcHRpb25zLmNsaWVudFJlcXVlc3RNRkFUb2tlbjtcbiAgICB9XG4gICAgbGV0IGRpc2FibGVDb25zb2xlTG9naW4gPSB0cnVlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmRpc2FibGVDb25zb2xlTG9naW4pKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlQ29uc29sZUxvZ2luKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9ESVNBQkxFX0NPTlNPTEVfTE9HSU4pO1xuICAgICAgICBkaXNhYmxlQ29uc29sZUxvZ2luID0gb3B0aW9ucy5kaXNhYmxlQ29uc29sZUxvZ2luO1xuICAgIH1cbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5mb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuZm9yY2VHQ1BVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwpO1xuICAgICAgICBwcm9jZXNzLmVudi5TTk9XRkxBS0VfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgPVxuICAgICAgICAgICAgb3B0aW9ucy5mb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuU05PV0ZMQUtFX0ZPUkNFX0dDUF9VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnJlcHJlc2VudE51bGxBc1N0cmluZ051bGwpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5yZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRVBSRVNFTlRfTlVMTF9BU19TVFJJTkdfTlVMTCk7XG4gICAgICAgIERhdGFUeXBlcy5zZXRJc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwob3B0aW9ucy5yZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsKTtcbiAgICB9XG4gICAgbGV0IGRpc2FibGVTYW1sVVJMQ2hlY2sgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5kaXNhYmxlU2FtbFVSTENoZWNrKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZVNhbWxVUkxDaGVjayksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRV9TQU1MX1VSTF9DSEVDSyk7XG4gICAgICAgIGRpc2FibGVTYW1sVVJMQ2hlY2sgPSBvcHRpb25zLmRpc2FibGVTYW1sVVJMQ2hlY2s7XG4gICAgfVxuICAgIGxldCBjbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5jbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5jbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9TVE9SRV9URU1QT1JBUllfQ1JFREVOVElBTCk7XG4gICAgICAgIGNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCA9IG9wdGlvbnMuY2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsO1xuICAgIH1cbiAgICBsZXQgY3JlZGVudGlhbENhY2hlRGlyID0gbnVsbDtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5jcmVkZW50aWFsQ2FjaGVEaXIpKSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmNyZWRlbnRpYWxDYWNoZURpcik7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC52YWxpZGF0ZVBhdGgoYWJzb2x1dGVQYXRoKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DUkVERU5USUFMX0NBQ0hFX0RJUik7XG4gICAgICAgIGNyZWRlbnRpYWxDYWNoZURpciA9IGFic29sdXRlUGF0aDtcbiAgICB9XG4gICAgbGV0IHBhc3Njb2RlSW5QYXNzd29yZCA9IGZhbHNlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZCkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU0NPREVfSU5fUEFTU1dPUkQpO1xuICAgICAgICBwYXNzY29kZUluUGFzc3dvcmQgPSBvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZDtcbiAgICB9XG4gICAgbGV0IHBhc3Njb2RlID0gbnVsbDtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5wYXNzY29kZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMucGFzc2NvZGUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BBU1NDT0RFKTtcbiAgICAgICAgcGFzc2NvZGUgPSBvcHRpb25zLnBhc3Njb2RlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5xdWVyeVRhZykge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcob3B0aW9ucy5xdWVyeVRhZykgJiYgb3B0aW9ucy5xdWVyeVRhZy5sZW5ndGggPD0gMjAwMCwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9RVUVSWV9UQUcpO1xuICAgICAgICB0aGlzLnF1ZXJ5VGFnID0gb3B0aW9ucy5xdWVyeVRhZztcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRlRGVmYXVsdFBhcmFtZXRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKCFERUZBVUxUX1BBUkFNUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbGV2ZW5zaHRlaW4uY2xvc2VzdChrZXksIERFRkFVTFRfUEFSQU1TKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgJyR7a2V5fScgaXMgYW4gdW5rbm93biBjb25uZWN0aW9uIHBhcmFtZXRlci4gRGlkIHlvdSBtZWFuICcke3Jlc3VsdH0nP2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb3h5IGhvc3RuYW1lLCBwb3J0LFxuICAgICAqIGV0Yy4gZm9yIHdoZW4gaHR0cCByZXF1ZXN0cyBhcmUgbWFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRQcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FyZWhvdXNlIHRvIGF1dG9tYXRpY2FsbHkgdXNlIG9uY2UgYSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0V2FyZWhvdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2FyZWhvdXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YWJhc2UgdG8gYXV0b21hdGljYWxseSB1c2Ugb25jZSBhIGNvbm5lY3Rpb24gaGFzIGJlZW5cbiAgICAgKiBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXREYXRhYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFiYXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2NoZW1hIHRvIGF1dG9tYXRpY2FsbHkgdXNlIG9uY2UgYSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9sZSB0byBhdXRvbWF0aWNhbGx5IHVzZSBvbmNlIGEgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqIGVzdGFibGlzaGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFJvbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByb2xlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2VydmljZSBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFNlcnZpY2VOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZU5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdXRoZW50aWNhdG9yIHRvIHVzZSBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRBdXRoZW50aWNhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRpbWVvdXQgaW4gbWlsbGlzIHVzZWQgZm9yIGF1dGhlbnRpY2F0aW9uIGJ5IGV4dGVybmFsIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0QnJvd3NlckFjdGlvblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBicm93c2VyQWN0aW9uVGltZW91dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaXZhdGUga2V5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZUtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaXZhdGUga2V5IGZpbGUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UHJpdmF0ZUtleVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5UGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaXZhdGUga2V5IHBhc3NwaHJhc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UHJpdmF0ZUtleVBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5UGFzcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9BdXRoIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJlYW1SZXN1bHQgZmxhZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RyZWFtUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmV0Y2hBc1N0cmluZyBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLmdldEZldGNoQXNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaEFzU3RyaW5nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm93TW9kZSBzdHJpbmcgdmFsdWUgKCdhcnJheScsICdvYmplY3QnIG9yICdvYmplY3Rfd2l0aF9yZW5hbWVkX2R1cGxpY2F0ZWRfY29sdW1ucycpLiBDb3VsZCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zICB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Um93TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJvd01vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRDbGllbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xpZW50VHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNsaWVudCBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldENsaWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbGllbnROYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2xpZW50IHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2xpZW50VmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFZlcnNpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgYXBwbGljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2xpZW50QXBwbGljYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRBcHBsaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIG9iamVjdCBjb250YWluaW5nIHZlcnNpb24gaW5mb3JtYXRpb24gZm9yIGFsbCB0aGUgdmFyaW91c1xuICAgICAqIGNvbXBvbmVudHMgb2YgdGhlIHJ1bnRpbWUsIGUuZy4gbm9kZSwgdjgsIG9wZW5zc2wsIGV0Yy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRDbGllbnRFbnZpcm9ubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudEVudmlyb25tZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2xpZW50IHNlc3Npb24ga2VlcCBhbGl2ZSBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRTZXNzaW9uS2VlcEFsaXZlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2xpZW50IHNlc3Npb24ga2VlcCBhbGl2ZSBoZWFydGJlYXQgZnJlcXVlbmN5IHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3k7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgdHJlYXQgaW50ZWdlciBhcyBzZXR0aW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXR0aW5nIGZvciB0aGUgR0NTX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgc2Vzc2lvbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRHY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmluZCB0aHJlc2hvbGRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRiaW5kVGhyZXNob2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmluZFRocmVzaG9sZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZvcmNlIHN0YWdlIGJpbmQgZXJyb3JcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRGb3JjZVN0YWdlQmluZEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm9yY2VTdGFnZUJpbmRFcnJvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgUmV0cnkgcmVhc29uIGlzIGluY2x1ZGVkIG9yIG5vdCBpbiB0aGUgcmV0cnkgdXJsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldEluY2x1ZGVSZXRyeVJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVSZXRyeVJlYXNvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgUXVlcnkgQ29udGV4dCBDYWNoZSBpcyBlbmFibGVkIG9yIG5vdCBieSB0aGUgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5nZXREaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgY29uZmlnIGZpbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRDbGllbnRDb25maWdGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnRmlsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heCBsb2dpbiB0aW1lb3V0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UmV0cnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmV0cnlUaW1lb3V0O1xuICAgIH07XG4gICAgdGhpcy5nZXREaXNhYmxlQ29uc29sZUxvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGlzYWJsZUNvbnNvbGVMb2dpbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU0FNTCBVUkwgY2hlY2sgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldERpc2FibGVTYW1sVVJMQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkaXNhYmxlU2FtbFVSTENoZWNrO1xuICAgIH07XG4gICAgdGhpcy5nZXRDcmVkZW50aWFsQ2FjaGVEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsQ2FjaGVEaXI7XG4gICAgfTtcbiAgICB0aGlzLmdldENsaWVudFJlcXVlc3RNRkFUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFJlcXVlc3RNRkFUb2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgYXV0aCB0b2tlbiBzYXZlcyBvbiB0aGUgbG9jYWwgbWFjaGluZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UGFzc2NvZGVJblBhc3N3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFzc2NvZGVJblBhc3N3b3JkO1xuICAgIH07XG4gICAgdGhpcy5nZXRQYXNzY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhc3Njb2RlO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aENsaWVudElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIVV0aWwuaXNOb3RFbXB0eVN0cmluZyhvcHRpb25zLm9hdXRoQ2xpZW50SWQpICYmXG4gICAgICAgICAgICAhVXRpbC5pc05vdEVtcHR5U3RyaW5nKG9wdGlvbnMub2F1dGhDbGllbnRTZWNyZXQpICYmXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yID09PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERSAmJlxuICAgICAgICAgICAgaXNTbm93Zmxha2VIb3N0KHRoaXMuZ2V0T2F1dGhBdXRob3JpemF0aW9uVXJsKCkpICYmXG4gICAgICAgICAgICBpc1Nub3dmbGFrZUhvc3QodGhpcy5nZXRPYXV0aFRva2VuUmVxdWVzdFVybCgpKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFVzaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBvYXV0aENsaWVudElkOiAke0xPQ0FMX0FQUExJQ0FUSU9OX0NMSUVOVF9DUkVERU5USUFMfWApO1xuICAgICAgICAgICAgb2F1dGhDbGllbnRJZCA9IExPQ0FMX0FQUExJQ0FUSU9OX0NMSUVOVF9DUkVERU5USUFMO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYXV0aENsaWVudElkO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aENsaWVudFNlY3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm9hdXRoQ2xpZW50SWQgJiZcbiAgICAgICAgICAgICFvcHRpb25zLm9hdXRoQ2xpZW50U2VjcmV0ICYmXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yID09PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERSAmJlxuICAgICAgICAgICAgaXNTbm93Zmxha2VIb3N0KHRoaXMuZ2V0T2F1dGhBdXRob3JpemF0aW9uVXJsKCkpICYmXG4gICAgICAgICAgICBpc1Nub3dmbGFrZUhvc3QodGhpcy5nZXRPYXV0aFRva2VuUmVxdWVzdFVybCgpKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFVzaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBvYXV0aENsaWVudFNlY3JldDogJHtMT0NBTF9BUFBMSUNBVElPTl9DTElFTlRfQ1JFREVOVElBTH1gKTtcbiAgICAgICAgICAgIG9hdXRoQ2xpZW50U2VjcmV0ID0gTE9DQUxfQVBQTElDQVRJT05fQ0xJRU5UX0NSRURFTlRJQUw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9hdXRoQ2xpZW50U2VjcmV0O1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aEF1dGhvcml6YXRpb25VcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYXV0aEF1dGhvcml6YXRpb25VcmwgPz8gb3B0aW9ucy5hY2Nlc3NVcmwgKyBTTk9XRkxBS0VfQVVUSE9SSVpFX0VORFBPSU5UO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aFRva2VuUmVxdWVzdFVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9hdXRoVG9rZW5SZXF1ZXN0VXJsID8/IG9wdGlvbnMuYWNjZXNzVXJsICsgU05PV0ZMQUtFX1RPS0VOX1JFUVVFU1RfRU5EUE9JTlQ7XG4gICAgfTtcbiAgICB0aGlzLmdldE9hdXRoUmVkaXJlY3RVcmkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYXV0aFJlZGlyZWN0VXJpO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2F1dGhTY29wZTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2F1dGhDaGFsbGVuZ2VNZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYXV0aENoYWxsZW5nZU1ldGhvZDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2F1dGhIdHRwQWxsb3dlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9hdXRoSHR0cEFsbG93ZWQgfHwgZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF0dHJpYnV0ZXMgb2YgQ29ubmVjdGlvbiBDb25maWcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnlcbiAgICAgKiB0aGUgY29ubmVjdGlvbiwgd2hlbiBJRCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBzY29wZS4gVGhpcyBpcyBub3Qgc3VmZmljaWVudCBzZXQsXG4gICAgICogc2luY2UgbXVsdGlwbGUgY29ubmVjdGlvbnMgY2FuIGJlIGluc3RhbnRpYXRlZCBmb3IgdGhlIHNhbWUgY29uZmlnLCBidXQgY2FuIGJlIHRyZWF0ZWQgYXMgYSBoaW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaWJlSWRlbnRpdHlBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGBob3N0OiAke3RoaXMuaG9zdH0sIGFjY291bnQ6ICR7dGhpcy5hY2NvdW50fSwgYWNjZXNzVXJsOiAke3RoaXMuYWNjZXNzVXJsfSwgYCArXG4gICAgICAgICAgICBgdXNlcjogJHt0aGlzLnVzZXJuYW1lfSwgcm9sZTogJHt0aGlzLmdldFJvbGUoKX0sIGRhdGFiYXNlOiAke3RoaXMuZ2V0RGF0YWJhc2UoKX0sIGAgK1xuICAgICAgICAgICAgYHNjaGVtYTogJHt0aGlzLmdldFNjaGVtYSgpfSwgd2FyZWhvdXNlOiAke3RoaXMuZ2V0V2FyZWhvdXNlKCl9LCBgICtcbiAgICAgICAgICAgIFByb3h5VXRpbC5kZXNjcmliZVByb3h5KHRoaXMuZ2V0UHJveHkoKSkpO1xuICAgIH07XG4gICAgLy8gTk9URTpcbiAgICAvLyBEb24ndCBhZGQgbmV3IGdldCogbWV0aG9kcyB3aGVuIGltcGxlbWVudGluZyBuZXcgb3B0aW9ucy4gVXNlIHRoaXMub3B0aW9uTmFtZSBpbnN0ZWFkLlxuICAgIC8vIElmIHlvdSBuZWVkIGFkdmFuY2VkIGxvZ2ljIGluIGdldHRlciwgdXNlIEpTIG9iamVjdCBnZXR0ZXJzLlxuICAgIC8vXG4gICAgLy8gRnV0dXJlIHBsYW4gaXMgdG8gcmVkdWNlIGNvbXBsZXhpdHkgb2YgdGhpcyBmaWxlIGJ5IG1lcmdpbmcgMyBvYmplY3RzIGludG8gb25lIGNvbnRleHQ6XG4gICAgLy8gZGVmYXVsdHMrb3B0aW9ucytjdXN0b20gZ2V0dGVycyA9IENvbm5lY3Rpb25Db25maWdcbiAgICB0aGlzLnVzZXJuYW1lID0gb3B0aW9ucy51c2VybmFtZTtcbiAgICB0aGlzLnBhc3N3b3JkID0gb3B0aW9ucy5wYXNzd29yZDtcbiAgICB0aGlzLmFjY2Vzc1VybCA9IG9wdGlvbnMuYWNjZXNzVXJsO1xuICAgIHRoaXMucmVnaW9uID0gb3B0aW9ucy5yZWdpb247XG4gICAgdGhpcy5hY2NvdW50ID0gb3B0aW9ucy5hY2NvdW50O1xuICAgIHRoaXMudG9rZW4gPSBvcHRpb25zLnRva2VuO1xuICAgIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IG9wdGlvbnMuc2Vzc2lvblRva2VuO1xuICAgIHRoaXMubWFzdGVyVG9rZW4gPSBvcHRpb25zLm1hc3RlclRva2VuO1xuICAgIHRoaXMubWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IG9wdGlvbnMubWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICB0aGlzLnNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lID0gb3B0aW9ucy5zZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICB0aGlzLmNsaWVudENvbmZpZ0ZpbGUgPSBvcHRpb25zLmNsaWVudENvbmZpZ0ZpbGU7XG4gICAgdGhpcy5vcGVuRXh0ZXJuYWxCcm93c2VyQ2FsbGJhY2sgPSBvcHRpb25zLm9wZW5FeHRlcm5hbEJyb3dzZXJDYWxsYmFjaztcbiAgICB0aGlzLm9hdXRoRW5hYmxlU2luZ2xlVXNlUmVmcmVzaFRva2VucyA9IG9wdGlvbnMub2F1dGhFbmFibGVTaW5nbGVVc2VSZWZyZXNoVG9rZW5zO1xuICAgIHRoaXMud29ya2xvYWRJZGVudGl0eVByb3ZpZGVyID0gb3B0aW9ucy53b3JrbG9hZElkZW50aXR5UHJvdmlkZXI7XG4gICAgdGhpcy53b3JrbG9hZElkZW50aXR5SW1wZXJzb25hdGlvblBhdGggPSBvcHRpb25zLndvcmtsb2FkSWRlbnRpdHlJbXBlcnNvbmF0aW9uUGF0aDtcbiAgICB0aGlzLndvcmtsb2FkSWRlbnRpdHlBenVyZUVudHJhSWRSZXNvdXJjZSA9IG9wdGlvbnMud29ya2xvYWRJZGVudGl0eUF6dXJlRW50cmFJZFJlc291cmNlO1xuICAgIHRoaXMud29ya2xvYWRJZGVudGl0eUF6dXJlQ2xpZW50SWQgPSBvcHRpb25zLndvcmtsb2FkSWRlbnRpdHlBenVyZUNsaWVudElkO1xuICAgIHRoaXMuY3JsVmFsaWRhdG9yQ29uZmlnID0ge1xuICAgICAgICBjaGVja01vZGU6IG9wdGlvbnMuY2VydFJldm9jYXRpb25DaGVja01vZGUgPz8gJ0RJU0FCTEVEJyxcbiAgICAgICAgYWxsb3dDZXJ0aWZpY2F0ZXNXaXRob3V0Q3JsVVJMOiBvcHRpb25zLmNybEFsbG93Q2VydGlmaWNhdGVzV2l0aG91dENybFVSTCA/PyBmYWxzZSxcbiAgICAgICAgaW5NZW1vcnlDYWNoZTogb3B0aW9ucy5jcmxJbk1lbW9yeUNhY2hlID8/IHRydWUsXG4gICAgICAgIG9uRGlza0NhY2hlOiBvcHRpb25zLmNybE9uRGlza0NhY2hlID8/IHRydWUsXG4gICAgfTtcbiAgICAvLyBjcmVhdGUgdGhlIHBhcmFtZXRlcnMgYXJyYXlcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gY3JlYXRlUGFyYW1ldGVycygpO1xuICAgIC8vIGNyZWF0ZSBhIG1hcCBpbiB3aGljaCB0aGUga2V5cyBhcmUgdGhlIHBhcmFtZXRlciBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmVcbiAgICAvLyB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXJzXG4gICAgY29uc3QgbWFwUGFyYW1ldGVycyA9IHt9O1xuICAgIGxldCBpbmRleCwgbGVuZ3RoLCBwYXJhbWV0ZXI7XG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzW2luZGV4XTtcbiAgICAgICAgbWFwUGFyYW1ldGVyc1twYXJhbWV0ZXIubmFtZV0gPSBwYXJhbWV0ZXI7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHZhbHVlIHRvIHRoZSBkZWZhdWx0XG4gICAgICAgIHBhcmFtZXRlci52YWx1ZSA9IHBhcmFtZXRlci5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIC8vIGZvciBlYWNoIHByb3BlcnR5IGluIHRoZSBvcHRpb25zIG9iamVjdCB0aGF0IG1hdGNoZXMgYSBrbm93biBwYXJhbWV0ZXIgbmFtZVxuICAgIGxldCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWU7XG4gICAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIHByb3BlcnR5TmFtZSkgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXBQYXJhbWV0ZXJzLCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyYW1ldGVyIG1hdGNoaW5nIHRoZSBwcm9wZXJ0eSBpcyBleHRlcm5hbCBhbmQgdGhlIHNwZWNpZmllZFxuICAgICAgICAgICAgLy8gdmFsdWUgaXMgdmFsaWQgZm9yIHRoZSBwYXJhbWV0ZXIsIHVwZGF0ZSB0aGUgcGFyYW1ldGVyIHZhbHVlXG4gICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID0gb3B0aW9uc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgcGFyYW1ldGVyID0gbWFwUGFyYW1ldGVyc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlci5leHRlcm5hbCAmJiBwYXJhbWV0ZXIudmFsaWRhdGUocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXIudmFsdWUgPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNhdmUgdGhlIHBhcmFtZXRlcnMgbWFwXG4gICAgdGhpcy5fbWFwUGFyYW1ldGVycyA9IG1hcFBhcmFtZXRlcnM7XG4gICAgLy8gY3VzdG9tIGFnZW50IGNsYXNzLCB0ZXN0IG9ubHlcbiAgICB0aGlzLmFnZW50Q2xhc3MgPSBvcHRpb25zLmFnZW50Q2xhc3M7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgcWEtbW9kZSBpcyBvbi5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuaXNRYU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3FhTW9kZTtcbn07XG4vKipcbiAqIENsZWFycyBhbGwgY3JlZGVudGlhbC1yZWxhdGVkIGluZm9ybWF0aW9uLlxuICovXG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5jbGVhckNyZWRlbnRpYWxzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNsZWFyIHRoZSBwYXNzd29yZFxuICAgIHRoaXMucGFzc3dvcmQgPSBudWxsO1xuICAgIC8vIFRPRE86IGNsZWFyIHBhc3Njb2RlIGFuZCBvdGhlciBjcmVkZW50aWFsLXJlbGF0ZWQgaW5mb3JtYXRpb24gYXMgd2VsbFxufTtcbmNvbnN0IFBBUkFNX1RJTUVPVVQgPSAndGltZW91dCc7XG5jb25zdCBQQVJBTV9SRVNVTFRfUFJFRkVUQ0ggPSAncmVzdWx0UHJlZmV0Y2gnO1xuY29uc3QgUEFSQU1fUkVTVUxUX1NUUkVBTV9JTlRFUlJVUFRTID0gJ3Jlc3VsdFN0cmVhbUludGVycnVwdHMnO1xuY29uc3QgUEFSQU1fUkVTVUxUX0NIVU5LX0NBQ0hFX1NJWkUgPSAncmVzdWx0Q2h1bmtDYWNoZVNpemUnO1xuY29uc3QgUEFSQU1fUkVTVUxUX1BST0NFU1NJTkdfQkFUQ0hfU0laRSA9ICdyZXN1bHRQcm9jZXNzaW5nQmF0Y2hTaXplJztcbmNvbnN0IFBBUkFNX1JFU1VMVF9QUk9DRVNTSU5HX0JBVENIX0RVUkFUSU9OID0gJ3Jlc3VsdFByb2Nlc3NpbmdCYXRjaER1cmF0aW9uJztcbmNvbnN0IFBBUkFNX1JPV19TVFJFQU1fSElHSF9XQVRFUl9NQVJLID0gJ3Jvd1N0cmVhbUhpZ2hXYXRlck1hcmsnO1xuY29uc3QgUEFSQU1fUkVUUllfTEFSR0VfUkVTVUxUX1NFVF9NQVhfTlVNX1JFVFJJRVMgPSAnbGFyZ2VSZXN1bHRTZXRSZXRyeU1heE51bVJldHJpZXMnO1xuY29uc3QgUEFSQU1fUkVUUllfTEFSR0VfUkVTVUxUX1NFVF9NQVhfU0xFRVBfVElNRSA9ICdsYXJnZVJlc3VsdFNldFJldHJ5TWF4U2xlZXBUaW1lJztcbmNvbnN0IFBBUkFNX1JFVFJZX1NGX01BWF9MT0dJTl9SRVRSSUVTID0gJ3NmUmV0cnlNYXhMb2dpblJldHJpZXMnO1xuY29uc3QgUEFSQU1fUkVUUllfU0ZfTUFYX05VTV9SRVRSSUVTID0gJ3NmUmV0cnlNYXhOdW1SZXRyaWVzJztcbmNvbnN0IFBBUkFNX1JFVFJZX1NGX1NUQVJUSU5HX1NMRUVQX1RJTUUgPSAnc2ZSZXRyeVN0YXJ0aW5nU2xlZXBUaW1lJztcbmNvbnN0IFBBUkFNX1JFVFJZX1NGX01BWF9TTEVFUF9USU1FID0gJ3NmUmV0cnlNYXhTbGVlcFRpbWUnO1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBsaXN0IG9mIGtub3duIHBhcmFtZXRlcnMuIElmIGEgcGFyYW1ldGVyIGlzIG1hcmtlZCBhcyBleHRlcm5hbCxcbiAqIGl0cyB2YWx1ZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSBhZGRpbmcgdGhlIGFwcHJvcHJpYXRlIG5hbWUtdmFsdWUgbWFwcGluZyB0b1xuICogdGhlIENvbm5lY3Rpb25Db25maWcgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgaXNOb25OZWdhdGl2ZUludGVnZXIgPSBVdGlsLm51bWJlci5pc05vbk5lZ2F0aXZlSW50ZWdlci5iaW5kKFV0aWwubnVtYmVyKTtcbiAgICBjb25zdCBpc1Bvc2l0aXZlSW50ZWdlciA9IFV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyLmJpbmQoVXRpbC5udW1iZXIpO1xuICAgIGNvbnN0IGlzTm9uTmVnYXRpdmVOdW1iZXIgPSBVdGlsLm51bWJlci5pc05vbk5lZ2F0aXZlLmJpbmQoVXRpbC5udW1iZXIpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1RJTUVPVVQsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDkwICogMTAwMCxcbiAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9SRVNVTFRfUFJFRkVUQ0gsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDIsXG4gICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVTVUxUX1NUUkVBTV9JTlRFUlJVUFRTLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAzLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyLFxuICAgICAgICB9LFxuICAgICAgICAvLyBmb3Igbm93IHdlIHNldCBjaHVuayBjYWNoZSBzaXplIHRvIDEsIHdoaWNoIGlzIHNhbWUgYXNcbiAgICAgICAgLy8gZGlzYWJsaW5nIHRoZSBjaHVuayBjYWNoZS4gT3RoZXJ3aXNlLCBjYWNoZSB3aWxsIGV4cGxvZGVcbiAgICAgICAgLy8gbWVtb3J5IHdoZW4gZmV0Y2hpbmcgbGFyZ2UgcmVzdWx0IHNldFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9SRVNVTFRfQ0hVTktfQ0FDSEVfU0laRSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVTVUxUX1BST0NFU1NJTkdfQkFUQ0hfU0laRSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMTAwMCxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVTVUxUX1BST0NFU1NJTkdfQkFUQ0hfRFVSQVRJT04sXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDEwMCxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUk9XX1NUUkVBTV9ISUdIX1dBVEVSX01BUkssXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDEwLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9SRVRSWV9MQVJHRV9SRVNVTFRfU0VUX01BWF9OVU1fUkVUUklFUyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMTAsXG4gICAgICAgICAgICB2YWxpZGF0ZTogaXNOb25OZWdhdGl2ZUludGVnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1JFVFJZX0xBUkdFX1JFU1VMVF9TRVRfTUFYX1NMRUVQX1RJTUUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDE2LFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzTm9uTmVnYXRpdmVJbnRlZ2VyLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9SRVRSWV9TRl9NQVhfTE9HSU5fUkVUUklFUyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogNyxcbiAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzTm9uTmVnYXRpdmVJbnRlZ2VyLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9SRVRSWV9TRl9NQVhfTlVNX1JFVFJJRVMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDEwMDAsXG4gICAgICAgICAgICB2YWxpZGF0ZTogaXNOb25OZWdhdGl2ZUludGVnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1JFVFJZX1NGX1NUQVJUSU5HX1NMRUVQX1RJTUUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDEsXG4gICAgICAgICAgICB2YWxpZGF0ZTogaXNOb25OZWdhdGl2ZU51bWJlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVUUllfU0ZfTUFYX1NMRUVQX1RJTUUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDE2LFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzTm9uTmVnYXRpdmVOdW1iZXIsXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1RJTUVPVVQpO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJlc3VsdFByZWZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVNVTFRfUFJFRkVUQ0gpO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJlc3VsdFN0cmVhbUludGVycnVwdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFU1VMVF9TVFJFQU1fSU5URVJSVVBUUyk7XG59O1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmVzdWx0Q2h1bmtDYWNoZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFU1VMVF9DSFVOS19DQUNIRV9TSVpFKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXN1bHRQcm9jZXNzaW5nQmF0Y2hTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVNVTFRfUFJPQ0VTU0lOR19CQVRDSF9TSVpFKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXN1bHRQcm9jZXNzaW5nQmF0Y2hEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UGFyYW1ldGVyVmFsdWUoUEFSQU1fUkVTVUxUX1BST0NFU1NJTkdfQkFUQ0hfRFVSQVRJT04pO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJvd1N0cmVhbUhpZ2hXYXRlck1hcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JPV19TVFJFQU1fSElHSF9XQVRFUl9NQVJLKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXRyeUxhcmdlUmVzdWx0U2V0TWF4TnVtUmV0cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UGFyYW1ldGVyVmFsdWUoUEFSQU1fUkVUUllfTEFSR0VfUkVTVUxUX1NFVF9NQVhfTlVNX1JFVFJJRVMpO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJldHJ5TGFyZ2VSZXN1bHRTZXRNYXhTbGVlcFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX0xBUkdFX1JFU1VMVF9TRVRfTUFYX1NMRUVQX1RJTUUpO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJldHJ5U2ZNYXhOdW1SZXRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVRSWV9TRl9NQVhfTlVNX1JFVFJJRVMpO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJldHJ5U2ZNYXhMb2dpblJldHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX1NGX01BWF9MT0dJTl9SRVRSSUVTKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXRyeVNmU3RhcnRpbmdTbGVlcFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX1NGX1NUQVJUSU5HX1NMRUVQX1RJTUUpO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJldHJ5U2ZNYXhTbGVlcFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX1NGX01BWF9TTEVFUF9USU1FKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gY29ubmVjdGlvbiBjb25maWcgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLl9nZXRQYXJhbWV0ZXJWYWx1ZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJOYW1lKSB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gdGhpcy5fbWFwUGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXTtcbiAgICByZXR1cm4gcGFyYW1ldGVyID8gcGFyYW1ldGVyLnZhbHVlIDogdW5kZWZpbmVkO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbkNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb25fY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst SfService = __webpack_require__(/*! ../services/sf */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/services/sf.js\");\nconst LargeResultSetService = __webpack_require__(/*! ../services/large_result_set */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * Creates a new ConnectionContext.\n *\n * @param {ConnectionConfig} connectionConfig\n * @param {Object} httpClient\n * @param {Object} config\n *\n * @constructor\n */\nfunction ConnectionContext(connectionConfig, httpClient, config) {\n    // validate input\n    Logger.getInstance().trace('Creating ConnectionContext object.');\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    Errors.assertInternal(Util.isObject(httpClient));\n    // if a config object was specified, verify\n    // that it has all the information we need\n    let sfServiceConfig;\n    if (Util.exists(config)) {\n        Logger.getInstance().trace('ConnectionContext - validating received config.');\n        Errors.assertInternal(Util.isObject(config));\n        Errors.assertInternal(Util.isObject(config.services));\n        Errors.assertInternal(Util.isObject(config.services.sf));\n        sfServiceConfig = config.services.sf;\n    }\n    Logger.getInstance().debug('ConnectionContext - received data was validated.');\n    // create a map that contains all the services we'll be using\n    const services = {\n        sf: new SfService(connectionConfig, httpClient, sfServiceConfig),\n        largeResultSet: new LargeResultSetService(connectionConfig, httpClient),\n    };\n    Logger.getInstance().debug('ConnectionContext - services were instantiated.');\n    /**\n     * Returns the ConnectionConfig for use by the connection.\n     *\n     * @returns {ConnectionConfig}\n     */\n    this.getConnectionConfig = function () {\n        return connectionConfig;\n    };\n    /**\n     * Returns a map that contains all the available services.\n     *\n     * @returns {Object}\n     */\n    this.getServices = function () {\n        return services;\n    };\n    /**\n     * Returns a configuration object that can be passed as an optional argument\n     * to the ConnectionContext constructor to create a new object that has the\n     * same state as this ConnectionContext instance.\n     *\n     * @returns {Object}\n     */\n    this.getConfig = function () {\n        return {\n            services: {\n                sf: services.sf.getConfig(),\n            },\n        };\n    };\n    /**\n     * Returns instance of httpClient\n     *\n     * @returns {NodeHttpClient}\n     */\n    this.getHttpClient = function () {\n        return httpClient;\n    };\n}\nmodule.exports = ConnectionContext;\n//# sourceMappingURL=connection_context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzFDLDhCQUE4QixtQkFBTyxDQUFDLDhHQUE4QjtBQUNwRSxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29udGV4dC5qcz9mMTc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgU2ZTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZXMvc2YnKTtcbmNvbnN0IExhcmdlUmVzdWx0U2V0U2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL2xhcmdlX3Jlc3VsdF9zZXQnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IENvbm5lY3Rpb25Db250ZXh0LlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbkNvbmZpZ30gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IGh0dHBDbGllbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29ubmVjdGlvbkNvbnRleHQoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgY29uZmlnKSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ3JlYXRpbmcgQ29ubmVjdGlvbkNvbnRleHQgb2JqZWN0LicpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbm5lY3Rpb25Db25maWcpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChodHRwQ2xpZW50KSk7XG4gICAgLy8gaWYgYSBjb25maWcgb2JqZWN0IHdhcyBzcGVjaWZpZWQsIHZlcmlmeVxuICAgIC8vIHRoYXQgaXQgaGFzIGFsbCB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZFxuICAgIGxldCBzZlNlcnZpY2VDb25maWc7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGNvbmZpZykpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25Db250ZXh0IC0gdmFsaWRhdGluZyByZWNlaXZlZCBjb25maWcuJyk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbmZpZykpO1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25maWcuc2VydmljZXMpKTtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29uZmlnLnNlcnZpY2VzLnNmKSk7XG4gICAgICAgIHNmU2VydmljZUNvbmZpZyA9IGNvbmZpZy5zZXJ2aWNlcy5zZjtcbiAgICB9XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25Db250ZXh0IC0gcmVjZWl2ZWQgZGF0YSB3YXMgdmFsaWRhdGVkLicpO1xuICAgIC8vIGNyZWF0ZSBhIG1hcCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgc2VydmljZXMgd2UnbGwgYmUgdXNpbmdcbiAgICBjb25zdCBzZXJ2aWNlcyA9IHtcbiAgICAgICAgc2Y6IG5ldyBTZlNlcnZpY2UoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgc2ZTZXJ2aWNlQ29uZmlnKSxcbiAgICAgICAgbGFyZ2VSZXN1bHRTZXQ6IG5ldyBMYXJnZVJlc3VsdFNldFNlcnZpY2UoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCksXG4gICAgfTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbkNvbnRleHQgLSBzZXJ2aWNlcyB3ZXJlIGluc3RhbnRpYXRlZC4nKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDb25uZWN0aW9uQ29uZmlnIGZvciB1c2UgYnkgdGhlIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvbkNvbmZpZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldENvbm5lY3Rpb25Db25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uQ29uZmlnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgYXZhaWxhYmxlIHNlcnZpY2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldFNlcnZpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIGFzIGFuIG9wdGlvbmFsIGFyZ3VtZW50XG4gICAgICogdG8gdGhlIENvbm5lY3Rpb25Db250ZXh0IGNvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdGhhdCBoYXMgdGhlXG4gICAgICogc2FtZSBzdGF0ZSBhcyB0aGlzIENvbm5lY3Rpb25Db250ZXh0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlcnZpY2VzOiB7XG4gICAgICAgICAgICAgICAgc2Y6IHNlcnZpY2VzLnNmLmdldENvbmZpZygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgaHR0cENsaWVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge05vZGVIdHRwQ2xpZW50fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0SHR0cENsaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGh0dHBDbGllbnQ7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbkNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uX2NvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n/**\n * Creates a new Chunk.\n *\n * @param options\n * @constructor\n */\nfunction Chunk(options) {\n    // make sure the options object contains all the necessary information\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isObject(options.statement));\n    Errors.assertInternal(Util.isObject(options.services));\n    Errors.assertInternal(Util.isNumber(options.startIndex));\n    Errors.assertInternal(Util.isArray(options.columns));\n    Errors.assertInternal(Util.isObject(options.mapColumnNameToIndices));\n    Errors.assertInternal(Util.isObject(options.statementParameters));\n    Errors.assertInternal(Util.isString(options.resultVersion));\n    Errors.assertInternal(Util.isNumber(options.rowCount));\n    // if the result is small (i.e. not persisted on S3/Blob), there's no\n    // compressed and uncompressed size, so default to -1\n    this._compressedSize = options.compressedSize || -1;\n    this._uncompressedSize = options.uncompressedSize || -1;\n    // copy out other information from the options object and save it\n    this._statement = options.statement;\n    this._services = options.services;\n    this._startIndex = options.startIndex;\n    this._url = options.url;\n    this._columns = options.columns;\n    this._mapColumnNameToIndices = options.mapColumnNameToIndices;\n    this._chunkHeaders = options.chunkHeaders;\n    this._rowset = options.rowset;\n    // use the start index and row count to compute the end index\n    this._endIndex = this._startIndex + options.rowCount - 1;\n    // use the start and end index to build an id for this chunk\n    this._id = buildId(this._startIndex, this._endIndex);\n}\nUtil.inherits(Chunk, EventEmitter);\n/**\n * Returns the compressed size of this chunk's contents on S3/Blob.\n * A value of -1 means the contents of this chunk are not stored on S3/Blob.\n *\n * @returns {Number}\n */\nChunk.prototype.getCompressedSize = function () {\n    return this._compressedSize;\n};\n/**\n * Returns the uncompressed size of this chunk's contents on S3/Blob.\n * A value of -1 means the contents of this chunk are not stored on S3/Blob.\n *\n * @returns {Number}\n */\nChunk.prototype.getUncompressedSize = function () {\n    return this._uncompressedSize;\n};\n/**\n * Returns the row index of the first row in this chunk.\n *\n * @returns {Number}\n */\nChunk.prototype.getStartIndex = function () {\n    return this._startIndex;\n};\n/**\n * Returns the row index of the last row in this chunk.\n *\n * @returns {Number}\n */\nChunk.prototype.getEndIndex = function () {\n    return this._endIndex;\n};\n/**\n * Returns the id of this chunk.\n *\n * @returns {String}\n */\nChunk.prototype.getId = function () {\n    return this._id;\n};\n/**\n * Determines if this chunk overlaps with a given window.\n *\n * @param {Number} start The start index of the window.\n * @param {Number} end The end index of the window.\n *\n * @returns {Boolean}\n */\nChunk.prototype.overlapsWithWindow = function (start, end) {\n    const chunkStart = this._startIndex, chunkEnd = this._endIndex;\n    // check if the window overlaps with the chunk from the left or\n    // from the right or from both sides\n    return ((end <= chunkEnd && end >= chunkStart) ||\n        (start >= chunkStart && start <= chunkEnd) ||\n        (start <= chunkStart && end >= chunkEnd));\n};\n/**\n * Returns the rows in this chunk.\n *\n * @returns {Object[]}\n */\nChunk.prototype.getRows = function () {\n    // if we don't already have a valid value for the rows\n    if (!Util.isArray(this._rows)) {\n        // if we have a string version of the rowset\n        if (Util.string.isNotNullOrEmpty(this._rowsetAsString)) {\n            // add square brackets on either side and do a json-parse to get the\n            // rowset\n            this._rowset = JSON.parse('[' + this._rowsetAsString + ']');\n            // we don't need the string version of the rowset anymore\n            this._rowsetAsString = undefined;\n        }\n        // if we have a valid value for the rowset\n        if (Util.isArray(this._rowset)) {\n            // convert the rowset to an array of rows\n            this._rows = convertRowsetToRows(this._statement, this._startIndex, this._rowset, this._columns, this._mapColumnNameToIndices);\n            // clear out the rowset because we don't need it anymore\n            this._rowset = undefined;\n        }\n    }\n    return this._rows;\n};\n/**\n * Clears out the rows in this chunk if it has a valid url or if the force flag\n * is true.\n *\n * @param force\n */\nChunk.prototype.clearRows = function (force) {\n    if (Util.string.isNotNullOrEmpty(this._url) || force) {\n        // clear out all row and rowset related fields\n        this._rowsetAsString = this._rowset = this._rows = undefined;\n    }\n};\n/**\n * Updates this chunk's url.\n *\n * @param url\n */\nChunk.prototype.setUrl = function (url) {\n    this._url = url;\n};\n/**\n * Returns true if this chunk's contents are loaded, false otherwise.\n *\n * @returns {Boolean}\n */\nChunk.prototype.isLoaded = function () {\n    // the chunk is considered loaded if we have valid values for\n    // _rowsetAsString, _rowset or _rows\n    return (Util.string.isNotNullOrEmpty(this._rowsetAsString) ||\n        Util.isArray(this._rowset) ||\n        Util.isArray(this._rows));\n};\n/**\n * Returns true if this chunk is currently in the process of loading its\n * contents, false otherwise.\n *\n * @returns {Boolean}\n */\nChunk.prototype.isLoading = function () {\n    return this._isLoading;\n};\n/**\n * Loads the contents of this chunk.\n *\n * @param callback\n */\nChunk.prototype.load = function (callback) {\n    // we've started loading\n    this._isLoading = true;\n    const self = this;\n    /**\n     * Completes the chunk load.\n     *\n     * @param err\n     */\n    const completeLoad = function (err) {\n        // we're done loading\n        self._isLoading = false;\n        // emit an event to notify subscribers\n        self.emit('loadcomplete', err, self);\n        // invoke the callback if one was specified\n        if (Util.isFunction(callback)) {\n            callback(err, self);\n        }\n    };\n    // If the chunk is already loaded, complete the load asynchronously.\n    // This ensure that we are streaming chunks the right order even if the data was received before\n    // another chunk.\n    if (this.isLoaded()) {\n        process.nextTick(completeLoad);\n    }\n    else {\n        // issue a request to load the chunk's contents from S3/Blob\n        this._services.largeResultSet.getObject({\n            url: this._url,\n            headers: this._chunkHeaders,\n            callback: function (err, body) {\n                // if the request succeeded, save the\n                // body as a string version of the rowset\n                if (!err) {\n                    self._rowsetAsString = body;\n                }\n                // complete the load\n                completeLoad(err);\n            },\n        });\n    }\n};\n/**\n * Builds an id for a chunk from its start and end index.\n *\n * @param startIndex The row index of the first chunk row.\n * @param endIndex The row index of the last chunk row.\n *\n * @returns {String}\n * @private\n */\nfunction buildId(startIndex, endIndex) {\n    return Util.format('s=%d, e=%d', startIndex, endIndex);\n}\n/**\n * Converts a rowset to an array of records.\n *\n * @param statement\n * @param startIndex the chunk start index.\n * @param rowset\n * @param columns\n * @param mapColumnNameToIndices\n *\n * @returns {Array}\n * @private\n */\nfunction convertRowsetToRows(statement, startIndex, rowset, columns, mapColumnNameToIndices) {\n    // assert that rowset and columns are arrays\n    Errors.assertInternal(Util.isArray(rowset));\n    Errors.assertInternal(Util.isArray(columns));\n    ///////////////////////////////////////////////////////////////////////////\n    ////     Create functions that will be used as row methods             ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * Returns the index of this row in the result.\n     *\n     * @returns {Number}\n     */\n    const getRowIndex = function () {\n        return this.rowIndex;\n    };\n    /**\n     * Returns the statement that produced this row.\n     *\n     * @returns {*}\n     */\n    const getStatement = function getStatement() {\n        return statement;\n    };\n    /**\n     * Returns the value of a column.\n     *\n     * @param {String | Number} columnIdentifier this can be either the column\n     *   name or the column index.\n     *\n     * @returns {*}\n     */\n    const getColumnValue = function getColumnValue(columnIdentifier) {\n        // resolve the column identifier to the correct column if possible\n        const column = resolveColumnIdentifierToColumn(columns, columnIdentifier, mapColumnNameToIndices);\n        return column ? column.getRowValue(this) : undefined;\n    };\n    /**\n     * Returns the value of a column as a String.\n     *\n     * @param {String | Number} columnIdentifier this can be either the column\n     *   name or the column index.\n     *\n     * @returns {*}\n     */\n    const getColumnValueAsString = function getColumnValueAsString(columnIdentifier) {\n        // resolve the column identifier to the correct column if possible\n        const column = resolveColumnIdentifierToColumn(columns, columnIdentifier, mapColumnNameToIndices);\n        return column ? column.getRowValueAsString(this) : undefined;\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////     Convert the rowset to an array of row objects                 ////\n    ///////////////////////////////////////////////////////////////////////////\n    // create a new array to store the processed rows\n    const length = rowset.length;\n    const rows = new Array(length);\n    for (let index = 0; index < length; index++) {\n        // add a new item to the rows array\n        rows[index] = {\n            _arrayProcessedColumns: [],\n            values: rowset[index],\n            rowIndex: startIndex + index,\n            getRowIndex: getRowIndex,\n            getStatement: getStatement,\n            getColumnValue: getColumnValue,\n            getColumnValueAsString: getColumnValueAsString,\n        };\n    }\n    return rows;\n}\n/**\n * Resolves a column identifier to the corresponding column if possible. The\n * column identifier can be a column name or a column index. If an invalid\n * column identifier is specified, we return undefined.\n *\n * @param {Object[]} columns\n * @param {String | Number} columnIdentifier\n * @param {Object} mapColumnNameToIndices\n *\n * @returns {*}\n */\nfunction resolveColumnIdentifierToColumn(columns, columnIdentifier, mapColumnNameToIndices) {\n    let columnIndex;\n    // if the column identifier is a string, treat it as a column\n    // name and use it to get the index of the specified column\n    if (Util.isString(columnIdentifier)) {\n        // if a valid column name was specified, get the index of the first column\n        // with the specified name\n        if (Object.prototype.hasOwnProperty.call(mapColumnNameToIndices, columnIdentifier)) {\n            columnIndex = mapColumnNameToIndices[columnIdentifier][0];\n        }\n    }\n    else if (Util.isNumber(columnIdentifier)) {\n        // if the column identifier is a number, treat it as a column index\n        columnIndex = columnIdentifier;\n    }\n    return columns[columnIndex];\n}\nmodule.exports = Chunk;\n//# sourceMappingURL=chunk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVuay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLHVFQUFZO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVuay5qcz85ZGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IENodW5rLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2h1bmsob3B0aW9ucykge1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb25cbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5zdGF0ZW1lbnQpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLnNlcnZpY2VzKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNOdW1iZXIob3B0aW9ucy5zdGFydEluZGV4KSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShvcHRpb25zLmNvbHVtbnMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLm1hcENvbHVtbk5hbWVUb0luZGljZXMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLnN0YXRlbWVudFBhcmFtZXRlcnMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc1N0cmluZyhvcHRpb25zLnJlc3VsdFZlcnNpb24pKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc051bWJlcihvcHRpb25zLnJvd0NvdW50KSk7XG4gICAgLy8gaWYgdGhlIHJlc3VsdCBpcyBzbWFsbCAoaS5lLiBub3QgcGVyc2lzdGVkIG9uIFMzL0Jsb2IpLCB0aGVyZSdzIG5vXG4gICAgLy8gY29tcHJlc3NlZCBhbmQgdW5jb21wcmVzc2VkIHNpemUsIHNvIGRlZmF1bHQgdG8gLTFcbiAgICB0aGlzLl9jb21wcmVzc2VkU2l6ZSA9IG9wdGlvbnMuY29tcHJlc3NlZFNpemUgfHwgLTE7XG4gICAgdGhpcy5fdW5jb21wcmVzc2VkU2l6ZSA9IG9wdGlvbnMudW5jb21wcmVzc2VkU2l6ZSB8fCAtMTtcbiAgICAvLyBjb3B5IG91dCBvdGhlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvcHRpb25zIG9iamVjdCBhbmQgc2F2ZSBpdFxuICAgIHRoaXMuX3N0YXRlbWVudCA9IG9wdGlvbnMuc3RhdGVtZW50O1xuICAgIHRoaXMuX3NlcnZpY2VzID0gb3B0aW9ucy5zZXJ2aWNlcztcbiAgICB0aGlzLl9zdGFydEluZGV4ID0gb3B0aW9ucy5zdGFydEluZGV4O1xuICAgIHRoaXMuX3VybCA9IG9wdGlvbnMudXJsO1xuICAgIHRoaXMuX2NvbHVtbnMgPSBvcHRpb25zLmNvbHVtbnM7XG4gICAgdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyA9IG9wdGlvbnMubWFwQ29sdW1uTmFtZVRvSW5kaWNlcztcbiAgICB0aGlzLl9jaHVua0hlYWRlcnMgPSBvcHRpb25zLmNodW5rSGVhZGVycztcbiAgICB0aGlzLl9yb3dzZXQgPSBvcHRpb25zLnJvd3NldDtcbiAgICAvLyB1c2UgdGhlIHN0YXJ0IGluZGV4IGFuZCByb3cgY291bnQgdG8gY29tcHV0ZSB0aGUgZW5kIGluZGV4XG4gICAgdGhpcy5fZW5kSW5kZXggPSB0aGlzLl9zdGFydEluZGV4ICsgb3B0aW9ucy5yb3dDb3VudCAtIDE7XG4gICAgLy8gdXNlIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IHRvIGJ1aWxkIGFuIGlkIGZvciB0aGlzIGNodW5rXG4gICAgdGhpcy5faWQgPSBidWlsZElkKHRoaXMuX3N0YXJ0SW5kZXgsIHRoaXMuX2VuZEluZGV4KTtcbn1cblV0aWwuaW5oZXJpdHMoQ2h1bmssIEV2ZW50RW1pdHRlcik7XG4vKipcbiAqIFJldHVybnMgdGhlIGNvbXByZXNzZWQgc2l6ZSBvZiB0aGlzIGNodW5rJ3MgY29udGVudHMgb24gUzMvQmxvYi5cbiAqIEEgdmFsdWUgb2YgLTEgbWVhbnMgdGhlIGNvbnRlbnRzIG9mIHRoaXMgY2h1bmsgYXJlIG5vdCBzdG9yZWQgb24gUzMvQmxvYi5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5DaHVuay5wcm90b3R5cGUuZ2V0Q29tcHJlc3NlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXByZXNzZWRTaXplO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdW5jb21wcmVzc2VkIHNpemUgb2YgdGhpcyBjaHVuaydzIGNvbnRlbnRzIG9uIFMzL0Jsb2IuXG4gKiBBIHZhbHVlIG9mIC0xIG1lYW5zIHRoZSBjb250ZW50cyBvZiB0aGlzIGNodW5rIGFyZSBub3Qgc3RvcmVkIG9uIFMzL0Jsb2IuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuQ2h1bmsucHJvdG90eXBlLmdldFVuY29tcHJlc3NlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuY29tcHJlc3NlZFNpemU7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSByb3cgaW5kZXggb2YgdGhlIGZpcnN0IHJvdyBpbiB0aGlzIGNodW5rLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbkNodW5rLnByb3RvdHlwZS5nZXRTdGFydEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydEluZGV4O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcm93IGluZGV4IG9mIHRoZSBsYXN0IHJvdyBpbiB0aGlzIGNodW5rLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbkNodW5rLnByb3RvdHlwZS5nZXRFbmRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kSW5kZXg7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGlzIGNodW5rLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkNodW5rLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoaXMgY2h1bmsgb3ZlcmxhcHMgd2l0aCBhIGdpdmVuIHdpbmRvdy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSB3aW5kb3cuXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kIFRoZSBlbmQgaW5kZXggb2YgdGhlIHdpbmRvdy5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuQ2h1bmsucHJvdG90eXBlLm92ZXJsYXBzV2l0aFdpbmRvdyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgY2h1bmtTdGFydCA9IHRoaXMuX3N0YXJ0SW5kZXgsIGNodW5rRW5kID0gdGhpcy5fZW5kSW5kZXg7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHdpbmRvdyBvdmVybGFwcyB3aXRoIHRoZSBjaHVuayBmcm9tIHRoZSBsZWZ0IG9yXG4gICAgLy8gZnJvbSB0aGUgcmlnaHQgb3IgZnJvbSBib3RoIHNpZGVzXG4gICAgcmV0dXJuICgoZW5kIDw9IGNodW5rRW5kICYmIGVuZCA+PSBjaHVua1N0YXJ0KSB8fFxuICAgICAgICAoc3RhcnQgPj0gY2h1bmtTdGFydCAmJiBzdGFydCA8PSBjaHVua0VuZCkgfHxcbiAgICAgICAgKHN0YXJ0IDw9IGNodW5rU3RhcnQgJiYgZW5kID49IGNodW5rRW5kKSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSByb3dzIGluIHRoaXMgY2h1bmsuXG4gKlxuICogQHJldHVybnMge09iamVjdFtdfVxuICovXG5DaHVuay5wcm90b3R5cGUuZ2V0Um93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSB2YWxpZCB2YWx1ZSBmb3IgdGhlIHJvd3NcbiAgICBpZiAoIVV0aWwuaXNBcnJheSh0aGlzLl9yb3dzKSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHJvd3NldFxuICAgICAgICBpZiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eSh0aGlzLl9yb3dzZXRBc1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIGFkZCBzcXVhcmUgYnJhY2tldHMgb24gZWl0aGVyIHNpZGUgYW5kIGRvIGEganNvbi1wYXJzZSB0byBnZXQgdGhlXG4gICAgICAgICAgICAvLyByb3dzZXRcbiAgICAgICAgICAgIHRoaXMuX3Jvd3NldCA9IEpTT04ucGFyc2UoJ1snICsgdGhpcy5fcm93c2V0QXNTdHJpbmcgKyAnXScpO1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHJvd3NldCBhbnltb3JlXG4gICAgICAgICAgICB0aGlzLl9yb3dzZXRBc1N0cmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgdmFsaWQgdmFsdWUgZm9yIHRoZSByb3dzZXRcbiAgICAgICAgaWYgKFV0aWwuaXNBcnJheSh0aGlzLl9yb3dzZXQpKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSByb3dzZXQgdG8gYW4gYXJyYXkgb2Ygcm93c1xuICAgICAgICAgICAgdGhpcy5fcm93cyA9IGNvbnZlcnRSb3dzZXRUb1Jvd3ModGhpcy5fc3RhdGVtZW50LCB0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9yb3dzZXQsIHRoaXMuX2NvbHVtbnMsIHRoaXMuX21hcENvbHVtbk5hbWVUb0luZGljZXMpO1xuICAgICAgICAgICAgLy8gY2xlYXIgb3V0IHRoZSByb3dzZXQgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIGl0IGFueW1vcmVcbiAgICAgICAgICAgIHRoaXMuX3Jvd3NldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm93cztcbn07XG4vKipcbiAqIENsZWFycyBvdXQgdGhlIHJvd3MgaW4gdGhpcyBjaHVuayBpZiBpdCBoYXMgYSB2YWxpZCB1cmwgb3IgaWYgdGhlIGZvcmNlIGZsYWdcbiAqIGlzIHRydWUuXG4gKlxuICogQHBhcmFtIGZvcmNlXG4gKi9cbkNodW5rLnByb3RvdHlwZS5jbGVhclJvd3MgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICBpZiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eSh0aGlzLl91cmwpIHx8IGZvcmNlKSB7XG4gICAgICAgIC8vIGNsZWFyIG91dCBhbGwgcm93IGFuZCByb3dzZXQgcmVsYXRlZCBmaWVsZHNcbiAgICAgICAgdGhpcy5fcm93c2V0QXNTdHJpbmcgPSB0aGlzLl9yb3dzZXQgPSB0aGlzLl9yb3dzID0gdW5kZWZpbmVkO1xuICAgIH1cbn07XG4vKipcbiAqIFVwZGF0ZXMgdGhpcyBjaHVuaydzIHVybC5cbiAqXG4gKiBAcGFyYW0gdXJsXG4gKi9cbkNodW5rLnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdGhpcy5fdXJsID0gdXJsO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2h1bmsncyBjb250ZW50cyBhcmUgbG9hZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkNodW5rLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0aGUgY2h1bmsgaXMgY29uc2lkZXJlZCBsb2FkZWQgaWYgd2UgaGF2ZSB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgLy8gX3Jvd3NldEFzU3RyaW5nLCBfcm93c2V0IG9yIF9yb3dzXG4gICAgcmV0dXJuIChVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KHRoaXMuX3Jvd3NldEFzU3RyaW5nKSB8fFxuICAgICAgICBVdGlsLmlzQXJyYXkodGhpcy5fcm93c2V0KSB8fFxuICAgICAgICBVdGlsLmlzQXJyYXkodGhpcy5fcm93cykpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2h1bmsgaXMgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIGxvYWRpbmcgaXRzXG4gKiBjb250ZW50cywgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5DaHVuay5wcm90b3R5cGUuaXNMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0xvYWRpbmc7XG59O1xuLyoqXG4gKiBMb2FkcyB0aGUgY29udGVudHMgb2YgdGhpcyBjaHVuay5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuQ2h1bmsucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyB3ZSd2ZSBzdGFydGVkIGxvYWRpbmdcbiAgICB0aGlzLl9pc0xvYWRpbmcgPSB0cnVlO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRlcyB0aGUgY2h1bmsgbG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJcbiAgICAgKi9cbiAgICBjb25zdCBjb21wbGV0ZUxvYWQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgbG9hZGluZ1xuICAgICAgICBzZWxmLl9pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gZW1pdCBhbiBldmVudCB0byBub3RpZnkgc3Vic2NyaWJlcnNcbiAgICAgICAgc2VsZi5lbWl0KCdsb2FkY29tcGxldGUnLCBlcnIsIHNlbGYpO1xuICAgICAgICAvLyBpbnZva2UgdGhlIGNhbGxiYWNrIGlmIG9uZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNlbGYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiB0aGUgY2h1bmsgaXMgYWxyZWFkeSBsb2FkZWQsIGNvbXBsZXRlIHRoZSBsb2FkIGFzeW5jaHJvbm91c2x5LlxuICAgIC8vIFRoaXMgZW5zdXJlIHRoYXQgd2UgYXJlIHN0cmVhbWluZyBjaHVua3MgdGhlIHJpZ2h0IG9yZGVyIGV2ZW4gaWYgdGhlIGRhdGEgd2FzIHJlY2VpdmVkIGJlZm9yZVxuICAgIC8vIGFub3RoZXIgY2h1bmsuXG4gICAgaWYgKHRoaXMuaXNMb2FkZWQoKSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNvbXBsZXRlTG9hZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBpc3N1ZSBhIHJlcXVlc3QgdG8gbG9hZCB0aGUgY2h1bmsncyBjb250ZW50cyBmcm9tIFMzL0Jsb2JcbiAgICAgICAgdGhpcy5fc2VydmljZXMubGFyZ2VSZXN1bHRTZXQuZ2V0T2JqZWN0KHtcbiAgICAgICAgICAgIHVybDogdGhpcy5fdXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5fY2h1bmtIZWFkZXJzLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkZWQsIHNhdmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gYm9keSBhcyBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSByb3dzZXRcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9yb3dzZXRBc1N0cmluZyA9IGJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlIHRoZSBsb2FkXG4gICAgICAgICAgICAgICAgY29tcGxldGVMb2FkKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBCdWlsZHMgYW4gaWQgZm9yIGEgY2h1bmsgZnJvbSBpdHMgc3RhcnQgYW5kIGVuZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgcm93IGluZGV4IG9mIHRoZSBmaXJzdCBjaHVuayByb3cuXG4gKiBAcGFyYW0gZW5kSW5kZXggVGhlIHJvdyBpbmRleCBvZiB0aGUgbGFzdCBjaHVuayByb3cuXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSWQoc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICByZXR1cm4gVXRpbC5mb3JtYXQoJ3M9JWQsIGU9JWQnLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcm93c2V0IHRvIGFuIGFycmF5IG9mIHJlY29yZHMuXG4gKlxuICogQHBhcmFtIHN0YXRlbWVudFxuICogQHBhcmFtIHN0YXJ0SW5kZXggdGhlIGNodW5rIHN0YXJ0IGluZGV4LlxuICogQHBhcmFtIHJvd3NldFxuICogQHBhcmFtIGNvbHVtbnNcbiAqIEBwYXJhbSBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29udmVydFJvd3NldFRvUm93cyhzdGF0ZW1lbnQsIHN0YXJ0SW5kZXgsIHJvd3NldCwgY29sdW1ucywgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcykge1xuICAgIC8vIGFzc2VydCB0aGF0IHJvd3NldCBhbmQgY29sdW1ucyBhcmUgYXJyYXlzXG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShyb3dzZXQpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KGNvbHVtbnMpKTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vICAgICBDcmVhdGUgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHJvdyBtZXRob2RzICAgICAgICAgICAgIC8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGlzIHJvdyBpbiB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCBnZXRSb3dJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93SW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZW1lbnQgdGhhdCBwcm9kdWNlZCB0aGlzIHJvdy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNvbnN0IGdldFN0YXRlbWVudCA9IGZ1bmN0aW9uIGdldFN0YXRlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgY29sdW1uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGNvbHVtbklkZW50aWZpZXIgdGhpcyBjYW4gYmUgZWl0aGVyIHRoZSBjb2x1bW5cbiAgICAgKiAgIG5hbWUgb3IgdGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNvbnN0IGdldENvbHVtblZhbHVlID0gZnVuY3Rpb24gZ2V0Q29sdW1uVmFsdWUoY29sdW1uSWRlbnRpZmllcikge1xuICAgICAgICAvLyByZXNvbHZlIHRoZSBjb2x1bW4gaWRlbnRpZmllciB0byB0aGUgY29ycmVjdCBjb2x1bW4gaWYgcG9zc2libGVcbiAgICAgICAgY29uc3QgY29sdW1uID0gcmVzb2x2ZUNvbHVtbklkZW50aWZpZXJUb0NvbHVtbihjb2x1bW5zLCBjb2x1bW5JZGVudGlmaWVyLCBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiA/IGNvbHVtbi5nZXRSb3dWYWx1ZSh0aGlzKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgY29sdW1uIGFzIGEgU3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGNvbHVtbklkZW50aWZpZXIgdGhpcyBjYW4gYmUgZWl0aGVyIHRoZSBjb2x1bW5cbiAgICAgKiAgIG5hbWUgb3IgdGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNvbnN0IGdldENvbHVtblZhbHVlQXNTdHJpbmcgPSBmdW5jdGlvbiBnZXRDb2x1bW5WYWx1ZUFzU3RyaW5nKGNvbHVtbklkZW50aWZpZXIpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSB0aGUgY29sdW1uIGlkZW50aWZpZXIgdG8gdGhlIGNvcnJlY3QgY29sdW1uIGlmIHBvc3NpYmxlXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHJlc29sdmVDb2x1bW5JZGVudGlmaWVyVG9Db2x1bW4oY29sdW1ucywgY29sdW1uSWRlbnRpZmllciwgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBjb2x1bW4gPyBjb2x1bW4uZ2V0Um93VmFsdWVBc1N0cmluZyh0aGlzKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8gICAgIENvbnZlcnQgdGhlIHJvd3NldCB0byBhbiBhcnJheSBvZiByb3cgb2JqZWN0cyAgICAgICAgICAgICAgICAgLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSB0byBzdG9yZSB0aGUgcHJvY2Vzc2VkIHJvd3NcbiAgICBjb25zdCBsZW5ndGggPSByb3dzZXQubGVuZ3RoO1xuICAgIGNvbnN0IHJvd3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIC8vIGFkZCBhIG5ldyBpdGVtIHRvIHRoZSByb3dzIGFycmF5XG4gICAgICAgIHJvd3NbaW5kZXhdID0ge1xuICAgICAgICAgICAgX2FycmF5UHJvY2Vzc2VkQ29sdW1uczogW10sXG4gICAgICAgICAgICB2YWx1ZXM6IHJvd3NldFtpbmRleF0sXG4gICAgICAgICAgICByb3dJbmRleDogc3RhcnRJbmRleCArIGluZGV4LFxuICAgICAgICAgICAgZ2V0Um93SW5kZXg6IGdldFJvd0luZGV4LFxuICAgICAgICAgICAgZ2V0U3RhdGVtZW50OiBnZXRTdGF0ZW1lbnQsXG4gICAgICAgICAgICBnZXRDb2x1bW5WYWx1ZTogZ2V0Q29sdW1uVmFsdWUsXG4gICAgICAgICAgICBnZXRDb2x1bW5WYWx1ZUFzU3RyaW5nOiBnZXRDb2x1bW5WYWx1ZUFzU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcm93cztcbn1cbi8qKlxuICogUmVzb2x2ZXMgYSBjb2x1bW4gaWRlbnRpZmllciB0byB0aGUgY29ycmVzcG9uZGluZyBjb2x1bW4gaWYgcG9zc2libGUuIFRoZVxuICogY29sdW1uIGlkZW50aWZpZXIgY2FuIGJlIGEgY29sdW1uIG5hbWUgb3IgYSBjb2x1bW4gaW5kZXguIElmIGFuIGludmFsaWRcbiAqIGNvbHVtbiBpZGVudGlmaWVyIGlzIHNwZWNpZmllZCwgd2UgcmV0dXJuIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gY29sdW1uSWRlbnRpZmllclxuICogQHBhcmFtIHtPYmplY3R9IG1hcENvbHVtbk5hbWVUb0luZGljZXNcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbHVtbklkZW50aWZpZXJUb0NvbHVtbihjb2x1bW5zLCBjb2x1bW5JZGVudGlmaWVyLCBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzKSB7XG4gICAgbGV0IGNvbHVtbkluZGV4O1xuICAgIC8vIGlmIHRoZSBjb2x1bW4gaWRlbnRpZmllciBpcyBhIHN0cmluZywgdHJlYXQgaXQgYXMgYSBjb2x1bW5cbiAgICAvLyBuYW1lIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNvbHVtblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgICAgIC8vIGlmIGEgdmFsaWQgY29sdW1uIG5hbWUgd2FzIHNwZWNpZmllZCwgZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY29sdW1uXG4gICAgICAgIC8vIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwQ29sdW1uTmFtZVRvSW5kaWNlcywgY29sdW1uSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW5JZGVudGlmaWVyXVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChVdGlsLmlzTnVtYmVyKGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBjb2x1bW4gaWRlbnRpZmllciBpcyBhIG51bWJlciwgdHJlYXQgaXQgYXMgYSBjb2x1bW4gaW5kZXhcbiAgICAgICAgY29sdW1uSW5kZXggPSBjb2x1bW5JZGVudGlmaWVyO1xuICAgIH1cbiAgICByZXR1cm4gY29sdW1uc1tjb2x1bW5JbmRleF07XG59XG5tb2R1bGUuZXhwb3J0cyA9IENodW5rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmsuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst DoublyLinkedList = __webpack_require__(/*! ./doubly_linked_list */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js\");\n/**\n * An LRU cache used to store chunks.\n *\n * !! This cache is not fully implemented and not used at this time !!\n *\n * @param capacity the cache size in terms of the number of chunks.\n * @constructor\n */\nfunction ChunkCache(capacity) {\n    this._capacity = capacity;\n    // create a map and a doubly linked list to track the cached chunks\n    this._map = {};\n    this._list = new DoublyLinkedList();\n}\n/**\n * Adds a chunk to the cache.\n *\n * @param chunk\n */\nChunkCache.prototype.put = function (chunk) {\n    let evictedNode;\n    let evictedChunk;\n    const map = this._map;\n    const list = this._list;\n    const chunkId = chunk.getId();\n    // if we already have the chunk in the cache, remove the corresponding node\n    // from the list\n    if (Object.prototype.hasOwnProperty.call(map, chunkId) && map[chunkId]) {\n        list.remove(map[chunkId]);\n    }\n    // append the chunk to the list and put the corresponding node in the map\n    map[chunkId] = list.insertEnd(chunk);\n    // if we've exceeded the cache capacity\n    if (list.getLength() > this._capacity) {\n        // remove the current head of the list\n        evictedNode = list.getHead();\n        list.remove(evictedNode);\n        // evict the chunk associated with the removed node\n        evictedChunk = evictedNode.getValue();\n        delete map[evictedChunk.getId()];\n        // clear the rows from the evicted chunk\n        // TODO: should the force flag be set to true here?\n        evictedChunk.clearRows();\n    }\n};\nmodule.exports = ChunkCache;\n//# sourceMappingURL=chunk_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVua19jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHlCQUF5QixtQkFBTyxDQUFDLGlIQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVua19jYWNoZS5qcz82MzgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgRG91Ymx5TGlua2VkTGlzdCA9IHJlcXVpcmUoJy4vZG91Ymx5X2xpbmtlZF9saXN0Jyk7XG4vKipcbiAqIEFuIExSVSBjYWNoZSB1c2VkIHRvIHN0b3JlIGNodW5rcy5cbiAqXG4gKiAhISBUaGlzIGNhY2hlIGlzIG5vdCBmdWxseSBpbXBsZW1lbnRlZCBhbmQgbm90IHVzZWQgYXQgdGhpcyB0aW1lICEhXG4gKlxuICogQHBhcmFtIGNhcGFjaXR5IHRoZSBjYWNoZSBzaXplIGluIHRlcm1zIG9mIHRoZSBudW1iZXIgb2YgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENodW5rQ2FjaGUoY2FwYWNpdHkpIHtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIC8vIGNyZWF0ZSBhIG1hcCBhbmQgYSBkb3VibHkgbGlua2VkIGxpc3QgdG8gdHJhY2sgdGhlIGNhY2hlZCBjaHVua3NcbiAgICB0aGlzLl9tYXAgPSB7fTtcbiAgICB0aGlzLl9saXN0ID0gbmV3IERvdWJseUxpbmtlZExpc3QoKTtcbn1cbi8qKlxuICogQWRkcyBhIGNodW5rIHRvIHRoZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gY2h1bmtcbiAqL1xuQ2h1bmtDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgbGV0IGV2aWN0ZWROb2RlO1xuICAgIGxldCBldmljdGVkQ2h1bms7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9saXN0O1xuICAgIGNvbnN0IGNodW5rSWQgPSBjaHVuay5nZXRJZCgpO1xuICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgY2h1bmsgaW4gdGhlIGNhY2hlLCByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZVxuICAgIC8vIGZyb20gdGhlIGxpc3RcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgY2h1bmtJZCkgJiYgbWFwW2NodW5rSWRdKSB7XG4gICAgICAgIGxpc3QucmVtb3ZlKG1hcFtjaHVua0lkXSk7XG4gICAgfVxuICAgIC8vIGFwcGVuZCB0aGUgY2h1bmsgdG8gdGhlIGxpc3QgYW5kIHB1dCB0aGUgY29ycmVzcG9uZGluZyBub2RlIGluIHRoZSBtYXBcbiAgICBtYXBbY2h1bmtJZF0gPSBsaXN0Lmluc2VydEVuZChjaHVuayk7XG4gICAgLy8gaWYgd2UndmUgZXhjZWVkZWQgdGhlIGNhY2hlIGNhcGFjaXR5XG4gICAgaWYgKGxpc3QuZ2V0TGVuZ3RoKCkgPiB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgbGlzdFxuICAgICAgICBldmljdGVkTm9kZSA9IGxpc3QuZ2V0SGVhZCgpO1xuICAgICAgICBsaXN0LnJlbW92ZShldmljdGVkTm9kZSk7XG4gICAgICAgIC8vIGV2aWN0IHRoZSBjaHVuayBhc3NvY2lhdGVkIHdpdGggdGhlIHJlbW92ZWQgbm9kZVxuICAgICAgICBldmljdGVkQ2h1bmsgPSBldmljdGVkTm9kZS5nZXRWYWx1ZSgpO1xuICAgICAgICBkZWxldGUgbWFwW2V2aWN0ZWRDaHVuay5nZXRJZCgpXTtcbiAgICAgICAgLy8gY2xlYXIgdGhlIHJvd3MgZnJvbSB0aGUgZXZpY3RlZCBjaHVua1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhlIGZvcmNlIGZsYWcgYmUgc2V0IHRvIHRydWUgaGVyZT9cbiAgICAgICAgZXZpY3RlZENodW5rLmNsZWFyUm93cygpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IENodW5rQ2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVua19jYWNoZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/column.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/column.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst BigNumber = __webpack_require__(/*! bignumber.js */ \"(rsc)/./node_modules/bignumber.js/bignumber.js\");\nconst GlobalConfig = __webpack_require__(/*! ../../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst SfTimestamp = __webpack_require__(/*! ./sf_timestamp */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js\");\nconst DataTypes = __webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst SqlTypes = (__webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\").SqlTypes);\nconst dateTimeFormatConverter = __webpack_require__(/*! ./datetime_format_converter */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(rsc)/./node_modules/big-integer/BigInteger.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst momentTimezone = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\n/**\n * Creates a new Column.\n *\n * @param {Object} options\n * @param {Number} index\n * @param {Object} statementParameters\n * @param {String} resultVersion\n *\n * @constructor\n */\nfunction Column(options, index, statementParameters, resultVersion) {\n    const name = options.overriddenName || options.name;\n    const nullable = options.nullable;\n    const scale = options.scale;\n    const type = options.type;\n    const precision = options.precision;\n    const fieldsMetadata = options.fields;\n    /**\n     * Returns the name of this column.\n     *\n     * @return {String}\n     */\n    this.getName = function () {\n        return name;\n    };\n    /**\n     * Returns the index of this column.\n     *\n     * @return {Number}\n     */\n    this.getIndex = function () {\n        return index;\n    };\n    /**\n     * Returns the id of this column.\n     *\n     * @return {Number}\n     */\n    this.getId = function () {\n        // use the index as the id for now\n        return index;\n    };\n    /**\n     * Determines if this column is nullable.\n     *\n     * @returns {Boolean}\n     */\n    this.isNullable = function () {\n        return nullable;\n    };\n    /**\n     * Returns the scale associated with this column.\n     *\n     * @returns {Number}\n     */\n    this.getScale = function () {\n        return scale;\n    };\n    /**\n     * Returns the type associated with this column.\n     *\n     * @returns {String}\n     */\n    this.getType = function () {\n        return type;\n    };\n    /**\n     * Returns the precision associated with this column\n     *\n     * @returns {Number}\n     */\n    this.getPrecision = function () {\n        return precision;\n    };\n    // add methods that make it easy to check if the column is of a specific type\n    this.isString = createFnIsColumnOfType(type, SqlTypes.isString, SqlTypes);\n    this.isBinary = createFnIsColumnOfType(type, SqlTypes.isBinary, SqlTypes);\n    this.isNumber = createFnIsColumnOfType(type, SqlTypes.isNumber, SqlTypes);\n    this.isBoolean = createFnIsColumnOfType(type, SqlTypes.isBoolean, SqlTypes);\n    this.isDate = createFnIsColumnOfType(type, SqlTypes.isDate, SqlTypes);\n    this.isTime = createFnIsColumnOfType(type, SqlTypes.isTime, SqlTypes);\n    this.isTimestamp = createFnIsColumnOfType(type, SqlTypes.isTimestamp, SqlTypes);\n    this.isTimestampLtz = createFnIsColumnOfType(type, SqlTypes.isTimestampLtz, SqlTypes);\n    this.isTimestampNtz = createFnIsColumnOfType(type, SqlTypes.isTimestampNtz, SqlTypes);\n    this.isTimestampTz = createFnIsColumnOfType(type, SqlTypes.isTimestampTz, SqlTypes);\n    this.isVariant = createFnIsColumnOfType(type, (type) => SqlTypes.isVariant(type, fieldsMetadata), SqlTypes);\n    this.isObject = createFnIsColumnOfType(type, (type) => SqlTypes.isObject(type, fieldsMetadata), SqlTypes);\n    this.isArray = createFnIsColumnOfType(type, (type) => SqlTypes.isArray(type, fieldsMetadata), SqlTypes);\n    this.isMap = createFnIsColumnOfType(type, (type) => SqlTypes.isMap(type, fieldsMetadata), SqlTypes);\n    let convert;\n    let toString;\n    let toValue;\n    let format;\n    if (this.isNumber()) {\n        const integerAs = statementParameters['JS_TREAT_INTEGER_AS_BIGINT'];\n        if (!integerAs) {\n            convert = convertRawNumber;\n        }\n        else {\n            if (this.getScale() > 0 || this.getType() === SqlTypes.values.REAL) {\n                convert = convertRawNumber;\n            }\n            else {\n                // This is an integer so represent it as a big int\n                convert = convertRawBigInt;\n            }\n        }\n        toValue = toValueFromNumber;\n        toString = toStringFromNumber;\n    }\n    else if (this.isTime()) {\n        convert = convertRawTime;\n        toValue = toValueFromTime;\n        toString = toStringFromTime;\n        format = statementParameters['TIME_OUTPUT_FORMAT'];\n    }\n    else {\n        toValue = noop;\n        if (this.isBoolean()) {\n            convert = convertRawBoolean;\n            toString = toStringFromBoolean;\n        }\n        else if (this.isDate()) {\n            convert = convertRawDate;\n            toString = toStringFromDate;\n            format = statementParameters['DATE_OUTPUT_FORMAT'];\n        }\n        else if (this.isTimestamp()) {\n            if (this.isTimestampLtz()) {\n                convert = convertRawTimestampLtz;\n                toString = toStringFromTimestamp;\n                format = statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'];\n            }\n            else if (this.isTimestampNtz()) {\n                convert = convertRawTimestampNtz;\n                toString = toStringFromTimestamp;\n                format = statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n            }\n            else if (this.isTimestampTz()) {\n                convert = convertRawTimestampTz;\n                toString = toStringFromTimestamp;\n                format = statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'];\n            }\n            // if we don't have a type-specific timezone, use the default format\n            if (!format) {\n                format = statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n            }\n        }\n        else if (this.isBinary()) {\n            convert = convertRawBinary;\n            toString = toStringFromBinary;\n            format = statementParameters['BINARY_OUTPUT_FORMAT'];\n        }\n        else if (this.isVariant()) {\n            convert = convertRawVariant;\n            toString = toStringFromRawValue;\n        }\n        else if (this.isObject()) {\n            convert = convertRawStructuredType(convertJsonObject);\n            toString = toStringFromRawValue;\n        }\n        else if (this.isArray()) {\n            convert = convertRawStructuredType(convertJsonArray);\n            toString = toStringFromRawValue;\n        }\n        else if (this.isMap()) {\n            convert = convertRawStructuredType(convertJsonMap);\n            toString = toStringFromRawValue;\n        }\n        else {\n            // column is of type string, so leave value as is\n            convert = noop;\n            toString = toStringFromString;\n        }\n    }\n    // create a private context to pass to the extract function\n    const context = {\n        convert: convert,\n        toValue: toValue,\n        toString: toString,\n        format: format,\n        resultVersion: resultVersion,\n        statementParameters: statementParameters,\n        fieldsMetadata: fieldsMetadata,\n    };\n    /**\n     * Returns the value of this column in a row.\n     *\n     * @param {Object} row\n     *\n     * @returns {*}\n     */\n    this.getRowValue = function (row) {\n        return extractFromRow.call(this, row, context, false);\n    };\n    /**\n     * Returns the value of this in a row as a String.\n     *\n     * @param {Object} row\n     *\n     * @returns {String}\n     */\n    this.getRowValueAsString = function (row) {\n        return extractFromRow.call(this, row, context, true);\n    };\n}\n/**\n * Returns a function that can be used to determine if a column is of a given\n * type.\n *\n * @param {String} columnType the column type.\n * @param {Function} columnComparisonFn the column comparison function.\n * @param {Object} scope the scope in which to invoke the column comparison\n *   function.\n *\n * @returns {Function}\n */\nfunction createFnIsColumnOfType(columnType, columnComparisonFn, scope) {\n    return function () {\n        return columnComparisonFn.call(scope, columnType);\n    };\n}\n/**\n * Converts a raw column value of type Number. The returned value is an object\n * that contains the raw string version of the value as well as the\n * post-processed version of the value obtained after casting to Number.\n *\n * @param {String} rawColumnValue\n *\n * @returns {Object}\n */\nfunction convertRawNumber(rawColumnValue) {\n    return {\n        raw: rawColumnValue,\n        processed: Number(rawColumnValue),\n    };\n}\n/**\n * Converts a raw column value that is an integer. The returned value is an object\n * that contains the raw string version of the value as well as the post-processed\n * version of the value obtained after casting to bigInt\n *\n * @param rawColumnValue\n * @returns {{processed: bigInt.BigInteger, raw: *}}\n */\nfunction convertRawBigInt(rawColumnValue) {\n    return {\n        raw: rawColumnValue,\n        processed: bigInt(rawColumnValue),\n    };\n}\n/**\n * Converts a raw column value of type Boolean to a boolean (true, false,\n * or null).\n *\n * @param {String} rawColumnValue\n *\n * @returns {Boolean}\n */\nfunction convertRawBoolean(rawColumnValue) {\n    let ret;\n    if (rawColumnValue === true ||\n        rawColumnValue === '1' ||\n        rawColumnValue.toUpperCase() === 'TRUE') {\n        ret = true;\n    }\n    else if (rawColumnValue === false ||\n        rawColumnValue === '0' ||\n        rawColumnValue.toUpperCase() === 'FALSE') {\n        ret = false;\n    }\n    else {\n        throw new Error(`Value could not be converted to boolean: ${rawColumnValue}`);\n    }\n    return ret;\n}\n/**\n * Converts a raw column value of structured type object to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonObject(json, context) {\n    if (context.fieldsMetadata) {\n        context.fieldsMetadata = context.fieldsMetadata.reduce(function (map, obj) {\n            map[obj.name] = obj;\n            return map;\n        }, {});\n        const result = {};\n        Object.keys(json).forEach(function (key) {\n            const fieldMetadata = context.fieldsMetadata[key];\n            result[key] = mapStructuredTypeValue(json[key], context, fieldMetadata);\n        });\n        return result;\n    }\n    else {\n        return json;\n    }\n}\n/**\n * Converts a raw column value of structured type array to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonArray(json, context) {\n    if (context.fieldsMetadata) {\n        const result = [];\n        json.forEach(function (value) {\n            result.push(mapStructuredTypeValue(value, context, context.fieldsMetadata[0]));\n        });\n        return result;\n    }\n    else {\n        return json;\n    }\n}\n/**\n * Converts a raw column value of structured type map to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonMap(json, context) {\n    if (Array.isArray(context.fieldsMetadata) && context.fieldsMetadata.length === 2) {\n        const result = new Map();\n        const keyMetadata = context.fieldsMetadata[0];\n        const valueMetadata = context.fieldsMetadata[1];\n        Object.keys(json).forEach(function (key) {\n            const convertedKey = mapStructuredTypeValue(key, context, keyMetadata);\n            const convertedValue = mapStructuredTypeValue(json[key], context, valueMetadata);\n            result.set(convertedKey, convertedValue);\n        });\n        return result;\n    }\n    else {\n        return json;\n    }\n}\n/**\n * Converts a raw column value of structured type OBJECT to javascript Object\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nconst convertRawStructuredType = (convertJsonFn) => (rawColumnValue, column, context) => {\n    if (Util.string.isNotNullOrEmpty(rawColumnValue)) {\n        try {\n            const json = JSON.parse(rawColumnValue);\n            return convertJsonFn(json, context);\n        }\n        catch (jsonParseError) {\n            Logger.getInstance().debug('Column %s raw value cannot be parsed as JSON: %s ', column.name, jsonParseError.message);\n            throw new Error(util.format('Column [%s] raw value cannot be parsed as JSON: %s ', column.name, jsonParseError.message));\n        }\n    }\n    else {\n        throw new Error(util.format('Column %s raw value is null or empty ', column.name));\n    }\n};\nfunction mapStructuredTypeValue(columnValue, context, metadataField) {\n    const formatLtz = context.statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'] ??\n        context.statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n    const formatTz = context.statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'] ??\n        context.statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n    const formatNtz = context.statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n    let value;\n    switch (metadataField.type) {\n        case 'text':\n            value = columnValue;\n            break;\n        case 'real':\n            value = toValueFromNumber(convertRawNumber(columnValue));\n            break;\n        case 'fixed':\n            value = toValueFromNumber(convertRawNumber(columnValue));\n            break;\n        case 'boolean':\n            value = convertRawBoolean(columnValue);\n            break;\n        case 'timestamp_ltz':\n            value = convertTimestampTzString(columnValue, formatLtz, context.statementParameters['TIMEZONE'], metadataField.scale).toSfDate();\n            break;\n        case 'timestamp_ntz':\n            value = convertTimestampNtzString(columnValue, formatNtz, moment.tz.zone('UTC'), metadataField.scale).toSfDate();\n            break;\n        case 'timestamp_tz':\n            value = convertTimestampTzString(columnValue, formatTz, context.statementParameters['TIMEZONE'], metadataField.scale).toSfDate();\n            break;\n        case 'date': {\n            context.format = context.statementParameters['DATE_OUTPUT_FORMAT'];\n            value = convertDateString(columnValue, context.format);\n            break;\n        }\n        case 'time':\n            context.format = context.statementParameters['TIME_OUTPUT_FORMAT'];\n            value = convertTimeString(columnValue, context.format, moment.tz.zone('UTC'), metadataField.scale).toSfTime();\n            break;\n        case 'binary':\n            context.format = context.statementParameters['BINARY_OUTPUT_FORMAT'];\n            value = convertRawBinary(columnValue, this, context).toJSON().data;\n            break;\n        case 'object': {\n            const internalContext = {\n                convert: convertRawStructuredType(convertJsonObject),\n                toValue: noop,\n                toString: toString,\n                format: toStringFromRawValue,\n                resultVersion: context.resultVersion,\n                statementParameters: context.statementParameters,\n                fieldsMetadata: metadataField.fields,\n            };\n            value = convertJsonObject(columnValue, internalContext);\n            break;\n        }\n        case 'array': {\n            const internalArrayContext = {\n                convert: convertRawStructuredType(convertJsonArray),\n                toValue: noop,\n                toString: toString,\n                format: toStringFromRawValue,\n                resultVersion: context.resultVersion,\n                statementParameters: context.statementParameters,\n                fieldsMetadata: metadataField.fields,\n            };\n            value = convertJsonArray(columnValue, internalArrayContext);\n            break;\n        }\n        case 'map': {\n            const internalMapContext = {\n                convert: convertRawStructuredType(convertJsonMap),\n                toValue: noop,\n                toString: toString,\n                format: toStringFromRawValue,\n                resultVersion: context.resultVersion,\n                statementParameters: context.statementParameters,\n                fieldsMetadata: metadataField.fields,\n            };\n            value = convertJsonMap(columnValue, internalMapContext);\n            break;\n        }\n        default:\n            Logger.getInstance().info(`Column type not supported: ${context.fieldsMetadata.type}`);\n            throw new Error(`Column type not supported: ${context.fieldsMetadata.type}`);\n    }\n    return value;\n}\nconst convertTimestampTzString = function (stringValue, formatSql, timezone, scale) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n    const epochSeconds = momentTimezone(stringValue, formatMoment).unix();\n    return new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n};\nconst convertTimestampNtzString = function (stringValue, formatSql, timezone, scale) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n    const epochSeconds = momentTimezone.utc(stringValue, formatMoment).unix();\n    return new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n};\nconst convertDateString = function (stringValue, formatSql) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, 0);\n    const epochSeconds = momentTimezone.utc(stringValue, formatMoment).unix();\n    const date = new SfTimestamp(epochSeconds, // convert to seconds\n    0, // no nano seconds\n    0, // no scale required\n    'UTC', // use utc as the timezone\n    context.format);\n    date._valueAsString = stringValue;\n    return date.toSfDate();\n};\nconst convertTimeString = function (stringValue, formatSql, timezone, scale) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n    const moment = momentTimezone(stringValue, formatMoment);\n    const epochSeconds = moment.hours() * 3600 + moment.minutes() * 60 + moment.seconds();\n    const time = new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n    time._valueAsString = stringValue;\n    return time;\n};\n/**\n * Converts a raw column value of type Date to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawDate(rawColumnValue, column, context) {\n    return new SfTimestamp(Number(rawColumnValue) * 86400, // convert to seconds\n    0, // no nano seconds\n    0, // no scale required\n    'UTC', // use utc as the timezone\n    context.format).toSfDate();\n}\n/**\n * Converts a raw column value of type Time to a Snowflake Time.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertRawTime(rawColumnValue, column, context) {\n    const columnScale = column.getScale();\n    // the values might be big so use BigNumber to do arithmetic\n    const valFracSecsBig = new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, 'UTC', context.format).toSfTime();\n}\n/**\n * Converts a raw column value of type TIMESTAMP_LTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampLtz(rawColumnValue, column, context) {\n    const columnScale = column.getScale();\n    // the values might be big so use BigNumber to do arithmetic\n    const valFracSecsBig = new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n    // create a new snowflake date\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, context.statementParameters['TIMEZONE'], context.format).toSfDate();\n}\n/**\n * Converts a raw column value of type TIMESTAMP_NTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampNtz(rawColumnValue, column, context) {\n    const columnScale = column.getScale();\n    // the values might be big so use BigNumber to do arithmetic\n    const valFracSecsBig = new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n    // create a new snowflake date\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, 'UTC', // it's _ntz, so use UTC for timezone\n    context.format).toSfDate();\n}\n/**\n * Converts a raw column value of type TIMESTAMP_TZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampTz(rawColumnValue, column, context) {\n    let valFracSecsBig;\n    let valFracSecsWithTzBig;\n    let timezoneBig;\n    let timezone;\n    let timestampAndTZIndex;\n    // compute the scale factor\n    const columnScale = column.getScale();\n    const scaleFactor = Math.pow(10, columnScale);\n    const resultVersion = context.resultVersion;\n    if (resultVersion === '0' || resultVersion === undefined) {\n        // the values might be big so use BigNumber to do arithmetic\n        valFracSecsBig = new BigNumber(rawColumnValue).times(scaleFactor);\n        // for _tz, the timezone is baked into the value\n        valFracSecsWithTzBig = valFracSecsBig;\n        // extract everything but the lowest 14 bits to get the fractional seconds\n        valFracSecsBig = valFracSecsWithTzBig.dividedBy(16384).integerValue(BigNumber.ROUND_FLOOR);\n        // extract the lowest 14 bits to get the timezone\n        if (valFracSecsWithTzBig.isGreaterThanOrEqualTo(0)) {\n            timezoneBig = valFracSecsWithTzBig.modulo(16384);\n        }\n        else {\n            timezoneBig = valFracSecsWithTzBig.modulo(16384).plus(16384);\n        }\n    }\n    else {\n        // split the value into number of seconds and timezone index\n        timestampAndTZIndex = rawColumnValue.split(' ');\n        // the values might be big so use BigNumber to do arithmetic\n        valFracSecsBig = new BigNumber(timestampAndTZIndex[0]).times(scaleFactor);\n        timezoneBig = new BigNumber(timestampAndTZIndex[1]);\n    }\n    timezone = timezoneBig.toNumber();\n    // assert that timezone is valid\n    Errors.assertInternal(timezone >= 0 && timezone <= 2880);\n    // subtract 24 hours from the timezone to map [0, 48] to\n    // [-24, 24], and convert the result to a number\n    timezone = timezone - 1440;\n    // create a new snowflake date\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, timezone, context.format).toSfDate();\n}\n/**\n * Helper function for the convertRawTimestamp*() functions.\n * Returns an instance of SfTimestamp.\n *\n * @param {Object} epochFracSecsBig\n * @param {Number} scale\n * @param {String | Number} timezone\n * @param {String} format\n *\n * @returns {Object}\n */\nfunction convertRawTimestampHelper(epochFracSecsBig, scale, timezone, format) {\n    // compute the scale factor\n    const scaleFactor = Math.pow(10, scale);\n    // split the value into epoch seconds + nanoseconds; for example,\n    // 1365148923.123456789 will be split into 1365148923 (epoch seconds)\n    // and 123456789 (nano seconds)\n    const valSecBig = epochFracSecsBig.dividedBy(scaleFactor).integerValue(BigNumber.ROUND_FLOOR);\n    const fractionsBig = epochFracSecsBig.minus(valSecBig.times(scaleFactor));\n    const valSecNanoBig = fractionsBig.times(Math.pow(10, 9 - scale));\n    // create a new snowflake date from the information\n    return new SfTimestamp(valSecBig.toNumber(), valSecNanoBig.toNumber(), scale, timezone, format);\n}\n/**\n * Converts a raw column value of type Variant to a JavaScript value.\n *\n * @param {String} rawColumnValue\n *\n * @returns {Object | Array}\n */\nfunction convertRawVariant(rawColumnValue) {\n    // if the input is a non-empty string, convert it to a json object\n    if (Util.string.isNotNullOrEmpty(rawColumnValue)) {\n        try {\n            return GlobalConfig.jsonColumnVariantParser(rawColumnValue);\n        }\n        catch (jsonParseError) {\n            try {\n                return GlobalConfig.xmlColumnVariantParser(rawColumnValue);\n            }\n            catch (xmlParseError) {\n                Logger.getInstance().debug('Variant cannot be parsed neither as JSON: %s nor as XML: %s', jsonParseError.message, xmlParseError.message);\n                throw new Errors.VariantParseError(jsonParseError, xmlParseError);\n            }\n        }\n    }\n}\n/**\n * Converts a raw column value of type Binary to a Buffer.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Buffer}\n */\nfunction convertRawBinary(rawColumnValue, column, context) {\n    // Ensure the format is valid.\n    const format = context.format.toUpperCase();\n    Errors.assertInternal(format === 'HEX' || format === 'BASE64');\n    // Decode hex string sent by GS.\n    const buffer = Buffer.from(rawColumnValue, 'HEX');\n    if (format === 'HEX') {\n        buffer.toStringSf = function () {\n            // The raw value is already an uppercase hex string, so just return it.\n            // Note that buffer.toString(\"HEX\") returns a lowercase hex string, but we\n            // want upper case.\n            return rawColumnValue;\n        };\n    }\n    else {\n        buffer.toStringSf = function () {\n            return this.toString('BASE64');\n        };\n    }\n    buffer.getFormat = function () {\n        return format;\n    };\n    return buffer;\n}\n/**\n * Returns the input value as is.\n *\n * @param {*} value\n *\n * @returns {*}\n */\nfunction noop(value) {\n    return value;\n}\n/**\n * The toValue() function for a column of type Number.\n *\n * @param {*} columnValue\n *\n * @returns {Number}\n */\nfunction toValueFromNumber(columnValue) {\n    return columnValue ? columnValue.processed : columnValue;\n}\n/**\n * The toValue() function for a column of type Time.\n *\n * @param {*} columnValue\n *\n * @returns {String}\n */\nfunction toValueFromTime(columnValue) {\n    // there's no native javascript type that can be used to represent time, so\n    // just convert to string\n    return toStringFromTime(columnValue);\n}\n/**\n * The toString() function for a column of type Number.\n *\n * @param {Number} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromNumber(columnValue) {\n    return columnValue !== null ? columnValue.raw : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Boolean.\n *\n * @param {Boolean} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBoolean(columnValue) {\n    return columnValue !== null ? String(columnValue).toUpperCase() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Date.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromDate(columnValue) {\n    return columnValue !== null ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Time.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTime(columnValue) {\n    return columnValue !== null ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Timestamp.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTimestamp(columnValue) {\n    return columnValue !== null ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Variant.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromRawValue(columnValue) {\n    return columnValue !== null ? JSON.stringify(columnValue) : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type String.\n *\n * @param {String} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromString(columnValue) {\n    return columnValue !== null ? columnValue : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Binary.\n *\n * @param {Buffer} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBinary(columnValue) {\n    return columnValue !== null ? columnValue.toStringSf() : DataTypes.getNullValue();\n}\n/**\n * Extracts the value of a column from a given row.\n *\n * @param {Object} row\n * @param {Object} context\n * @param {Boolean} asString\n *\n * @returns {*}\n */\nfunction extractFromRow(row, context, asString) {\n    const map = row._arrayProcessedColumns;\n    const values = row.values;\n    // get the value\n    const columnIndex = this.getIndex();\n    let ret = values[columnIndex];\n    // if we want the value as a string, and the column is of type variant, and we\n    // haven't already processed the value before, we don't need to process the\n    // value, so only process if none of the aforementioned conditions are true\n    if (!(asString && this.isVariant() && !map[columnIndex])) {\n        // if the column value has not been processed yet, process it, put it back\n        // in the values array, and remember that the value has been processed\n        if (!map[columnIndex]) {\n            if (ret !== null) {\n                ret = values[columnIndex] = context.convert(values[columnIndex], this, context);\n            }\n            map[columnIndex] = true;\n        }\n        // use the appropriate extraction function depending on whether\n        // we want the value or a string representation of the value\n        const extractFn = !asString ? context.toValue : context.toString;\n        ret = extractFn(ret);\n    }\n    return ret;\n}\nmodule.exports = Column;\n//# sourceMappingURL=column.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jb2x1bW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDJFQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFjO0FBQ3hDLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFxQjtBQUNsRCxlQUFlLG1CQUFPLENBQUMsMkVBQWM7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMscUdBQWdCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGlHQUFjO0FBQ3hDLGlCQUFpQixpSUFBZ0M7QUFDakQsZ0NBQWdDLG1CQUFPLENBQUMsK0hBQTZCO0FBQ3JFLGVBQWUsbUJBQU8sQ0FBQyxtRUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsc0VBQWlCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyx1RUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsNEJBQTRCO0FBQ2hHLDBEQUEwRCw0QkFBNEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L2NvbHVtbi5qcz9jYjZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi8uLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi8uLi9sb2dnZXInKTtcbmNvbnN0IFNmVGltZXN0YW1wID0gcmVxdWlyZSgnLi9zZl90aW1lc3RhbXAnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YV90eXBlcycpO1xuY29uc3QgU3FsVHlwZXMgPSByZXF1aXJlKCcuL2RhdGFfdHlwZXMnKS5TcWxUeXBlcztcbmNvbnN0IGRhdGVUaW1lRm9ybWF0Q29udmVydGVyID0gcmVxdWlyZSgnLi9kYXRldGltZV9mb3JtYXRfY29udmVydGVyJyk7XG5jb25zdCBiaWdJbnQgPSByZXF1aXJlKCdiaWctaW50ZWdlcicpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5jb25zdCBtb21lbnRUaW1lem9uZSA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBDb2x1bW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXN1bHRWZXJzaW9uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbHVtbihvcHRpb25zLCBpbmRleCwgc3RhdGVtZW50UGFyYW1ldGVycywgcmVzdWx0VmVyc2lvbikge1xuICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zLm92ZXJyaWRkZW5OYW1lIHx8IG9wdGlvbnMubmFtZTtcbiAgICBjb25zdCBudWxsYWJsZSA9IG9wdGlvbnMubnVsbGFibGU7XG4gICAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgY29uc3QgcHJlY2lzaW9uID0gb3B0aW9ucy5wcmVjaXNpb247XG4gICAgY29uc3QgZmllbGRzTWV0YWRhdGEgPSBvcHRpb25zLmZpZWxkcztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoaXMgY29sdW1uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGlzIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGlzIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB1c2UgdGhlIGluZGV4IGFzIHRoZSBpZCBmb3Igbm93XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhpcyBjb2x1bW4gaXMgbnVsbGFibGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzTnVsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsYWJsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmVjaXNpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29sdW1uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJlY2lzaW9uO1xuICAgIH07XG4gICAgLy8gYWRkIG1ldGhvZHMgdGhhdCBtYWtlIGl0IGVhc3kgdG8gY2hlY2sgaWYgdGhlIGNvbHVtbiBpcyBvZiBhIHNwZWNpZmljIHR5cGVcbiAgICB0aGlzLmlzU3RyaW5nID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc1N0cmluZywgU3FsVHlwZXMpO1xuICAgIHRoaXMuaXNCaW5hcnkgPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzQmluYXJ5LCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc051bWJlciA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNOdW1iZXIsIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzQm9vbGVhbiA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNCb29sZWFuLCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc0RhdGUgPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzRGF0ZSwgU3FsVHlwZXMpO1xuICAgIHRoaXMuaXNUaW1lID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc1RpbWUsIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzVGltZXN0YW1wID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc1RpbWVzdGFtcCwgU3FsVHlwZXMpO1xuICAgIHRoaXMuaXNUaW1lc3RhbXBMdHogPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzVGltZXN0YW1wTHR6LCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc1RpbWVzdGFtcE50eiA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNUaW1lc3RhbXBOdHosIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzVGltZXN0YW1wVHogPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzVGltZXN0YW1wVHosIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzVmFyaWFudCA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgKHR5cGUpID0+IFNxbFR5cGVzLmlzVmFyaWFudCh0eXBlLCBmaWVsZHNNZXRhZGF0YSksIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzT2JqZWN0ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCAodHlwZSkgPT4gU3FsVHlwZXMuaXNPYmplY3QodHlwZSwgZmllbGRzTWV0YWRhdGEpLCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc0FycmF5ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCAodHlwZSkgPT4gU3FsVHlwZXMuaXNBcnJheSh0eXBlLCBmaWVsZHNNZXRhZGF0YSksIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzTWFwID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCAodHlwZSkgPT4gU3FsVHlwZXMuaXNNYXAodHlwZSwgZmllbGRzTWV0YWRhdGEpLCBTcWxUeXBlcyk7XG4gICAgbGV0IGNvbnZlcnQ7XG4gICAgbGV0IHRvU3RyaW5nO1xuICAgIGxldCB0b1ZhbHVlO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKHRoaXMuaXNOdW1iZXIoKSkge1xuICAgICAgICBjb25zdCBpbnRlZ2VyQXMgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydKU19UUkVBVF9JTlRFR0VSX0FTX0JJR0lOVCddO1xuICAgICAgICBpZiAoIWludGVnZXJBcykge1xuICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRTY2FsZSgpID4gMCB8fCB0aGlzLmdldFR5cGUoKSA9PT0gU3FsVHlwZXMudmFsdWVzLlJFQUwpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZWdlciBzbyByZXByZXNlbnQgaXQgYXMgYSBiaWcgaW50XG4gICAgICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdCaWdJbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9WYWx1ZSA9IHRvVmFsdWVGcm9tTnVtYmVyO1xuICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbU51bWJlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc1RpbWUoKSkge1xuICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd1RpbWU7XG4gICAgICAgIHRvVmFsdWUgPSB0b1ZhbHVlRnJvbVRpbWU7XG4gICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tVGltZTtcbiAgICAgICAgZm9ybWF0ID0gc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRV9PVVRQVVRfRk9STUFUJ107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b1ZhbHVlID0gbm9vcDtcbiAgICAgICAgaWYgKHRoaXMuaXNCb29sZWFuKCkpIHtcbiAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3Qm9vbGVhbjtcbiAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tQm9vbGVhbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzRGF0ZSgpKSB7XG4gICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd0RhdGU7XG4gICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbURhdGU7XG4gICAgICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydEQVRFX09VVFBVVF9GT1JNQVQnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVGltZXN0YW1wKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGltZXN0YW1wTHR6KCkpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd1RpbWVzdGFtcEx0ejtcbiAgICAgICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfTFRaX09VVFBVVF9GT1JNQVQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUaW1lc3RhbXBOdHooKSkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3VGltZXN0YW1wTnR6O1xuICAgICAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tVGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9OVFpfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1RpbWVzdGFtcFR6KCkpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd1RpbWVzdGFtcFR6O1xuICAgICAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tVGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9UWl9PVVRQVVRfRk9STUFUJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgdHlwZS1zcGVjaWZpYyB0aW1lem9uZSwgdXNlIHRoZSBkZWZhdWx0IGZvcm1hdFxuICAgICAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNCaW5hcnkoKSkge1xuICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdCaW5hcnk7XG4gICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbUJpbmFyeTtcbiAgICAgICAgICAgIGZvcm1hdCA9IHN0YXRlbWVudFBhcmFtZXRlcnNbJ0JJTkFSWV9PVVRQVVRfRk9STUFUJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1ZhcmlhbnQoKSkge1xuICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdWYXJpYW50O1xuICAgICAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21SYXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzT2JqZWN0KCkpIHtcbiAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3U3RydWN0dXJlZFR5cGUoY29udmVydEpzb25PYmplY3QpO1xuICAgICAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21SYXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdTdHJ1Y3R1cmVkVHlwZShjb252ZXJ0SnNvbkFycmF5KTtcbiAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tUmF3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc01hcCgpKSB7XG4gICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd1N0cnVjdHVyZWRUeXBlKGNvbnZlcnRKc29uTWFwKTtcbiAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tUmF3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjb2x1bW4gaXMgb2YgdHlwZSBzdHJpbmcsIHNvIGxlYXZlIHZhbHVlIGFzIGlzXG4gICAgICAgICAgICBjb252ZXJ0ID0gbm9vcDtcbiAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tU3RyaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIHByaXZhdGUgY29udGV4dCB0byBwYXNzIHRvIHRoZSBleHRyYWN0IGZ1bmN0aW9uXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgY29udmVydDogY29udmVydCxcbiAgICAgICAgdG9WYWx1ZTogdG9WYWx1ZSxcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgcmVzdWx0VmVyc2lvbjogcmVzdWx0VmVyc2lvbixcbiAgICAgICAgc3RhdGVtZW50UGFyYW1ldGVyczogc3RhdGVtZW50UGFyYW1ldGVycyxcbiAgICAgICAgZmllbGRzTWV0YWRhdGE6IGZpZWxkc01ldGFkYXRhLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhpcyBjb2x1bW4gaW4gYSByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm93XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmdldFJvd1ZhbHVlID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gZXh0cmFjdEZyb21Sb3cuY2FsbCh0aGlzLCByb3csIGNvbnRleHQsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgaW4gYSByb3cgYXMgYSBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm93XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Um93VmFsdWVBc1N0cmluZyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RGcm9tUm93LmNhbGwodGhpcywgcm93LCBjb250ZXh0LCB0cnVlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjb2x1bW4gaXMgb2YgYSBnaXZlblxuICogdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uVHlwZSB0aGUgY29sdW1uIHR5cGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2x1bW5Db21wYXJpc29uRm4gdGhlIGNvbHVtbiBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHRoZSBzY29wZSBpbiB3aGljaCB0byBpbnZva2UgdGhlIGNvbHVtbiBjb21wYXJpc29uXG4gKiAgIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZShjb2x1bW5UeXBlLCBjb2x1bW5Db21wYXJpc29uRm4sIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbkNvbXBhcmlzb25Gbi5jYWxsKHNjb3BlLCBjb2x1bW5UeXBlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBOdW1iZXIuIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3RcbiAqIHRoYXQgY29udGFpbnMgdGhlIHJhdyBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgdmFsdWUgYXMgd2VsbCBhcyB0aGVcbiAqIHBvc3QtcHJvY2Vzc2VkIHZlcnNpb24gb2YgdGhlIHZhbHVlIG9idGFpbmVkIGFmdGVyIGNhc3RpbmcgdG8gTnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdOdW1iZXIocmF3Q29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByYXc6IHJhd0NvbHVtblZhbHVlLFxuICAgICAgICBwcm9jZXNzZWQ6IE51bWJlcihyYXdDb2x1bW5WYWx1ZSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIHRoYXQgaXMgYW4gaW50ZWdlci4gVGhlIHJldHVybmVkIHZhbHVlIGlzIGFuIG9iamVjdFxuICogdGhhdCBjb250YWlucyB0aGUgcmF3IHN0cmluZyB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSBhcyB3ZWxsIGFzIHRoZSBwb3N0LXByb2Nlc3NlZFxuICogdmVyc2lvbiBvZiB0aGUgdmFsdWUgb2J0YWluZWQgYWZ0ZXIgY2FzdGluZyB0byBiaWdJbnRcbiAqXG4gKiBAcGFyYW0gcmF3Q29sdW1uVmFsdWVcbiAqIEByZXR1cm5zIHt7cHJvY2Vzc2VkOiBiaWdJbnQuQmlnSW50ZWdlciwgcmF3OiAqfX1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd0JpZ0ludChyYXdDb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhdzogcmF3Q29sdW1uVmFsdWUsXG4gICAgICAgIHByb2Nlc3NlZDogYmlnSW50KHJhd0NvbHVtblZhbHVlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBCb29sZWFuIHRvIGEgYm9vbGVhbiAodHJ1ZSwgZmFsc2UsXG4gKiBvciBudWxsKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd0Jvb2xlYW4ocmF3Q29sdW1uVmFsdWUpIHtcbiAgICBsZXQgcmV0O1xuICAgIGlmIChyYXdDb2x1bW5WYWx1ZSA9PT0gdHJ1ZSB8fFxuICAgICAgICByYXdDb2x1bW5WYWx1ZSA9PT0gJzEnIHx8XG4gICAgICAgIHJhd0NvbHVtblZhbHVlLnRvVXBwZXJDYXNlKCkgPT09ICdUUlVFJykge1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYXdDb2x1bW5WYWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgcmF3Q29sdW1uVmFsdWUgPT09ICcwJyB8fFxuICAgICAgICByYXdDb2x1bW5WYWx1ZS50b1VwcGVyQ2FzZSgpID09PSAnRkFMU0UnKSB7XG4gICAgICAgIHJldCA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBjb3VsZCBub3QgYmUgY29udmVydGVkIHRvIGJvb2xlYW46ICR7cmF3Q29sdW1uVmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiBzdHJ1Y3R1cmVkIHR5cGUgb2JqZWN0IHRvIGphdmFzY3JpcHQgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydEpzb25PYmplY3QoanNvbiwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmZpZWxkc01ldGFkYXRhKSB7XG4gICAgICAgIGNvbnRleHQuZmllbGRzTWV0YWRhdGEgPSBjb250ZXh0LmZpZWxkc01ldGFkYXRhLnJlZHVjZShmdW5jdGlvbiAobWFwLCBvYmopIHtcbiAgICAgICAgICAgIG1hcFtvYmoubmFtZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTWV0YWRhdGEgPSBjb250ZXh0LmZpZWxkc01ldGFkYXRhW2tleV07XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG1hcFN0cnVjdHVyZWRUeXBlVmFsdWUoanNvbltrZXldLCBjb250ZXh0LCBmaWVsZE1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiBzdHJ1Y3R1cmVkIHR5cGUgYXJyYXkgdG8gamF2YXNjcmlwdCBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0SnNvbkFycmF5KGpzb24sIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5maWVsZHNNZXRhZGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAganNvbi5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwU3RydWN0dXJlZFR5cGVWYWx1ZSh2YWx1ZSwgY29udGV4dCwgY29udGV4dC5maWVsZHNNZXRhZGF0YVswXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHN0cnVjdHVyZWQgdHlwZSBtYXAgdG8gamF2YXNjcmlwdCBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0SnNvbk1hcChqc29uLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGV4dC5maWVsZHNNZXRhZGF0YSkgJiYgY29udGV4dC5maWVsZHNNZXRhZGF0YS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBrZXlNZXRhZGF0YSA9IGNvbnRleHQuZmllbGRzTWV0YWRhdGFbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlTWV0YWRhdGEgPSBjb250ZXh0LmZpZWxkc01ldGFkYXRhWzFdO1xuICAgICAgICBPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEtleSA9IG1hcFN0cnVjdHVyZWRUeXBlVmFsdWUoa2V5LCBjb250ZXh0LCBrZXlNZXRhZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IG1hcFN0cnVjdHVyZWRUeXBlVmFsdWUoanNvbltrZXldLCBjb250ZXh0LCB2YWx1ZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoY29udmVydGVkS2V5LCBjb252ZXJ0ZWRWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2Ygc3RydWN0dXJlZCB0eXBlIE9CSkVDVCB0byBqYXZhc2NyaXB0IE9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb2x1bW5WYWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbHVtblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCBjb252ZXJ0UmF3U3RydWN0dXJlZFR5cGUgPSAoY29udmVydEpzb25GbikgPT4gKHJhd0NvbHVtblZhbHVlLCBjb2x1bW4sIGNvbnRleHQpID0+IHtcbiAgICBpZiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eShyYXdDb2x1bW5WYWx1ZSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHJhd0NvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0SnNvbkZuKGpzb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChqc29uUGFyc2VFcnJvcikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0NvbHVtbiAlcyByYXcgdmFsdWUgY2Fubm90IGJlIHBhcnNlZCBhcyBKU09OOiAlcyAnLCBjb2x1bW4ubmFtZSwganNvblBhcnNlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ0NvbHVtbiBbJXNdIHJhdyB2YWx1ZSBjYW5ub3QgYmUgcGFyc2VkIGFzIEpTT046ICVzICcsIGNvbHVtbi5uYW1lLCBqc29uUGFyc2VFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnQ29sdW1uICVzIHJhdyB2YWx1ZSBpcyBudWxsIG9yIGVtcHR5ICcsIGNvbHVtbi5uYW1lKSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIG1hcFN0cnVjdHVyZWRUeXBlVmFsdWUoY29sdW1uVmFsdWUsIGNvbnRleHQsIG1ldGFkYXRhRmllbGQpIHtcbiAgICBjb25zdCBmb3JtYXRMdHogPSBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9MVFpfT1VUUFVUX0ZPUk1BVCddID8/XG4gICAgICAgIGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVNUQU1QX09VVFBVVF9GT1JNQVQnXTtcbiAgICBjb25zdCBmb3JtYXRUeiA9IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVNUQU1QX1RaX09VVFBVVF9GT1JNQVQnXSA/P1xuICAgICAgICBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9PVVRQVVRfRk9STUFUJ107XG4gICAgY29uc3QgZm9ybWF0TnR6ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfTlRaX09VVFBVVF9GT1JNQVQnXTtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3dpdGNoIChtZXRhZGF0YUZpZWxkLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbHVtblZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlYWwnOlxuICAgICAgICAgICAgdmFsdWUgPSB0b1ZhbHVlRnJvbU51bWJlcihjb252ZXJ0UmF3TnVtYmVyKGNvbHVtblZhbHVlKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZml4ZWQnOlxuICAgICAgICAgICAgdmFsdWUgPSB0b1ZhbHVlRnJvbU51bWJlcihjb252ZXJ0UmF3TnVtYmVyKGNvbHVtblZhbHVlKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRSYXdCb29sZWFuKGNvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aW1lc3RhbXBfbHR6JzpcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydFRpbWVzdGFtcFR6U3RyaW5nKGNvbHVtblZhbHVlLCBmb3JtYXRMdHosIGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVpPTkUnXSwgbWV0YWRhdGFGaWVsZC5zY2FsZSkudG9TZkRhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aW1lc3RhbXBfbnR6JzpcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydFRpbWVzdGFtcE50elN0cmluZyhjb2x1bW5WYWx1ZSwgZm9ybWF0TnR6LCBtb21lbnQudHouem9uZSgnVVRDJyksIG1ldGFkYXRhRmllbGQuc2NhbGUpLnRvU2ZEYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGltZXN0YW1wX3R6JzpcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydFRpbWVzdGFtcFR6U3RyaW5nKGNvbHVtblZhbHVlLCBmb3JtYXRUeiwgY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FWk9ORSddLCBtZXRhZGF0YUZpZWxkLnNjYWxlKS50b1NmRGF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RhdGUnOiB7XG4gICAgICAgICAgICBjb250ZXh0LmZvcm1hdCA9IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snREFURV9PVVRQVVRfRk9STUFUJ107XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnREYXRlU3RyaW5nKGNvbHVtblZhbHVlLCBjb250ZXh0LmZvcm1hdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgICAgIGNvbnRleHQuZm9ybWF0ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FX09VVFBVVF9GT1JNQVQnXTtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydFRpbWVTdHJpbmcoY29sdW1uVmFsdWUsIGNvbnRleHQuZm9ybWF0LCBtb21lbnQudHouem9uZSgnVVRDJyksIG1ldGFkYXRhRmllbGQuc2NhbGUpLnRvU2ZUaW1lKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICAgIGNvbnRleHQuZm9ybWF0ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydCSU5BUllfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0UmF3QmluYXJ5KGNvbHVtblZhbHVlLCB0aGlzLCBjb250ZXh0KS50b0pTT04oKS5kYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0OiBjb252ZXJ0UmF3U3RydWN0dXJlZFR5cGUoY29udmVydEpzb25PYmplY3QpLFxuICAgICAgICAgICAgICAgIHRvVmFsdWU6IG5vb3AsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogdG9TdHJpbmdGcm9tUmF3VmFsdWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0VmVyc2lvbjogY29udGV4dC5yZXN1bHRWZXJzaW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlbWVudFBhcmFtZXRlcnM6IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBmaWVsZHNNZXRhZGF0YTogbWV0YWRhdGFGaWVsZC5maWVsZHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0SnNvbk9iamVjdChjb2x1bW5WYWx1ZSwgaW50ZXJuYWxDb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5Jzoge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxBcnJheUNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgY29udmVydDogY29udmVydFJhd1N0cnVjdHVyZWRUeXBlKGNvbnZlcnRKc29uQXJyYXkpLFxuICAgICAgICAgICAgICAgIHRvVmFsdWU6IG5vb3AsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogdG9TdHJpbmdGcm9tUmF3VmFsdWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0VmVyc2lvbjogY29udGV4dC5yZXN1bHRWZXJzaW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlbWVudFBhcmFtZXRlcnM6IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBmaWVsZHNNZXRhZGF0YTogbWV0YWRhdGFGaWVsZC5maWVsZHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0SnNvbkFycmF5KGNvbHVtblZhbHVlLCBpbnRlcm5hbEFycmF5Q29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtYXAnOiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbE1hcENvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgY29udmVydDogY29udmVydFJhd1N0cnVjdHVyZWRUeXBlKGNvbnZlcnRKc29uTWFwKSxcbiAgICAgICAgICAgICAgICB0b1ZhbHVlOiBub29wLFxuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRvU3RyaW5nRnJvbVJhd1ZhbHVlLFxuICAgICAgICAgICAgICAgIHJlc3VsdFZlcnNpb246IGNvbnRleHQucmVzdWx0VmVyc2lvbixcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRQYXJhbWV0ZXJzOiBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgZmllbGRzTWV0YWRhdGE6IG1ldGFkYXRhRmllbGQuZmllbGRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydEpzb25NYXAoY29sdW1uVmFsdWUsIGludGVybmFsTWFwQ29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbyhgQ29sdW1uIHR5cGUgbm90IHN1cHBvcnRlZDogJHtjb250ZXh0LmZpZWxkc01ldGFkYXRhLnR5cGV9YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbHVtbiB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICR7Y29udGV4dC5maWVsZHNNZXRhZGF0YS50eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBjb252ZXJ0VGltZXN0YW1wVHpTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nVmFsdWUsIGZvcm1hdFNxbCwgdGltZXpvbmUsIHNjYWxlKSB7XG4gICAgY29uc3QgZm9ybWF0TW9tZW50ID0gZGF0ZVRpbWVGb3JtYXRDb252ZXJ0ZXIuY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0KGZvcm1hdFNxbCwgc2NhbGUpO1xuICAgIGNvbnN0IGVwb2NoU2Vjb25kcyA9IG1vbWVudFRpbWV6b25lKHN0cmluZ1ZhbHVlLCBmb3JtYXRNb21lbnQpLnVuaXgoKTtcbiAgICByZXR1cm4gbmV3IFNmVGltZXN0YW1wKGVwb2NoU2Vjb25kcywgMCwgc2NhbGUsIHRpbWV6b25lLCBmb3JtYXRTcWwpO1xufTtcbmNvbnN0IGNvbnZlcnRUaW1lc3RhbXBOdHpTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nVmFsdWUsIGZvcm1hdFNxbCwgdGltZXpvbmUsIHNjYWxlKSB7XG4gICAgY29uc3QgZm9ybWF0TW9tZW50ID0gZGF0ZVRpbWVGb3JtYXRDb252ZXJ0ZXIuY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0KGZvcm1hdFNxbCwgc2NhbGUpO1xuICAgIGNvbnN0IGVwb2NoU2Vjb25kcyA9IG1vbWVudFRpbWV6b25lLnV0YyhzdHJpbmdWYWx1ZSwgZm9ybWF0TW9tZW50KS51bml4KCk7XG4gICAgcmV0dXJuIG5ldyBTZlRpbWVzdGFtcChlcG9jaFNlY29uZHMsIDAsIHNjYWxlLCB0aW1lem9uZSwgZm9ybWF0U3FsKTtcbn07XG5jb25zdCBjb252ZXJ0RGF0ZVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmdWYWx1ZSwgZm9ybWF0U3FsKSB7XG4gICAgY29uc3QgZm9ybWF0TW9tZW50ID0gZGF0ZVRpbWVGb3JtYXRDb252ZXJ0ZXIuY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0KGZvcm1hdFNxbCwgMCk7XG4gICAgY29uc3QgZXBvY2hTZWNvbmRzID0gbW9tZW50VGltZXpvbmUudXRjKHN0cmluZ1ZhbHVlLCBmb3JtYXRNb21lbnQpLnVuaXgoKTtcbiAgICBjb25zdCBkYXRlID0gbmV3IFNmVGltZXN0YW1wKGVwb2NoU2Vjb25kcywgLy8gY29udmVydCB0byBzZWNvbmRzXG4gICAgMCwgLy8gbm8gbmFubyBzZWNvbmRzXG4gICAgMCwgLy8gbm8gc2NhbGUgcmVxdWlyZWRcbiAgICAnVVRDJywgLy8gdXNlIHV0YyBhcyB0aGUgdGltZXpvbmVcbiAgICBjb250ZXh0LmZvcm1hdCk7XG4gICAgZGF0ZS5fdmFsdWVBc1N0cmluZyA9IHN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiBkYXRlLnRvU2ZEYXRlKCk7XG59O1xuY29uc3QgY29udmVydFRpbWVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nVmFsdWUsIGZvcm1hdFNxbCwgdGltZXpvbmUsIHNjYWxlKSB7XG4gICAgY29uc3QgZm9ybWF0TW9tZW50ID0gZGF0ZVRpbWVGb3JtYXRDb252ZXJ0ZXIuY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0KGZvcm1hdFNxbCwgc2NhbGUpO1xuICAgIGNvbnN0IG1vbWVudCA9IG1vbWVudFRpbWV6b25lKHN0cmluZ1ZhbHVlLCBmb3JtYXRNb21lbnQpO1xuICAgIGNvbnN0IGVwb2NoU2Vjb25kcyA9IG1vbWVudC5ob3VycygpICogMzYwMCArIG1vbWVudC5taW51dGVzKCkgKiA2MCArIG1vbWVudC5zZWNvbmRzKCk7XG4gICAgY29uc3QgdGltZSA9IG5ldyBTZlRpbWVzdGFtcChlcG9jaFNlY29uZHMsIDAsIHNjYWxlLCB0aW1lem9uZSwgZm9ybWF0U3FsKTtcbiAgICB0aW1lLl92YWx1ZUFzU3RyaW5nID0gc3RyaW5nVmFsdWU7XG4gICAgcmV0dXJuIHRpbWU7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBEYXRlIHRvIGEgU25vd2ZsYWtlIERhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbHVtblZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3RGF0ZShyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBTZlRpbWVzdGFtcChOdW1iZXIocmF3Q29sdW1uVmFsdWUpICogODY0MDAsIC8vIGNvbnZlcnQgdG8gc2Vjb25kc1xuICAgIDAsIC8vIG5vIG5hbm8gc2Vjb25kc1xuICAgIDAsIC8vIG5vIHNjYWxlIHJlcXVpcmVkXG4gICAgJ1VUQycsIC8vIHVzZSB1dGMgYXMgdGhlIHRpbWV6b25lXG4gICAgY29udGV4dC5mb3JtYXQpLnRvU2ZEYXRlKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIFRpbWUgdG8gYSBTbm93Zmxha2UgVGltZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd1RpbWUocmF3Q29sdW1uVmFsdWUsIGNvbHVtbiwgY29udGV4dCkge1xuICAgIGNvbnN0IGNvbHVtblNjYWxlID0gY29sdW1uLmdldFNjYWxlKCk7XG4gICAgLy8gdGhlIHZhbHVlcyBtaWdodCBiZSBiaWcgc28gdXNlIEJpZ051bWJlciB0byBkbyBhcml0aG1ldGljXG4gICAgY29uc3QgdmFsRnJhY1NlY3NCaWcgPSBuZXcgQmlnTnVtYmVyKHJhd0NvbHVtblZhbHVlKS50aW1lcyhNYXRoLnBvdygxMCwgY29sdW1uU2NhbGUpKTtcbiAgICByZXR1cm4gY29udmVydFJhd1RpbWVzdGFtcEhlbHBlcih2YWxGcmFjU2Vjc0JpZywgY29sdW1uU2NhbGUsICdVVEMnLCBjb250ZXh0LmZvcm1hdCkudG9TZlRpbWUoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgVElNRVNUQU1QX0xUWiB0byBhIFNub3dmbGFrZSBEYXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb2x1bW5WYWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbHVtblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd1RpbWVzdGFtcEx0eihyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSB7XG4gICAgY29uc3QgY29sdW1uU2NhbGUgPSBjb2x1bW4uZ2V0U2NhbGUoKTtcbiAgICAvLyB0aGUgdmFsdWVzIG1pZ2h0IGJlIGJpZyBzbyB1c2UgQmlnTnVtYmVyIHRvIGRvIGFyaXRobWV0aWNcbiAgICBjb25zdCB2YWxGcmFjU2Vjc0JpZyA9IG5ldyBCaWdOdW1iZXIocmF3Q29sdW1uVmFsdWUpLnRpbWVzKE1hdGgucG93KDEwLCBjb2x1bW5TY2FsZSkpO1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBzbm93Zmxha2UgZGF0ZVxuICAgIHJldHVybiBjb252ZXJ0UmF3VGltZXN0YW1wSGVscGVyKHZhbEZyYWNTZWNzQmlnLCBjb2x1bW5TY2FsZSwgY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FWk9ORSddLCBjb250ZXh0LmZvcm1hdCkudG9TZkRhdGUoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgVElNRVNUQU1QX05UWiB0byBhIFNub3dmbGFrZSBEYXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb2x1bW5WYWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbHVtblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd1RpbWVzdGFtcE50eihyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSB7XG4gICAgY29uc3QgY29sdW1uU2NhbGUgPSBjb2x1bW4uZ2V0U2NhbGUoKTtcbiAgICAvLyB0aGUgdmFsdWVzIG1pZ2h0IGJlIGJpZyBzbyB1c2UgQmlnTnVtYmVyIHRvIGRvIGFyaXRobWV0aWNcbiAgICBjb25zdCB2YWxGcmFjU2Vjc0JpZyA9IG5ldyBCaWdOdW1iZXIocmF3Q29sdW1uVmFsdWUpLnRpbWVzKE1hdGgucG93KDEwLCBjb2x1bW5TY2FsZSkpO1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBzbm93Zmxha2UgZGF0ZVxuICAgIHJldHVybiBjb252ZXJ0UmF3VGltZXN0YW1wSGVscGVyKHZhbEZyYWNTZWNzQmlnLCBjb2x1bW5TY2FsZSwgJ1VUQycsIC8vIGl0J3MgX250eiwgc28gdXNlIFVUQyBmb3IgdGltZXpvbmVcbiAgICBjb250ZXh0LmZvcm1hdCkudG9TZkRhdGUoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgVElNRVNUQU1QX1RaIHRvIGEgU25vd2ZsYWtlIERhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbHVtblZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3VGltZXN0YW1wVHoocmF3Q29sdW1uVmFsdWUsIGNvbHVtbiwgY29udGV4dCkge1xuICAgIGxldCB2YWxGcmFjU2Vjc0JpZztcbiAgICBsZXQgdmFsRnJhY1NlY3NXaXRoVHpCaWc7XG4gICAgbGV0IHRpbWV6b25lQmlnO1xuICAgIGxldCB0aW1lem9uZTtcbiAgICBsZXQgdGltZXN0YW1wQW5kVFpJbmRleDtcbiAgICAvLyBjb21wdXRlIHRoZSBzY2FsZSBmYWN0b3JcbiAgICBjb25zdCBjb2x1bW5TY2FsZSA9IGNvbHVtbi5nZXRTY2FsZSgpO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gTWF0aC5wb3coMTAsIGNvbHVtblNjYWxlKTtcbiAgICBjb25zdCByZXN1bHRWZXJzaW9uID0gY29udGV4dC5yZXN1bHRWZXJzaW9uO1xuICAgIGlmIChyZXN1bHRWZXJzaW9uID09PSAnMCcgfHwgcmVzdWx0VmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRoZSB2YWx1ZXMgbWlnaHQgYmUgYmlnIHNvIHVzZSBCaWdOdW1iZXIgdG8gZG8gYXJpdGhtZXRpY1xuICAgICAgICB2YWxGcmFjU2Vjc0JpZyA9IG5ldyBCaWdOdW1iZXIocmF3Q29sdW1uVmFsdWUpLnRpbWVzKHNjYWxlRmFjdG9yKTtcbiAgICAgICAgLy8gZm9yIF90eiwgdGhlIHRpbWV6b25lIGlzIGJha2VkIGludG8gdGhlIHZhbHVlXG4gICAgICAgIHZhbEZyYWNTZWNzV2l0aFR6QmlnID0gdmFsRnJhY1NlY3NCaWc7XG4gICAgICAgIC8vIGV4dHJhY3QgZXZlcnl0aGluZyBidXQgdGhlIGxvd2VzdCAxNCBiaXRzIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBzZWNvbmRzXG4gICAgICAgIHZhbEZyYWNTZWNzQmlnID0gdmFsRnJhY1NlY3NXaXRoVHpCaWcuZGl2aWRlZEJ5KDE2Mzg0KS5pbnRlZ2VyVmFsdWUoQmlnTnVtYmVyLlJPVU5EX0ZMT09SKTtcbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgbG93ZXN0IDE0IGJpdHMgdG8gZ2V0IHRoZSB0aW1lem9uZVxuICAgICAgICBpZiAodmFsRnJhY1NlY3NXaXRoVHpCaWcuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbygwKSkge1xuICAgICAgICAgICAgdGltZXpvbmVCaWcgPSB2YWxGcmFjU2Vjc1dpdGhUekJpZy5tb2R1bG8oMTYzODQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGltZXpvbmVCaWcgPSB2YWxGcmFjU2Vjc1dpdGhUekJpZy5tb2R1bG8oMTYzODQpLnBsdXMoMTYzODQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzcGxpdCB0aGUgdmFsdWUgaW50byBudW1iZXIgb2Ygc2Vjb25kcyBhbmQgdGltZXpvbmUgaW5kZXhcbiAgICAgICAgdGltZXN0YW1wQW5kVFpJbmRleCA9IHJhd0NvbHVtblZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgIC8vIHRoZSB2YWx1ZXMgbWlnaHQgYmUgYmlnIHNvIHVzZSBCaWdOdW1iZXIgdG8gZG8gYXJpdGhtZXRpY1xuICAgICAgICB2YWxGcmFjU2Vjc0JpZyA9IG5ldyBCaWdOdW1iZXIodGltZXN0YW1wQW5kVFpJbmRleFswXSkudGltZXMoc2NhbGVGYWN0b3IpO1xuICAgICAgICB0aW1lem9uZUJpZyA9IG5ldyBCaWdOdW1iZXIodGltZXN0YW1wQW5kVFpJbmRleFsxXSk7XG4gICAgfVxuICAgIHRpbWV6b25lID0gdGltZXpvbmVCaWcudG9OdW1iZXIoKTtcbiAgICAvLyBhc3NlcnQgdGhhdCB0aW1lem9uZSBpcyB2YWxpZFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbCh0aW1lem9uZSA+PSAwICYmIHRpbWV6b25lIDw9IDI4ODApO1xuICAgIC8vIHN1YnRyYWN0IDI0IGhvdXJzIGZyb20gdGhlIHRpbWV6b25lIHRvIG1hcCBbMCwgNDhdIHRvXG4gICAgLy8gWy0yNCwgMjRdLCBhbmQgY29udmVydCB0aGUgcmVzdWx0IHRvIGEgbnVtYmVyXG4gICAgdGltZXpvbmUgPSB0aW1lem9uZSAtIDE0NDA7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHNub3dmbGFrZSBkYXRlXG4gICAgcmV0dXJuIGNvbnZlcnRSYXdUaW1lc3RhbXBIZWxwZXIodmFsRnJhY1NlY3NCaWcsIGNvbHVtblNjYWxlLCB0aW1lem9uZSwgY29udGV4dC5mb3JtYXQpLnRvU2ZEYXRlKCk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgdGhlIGNvbnZlcnRSYXdUaW1lc3RhbXAqKCkgZnVuY3Rpb25zLlxuICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBTZlRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXBvY2hGcmFjU2Vjc0JpZ1xuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gdGltZXpvbmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3VGltZXN0YW1wSGVscGVyKGVwb2NoRnJhY1NlY3NCaWcsIHNjYWxlLCB0aW1lem9uZSwgZm9ybWF0KSB7XG4gICAgLy8gY29tcHV0ZSB0aGUgc2NhbGUgZmFjdG9yXG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBNYXRoLnBvdygxMCwgc2NhbGUpO1xuICAgIC8vIHNwbGl0IHRoZSB2YWx1ZSBpbnRvIGVwb2NoIHNlY29uZHMgKyBuYW5vc2Vjb25kczsgZm9yIGV4YW1wbGUsXG4gICAgLy8gMTM2NTE0ODkyMy4xMjM0NTY3ODkgd2lsbCBiZSBzcGxpdCBpbnRvIDEzNjUxNDg5MjMgKGVwb2NoIHNlY29uZHMpXG4gICAgLy8gYW5kIDEyMzQ1Njc4OSAobmFubyBzZWNvbmRzKVxuICAgIGNvbnN0IHZhbFNlY0JpZyA9IGVwb2NoRnJhY1NlY3NCaWcuZGl2aWRlZEJ5KHNjYWxlRmFjdG9yKS5pbnRlZ2VyVmFsdWUoQmlnTnVtYmVyLlJPVU5EX0ZMT09SKTtcbiAgICBjb25zdCBmcmFjdGlvbnNCaWcgPSBlcG9jaEZyYWNTZWNzQmlnLm1pbnVzKHZhbFNlY0JpZy50aW1lcyhzY2FsZUZhY3RvcikpO1xuICAgIGNvbnN0IHZhbFNlY05hbm9CaWcgPSBmcmFjdGlvbnNCaWcudGltZXMoTWF0aC5wb3coMTAsIDkgLSBzY2FsZSkpO1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBzbm93Zmxha2UgZGF0ZSBmcm9tIHRoZSBpbmZvcm1hdGlvblxuICAgIHJldHVybiBuZXcgU2ZUaW1lc3RhbXAodmFsU2VjQmlnLnRvTnVtYmVyKCksIHZhbFNlY05hbm9CaWcudG9OdW1iZXIoKSwgc2NhbGUsIHRpbWV6b25lLCBmb3JtYXQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBWYXJpYW50IHRvIGEgSmF2YVNjcmlwdCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0IHwgQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdWYXJpYW50KHJhd0NvbHVtblZhbHVlKSB7XG4gICAgLy8gaWYgdGhlIGlucHV0IGlzIGEgbm9uLWVtcHR5IHN0cmluZywgY29udmVydCBpdCB0byBhIGpzb24gb2JqZWN0XG4gICAgaWYgKFV0aWwuc3RyaW5nLmlzTm90TnVsbE9yRW1wdHkocmF3Q29sdW1uVmFsdWUpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gR2xvYmFsQ29uZmlnLmpzb25Db2x1bW5WYXJpYW50UGFyc2VyKHJhd0NvbHVtblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoanNvblBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdsb2JhbENvbmZpZy54bWxDb2x1bW5WYXJpYW50UGFyc2VyKHJhd0NvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh4bWxQYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1ZhcmlhbnQgY2Fubm90IGJlIHBhcnNlZCBuZWl0aGVyIGFzIEpTT046ICVzIG5vciBhcyBYTUw6ICVzJywganNvblBhcnNlRXJyb3IubWVzc2FnZSwgeG1sUGFyc2VFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhcmlhbnRQYXJzZUVycm9yKGpzb25QYXJzZUVycm9yLCB4bWxQYXJzZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgQmluYXJ5IHRvIGEgQnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb2x1bW5WYWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbHVtblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3QmluYXJ5KHJhd0NvbHVtblZhbHVlLCBjb2x1bW4sIGNvbnRleHQpIHtcbiAgICAvLyBFbnN1cmUgdGhlIGZvcm1hdCBpcyB2YWxpZC5cbiAgICBjb25zdCBmb3JtYXQgPSBjb250ZXh0LmZvcm1hdC50b1VwcGVyQ2FzZSgpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChmb3JtYXQgPT09ICdIRVgnIHx8IGZvcm1hdCA9PT0gJ0JBU0U2NCcpO1xuICAgIC8vIERlY29kZSBoZXggc3RyaW5nIHNlbnQgYnkgR1MuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20ocmF3Q29sdW1uVmFsdWUsICdIRVgnKTtcbiAgICBpZiAoZm9ybWF0ID09PSAnSEVYJykge1xuICAgICAgICBidWZmZXIudG9TdHJpbmdTZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSByYXcgdmFsdWUgaXMgYWxyZWFkeSBhbiB1cHBlcmNhc2UgaGV4IHN0cmluZywgc28ganVzdCByZXR1cm4gaXQuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYnVmZmVyLnRvU3RyaW5nKFwiSEVYXCIpIHJldHVybnMgYSBsb3dlcmNhc2UgaGV4IHN0cmluZywgYnV0IHdlXG4gICAgICAgICAgICAvLyB3YW50IHVwcGVyIGNhc2UuXG4gICAgICAgICAgICByZXR1cm4gcmF3Q29sdW1uVmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXIudG9TdHJpbmdTZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCdCQVNFNjQnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVmZmVyLmdldEZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9O1xuICAgIHJldHVybiBidWZmZXI7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGlucHV0IHZhbHVlIGFzIGlzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gbm9vcCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogVGhlIHRvVmFsdWUoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBOdW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWVGcm9tTnVtYmVyKGNvbHVtblZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbHVtblZhbHVlID8gY29sdW1uVmFsdWUucHJvY2Vzc2VkIDogY29sdW1uVmFsdWU7XG59XG4vKipcbiAqIFRoZSB0b1ZhbHVlKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgVGltZS5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZUZyb21UaW1lKGNvbHVtblZhbHVlKSB7XG4gICAgLy8gdGhlcmUncyBubyBuYXRpdmUgamF2YXNjcmlwdCB0eXBlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRpbWUsIHNvXG4gICAgLy8ganVzdCBjb252ZXJ0IHRvIHN0cmluZ1xuICAgIHJldHVybiB0b1N0cmluZ0Zyb21UaW1lKGNvbHVtblZhbHVlKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgTnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbU51bWJlcihjb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiBjb2x1bW5WYWx1ZSAhPT0gbnVsbCA/IGNvbHVtblZhbHVlLnJhdyA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgQm9vbGVhbi5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdGcm9tQm9vbGVhbihjb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiBjb2x1bW5WYWx1ZSAhPT0gbnVsbCA/IFN0cmluZyhjb2x1bW5WYWx1ZSkudG9VcHBlckNhc2UoKSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgRGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdGcm9tRGF0ZShjb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiBjb2x1bW5WYWx1ZSAhPT0gbnVsbCA/IGNvbHVtblZhbHVlLnRvSlNPTigpIDogRGF0YVR5cGVzLmdldE51bGxWYWx1ZSgpO1xufVxuLyoqXG4gKiBUaGUgdG9TdHJpbmcoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBUaW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbVRpbWUoY29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWUgIT09IG51bGwgPyBjb2x1bW5WYWx1ZS50b0pTT04oKSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgVGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21UaW1lc3RhbXAoY29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWUgIT09IG51bGwgPyBjb2x1bW5WYWx1ZS50b0pTT04oKSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgVmFyaWFudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21SYXdWYWx1ZShjb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiBjb2x1bW5WYWx1ZSAhPT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KGNvbHVtblZhbHVlKSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgU3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbVN0cmluZyhjb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiBjb2x1bW5WYWx1ZSAhPT0gbnVsbCA/IGNvbHVtblZhbHVlIDogRGF0YVR5cGVzLmdldE51bGxWYWx1ZSgpO1xufVxuLyoqXG4gKiBUaGUgdG9TdHJpbmcoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBCaW5hcnkuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdGcm9tQmluYXJ5KGNvbHVtblZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbHVtblZhbHVlICE9PSBudWxsID8gY29sdW1uVmFsdWUudG9TdHJpbmdTZigpIDogRGF0YVR5cGVzLmdldE51bGxWYWx1ZSgpO1xufVxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdmFsdWUgb2YgYSBjb2x1bW4gZnJvbSBhIGdpdmVuIHJvdy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcm93XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufSBhc1N0cmluZ1xuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBleHRyYWN0RnJvbVJvdyhyb3csIGNvbnRleHQsIGFzU3RyaW5nKSB7XG4gICAgY29uc3QgbWFwID0gcm93Ll9hcnJheVByb2Nlc3NlZENvbHVtbnM7XG4gICAgY29uc3QgdmFsdWVzID0gcm93LnZhbHVlcztcbiAgICAvLyBnZXQgdGhlIHZhbHVlXG4gICAgY29uc3QgY29sdW1uSW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgbGV0IHJldCA9IHZhbHVlc1tjb2x1bW5JbmRleF07XG4gICAgLy8gaWYgd2Ugd2FudCB0aGUgdmFsdWUgYXMgYSBzdHJpbmcsIGFuZCB0aGUgY29sdW1uIGlzIG9mIHR5cGUgdmFyaWFudCwgYW5kIHdlXG4gICAgLy8gaGF2ZW4ndCBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgdmFsdWUgYmVmb3JlLCB3ZSBkb24ndCBuZWVkIHRvIHByb2Nlc3MgdGhlXG4gICAgLy8gdmFsdWUsIHNvIG9ubHkgcHJvY2VzcyBpZiBub25lIG9mIHRoZSBhZm9yZW1lbnRpb25lZCBjb25kaXRpb25zIGFyZSB0cnVlXG4gICAgaWYgKCEoYXNTdHJpbmcgJiYgdGhpcy5pc1ZhcmlhbnQoKSAmJiAhbWFwW2NvbHVtbkluZGV4XSkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGNvbHVtbiB2YWx1ZSBoYXMgbm90IGJlZW4gcHJvY2Vzc2VkIHlldCwgcHJvY2VzcyBpdCwgcHV0IGl0IGJhY2tcbiAgICAgICAgLy8gaW4gdGhlIHZhbHVlcyBhcnJheSwgYW5kIHJlbWVtYmVyIHRoYXQgdGhlIHZhbHVlIGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgICAgICBpZiAoIW1hcFtjb2x1bW5JbmRleF0pIHtcbiAgICAgICAgICAgIGlmIChyZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXQgPSB2YWx1ZXNbY29sdW1uSW5kZXhdID0gY29udGV4dC5jb252ZXJ0KHZhbHVlc1tjb2x1bW5JbmRleF0sIHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwW2NvbHVtbkluZGV4XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlIHRoZSBhcHByb3ByaWF0ZSBleHRyYWN0aW9uIGZ1bmN0aW9uIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gICAgICAgIC8vIHdlIHdhbnQgdGhlIHZhbHVlIG9yIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxuICAgICAgICBjb25zdCBleHRyYWN0Rm4gPSAhYXNTdHJpbmcgPyBjb250ZXh0LnRvVmFsdWUgOiBjb250ZXh0LnRvU3RyaW5nO1xuICAgICAgICByZXQgPSBleHRyYWN0Rm4ocmV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sdW1uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/column.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst sqlTypes = {\n    values: {\n        TEXT: 'text',\n        BINARY: 'binary',\n        BOOLEAN: 'boolean',\n        FIXED: 'fixed',\n        REAL: 'real',\n        DATE: 'date',\n        TIME: 'time',\n        TIMESTAMP_LTZ: 'timestamp_ltz',\n        TIMESTAMP_NTZ: 'timestamp_ntz',\n        TIMESTAMP_TZ: 'timestamp_tz',\n        VARIANT: 'variant',\n        OBJECT: 'object',\n        ARRAY: 'array',\n        MAP: 'map',\n    },\n    /**\n     * Determines if a column's SQL type is String.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isString: function (sqlType) {\n        return sqlType === this.values.TEXT;\n    },\n    /**\n     * Determines if a column's SQL type is Binary.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isBinary: function (sqlType) {\n        return sqlType === this.values.BINARY;\n    },\n    /**\n     * Determines if a column's SQL type is Boolean.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isBoolean: function (sqlType) {\n        return sqlType === this.values.BOOLEAN;\n    },\n    /**\n     * Determines if a column's SQL type is Number.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isNumber: function (sqlType) {\n        return sqlType === this.values.FIXED || sqlType === this.values.REAL;\n    },\n    /**\n     * Determines if a column's SQL type is Date.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isDate: function (sqlType) {\n        return sqlType === this.values.DATE;\n    },\n    /**\n     * Determines if a column's SQL type is Time.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTime: function (sqlType) {\n        return sqlType === this.values.TIME;\n    },\n    /**\n     * Determines if a column's SQL type is Timestamp.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestamp: function (sqlType) {\n        return (sqlType === this.values.TIMESTAMP_LTZ ||\n            sqlType === this.values.TIMESTAMP_NTZ ||\n            sqlType === this.values.TIMESTAMP_TZ);\n    },\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_LTZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampLtz: function (sqlType) {\n        return sqlType === this.values.TIMESTAMP_LTZ;\n    },\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_NTZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampNtz: function (sqlType) {\n        return sqlType === this.values.TIMESTAMP_NTZ;\n    },\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_TZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampTz: function (sqlType) {\n        return sqlType === this.values.TIMESTAMP_TZ;\n    },\n    /**\n     * Determines if a column's SQL type is Variant.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isVariant: function (sqlType, fieldsMetadata) {\n        return (sqlType === this.values.VARIANT ||\n            (sqlType === this.values.OBJECT && fieldsMetadata == null) ||\n            (sqlType === this.values.ARRAY && fieldsMetadata == null) ||\n            (sqlType === this.values.MAP && fieldsMetadata == null));\n    },\n    /**\n     * Determines if a column's SQL type is Object.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isObject: function (sqlType, fieldsMetadata) {\n        return sqlType === this.values.OBJECT && fieldsMetadata != null;\n    },\n    /**\n     * Determines if a column's SQL type is Array.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isArray: function (sqlType, fieldsMetadata) {\n        return sqlType === this.values.ARRAY && fieldsMetadata != null;\n    },\n    /**\n     * Determines if a column's SQL type is Map.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isMap: function (sqlType, fieldsMetadata) {\n        return sqlType === this.values.MAP && fieldsMetadata != null;\n    },\n};\nconst nativeTypes = {\n    values: {\n        STRING: 'STRING',\n        BOOLEAN: 'BOOLEAN',\n        NUMBER: 'NUMBER',\n        DATE: 'DATE',\n        JSON: 'JSON',\n        BUFFER: 'BUFFER',\n        OBJECT: 'OBJECT',\n        ARRAY: 'ARRAY',\n        MAP: 'MAP',\n    },\n    /**\n     * Determines if a given value is a valid native type.\n     *\n     * @param {*} value\n     *\n     * @returns {boolean}\n     */\n    isValidValue: function (value) {\n        return !!this.values[Util.isString(value) ? value.toUpperCase() : value];\n    },\n    /**\n     * Given an array of strings, returns the index of the first element that\n     * represents an invalid native type. If the values are all valid, a value of\n     * -1 is returned.\n     *\n     * @param {String[]} nativeTypes\n     *\n     * @returns {Number}\n     */\n    findInvalidValue: function (nativeTypes) {\n        // validate input\n        Errors.assertInternal(Util.isArray(nativeTypes));\n        // find the index of the first invalid value\n        let invalidValueIndex = -1;\n        for (let index = 0, length = nativeTypes.length; index < length; index++) {\n            if (!this.isValidValue(nativeTypes[index])) {\n                invalidValueIndex = index;\n                break;\n            }\n        }\n        return invalidValueIndex;\n    },\n};\nlet isRepresentNullAsStringNull = true;\nexports.setIsRepresentNullAsStringNull = function (option) {\n    isRepresentNullAsStringNull = option;\n};\nexports.getNullValue = function () {\n    return isRepresentNullAsStringNull ? 'NULL' : null;\n};\nconst sqlTypeValues = sqlTypes.values;\nconst nativeTypeValues = nativeTypes.values;\nconst MAP_SQL_TO_NATIVE = {};\nMAP_SQL_TO_NATIVE[sqlTypeValues.TEXT] = nativeTypeValues.STRING;\nMAP_SQL_TO_NATIVE[sqlTypeValues.BINARY] = nativeTypeValues.BUFFER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.BOOLEAN] = nativeTypeValues.BOOLEAN;\nMAP_SQL_TO_NATIVE[sqlTypeValues.FIXED] = nativeTypeValues.NUMBER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.REAL] = nativeTypeValues.NUMBER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.DATE] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIME] = nativeTypeValues.STRING;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_LTZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_NTZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_TZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.VARIANT] = nativeTypeValues.JSON;\nMAP_SQL_TO_NATIVE[sqlTypeValues.OBJECT] = nativeTypeValues.OBJECT;\nMAP_SQL_TO_NATIVE[sqlTypeValues.ARRAY] = nativeTypeValues.ARRAY;\nMAP_SQL_TO_NATIVE[sqlTypeValues.MAP] = nativeTypeValues.MAP;\nexports.SqlTypes = sqlTypes;\nexports.NativeTypes = nativeTypes;\n/**\n * Given a SQL type, returns the corresponding native type.\n *\n * @param {String} sqlType\n *\n * @returns {String}\n */\nexports.toNativeType = function (sqlType) {\n    return MAP_SQL_TO_NATIVE[sqlType];\n};\n//# sourceMappingURL=data_types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRhX3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLHVFQUFZO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRhX3R5cGVzLmpzP2U2MTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBzcWxUeXBlcyA9IHtcbiAgICB2YWx1ZXM6IHtcbiAgICAgICAgVEVYVDogJ3RleHQnLFxuICAgICAgICBCSU5BUlk6ICdiaW5hcnknLFxuICAgICAgICBCT09MRUFOOiAnYm9vbGVhbicsXG4gICAgICAgIEZJWEVEOiAnZml4ZWQnLFxuICAgICAgICBSRUFMOiAncmVhbCcsXG4gICAgICAgIERBVEU6ICdkYXRlJyxcbiAgICAgICAgVElNRTogJ3RpbWUnLFxuICAgICAgICBUSU1FU1RBTVBfTFRaOiAndGltZXN0YW1wX2x0eicsXG4gICAgICAgIFRJTUVTVEFNUF9OVFo6ICd0aW1lc3RhbXBfbnR6JyxcbiAgICAgICAgVElNRVNUQU1QX1RaOiAndGltZXN0YW1wX3R6JyxcbiAgICAgICAgVkFSSUFOVDogJ3ZhcmlhbnQnLFxuICAgICAgICBPQkpFQ1Q6ICdvYmplY3QnLFxuICAgICAgICBBUlJBWTogJ2FycmF5JyxcbiAgICAgICAgTUFQOiAnbWFwJyxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5URVhUO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIEJpbmFyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0JpbmFyeTogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkJJTkFSWTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBCb29sZWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkJPT0xFQU47XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgTnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTnVtYmVyOiBmdW5jdGlvbiAoc3FsVHlwZSkge1xuICAgICAgICByZXR1cm4gc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuRklYRUQgfHwgc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuUkVBTDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBEYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRGF0ZTogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkRBVEU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgVGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RpbWU6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5USU1FO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFRpbWVzdGFtcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RpbWVzdGFtcDogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5USU1FU1RBTVBfTFRaIHx8XG4gICAgICAgICAgICBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5USU1FU1RBTVBfTlRaIHx8XG4gICAgICAgICAgICBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5USU1FU1RBTVBfVFopO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFRJTUVTVEFNUF9MVFouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lc3RhbXBMdHo6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5USU1FU1RBTVBfTFRaO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFRJTUVTVEFNUF9OVFouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lc3RhbXBOdHo6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5USU1FU1RBTVBfTlRaO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFRJTUVTVEFNUF9UWi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RpbWVzdGFtcFR6OiBmdW5jdGlvbiAoc3FsVHlwZSkge1xuICAgICAgICByZXR1cm4gc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX1RaO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFZhcmlhbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYXJpYW50OiBmdW5jdGlvbiAoc3FsVHlwZSwgZmllbGRzTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5WQVJJQU5UIHx8XG4gICAgICAgICAgICAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuT0JKRUNUICYmIGZpZWxkc01ldGFkYXRhID09IG51bGwpIHx8XG4gICAgICAgICAgICAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuQVJSQVkgJiYgZmllbGRzTWV0YWRhdGEgPT0gbnVsbCkgfHxcbiAgICAgICAgICAgIChzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5NQVAgJiYgZmllbGRzTWV0YWRhdGEgPT0gbnVsbCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIE9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09iamVjdDogZnVuY3Rpb24gKHNxbFR5cGUsIGZpZWxkc01ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5PQkpFQ1QgJiYgZmllbGRzTWV0YWRhdGEgIT0gbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBBcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FycmF5OiBmdW5jdGlvbiAoc3FsVHlwZSwgZmllbGRzTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkFSUkFZICYmIGZpZWxkc01ldGFkYXRhICE9IG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgTWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTWFwOiBmdW5jdGlvbiAoc3FsVHlwZSwgZmllbGRzTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLk1BUCAmJiBmaWVsZHNNZXRhZGF0YSAhPSBudWxsO1xuICAgIH0sXG59O1xuY29uc3QgbmF0aXZlVHlwZXMgPSB7XG4gICAgdmFsdWVzOiB7XG4gICAgICAgIFNUUklORzogJ1NUUklORycsXG4gICAgICAgIEJPT0xFQU46ICdCT09MRUFOJyxcbiAgICAgICAgTlVNQkVSOiAnTlVNQkVSJyxcbiAgICAgICAgREFURTogJ0RBVEUnLFxuICAgICAgICBKU09OOiAnSlNPTicsXG4gICAgICAgIEJVRkZFUjogJ0JVRkZFUicsXG4gICAgICAgIE9CSkVDVDogJ09CSkVDVCcsXG4gICAgICAgIEFSUkFZOiAnQVJSQVknLFxuICAgICAgICBNQVA6ICdNQVAnLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgbmF0aXZlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnZhbHVlc1tVdGlsLmlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZV07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBzdHJpbmdzLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAgICogcmVwcmVzZW50cyBhbiBpbnZhbGlkIG5hdGl2ZSB0eXBlLiBJZiB0aGUgdmFsdWVzIGFyZSBhbGwgdmFsaWQsIGEgdmFsdWUgb2ZcbiAgICAgKiAtMSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG5hdGl2ZVR5cGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGZpbmRJbnZhbGlkVmFsdWU6IGZ1bmN0aW9uIChuYXRpdmVUeXBlcykge1xuICAgICAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KG5hdGl2ZVR5cGVzKSk7XG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpbnZhbGlkIHZhbHVlXG4gICAgICAgIGxldCBpbnZhbGlkVmFsdWVJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IG5hdGl2ZVR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkVmFsdWUobmF0aXZlVHlwZXNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRWYWx1ZUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZUluZGV4O1xuICAgIH0sXG59O1xubGV0IGlzUmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCA9IHRydWU7XG5leHBvcnRzLnNldElzUmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBpc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwgPSBvcHRpb247XG59O1xuZXhwb3J0cy5nZXROdWxsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCA/ICdOVUxMJyA6IG51bGw7XG59O1xuY29uc3Qgc3FsVHlwZVZhbHVlcyA9IHNxbFR5cGVzLnZhbHVlcztcbmNvbnN0IG5hdGl2ZVR5cGVWYWx1ZXMgPSBuYXRpdmVUeXBlcy52YWx1ZXM7XG5jb25zdCBNQVBfU1FMX1RPX05BVElWRSA9IHt9O1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5URVhUXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuU1RSSU5HO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5CSU5BUlldID0gbmF0aXZlVHlwZVZhbHVlcy5CVUZGRVI7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLkJPT0xFQU5dID0gbmF0aXZlVHlwZVZhbHVlcy5CT09MRUFOO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5GSVhFRF0gPSBuYXRpdmVUeXBlVmFsdWVzLk5VTUJFUjtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuUkVBTF0gPSBuYXRpdmVUeXBlVmFsdWVzLk5VTUJFUjtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuREFURV0gPSBuYXRpdmVUeXBlVmFsdWVzLkRBVEU7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLlRJTUVdID0gbmF0aXZlVHlwZVZhbHVlcy5TVFJJTkc7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLlRJTUVTVEFNUF9MVFpdID0gbmF0aXZlVHlwZVZhbHVlcy5EQVRFO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5USU1FU1RBTVBfTlRaXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuREFURTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuVElNRVNUQU1QX1RaXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuREFURTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuVkFSSUFOVF0gPSBuYXRpdmVUeXBlVmFsdWVzLkpTT047XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLk9CSkVDVF0gPSBuYXRpdmVUeXBlVmFsdWVzLk9CSkVDVDtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuQVJSQVldID0gbmF0aXZlVHlwZVZhbHVlcy5BUlJBWTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuTUFQXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuTUFQO1xuZXhwb3J0cy5TcWxUeXBlcyA9IHNxbFR5cGVzO1xuZXhwb3J0cy5OYXRpdmVUeXBlcyA9IG5hdGl2ZVR5cGVzO1xuLyoqXG4gKiBHaXZlbiBhIFNRTCB0eXBlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIG5hdGl2ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcWxUeXBlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0cy50b05hdGl2ZVR5cGUgPSBmdW5jdGlvbiAoc3FsVHlwZSkge1xuICAgIHJldHVybiBNQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlXTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhX3R5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * The map of symbols for datatime representation in Snowflake and in Moment.js formatting.\n * The order of tags is important Please don't change it\n */\nfunction formatTagsMap() {\n    return [\n        // proper mappings\n        ['YYYY', 'YYYY'],\n        ['YY', 'YY'],\n        ['MM', 'MM'],\n        ['MON', 'MMM'],\n        ['DD', 'DD'],\n        ['DY', 'ddd'],\n        ['HH24', 'HH'],\n        ['HH12', 'hh'],\n        ['HH', 'HH'],\n        ['AM', 'A'],\n        ['PM', 'A'],\n        ['MI', 'mm'],\n        ['SS', 'ss'],\n        ['TZH:TZM', 'Z'],\n        ['TZHTZM', 'ZZ'],\n        // special code needed\n        ['TZH', ''],\n        ['TZM', ''],\n        ['FF', ''],\n    ];\n}\nfunction convertSnowflakeFormatToMomentFormat(formatSql, scale) {\n    const tags = formatTagsMap();\n    // get an upper-case version of the input sql format\n    const formatSqlUpper = formatSql.toUpperCase();\n    // iterate over the format string\n    const length = formatSql.length;\n    let formatMoment = '';\n    for (let pos = 0; pos < length;) {\n        let tag = null;\n        let out = null;\n        // at each position, check if there's a tag at that position; if so, use\n        // 'out' as the replacement\n        for (let index = 0; index < tags.length; index++) {\n            if (formatSqlUpper.substr(pos).indexOf(tags[index][0]) === 0) {\n                tag = tags[index][0];\n                out = tags[index][1];\n                break;\n            }\n        }\n        // if we didn't find a match, just insert the character after escaping it\n        // (by wrapping it in square brackets)\n        if (out === null) {\n            formatMoment += formatSql[pos];\n            pos++;\n        }\n        else {\n            // we found one of our special tags\n            if (out === '') {\n                if (tag === 'TZH') {\n                    out = 'Z';\n                }\n                else if (tag === 'FF') {\n                    // if 'FF' is followed by a digit, use the digit as the scale\n                    let digit = null;\n                    if (pos + tag.length < length) {\n                        const matches = formatSql[pos + tag.length].match(/[0-9]/);\n                        if (matches) {\n                            digit = matches[0];\n                        }\n                    }\n                    if (digit !== null) {\n                        pos++; // skip the digit as well\n                    }\n                    // if we need to include fractional seconds\n                    if (scale > 0) {\n                        // divide the nanoSeconds to get the requested number of\n                        // meaningful digits\n                        // pad with the appropriate number of leading zeros\n                        out = new Array(9).join('S').substr(-scale);\n                    }\n                }\n            }\n            // append the 'out' text to the moment format and update the position\n            formatMoment += out;\n            pos += tag.length;\n        }\n    }\n    return formatMoment;\n}\nmodule.exports.formatTagsMap = formatTagsMap;\nmodule.exports.convertSnowflakeFormatToMomentFormat = convertSnowflakeFormatToMomentFormat;\n//# sourceMappingURL=datetime_format_converter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRldGltZV9mb3JtYXRfY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbURBQW1EO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRldGltZV9mb3JtYXRfY29udmVydGVyLmpzPzc5N2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoZSBtYXAgb2Ygc3ltYm9scyBmb3IgZGF0YXRpbWUgcmVwcmVzZW50YXRpb24gaW4gU25vd2ZsYWtlIGFuZCBpbiBNb21lbnQuanMgZm9ybWF0dGluZy5cbiAqIFRoZSBvcmRlciBvZiB0YWdzIGlzIGltcG9ydGFudCBQbGVhc2UgZG9uJ3QgY2hhbmdlIGl0XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRhZ3NNYXAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gcHJvcGVyIG1hcHBpbmdzXG4gICAgICAgIFsnWVlZWScsICdZWVlZJ10sXG4gICAgICAgIFsnWVknLCAnWVknXSxcbiAgICAgICAgWydNTScsICdNTSddLFxuICAgICAgICBbJ01PTicsICdNTU0nXSxcbiAgICAgICAgWydERCcsICdERCddLFxuICAgICAgICBbJ0RZJywgJ2RkZCddLFxuICAgICAgICBbJ0hIMjQnLCAnSEgnXSxcbiAgICAgICAgWydISDEyJywgJ2hoJ10sXG4gICAgICAgIFsnSEgnLCAnSEgnXSxcbiAgICAgICAgWydBTScsICdBJ10sXG4gICAgICAgIFsnUE0nLCAnQSddLFxuICAgICAgICBbJ01JJywgJ21tJ10sXG4gICAgICAgIFsnU1MnLCAnc3MnXSxcbiAgICAgICAgWydUWkg6VFpNJywgJ1onXSxcbiAgICAgICAgWydUWkhUWk0nLCAnWlonXSxcbiAgICAgICAgLy8gc3BlY2lhbCBjb2RlIG5lZWRlZFxuICAgICAgICBbJ1RaSCcsICcnXSxcbiAgICAgICAgWydUWk0nLCAnJ10sXG4gICAgICAgIFsnRkYnLCAnJ10sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTbm93Zmxha2VGb3JtYXRUb01vbWVudEZvcm1hdChmb3JtYXRTcWwsIHNjYWxlKSB7XG4gICAgY29uc3QgdGFncyA9IGZvcm1hdFRhZ3NNYXAoKTtcbiAgICAvLyBnZXQgYW4gdXBwZXItY2FzZSB2ZXJzaW9uIG9mIHRoZSBpbnB1dCBzcWwgZm9ybWF0XG4gICAgY29uc3QgZm9ybWF0U3FsVXBwZXIgPSBmb3JtYXRTcWwudG9VcHBlckNhc2UoKTtcbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGZvcm1hdCBzdHJpbmdcbiAgICBjb25zdCBsZW5ndGggPSBmb3JtYXRTcWwubGVuZ3RoO1xuICAgIGxldCBmb3JtYXRNb21lbnQgPSAnJztcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW5ndGg7KSB7XG4gICAgICAgIGxldCB0YWcgPSBudWxsO1xuICAgICAgICBsZXQgb3V0ID0gbnVsbDtcbiAgICAgICAgLy8gYXQgZWFjaCBwb3NpdGlvbiwgY2hlY2sgaWYgdGhlcmUncyBhIHRhZyBhdCB0aGF0IHBvc2l0aW9uOyBpZiBzbywgdXNlXG4gICAgICAgIC8vICdvdXQnIGFzIHRoZSByZXBsYWNlbWVudFxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFncy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRTcWxVcHBlci5zdWJzdHIocG9zKS5pbmRleE9mKHRhZ3NbaW5kZXhdWzBdKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhZyA9IHRhZ3NbaW5kZXhdWzBdO1xuICAgICAgICAgICAgICAgIG91dCA9IHRhZ3NbaW5kZXhdWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbWF0Y2gsIGp1c3QgaW5zZXJ0IHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgZXNjYXBpbmcgaXRcbiAgICAgICAgLy8gKGJ5IHdyYXBwaW5nIGl0IGluIHNxdWFyZSBicmFja2V0cylcbiAgICAgICAgaWYgKG91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0TW9tZW50ICs9IGZvcm1hdFNxbFtwb3NdO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBmb3VuZCBvbmUgb2Ygb3VyIHNwZWNpYWwgdGFnc1xuICAgICAgICAgICAgaWYgKG91dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnVFpIJykge1xuICAgICAgICAgICAgICAgICAgICBvdXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ0ZGJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAnRkYnIGlzIGZvbGxvd2VkIGJ5IGEgZGlnaXQsIHVzZSB0aGUgZGlnaXQgYXMgdGhlIHNjYWxlXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0YWcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZm9ybWF0U3FsW3BvcyArIHRhZy5sZW5ndGhdLm1hdGNoKC9bMC05XS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdCA9IG1hdGNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKzsgLy8gc2tpcCB0aGUgZGlnaXQgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIG5lZWQgdG8gaW5jbHVkZSBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl2aWRlIHRoZSBuYW5vU2Vjb25kcyB0byBnZXQgdGhlIHJlcXVlc3RlZCBudW1iZXIgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZGlnaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IG5ldyBBcnJheSg5KS5qb2luKCdTJykuc3Vic3RyKC1zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBlbmQgdGhlICdvdXQnIHRleHQgdG8gdGhlIG1vbWVudCBmb3JtYXQgYW5kIHVwZGF0ZSB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgIGZvcm1hdE1vbWVudCArPSBvdXQ7XG4gICAgICAgICAgICBwb3MgKz0gdGFnLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TW9tZW50O1xufVxubW9kdWxlLmV4cG9ydHMuZm9ybWF0VGFnc01hcCA9IGZvcm1hdFRhZ3NNYXA7XG5tb2R1bGUuZXhwb3J0cy5jb252ZXJ0U25vd2ZsYWtlRm9ybWF0VG9Nb21lbnRGb3JtYXQgPSBjb252ZXJ0U25vd2ZsYWtlRm9ybWF0VG9Nb21lbnRGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRldGltZV9mb3JtYXRfY29udmVydGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction DoublyLinkedList() {\n    this._length = 0;\n    this._head = null;\n    this._tail = null;\n}\n/**\n * Returns the length of the list.\n *\n * @returns {number}\n */\nDoublyLinkedList.prototype.getLength = function () {\n    return this._length;\n};\n/**\n * Returns the first element in the list.\n *\n * @returns {Object}\n */\nDoublyLinkedList.prototype.getHead = function () {\n    return this._head;\n};\n/**\n * Returns the last element in the list.\n *\n * @returns {Object}\n */\nDoublyLinkedList.prototype.getTail = function () {\n    return this._tail;\n};\n/**\n * Inserts a value at the end of the list.\n *\n * @param value\n *\n * @returns {Object} the node that was inserted into the list.\n */\nDoublyLinkedList.prototype.insertEnd = function (value) {\n    // create a node from the specified value\n    const node = new Node(value, null, null);\n    // if there are no element in the list yet\n    if (this._length === 0) {\n        this._head = node;\n        this._tail = node;\n    }\n    else {\n        // add the node to the end\n        this._tail.setNext(node);\n        node.setPrev(this._tail);\n        this._tail = node;\n    }\n    // increment the length\n    this._length++;\n    // return the node that was created\n    return node;\n};\n/**\n * Removes a given node from the list.\n *\n * @param node\n */\nDoublyLinkedList.prototype.remove = function (node) {\n    // if no node was specified, we have nothing to do\n    if (!node) {\n        return;\n    }\n    // if we're removing the first element in the list, adjust the head,\n    // otherwise connect the node's previous to its next\n    if (node.getPrev() === null) {\n        this._head = node.getNext();\n    }\n    else {\n        node.getPrev().setNext(node.getNext());\n    }\n    // if we're removing the last element in the list, adjust the tail,\n    // otherwise connect the node's next to its previous\n    if (node.getNext() === null) {\n        this._tail = node.getPrev();\n    }\n    else {\n        node.getNext().setPrev(node.getPrev());\n    }\n    // decrement the length\n    this._length--;\n};\nfunction Node(value, prev, next) {\n    this._value = value;\n    this._prev = prev;\n    this._next = next;\n}\nNode.prototype.getValue = function () {\n    return this._value;\n};\nNode.prototype.getPrev = function () {\n    return this._prev;\n};\nNode.prototype.setPrev = function (prev) {\n    this._prev = prev;\n};\nNode.prototype.getNext = function () {\n    return this._next;\n};\nNode.prototype.setNext = function (next) {\n    this._next = next;\n};\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=doubly_linked_list.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kb3VibHlfbGlua2VkX2xpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kb3VibHlfbGlua2VkX2xpc3QuanM/ZWQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIERvdWJseUxpbmtlZExpc3QoKSB7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICB0aGlzLl90YWlsID0gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaXN0LlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkRvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbkRvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmdldFRhaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XG59O1xuLyoqXG4gKiBJbnNlcnRzIGEgdmFsdWUgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgbm9kZSB0aGF0IHdhcyBpbnNlcnRlZCBpbnRvIHRoZSBsaXN0LlxuICovXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5pbnNlcnRFbmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBjcmVhdGUgYSBub2RlIGZyb20gdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbnVsbCk7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnQgaW4gdGhlIGxpc3QgeWV0XG4gICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9oZWFkID0gbm9kZTtcbiAgICAgICAgdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhZGQgdGhlIG5vZGUgdG8gdGhlIGVuZFxuICAgICAgICB0aGlzLl90YWlsLnNldE5leHQobm9kZSk7XG4gICAgICAgIG5vZGUuc2V0UHJldih0aGlzLl90YWlsKTtcbiAgICAgICAgdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgfVxuICAgIC8vIGluY3JlbWVudCB0aGUgbGVuZ3RoXG4gICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgLy8gcmV0dXJuIHRoZSBub2RlIHRoYXQgd2FzIGNyZWF0ZWRcbiAgICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIFJlbW92ZXMgYSBnaXZlbiBub2RlIGZyb20gdGhlIGxpc3QuXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqL1xuRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBpZiBubyBub2RlIHdhcyBzcGVjaWZpZWQsIHdlIGhhdmUgbm90aGluZyB0byBkb1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIHdlJ3JlIHJlbW92aW5nIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBsaXN0LCBhZGp1c3QgdGhlIGhlYWQsXG4gICAgLy8gb3RoZXJ3aXNlIGNvbm5lY3QgdGhlIG5vZGUncyBwcmV2aW91cyB0byBpdHMgbmV4dFxuICAgIGlmIChub2RlLmdldFByZXYoKSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9oZWFkID0gbm9kZS5nZXROZXh0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLmdldFByZXYoKS5zZXROZXh0KG5vZGUuZ2V0TmV4dCgpKTtcbiAgICB9XG4gICAgLy8gaWYgd2UncmUgcmVtb3ZpbmcgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgbGlzdCwgYWRqdXN0IHRoZSB0YWlsLFxuICAgIC8vIG90aGVyd2lzZSBjb25uZWN0IHRoZSBub2RlJ3MgbmV4dCB0byBpdHMgcHJldmlvdXNcbiAgICBpZiAobm9kZS5nZXROZXh0KCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdGFpbCA9IG5vZGUuZ2V0UHJldigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5nZXROZXh0KCkuc2V0UHJldihub2RlLmdldFByZXYoKSk7XG4gICAgfVxuICAgIC8vIGRlY3JlbWVudCB0aGUgbGVuZ3RoXG4gICAgdGhpcy5fbGVuZ3RoLS07XG59O1xuZnVuY3Rpb24gTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCkge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fcHJldiA9IHByZXY7XG4gICAgdGhpcy5fbmV4dCA9IG5leHQ7XG59XG5Ob2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG59O1xuTm9kZS5wcm90b3R5cGUuZ2V0UHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldjtcbn07XG5Ob2RlLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24gKHByZXYpIHtcbiAgICB0aGlzLl9wcmV2ID0gcHJldjtcbn07XG5Ob2RlLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXh0O1xufTtcbk5vZGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gRG91Ymx5TGlua2VkTGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvdWJseV9saW5rZWRfbGlzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/result.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst Chunk = __webpack_require__(/*! ./chunk */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js\");\nconst ResultStream = __webpack_require__(/*! ./result_stream */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js\");\nconst ChunkCache = __webpack_require__(/*! ./chunk_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js\");\nconst Column = __webpack_require__(/*! ./column */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/column.js\");\nconst StatementType = __webpack_require__(/*! ./statement_type */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js\");\nconst ColumnNamesCreator = __webpack_require__(/*! ./unique_column_name_creator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js\");\nconst RowMode = __webpack_require__(/*! ../../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\nconst Logger = (__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst ExecutionTimer = __webpack_require__(/*! ../../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\n/**\n * Creates a new Result.\n *\n * @param {Object} options\n * @constructor\n */\nfunction Result(options) {\n    let chunkHeaders;\n    let length;\n    let index;\n    let parameter;\n    let mapColumnNameToIndices;\n    let columns;\n    let column;\n    let version;\n    // assert that options is a valid object that contains a response, statement,\n    // services and connection config\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isObject(options.response));\n    Errors.assertInternal(Util.isObject(options.statement));\n    Errors.assertInternal(Util.isObject(options.services));\n    Errors.assertInternal(Util.isObject(options.connectionConfig));\n    // save the statement, services and connection config\n    this._statement = options.statement;\n    this._services = options.services;\n    this._connectionConfig = options.connectionConfig;\n    const data = options.response.data;\n    this._queryId = data.queryId;\n    this._version = version = String(data.version); // don't rely on the version being a number\n    this._returnedRows = data.returned;\n    this._totalRows = data.total;\n    this._statementTypeId = data.statementTypeId;\n    this._queryContext = data.queryContext;\n    // if no chunk headers were specified, but a query-result-master-key (qrmk)\n    // was specified, build the chunk headers from the qrmk\n    chunkHeaders = data.chunkHeaders;\n    if (!Util.isObject(chunkHeaders) && Util.isString(data.qrmk)) {\n        chunkHeaders = {\n            'x-amz-server-side-encryption-customer-algorithm': 'AES256',\n            'x-amz-server-side-encryption-customer-key': data.qrmk,\n        };\n    }\n    this._chunkHeaders = chunkHeaders;\n    // build a session state object from the response data; this can be used to\n    // get the values of the current role, current warehouse, current database,\n    // etc.\n    this._sessionState = createSessionState(data);\n    // convert the parameters array to a map\n    const parametersMap = {};\n    const parametersArray = data.parameters || [];\n    for (index = 0, length = parametersArray.length; index < length; index++) {\n        parameter = parametersArray[index];\n        parametersMap[parameter.name] = parameter.value;\n    }\n    // save the parameters array\n    this._parametersArray = parametersArray;\n    // TODO: add timezone related information to columns\n    // create columns from the rowtype array returned in the result\n    const rowtype = data.rowtype;\n    const numColumns = rowtype.length;\n    this._columns = columns = new Array(numColumns);\n    // convert the rowtype array to an array of columns and build an inverted\n    // index map in which the keys are the column names and the values are the\n    // indices of the columns with the corresponding names\n    this._mapColumnNameToIndices = mapColumnNameToIndices = {};\n    const rowMode = options.rowMode;\n    if (rowMode === RowMode.OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS) {\n        ColumnNamesCreator.addOverridenNamesForDuplicatedColumns(rowtype);\n    }\n    Logger().trace(`Mapping columns in resultset (total: ${numColumns})`);\n    for (let index = 0; index < numColumns; index++) {\n        // create a new column and add it to the columns array\n        columns[index] = column = new Column(rowtype[index], index, parametersMap, version);\n        // if we don't already have an index array for a column with this name,\n        // create a new one, otherwise just append to the existing array of indices\n        mapColumnNameToIndices[column.getName()] = mapColumnNameToIndices[column.getName()] || [];\n        mapColumnNameToIndices[column.getName()].push(index);\n    }\n    Logger().trace('Finished mapping columns.');\n    // create chunks\n    //TODO SNOW-2090883 chunks or rowset should verified on containing data\n    this._chunks = createChunks(data.chunks, data.rowset, this._columns, this._mapColumnNameToIndices, this._chunkHeaders, parametersMap, this._version, this._statement, this._services);\n    this.getQueryContext = function () {\n        return this._queryContext;\n    };\n    /* Disable the ChunkCache until the implementation is complete.\n     *\n     *   // create a chunk cache and save a reference to it in case we need to\n     *   // TODO: should we be clearing the cache at some point, e.g. when the result\n     *   // is destroyed?\n     *   this._chunkCache = createChunkCache(\n     *   this._chunks,\n     *   this._connectionConfig.getResultChunkCacheSize());\n     */\n}\nUtil.inherits(Result, EventEmitter);\n/**\n * Refreshes the result by updating the chunk urls.\n *\n * @param response\n */\nResult.prototype.refresh = function (response) {\n    const chunks = this._chunks;\n    const chunkCfgs = response.data.chunks;\n    for (let index = 0, length = chunks.length; index < length; index++) {\n        chunks[index].setUrl(chunkCfgs[index].url);\n    }\n};\n/**\n * TODO\n *\n * @param chunks\n * @param capacity\n *\n * @returns {ChunkCache}\n */\n// eslint-disable-next-line no-unused-vars\nfunction createChunkCache(chunks, capacity) {\n    let index;\n    let length;\n    // create a chunk cache\n    const chunkCache = new ChunkCache(capacity);\n    // every time a chunk is loaded, add it to the cache\n    // TODO: should the caching be based on most recently 'used' or most recently\n    // 'loaded'?\n    const onLoadComplete = function (err, chunk) {\n        if (!err) {\n            chunkCache.put(chunk);\n        }\n    };\n    // subscribe to the 'loadcomplete' event on all the chunks\n    for (index = 0, length = chunks.length; index < length; index++) {\n        chunks[index].on('loadcomplete', onLoadComplete);\n    }\n    // TODO: do we need to unsubscribe from the loadcomplete event at some point?\n    return chunkCache;\n}\n/**\n * Creates a session state object from the values of the current role, current\n * warehouse, etc., returned in the result response.\n *\n * @param responseData\n *\n * @returns {Object}\n */\nfunction createSessionState(responseData) {\n    const currentRole = responseData.finalRoleName;\n    const currentWarehouse = responseData.finalWarehouseName;\n    const currentDatabaseProvider = responseData.databaseProvider;\n    const currentDatabase = responseData.finalDatabaseName;\n    const currentSchema = responseData.finalSchemaName;\n    return {\n        getCurrentRole: function () {\n            return currentRole;\n        },\n        getCurrentWarehouse: function () {\n            return currentWarehouse;\n        },\n        getCurrentDatabaseProvider: function () {\n            return currentDatabaseProvider;\n        },\n        getCurrentDatabase: function () {\n            return currentDatabase;\n        },\n        getCurrentSchema: function () {\n            return currentSchema;\n        },\n    };\n}\n/**\n * Creates an array of Chunk instances from the chunk-related information in the\n * result response.\n *\n * @param chunkCfgs\n * @param rowset\n * @param columns\n * @param mapColumnNameToIndices\n * @param chunkHeaders\n * @param statementParameters\n * @param resultVersion\n * @param statement\n * @param services\n *\n * @returns {Chunk}\n */\nfunction createChunks(chunkCfgs, rowset, columns, mapColumnNameToIndices, chunkHeaders, statementParameters, resultVersion, statement, services) {\n    let startIndex;\n    let index;\n    let chunkCfg;\n    // if we don't have any chunks, or if some records were returned inline,\n    // fabricate a config object for the first chunk\n    chunkCfgs = chunkCfgs || [];\n    if (!chunkCfgs || rowset.length > 0) {\n        chunkCfgs.unshift({\n            rowCount: rowset.length,\n            url: null,\n            rowset: rowset,\n        });\n    }\n    const chunks = new Array(chunkCfgs.length);\n    Logger().trace(`Downloading ${chunkCfgs.length} chunks`);\n    // loop over the chunk config objects and build Chunk instances out of them\n    startIndex = 0;\n    const length = chunkCfgs.length;\n    for (index = 0; index < length; index++) {\n        chunkCfg = chunkCfgs[index];\n        // augment the chunk config object with additional information\n        chunkCfg.statement = statement;\n        chunkCfg.services = services;\n        chunkCfg.startIndex = startIndex;\n        chunkCfg.columns = columns;\n        chunkCfg.mapColumnNameToIndices = mapColumnNameToIndices;\n        chunkCfg.chunkHeaders = chunkHeaders;\n        chunkCfg.statementParameters = statementParameters;\n        chunkCfg.resultVersion = resultVersion;\n        // increment the start index for the next chunk\n        startIndex += chunkCfg.rowCount;\n        // create a new Chunk from the config object, and add it to the chunks array\n        chunks[index] = new Chunk(chunkCfg);\n    }\n    return chunks;\n}\n/**\n * Returns the chunks in this result that overlap with a specified window.\n *\n * @param {Number} start the start index of the window.\n * @param {Number} end the end index of the window.\n *\n * @returns {Chunk[]}\n */\nResult.prototype.findOverlappingChunks = function (start, end) {\n    return findOverlappingChunks(this._chunks, start, end);\n};\n/**\n * Fetches the rows from the result.\n *\n * @param {Object} options\n *\n * @returns {EventEmitter}\n */\nResult.prototype.fetchRows = function (options) {\n    // validate options\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isFunction(options.each));\n    // if no value was specified for the start index or if the specified start\n    // index is negative, default to 0, otherwise truncate the fractional part\n    let start = options.startIndex;\n    start = !Util.isNumber(start) || start < 0 ? 0 : Math.floor(start);\n    // if no value was specified for the end index or if the end index is larger\n    // than the row index of the last row, default to the index of the last row,\n    // otherwise truncate the fractional part\n    const returnedRows = this.getReturnedRows();\n    let end = options.endIndex;\n    end = !Util.isNumber(end) || end >= returnedRows ? returnedRows - 1 : Math.floor(end);\n    // create an EventEmitter that will be returned to the\n    // caller to track progress of the fetch-rows operation\n    const operation = new EventEmitter();\n    // define a function to asynchronously complete the operation\n    const asyncComplete = function (err, continueCallback) {\n        process.nextTick(function () {\n            operation.emit('complete', err, continueCallback);\n        });\n    };\n    // if the start index is greater than the end index, asynchronously\n    // complete the operation and return the operation\n    if (start > end) {\n        // the operation is now complete\n        asyncComplete();\n        return operation;\n    }\n    const connectionConfig = this._connectionConfig;\n    // create a context object to store the state of the operation; we could store\n    // the state in the operation itself, but it would be good to keep this state\n    // private\n    const context = {\n        maxNumRowsToProcess: end - start + 1,\n        numRowsProcessed: 0,\n        rowBatchSize: connectionConfig.getResultProcessingBatchSize(),\n        rowBatchDuration: connectionConfig.getResultProcessingBatchDuration(),\n    };\n    // identify the chunks needed to get the requested rows, and create a stream\n    // to read their contents\n    const resultStream = new ResultStream({\n        chunks: findOverlappingChunks(this._chunks, start, end),\n        prefetchSize: connectionConfig.getResultPrefetch(),\n    });\n    // subscribe to the stream's 'close' event\n    resultStream.on('close', function (err, continueCallback) {\n        // the operation is now complete\n        asyncComplete(err, continueCallback);\n    });\n    // subscribe to the stream's 'data' event\n    resultStream.on('data', function (chunk) {\n        // start processing the chunk rows\n        processChunk(chunk);\n    });\n    /**\n     * Processes the rows in a given chunk.\n     *\n     * @param {Object} chunk\n     */\n    const processChunk = function (chunk) {\n        // get all the rows in the current chunk that overlap with the requested\n        // window\n        Logger().debug(`Start Processing chunks`);\n        const timer = new ExecutionTimer().start();\n        const chunkStart = chunk.getStartIndex();\n        const chunkEnd = chunk.getEndIndex();\n        const rows = chunk\n            .getRows()\n            .slice(Math.max(chunkStart, start) - chunkStart, Math.min(chunkEnd, end) + 1 - chunkStart);\n        let rowIndex = 0;\n        const rowsLength = rows.length;\n        // create a function that can be called to batch-process rows\n        const processRows = function () {\n            // get the start position and start time\n            const startIndex = rowIndex;\n            const startTime = Date.now();\n            const each = options.each;\n            let stoppedProcessingRows;\n            while (rowIndex < rowsLength) {\n                // invoke the each() callback on the current row\n                const ret = each(rows[rowIndex++]);\n                context.numRowsProcessed++;\n                // if the callback returned false, stop processing rows\n                if (ret === false) {\n                    stoppedProcessingRows = true;\n                    break;\n                }\n                // use the current position and current time to check if we've been\n                // processing rows for too long; if so, leave the rest for the next\n                // tick of the event loop\n                if (rowIndex - startIndex >= context.rowBatchSize &&\n                    Date.now() - startTime > context.rowBatchDuration) {\n                    process.nextTick(processRows);\n                    break;\n                }\n            }\n            // if there are no more rows for us to process in this chunk\n            if (!(rowIndex < rowsLength) || stoppedProcessingRows) {\n                // if we exhausted all the rows in this chunk and we haven't yet\n                // processed all the rows we want to process, ask the result stream to\n                // do another read\n                if (!(rowIndex < rowsLength) && context.numRowsProcessed !== context.maxNumRowsToProcess) {\n                    resultStream.read();\n                }\n                else {\n                    // we've either processed all the rows we wanted to process or we\n                    // were told to stop processing rows by the each() callback; either\n                    // way, close the result stream to complete the operation\n                    resultStream.asyncClose();\n                }\n            }\n        };\n        // start processing rows\n        processRows();\n        timer.stop();\n        Logger().debug(`Finished processing Chunks: Processed ${rowsLength} rows in ${timer.getDuration()} ms`);\n    };\n    // start reading from the stream in the next tick of the event loop\n    process.nextTick(function () {\n        resultStream.read();\n    });\n    return operation;\n};\n/**\n * Given a sorted array of chunks, returns a sub-array that overlaps with a\n * specified window.\n *\n * @param chunks\n * @param windowStart\n * @param windowEnd\n *\n * @returns {Array}\n */\nfunction findOverlappingChunks(chunks, windowStart, windowEnd) {\n    const overlappingChunks = [];\n    if (chunks.length !== 0) {\n        // get the index of the first chunk that overlaps with the specified window\n        let index = findFirstOverlappingChunk(chunks, windowStart, windowEnd);\n        // iterate over the chunks starting with the first overlapping chunk and\n        // keep going until there's no overlap\n        for (let length = chunks.length; index < length; index++) {\n            const chunk = chunks[index];\n            if (chunk.overlapsWithWindow(windowStart, windowEnd)) {\n                overlappingChunks.push(chunk);\n            }\n            else {\n                // no future chunks will overlap because the chunks array is sorted\n                break;\n            }\n        }\n    }\n    return overlappingChunks;\n}\n/**\n * Given a sorted array of chunks, returns the index of the first chunk in the\n * array that overlaps with a specified window.\n *\n * @param chunks\n * @param windowStartIndex\n * @param windowEndIndex\n *\n * @returns {number}\n */\nfunction findFirstOverlappingChunk(chunks, windowStartIndex, windowEndIndex) {\n    const helper = function (chunks, chunkIndexLeft, chunkIndexRight, windowStartIndex, windowEndIndex) {\n        let result;\n        let middleChunkEndIndex;\n        // initialize the return value to -1\n        result = -1;\n        // compute the index of the middle chunk and get the middle chunk\n        const chunkIndexMiddle = Math.floor((chunkIndexLeft + chunkIndexRight) / 2);\n        const middleChunk = chunks[chunkIndexMiddle];\n        // if we have two or fewer chunks\n        if (chunkIndexMiddle === chunkIndexLeft || chunkIndexMiddle === chunkIndexRight) {\n            // if we have just one chunk, and it overlaps with the specified window,\n            // we've found the chunk we were looking for\n            if (chunkIndexLeft === chunkIndexRight) {\n                if (middleChunk.overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                    result = chunkIndexLeft;\n                }\n            }\n            else {\n                // we just have two chunks left to check\n                // if the first chunk overlaps with the specified window, that's the\n                // chunk we were looking for\n                if (chunks[chunkIndexLeft].overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                    result = chunkIndexLeft;\n                }\n                else if (chunks[chunkIndexRight].overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                    // otherwise, if the second chunk overlaps with the specified window,\n                    // that's the chunk we were looking for\n                    result = chunkIndexRight;\n                }\n            }\n            return result;\n        }\n        // if the middle chunk does not overlap with the specified window\n        if (!middleChunk.overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n            middleChunkEndIndex = middleChunk.getEndIndex();\n            // if the window is to the right of the middle chunk,\n            // recurse on the right half\n            if (windowStartIndex > middleChunkEndIndex) {\n                return helper(chunks, chunkIndexMiddle, chunkIndexRight, windowStartIndex, windowEndIndex);\n            }\n            else {\n                // recurse on the left half\n                return helper(chunks, chunkIndexLeft, chunkIndexMiddle, windowStartIndex, windowEndIndex);\n            }\n        }\n        else {\n            // if the middle chunk overlaps but the chunk before it does not, the\n            // middle chunk is the one we were looking\n            if (chunkIndexMiddle === 0 ||\n                !chunks[chunkIndexMiddle - 1].overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                return chunkIndexMiddle;\n            }\n            else {\n                // recurse on the left half\n                return helper(chunks, chunkIndexLeft, chunkIndexMiddle, windowStartIndex, windowEndIndex);\n            }\n        }\n    };\n    return helper(chunks, 0, chunks.length - 1, windowStartIndex, windowEndIndex);\n}\n/**\n * Returns the columns in this result.\n *\n * @returns {Object[]}\n */\nResult.prototype.getColumns = function () {\n    return this._columns;\n};\n/**\n * Given a column identifier, returns the corresponding column. The column\n * identifier can be either the column name (String) or the column index\n * (Number). If a column name is specified and there is more than one column\n * with that name, the first column with the specified name will be returned.\n *\n * @param {String | Number} columnIdentifier\n *\n * @returns {Object}\n */\nResult.prototype.getColumn = function (columnIdentifier) {\n    let columnIndex;\n    // if the column identifier is a string, treat it as a column\n    // name and use it to get the index of the specified column\n    if (Util.isString(columnIdentifier)) {\n        // if a valid column name was specified, get the index of the first column\n        // with the specified name\n        if (Object.prototype.hasOwnProperty.call(this._mapColumnNameToIndices, columnIdentifier)) {\n            columnIndex = this._mapColumnNameToIndices[columnIdentifier][0];\n        }\n    }\n    else if (Util.isNumber(columnIdentifier)) {\n        // if the column identifier is a number, treat it as a column index\n        columnIndex = columnIdentifier;\n    }\n    return this._columns[columnIndex];\n};\n/**\n * Returns the statement id generated by the server for the statement that\n * produced this result.\n *\n * Should use getQueryId instead.\n * @deprecated\n * @returns {string}\n */\nResult.prototype.getStatementId = function () {\n    return this._queryId;\n};\n/**\n * Returns the query id generated by the server for the statement that\n * produced this result.\n *\n * @returns {string}\n */\nResult.prototype.getQueryId = function () {\n    return this._queryId;\n};\n/**\n * Returns the number of rows in this result.\n *\n * @returns {number}\n */\nResult.prototype.getReturnedRows = function () {\n    return this._returnedRows;\n};\n/**\n * Returns the number of rows updated by the statement that produced this\n * result. If the statement isn't a DML, we return -1.\n *\n * @returns {Number}\n */\nResult.prototype.getNumUpdatedRows = function () {\n    // initialize if necessary\n    if (!this._numUpdatedRows) {\n        let numUpdatedRows = -1;\n        // the updated-rows metric only applies to dml's\n        const statementTypeId = this._statementTypeId;\n        if (StatementType.isDml(statementTypeId)) {\n            if (StatementType.isInsert(statementTypeId) ||\n                StatementType.isUpdate(statementTypeId) ||\n                StatementType.isDelete(statementTypeId) ||\n                StatementType.isMerge(statementTypeId) ||\n                StatementType.isMultiTableInsert(statementTypeId)) {\n                const chunks = this._chunks;\n                const columns = this._columns;\n                // if the statement is a dml, the result should be small,\n                // meaning we only have one chunk\n                Errors.assertInternal(Util.isArray(chunks) && chunks.length === 1);\n                // add up the values in all the columns\n                numUpdatedRows = 0;\n                const rows = chunks[0].getRows();\n                for (let rowIndex = 0, rowsLength = rows.length; rowIndex < rowsLength; rowIndex++) {\n                    const row = rows[rowIndex];\n                    for (let colIndex = 0, colsLength = columns.length; colIndex < colsLength; colIndex++) {\n                        numUpdatedRows += Number(row.getColumnValue(columns[colIndex].getId()));\n                    }\n                }\n            }\n            // TODO: handle 'copy' and 'unload'\n        }\n        this._numUpdatedRows = numUpdatedRows;\n    }\n    return this._numUpdatedRows;\n};\n/**\n * Returns the number of rows we would have had in this result if the value of\n * the ROWS_PER_RESULTSET parameter was 0 at the time this statement was\n * executed.\n *\n * @returns {number}\n */\nResult.prototype.getTotalRows = function () {\n    return this._totalRows;\n};\n/**\n * Returns the parameters associated with this result. These parameters contain\n * directives about how to consume and present the result.\n *\n * @returns {Object[]}\n */\nResult.prototype.getParametersArray = function () {\n    return this._parametersArray;\n};\n/**\n * Returns an object that contains information about the values of the current\n * warehouse, current database, and any other session-related state when the\n * statement that produced this result finished executing.\n *\n * @returns {Object}\n */\nResult.prototype.getSessionState = function () {\n    return this._sessionState;\n};\n/**\n * Returns the version associated with this result.\n *\n * @returns {string}\n */\nResult.prototype.getVersion = function () {\n    return this._version;\n};\nmodule.exports = Result;\n//# sourceMappingURL=result.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9yZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxQkFBcUIsMERBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyx1RUFBWTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsMkVBQWM7QUFDckMsY0FBYyxtQkFBTyxDQUFDLHVGQUFTO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLHVHQUFpQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBZTtBQUMxQyxlQUFlLG1CQUFPLENBQUMseUZBQVU7QUFDakMsc0JBQXNCLG1CQUFPLENBQUMseUdBQWtCO0FBQ2hELDJCQUEyQixtQkFBTyxDQUFDLGlJQUE4QjtBQUNqRSxnQkFBZ0IsbUJBQU8sQ0FBQyxtR0FBMEI7QUFDbEQsZUFBZSw2R0FBK0I7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsMkdBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZLFVBQVUscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVCQUF1QjtBQUN4RjtBQUNBLHdFQUF3RSx1QkFBdUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9yZXN1bHQvcmVzdWx0LmpzPzFhMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBDaHVuayA9IHJlcXVpcmUoJy4vY2h1bmsnKTtcbmNvbnN0IFJlc3VsdFN0cmVhbSA9IHJlcXVpcmUoJy4vcmVzdWx0X3N0cmVhbScpO1xuY29uc3QgQ2h1bmtDYWNoZSA9IHJlcXVpcmUoJy4vY2h1bmtfY2FjaGUnKTtcbmNvbnN0IENvbHVtbiA9IHJlcXVpcmUoJy4vY29sdW1uJyk7XG5jb25zdCBTdGF0ZW1lbnRUeXBlID0gcmVxdWlyZSgnLi9zdGF0ZW1lbnRfdHlwZScpO1xuY29uc3QgQ29sdW1uTmFtZXNDcmVhdG9yID0gcmVxdWlyZSgnLi91bmlxdWVfY29sdW1uX25hbWVfY3JlYXRvcicpO1xuY29uc3QgUm93TW9kZSA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cy9yb3dfbW9kZScpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vbG9nZ2VyJykuZGVmYXVsdDtcbmNvbnN0IEV4ZWN1dGlvblRpbWVyID0gcmVxdWlyZSgnLi4vLi4vbG9nZ2VyL2V4ZWN1dGlvbl90aW1lcicpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlc3VsdChvcHRpb25zKSB7XG4gICAgbGV0IGNodW5rSGVhZGVycztcbiAgICBsZXQgbGVuZ3RoO1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgcGFyYW1ldGVyO1xuICAgIGxldCBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzO1xuICAgIGxldCBjb2x1bW5zO1xuICAgIGxldCBjb2x1bW47XG4gICAgbGV0IHZlcnNpb247XG4gICAgLy8gYXNzZXJ0IHRoYXQgb3B0aW9ucyBpcyBhIHZhbGlkIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgcmVzcG9uc2UsIHN0YXRlbWVudCxcbiAgICAvLyBzZXJ2aWNlcyBhbmQgY29ubmVjdGlvbiBjb25maWdcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5yZXNwb25zZSkpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMuc3RhdGVtZW50KSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5zZXJ2aWNlcykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMuY29ubmVjdGlvbkNvbmZpZykpO1xuICAgIC8vIHNhdmUgdGhlIHN0YXRlbWVudCwgc2VydmljZXMgYW5kIGNvbm5lY3Rpb24gY29uZmlnXG4gICAgdGhpcy5fc3RhdGVtZW50ID0gb3B0aW9ucy5zdGF0ZW1lbnQ7XG4gICAgdGhpcy5fc2VydmljZXMgPSBvcHRpb25zLnNlcnZpY2VzO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25Db25maWcgPSBvcHRpb25zLmNvbm5lY3Rpb25Db25maWc7XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMucmVzcG9uc2UuZGF0YTtcbiAgICB0aGlzLl9xdWVyeUlkID0gZGF0YS5xdWVyeUlkO1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uID0gU3RyaW5nKGRhdGEudmVyc2lvbik7IC8vIGRvbid0IHJlbHkgb24gdGhlIHZlcnNpb24gYmVpbmcgYSBudW1iZXJcbiAgICB0aGlzLl9yZXR1cm5lZFJvd3MgPSBkYXRhLnJldHVybmVkO1xuICAgIHRoaXMuX3RvdGFsUm93cyA9IGRhdGEudG90YWw7XG4gICAgdGhpcy5fc3RhdGVtZW50VHlwZUlkID0gZGF0YS5zdGF0ZW1lbnRUeXBlSWQ7XG4gICAgdGhpcy5fcXVlcnlDb250ZXh0ID0gZGF0YS5xdWVyeUNvbnRleHQ7XG4gICAgLy8gaWYgbm8gY2h1bmsgaGVhZGVycyB3ZXJlIHNwZWNpZmllZCwgYnV0IGEgcXVlcnktcmVzdWx0LW1hc3Rlci1rZXkgKHFybWspXG4gICAgLy8gd2FzIHNwZWNpZmllZCwgYnVpbGQgdGhlIGNodW5rIGhlYWRlcnMgZnJvbSB0aGUgcXJta1xuICAgIGNodW5rSGVhZGVycyA9IGRhdGEuY2h1bmtIZWFkZXJzO1xuICAgIGlmICghVXRpbC5pc09iamVjdChjaHVua0hlYWRlcnMpICYmIFV0aWwuaXNTdHJpbmcoZGF0YS5xcm1rKSkge1xuICAgICAgICBjaHVua0hlYWRlcnMgPSB7XG4gICAgICAgICAgICAneC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG0nOiAnQUVTMjU2JyxcbiAgICAgICAgICAgICd4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleSc6IGRhdGEucXJtayxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fY2h1bmtIZWFkZXJzID0gY2h1bmtIZWFkZXJzO1xuICAgIC8vIGJ1aWxkIGEgc2Vzc2lvbiBzdGF0ZSBvYmplY3QgZnJvbSB0aGUgcmVzcG9uc2UgZGF0YTsgdGhpcyBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGdldCB0aGUgdmFsdWVzIG9mIHRoZSBjdXJyZW50IHJvbGUsIGN1cnJlbnQgd2FyZWhvdXNlLCBjdXJyZW50IGRhdGFiYXNlLFxuICAgIC8vIGV0Yy5cbiAgICB0aGlzLl9zZXNzaW9uU3RhdGUgPSBjcmVhdGVTZXNzaW9uU3RhdGUoZGF0YSk7XG4gICAgLy8gY29udmVydCB0aGUgcGFyYW1ldGVycyBhcnJheSB0byBhIG1hcFxuICAgIGNvbnN0IHBhcmFtZXRlcnNNYXAgPSB7fTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzQXJyYXkgPSBkYXRhLnBhcmFtZXRlcnMgfHwgW107XG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHBhcmFtZXRlcnNBcnJheS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlcnNBcnJheVtpbmRleF07XG4gICAgICAgIHBhcmFtZXRlcnNNYXBbcGFyYW1ldGVyLm5hbWVdID0gcGFyYW1ldGVyLnZhbHVlO1xuICAgIH1cbiAgICAvLyBzYXZlIHRoZSBwYXJhbWV0ZXJzIGFycmF5XG4gICAgdGhpcy5fcGFyYW1ldGVyc0FycmF5ID0gcGFyYW1ldGVyc0FycmF5O1xuICAgIC8vIFRPRE86IGFkZCB0aW1lem9uZSByZWxhdGVkIGluZm9ybWF0aW9uIHRvIGNvbHVtbnNcbiAgICAvLyBjcmVhdGUgY29sdW1ucyBmcm9tIHRoZSByb3d0eXBlIGFycmF5IHJldHVybmVkIGluIHRoZSByZXN1bHRcbiAgICBjb25zdCByb3d0eXBlID0gZGF0YS5yb3d0eXBlO1xuICAgIGNvbnN0IG51bUNvbHVtbnMgPSByb3d0eXBlLmxlbmd0aDtcbiAgICB0aGlzLl9jb2x1bW5zID0gY29sdW1ucyA9IG5ldyBBcnJheShudW1Db2x1bW5zKTtcbiAgICAvLyBjb252ZXJ0IHRoZSByb3d0eXBlIGFycmF5IHRvIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIGJ1aWxkIGFuIGludmVydGVkXG4gICAgLy8gaW5kZXggbWFwIGluIHdoaWNoIHRoZSBrZXlzIGFyZSB0aGUgY29sdW1uIG5hbWVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGVcbiAgICAvLyBpbmRpY2VzIG9mIHRoZSBjb2x1bW5zIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbmFtZXNcbiAgICB0aGlzLl9tYXBDb2x1bW5OYW1lVG9JbmRpY2VzID0gbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyA9IHt9O1xuICAgIGNvbnN0IHJvd01vZGUgPSBvcHRpb25zLnJvd01vZGU7XG4gICAgaWYgKHJvd01vZGUgPT09IFJvd01vZGUuT0JKRUNUX1dJVEhfUkVOQU1FRF9EVVBMSUNBVEVEX0NPTFVNTlMpIHtcbiAgICAgICAgQ29sdW1uTmFtZXNDcmVhdG9yLmFkZE92ZXJyaWRlbk5hbWVzRm9yRHVwbGljYXRlZENvbHVtbnMocm93dHlwZSk7XG4gICAgfVxuICAgIExvZ2dlcigpLnRyYWNlKGBNYXBwaW5nIGNvbHVtbnMgaW4gcmVzdWx0c2V0ICh0b3RhbDogJHtudW1Db2x1bW5zfSlgKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtQ29sdW1uczsgaW5kZXgrKykge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgY29sdW1uIGFuZCBhZGQgaXQgdG8gdGhlIGNvbHVtbnMgYXJyYXlcbiAgICAgICAgY29sdW1uc1tpbmRleF0gPSBjb2x1bW4gPSBuZXcgQ29sdW1uKHJvd3R5cGVbaW5kZXhdLCBpbmRleCwgcGFyYW1ldGVyc01hcCwgdmVyc2lvbik7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBpbmRleCBhcnJheSBmb3IgYSBjb2x1bW4gd2l0aCB0aGlzIG5hbWUsXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBvbmUsIG90aGVyd2lzZSBqdXN0IGFwcGVuZCB0byB0aGUgZXhpc3RpbmcgYXJyYXkgb2YgaW5kaWNlc1xuICAgICAgICBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzW2NvbHVtbi5nZXROYW1lKCldID0gbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW4uZ2V0TmFtZSgpXSB8fCBbXTtcbiAgICAgICAgbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW4uZ2V0TmFtZSgpXS5wdXNoKGluZGV4KTtcbiAgICB9XG4gICAgTG9nZ2VyKCkudHJhY2UoJ0ZpbmlzaGVkIG1hcHBpbmcgY29sdW1ucy4nKTtcbiAgICAvLyBjcmVhdGUgY2h1bmtzXG4gICAgLy9UT0RPIFNOT1ctMjA5MDg4MyBjaHVua3Mgb3Igcm93c2V0IHNob3VsZCB2ZXJpZmllZCBvbiBjb250YWluaW5nIGRhdGFcbiAgICB0aGlzLl9jaHVua3MgPSBjcmVhdGVDaHVua3MoZGF0YS5jaHVua3MsIGRhdGEucm93c2V0LCB0aGlzLl9jb2x1bW5zLCB0aGlzLl9tYXBDb2x1bW5OYW1lVG9JbmRpY2VzLCB0aGlzLl9jaHVua0hlYWRlcnMsIHBhcmFtZXRlcnNNYXAsIHRoaXMuX3ZlcnNpb24sIHRoaXMuX3N0YXRlbWVudCwgdGhpcy5fc2VydmljZXMpO1xuICAgIHRoaXMuZ2V0UXVlcnlDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlDb250ZXh0O1xuICAgIH07XG4gICAgLyogRGlzYWJsZSB0aGUgQ2h1bmtDYWNoZSB1bnRpbCB0aGUgaW1wbGVtZW50YXRpb24gaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiAgIC8vIGNyZWF0ZSBhIGNodW5rIGNhY2hlIGFuZCBzYXZlIGEgcmVmZXJlbmNlIHRvIGl0IGluIGNhc2Ugd2UgbmVlZCB0b1xuICAgICAqICAgLy8gVE9ETzogc2hvdWxkIHdlIGJlIGNsZWFyaW5nIHRoZSBjYWNoZSBhdCBzb21lIHBvaW50LCBlLmcuIHdoZW4gdGhlIHJlc3VsdFxuICAgICAqICAgLy8gaXMgZGVzdHJveWVkP1xuICAgICAqICAgdGhpcy5fY2h1bmtDYWNoZSA9IGNyZWF0ZUNodW5rQ2FjaGUoXG4gICAgICogICB0aGlzLl9jaHVua3MsXG4gICAgICogICB0aGlzLl9jb25uZWN0aW9uQ29uZmlnLmdldFJlc3VsdENodW5rQ2FjaGVTaXplKCkpO1xuICAgICAqL1xufVxuVXRpbC5pbmhlcml0cyhSZXN1bHQsIEV2ZW50RW1pdHRlcik7XG4vKipcbiAqIFJlZnJlc2hlcyB0aGUgcmVzdWx0IGJ5IHVwZGF0aW5nIHRoZSBjaHVuayB1cmxzLlxuICpcbiAqIEBwYXJhbSByZXNwb25zZVxuICovXG5SZXN1bHQucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBjb25zdCBjaHVua3MgPSB0aGlzLl9jaHVua3M7XG4gICAgY29uc3QgY2h1bmtDZmdzID0gcmVzcG9uc2UuZGF0YS5jaHVua3M7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBjaHVua3MubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjaHVua3NbaW5kZXhdLnNldFVybChjaHVua0NmZ3NbaW5kZXhdLnVybCk7XG4gICAgfVxufTtcbi8qKlxuICogVE9ET1xuICpcbiAqIEBwYXJhbSBjaHVua3NcbiAqIEBwYXJhbSBjYXBhY2l0eVxuICpcbiAqIEByZXR1cm5zIHtDaHVua0NhY2hlfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rQ2FjaGUoY2h1bmtzLCBjYXBhY2l0eSkge1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgbGVuZ3RoO1xuICAgIC8vIGNyZWF0ZSBhIGNodW5rIGNhY2hlXG4gICAgY29uc3QgY2h1bmtDYWNoZSA9IG5ldyBDaHVua0NhY2hlKGNhcGFjaXR5KTtcbiAgICAvLyBldmVyeSB0aW1lIGEgY2h1bmsgaXMgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGNhY2hlXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoZSBjYWNoaW5nIGJlIGJhc2VkIG9uIG1vc3QgcmVjZW50bHkgJ3VzZWQnIG9yIG1vc3QgcmVjZW50bHlcbiAgICAvLyAnbG9hZGVkJz9cbiAgICBjb25zdCBvbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGNodW5rKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICBjaHVua0NhY2hlLnB1dChjaHVuayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHN1YnNjcmliZSB0byB0aGUgJ2xvYWRjb21wbGV0ZScgZXZlbnQgb24gYWxsIHRoZSBjaHVua3NcbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gY2h1bmtzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY2h1bmtzW2luZGV4XS5vbignbG9hZGNvbXBsZXRlJywgb25Mb2FkQ29tcGxldGUpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIHVuc3Vic2NyaWJlIGZyb20gdGhlIGxvYWRjb21wbGV0ZSBldmVudCBhdCBzb21lIHBvaW50P1xuICAgIHJldHVybiBjaHVua0NhY2hlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc2Vzc2lvbiBzdGF0ZSBvYmplY3QgZnJvbSB0aGUgdmFsdWVzIG9mIHRoZSBjdXJyZW50IHJvbGUsIGN1cnJlbnRcbiAqIHdhcmVob3VzZSwgZXRjLiwgcmV0dXJuZWQgaW4gdGhlIHJlc3VsdCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2VEYXRhXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2Vzc2lvblN0YXRlKHJlc3BvbnNlRGF0YSkge1xuICAgIGNvbnN0IGN1cnJlbnRSb2xlID0gcmVzcG9uc2VEYXRhLmZpbmFsUm9sZU5hbWU7XG4gICAgY29uc3QgY3VycmVudFdhcmVob3VzZSA9IHJlc3BvbnNlRGF0YS5maW5hbFdhcmVob3VzZU5hbWU7XG4gICAgY29uc3QgY3VycmVudERhdGFiYXNlUHJvdmlkZXIgPSByZXNwb25zZURhdGEuZGF0YWJhc2VQcm92aWRlcjtcbiAgICBjb25zdCBjdXJyZW50RGF0YWJhc2UgPSByZXNwb25zZURhdGEuZmluYWxEYXRhYmFzZU5hbWU7XG4gICAgY29uc3QgY3VycmVudFNjaGVtYSA9IHJlc3BvbnNlRGF0YS5maW5hbFNjaGVtYU5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0Q3VycmVudFJvbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Um9sZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q3VycmVudFdhcmVob3VzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRXYXJlaG91c2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEN1cnJlbnREYXRhYmFzZVByb3ZpZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGFiYXNlUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEN1cnJlbnREYXRhYmFzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRhYmFzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q3VycmVudFNjaGVtYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTY2hlbWE7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBDaHVuayBpbnN0YW5jZXMgZnJvbSB0aGUgY2h1bmstcmVsYXRlZCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIHJlc3VsdCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gY2h1bmtDZmdzXG4gKiBAcGFyYW0gcm93c2V0XG4gKiBAcGFyYW0gY29sdW1uc1xuICogQHBhcmFtIG1hcENvbHVtbk5hbWVUb0luZGljZXNcbiAqIEBwYXJhbSBjaHVua0hlYWRlcnNcbiAqIEBwYXJhbSBzdGF0ZW1lbnRQYXJhbWV0ZXJzXG4gKiBAcGFyYW0gcmVzdWx0VmVyc2lvblxuICogQHBhcmFtIHN0YXRlbWVudFxuICogQHBhcmFtIHNlcnZpY2VzXG4gKlxuICogQHJldHVybnMge0NodW5rfVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaHVua3MoY2h1bmtDZmdzLCByb3dzZXQsIGNvbHVtbnMsIG1hcENvbHVtbk5hbWVUb0luZGljZXMsIGNodW5rSGVhZGVycywgc3RhdGVtZW50UGFyYW1ldGVycywgcmVzdWx0VmVyc2lvbiwgc3RhdGVtZW50LCBzZXJ2aWNlcykge1xuICAgIGxldCBzdGFydEluZGV4O1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgY2h1bmtDZmc7XG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY2h1bmtzLCBvciBpZiBzb21lIHJlY29yZHMgd2VyZSByZXR1cm5lZCBpbmxpbmUsXG4gICAgLy8gZmFicmljYXRlIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGZpcnN0IGNodW5rXG4gICAgY2h1bmtDZmdzID0gY2h1bmtDZmdzIHx8IFtdO1xuICAgIGlmICghY2h1bmtDZmdzIHx8IHJvd3NldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNodW5rQ2Zncy51bnNoaWZ0KHtcbiAgICAgICAgICAgIHJvd0NvdW50OiByb3dzZXQubGVuZ3RoLFxuICAgICAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICAgICAgcm93c2V0OiByb3dzZXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjaHVua3MgPSBuZXcgQXJyYXkoY2h1bmtDZmdzLmxlbmd0aCk7XG4gICAgTG9nZ2VyKCkudHJhY2UoYERvd25sb2FkaW5nICR7Y2h1bmtDZmdzLmxlbmd0aH0gY2h1bmtzYCk7XG4gICAgLy8gbG9vcCBvdmVyIHRoZSBjaHVuayBjb25maWcgb2JqZWN0cyBhbmQgYnVpbGQgQ2h1bmsgaW5zdGFuY2VzIG91dCBvZiB0aGVtXG4gICAgc3RhcnRJbmRleCA9IDA7XG4gICAgY29uc3QgbGVuZ3RoID0gY2h1bmtDZmdzLmxlbmd0aDtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY2h1bmtDZmcgPSBjaHVua0NmZ3NbaW5kZXhdO1xuICAgICAgICAvLyBhdWdtZW50IHRoZSBjaHVuayBjb25maWcgb2JqZWN0IHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICAgICAgICBjaHVua0NmZy5zdGF0ZW1lbnQgPSBzdGF0ZW1lbnQ7XG4gICAgICAgIGNodW5rQ2ZnLnNlcnZpY2VzID0gc2VydmljZXM7XG4gICAgICAgIGNodW5rQ2ZnLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICBjaHVua0NmZy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgY2h1bmtDZmcubWFwQ29sdW1uTmFtZVRvSW5kaWNlcyA9IG1hcENvbHVtbk5hbWVUb0luZGljZXM7XG4gICAgICAgIGNodW5rQ2ZnLmNodW5rSGVhZGVycyA9IGNodW5rSGVhZGVycztcbiAgICAgICAgY2h1bmtDZmcuc3RhdGVtZW50UGFyYW1ldGVycyA9IHN0YXRlbWVudFBhcmFtZXRlcnM7XG4gICAgICAgIGNodW5rQ2ZnLnJlc3VsdFZlcnNpb24gPSByZXN1bHRWZXJzaW9uO1xuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHN0YXJ0IGluZGV4IGZvciB0aGUgbmV4dCBjaHVua1xuICAgICAgICBzdGFydEluZGV4ICs9IGNodW5rQ2ZnLnJvd0NvdW50O1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgQ2h1bmsgZnJvbSB0aGUgY29uZmlnIG9iamVjdCwgYW5kIGFkZCBpdCB0byB0aGUgY2h1bmtzIGFycmF5XG4gICAgICAgIGNodW5rc1tpbmRleF0gPSBuZXcgQ2h1bmsoY2h1bmtDZmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaHVua3MgaW4gdGhpcyByZXN1bHQgdGhhdCBvdmVybGFwIHdpdGggYSBzcGVjaWZpZWQgd2luZG93LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHdpbmRvdy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgdGhlIGVuZCBpbmRleCBvZiB0aGUgd2luZG93LlxuICpcbiAqIEByZXR1cm5zIHtDaHVua1tdfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmZpbmRPdmVybGFwcGluZ0NodW5rcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGZpbmRPdmVybGFwcGluZ0NodW5rcyh0aGlzLl9jaHVua3MsIHN0YXJ0LCBlbmQpO1xufTtcbi8qKlxuICogRmV0Y2hlcyB0aGUgcm93cyBmcm9tIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmZldGNoUm93cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuZWFjaCkpO1xuICAgIC8vIGlmIG5vIHZhbHVlIHdhcyBzcGVjaWZpZWQgZm9yIHRoZSBzdGFydCBpbmRleCBvciBpZiB0aGUgc3BlY2lmaWVkIHN0YXJ0XG4gICAgLy8gaW5kZXggaXMgbmVnYXRpdmUsIGRlZmF1bHQgdG8gMCwgb3RoZXJ3aXNlIHRydW5jYXRlIHRoZSBmcmFjdGlvbmFsIHBhcnRcbiAgICBsZXQgc3RhcnQgPSBvcHRpb25zLnN0YXJ0SW5kZXg7XG4gICAgc3RhcnQgPSAhVXRpbC5pc051bWJlcihzdGFydCkgfHwgc3RhcnQgPCAwID8gMCA6IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgIC8vIGlmIG5vIHZhbHVlIHdhcyBzcGVjaWZpZWQgZm9yIHRoZSBlbmQgaW5kZXggb3IgaWYgdGhlIGVuZCBpbmRleCBpcyBsYXJnZXJcbiAgICAvLyB0aGFuIHRoZSByb3cgaW5kZXggb2YgdGhlIGxhc3Qgcm93LCBkZWZhdWx0IHRvIHRoZSBpbmRleCBvZiB0aGUgbGFzdCByb3csXG4gICAgLy8gb3RoZXJ3aXNlIHRydW5jYXRlIHRoZSBmcmFjdGlvbmFsIHBhcnRcbiAgICBjb25zdCByZXR1cm5lZFJvd3MgPSB0aGlzLmdldFJldHVybmVkUm93cygpO1xuICAgIGxldCBlbmQgPSBvcHRpb25zLmVuZEluZGV4O1xuICAgIGVuZCA9ICFVdGlsLmlzTnVtYmVyKGVuZCkgfHwgZW5kID49IHJldHVybmVkUm93cyA/IHJldHVybmVkUm93cyAtIDEgOiBNYXRoLmZsb29yKGVuZCk7XG4gICAgLy8gY3JlYXRlIGFuIEV2ZW50RW1pdHRlciB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlXG4gICAgLy8gY2FsbGVyIHRvIHRyYWNrIHByb2dyZXNzIG9mIHRoZSBmZXRjaC1yb3dzIG9wZXJhdGlvblxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvLyBkZWZpbmUgYSBmdW5jdGlvbiB0byBhc3luY2hyb25vdXNseSBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uXG4gICAgY29uc3QgYXN5bmNDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGNvbnRpbnVlQ2FsbGJhY2spIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uZW1pdCgnY29tcGxldGUnLCBlcnIsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGlmIHRoZSBzdGFydCBpbmRleCBpcyBncmVhdGVyIHRoYW4gdGhlIGVuZCBpbmRleCwgYXN5bmNocm9ub3VzbHlcbiAgICAvLyBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGFuZCByZXR1cm4gdGhlIG9wZXJhdGlvblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIGlzIG5vdyBjb21wbGV0ZVxuICAgICAgICBhc3luY0NvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSB0aGlzLl9jb25uZWN0aW9uQ29uZmlnO1xuICAgIC8vIGNyZWF0ZSBhIGNvbnRleHQgb2JqZWN0IHRvIHN0b3JlIHRoZSBzdGF0ZSBvZiB0aGUgb3BlcmF0aW9uOyB3ZSBjb3VsZCBzdG9yZVxuICAgIC8vIHRoZSBzdGF0ZSBpbiB0aGUgb3BlcmF0aW9uIGl0c2VsZiwgYnV0IGl0IHdvdWxkIGJlIGdvb2QgdG8ga2VlcCB0aGlzIHN0YXRlXG4gICAgLy8gcHJpdmF0ZVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG1heE51bVJvd3NUb1Byb2Nlc3M6IGVuZCAtIHN0YXJ0ICsgMSxcbiAgICAgICAgbnVtUm93c1Byb2Nlc3NlZDogMCxcbiAgICAgICAgcm93QmF0Y2hTaXplOiBjb25uZWN0aW9uQ29uZmlnLmdldFJlc3VsdFByb2Nlc3NpbmdCYXRjaFNpemUoKSxcbiAgICAgICAgcm93QmF0Y2hEdXJhdGlvbjogY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRQcm9jZXNzaW5nQmF0Y2hEdXJhdGlvbigpLFxuICAgIH07XG4gICAgLy8gaWRlbnRpZnkgdGhlIGNodW5rcyBuZWVkZWQgdG8gZ2V0IHRoZSByZXF1ZXN0ZWQgcm93cywgYW5kIGNyZWF0ZSBhIHN0cmVhbVxuICAgIC8vIHRvIHJlYWQgdGhlaXIgY29udGVudHNcbiAgICBjb25zdCByZXN1bHRTdHJlYW0gPSBuZXcgUmVzdWx0U3RyZWFtKHtcbiAgICAgICAgY2h1bmtzOiBmaW5kT3ZlcmxhcHBpbmdDaHVua3ModGhpcy5fY2h1bmtzLCBzdGFydCwgZW5kKSxcbiAgICAgICAgcHJlZmV0Y2hTaXplOiBjb25uZWN0aW9uQ29uZmlnLmdldFJlc3VsdFByZWZldGNoKCksXG4gICAgfSk7XG4gICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBzdHJlYW0ncyAnY2xvc2UnIGV2ZW50XG4gICAgcmVzdWx0U3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uIChlcnIsIGNvbnRpbnVlQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiBpcyBub3cgY29tcGxldGVcbiAgICAgICAgYXN5bmNDb21wbGV0ZShlcnIsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgIH0pO1xuICAgIC8vIHN1YnNjcmliZSB0byB0aGUgc3RyZWFtJ3MgJ2RhdGEnIGV2ZW50XG4gICAgcmVzdWx0U3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGNodW5rIHJvd3NcbiAgICAgICAgcHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIHJvd3MgaW4gYSBnaXZlbiBjaHVuay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVua1xuICAgICAqL1xuICAgIGNvbnN0IHByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAvLyBnZXQgYWxsIHRoZSByb3dzIGluIHRoZSBjdXJyZW50IGNodW5rIHRoYXQgb3ZlcmxhcCB3aXRoIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgLy8gd2luZG93XG4gICAgICAgIExvZ2dlcigpLmRlYnVnKGBTdGFydCBQcm9jZXNzaW5nIGNodW5rc2ApO1xuICAgICAgICBjb25zdCB0aW1lciA9IG5ldyBFeGVjdXRpb25UaW1lcigpLnN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IGNodW5rU3RhcnQgPSBjaHVuay5nZXRTdGFydEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGNodW5rRW5kID0gY2h1bmsuZ2V0RW5kSW5kZXgoKTtcbiAgICAgICAgY29uc3Qgcm93cyA9IGNodW5rXG4gICAgICAgICAgICAuZ2V0Um93cygpXG4gICAgICAgICAgICAuc2xpY2UoTWF0aC5tYXgoY2h1bmtTdGFydCwgc3RhcnQpIC0gY2h1bmtTdGFydCwgTWF0aC5taW4oY2h1bmtFbmQsIGVuZCkgKyAxIC0gY2h1bmtTdGFydCk7XG4gICAgICAgIGxldCByb3dJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHJvd3NMZW5ndGggPSByb3dzLmxlbmd0aDtcbiAgICAgICAgLy8gY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHRvIGJhdGNoLXByb2Nlc3Mgcm93c1xuICAgICAgICBjb25zdCBwcm9jZXNzUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHN0YXJ0IHRpbWVcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSByb3dJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjb25zdCBlYWNoID0gb3B0aW9ucy5lYWNoO1xuICAgICAgICAgICAgbGV0IHN0b3BwZWRQcm9jZXNzaW5nUm93cztcbiAgICAgICAgICAgIHdoaWxlIChyb3dJbmRleCA8IHJvd3NMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnZva2UgdGhlIGVhY2goKSBjYWxsYmFjayBvbiB0aGUgY3VycmVudCByb3dcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBlYWNoKHJvd3Nbcm93SW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubnVtUm93c1Byb2Nlc3NlZCsrO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjYWxsYmFjayByZXR1cm5lZCBmYWxzZSwgc3RvcCBwcm9jZXNzaW5nIHJvd3NcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkUHJvY2Vzc2luZ1Jvd3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBjdXJyZW50IHRpbWUgdG8gY2hlY2sgaWYgd2UndmUgYmVlblxuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3Npbmcgcm93cyBmb3IgdG9vIGxvbmc7IGlmIHNvLCBsZWF2ZSB0aGUgcmVzdCBmb3IgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyB0aWNrIG9mIHRoZSBldmVudCBsb29wXG4gICAgICAgICAgICAgICAgaWYgKHJvd0luZGV4IC0gc3RhcnRJbmRleCA+PSBjb250ZXh0LnJvd0JhdGNoU2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICBEYXRlLm5vdygpIC0gc3RhcnRUaW1lID4gY29udGV4dC5yb3dCYXRjaER1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socHJvY2Vzc1Jvd3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSByb3dzIGZvciB1cyB0byBwcm9jZXNzIGluIHRoaXMgY2h1bmtcbiAgICAgICAgICAgIGlmICghKHJvd0luZGV4IDwgcm93c0xlbmd0aCkgfHwgc3RvcHBlZFByb2Nlc3NpbmdSb3dzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZXhoYXVzdGVkIGFsbCB0aGUgcm93cyBpbiB0aGlzIGNodW5rIGFuZCB3ZSBoYXZlbid0IHlldFxuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3NlZCBhbGwgdGhlIHJvd3Mgd2Ugd2FudCB0byBwcm9jZXNzLCBhc2sgdGhlIHJlc3VsdCBzdHJlYW0gdG9cbiAgICAgICAgICAgICAgICAvLyBkbyBhbm90aGVyIHJlYWRcbiAgICAgICAgICAgICAgICBpZiAoIShyb3dJbmRleCA8IHJvd3NMZW5ndGgpICYmIGNvbnRleHQubnVtUm93c1Byb2Nlc3NlZCAhPT0gY29udGV4dC5tYXhOdW1Sb3dzVG9Qcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmVhbS5yZWFkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBlaXRoZXIgcHJvY2Vzc2VkIGFsbCB0aGUgcm93cyB3ZSB3YW50ZWQgdG8gcHJvY2VzcyBvciB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZXJlIHRvbGQgdG8gc3RvcCBwcm9jZXNzaW5nIHJvd3MgYnkgdGhlIGVhY2goKSBjYWxsYmFjazsgZWl0aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdheSwgY2xvc2UgdGhlIHJlc3VsdCBzdHJlYW0gdG8gY29tcGxldGUgdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJlYW0uYXN5bmNDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyByb3dzXG4gICAgICAgIHByb2Nlc3NSb3dzKCk7XG4gICAgICAgIHRpbWVyLnN0b3AoKTtcbiAgICAgICAgTG9nZ2VyKCkuZGVidWcoYEZpbmlzaGVkIHByb2Nlc3NpbmcgQ2h1bmtzOiBQcm9jZXNzZWQgJHtyb3dzTGVuZ3RofSByb3dzIGluICR7dGltZXIuZ2V0RHVyYXRpb24oKX0gbXNgKTtcbiAgICB9O1xuICAgIC8vIHN0YXJ0IHJlYWRpbmcgZnJvbSB0aGUgc3RyZWFtIGluIHRoZSBuZXh0IHRpY2sgb2YgdGhlIGV2ZW50IGxvb3BcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdWx0U3RyZWFtLnJlYWQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3BlcmF0aW9uO1xufTtcbi8qKlxuICogR2l2ZW4gYSBzb3J0ZWQgYXJyYXkgb2YgY2h1bmtzLCByZXR1cm5zIGEgc3ViLWFycmF5IHRoYXQgb3ZlcmxhcHMgd2l0aCBhXG4gKiBzcGVjaWZpZWQgd2luZG93LlxuICpcbiAqIEBwYXJhbSBjaHVua3NcbiAqIEBwYXJhbSB3aW5kb3dTdGFydFxuICogQHBhcmFtIHdpbmRvd0VuZFxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmluZE92ZXJsYXBwaW5nQ2h1bmtzKGNodW5rcywgd2luZG93U3RhcnQsIHdpbmRvd0VuZCkge1xuICAgIGNvbnN0IG92ZXJsYXBwaW5nQ2h1bmtzID0gW107XG4gICAgaWYgKGNodW5rcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2h1bmsgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzcGVjaWZpZWQgd2luZG93XG4gICAgICAgIGxldCBpbmRleCA9IGZpbmRGaXJzdE92ZXJsYXBwaW5nQ2h1bmsoY2h1bmtzLCB3aW5kb3dTdGFydCwgd2luZG93RW5kKTtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBjaHVua3Mgc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3Qgb3ZlcmxhcHBpbmcgY2h1bmsgYW5kXG4gICAgICAgIC8vIGtlZXAgZ29pbmcgdW50aWwgdGhlcmUncyBubyBvdmVybGFwXG4gICAgICAgIGZvciAobGV0IGxlbmd0aCA9IGNodW5rcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoY2h1bmsub3ZlcmxhcHNXaXRoV2luZG93KHdpbmRvd1N0YXJ0LCB3aW5kb3dFbmQpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdDaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmdXR1cmUgY2h1bmtzIHdpbGwgb3ZlcmxhcCBiZWNhdXNlIHRoZSBjaHVua3MgYXJyYXkgaXMgc29ydGVkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nQ2h1bmtzO1xufVxuLyoqXG4gKiBHaXZlbiBhIHNvcnRlZCBhcnJheSBvZiBjaHVua3MsIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaHVuayBpbiB0aGVcbiAqIGFycmF5IHRoYXQgb3ZlcmxhcHMgd2l0aCBhIHNwZWNpZmllZCB3aW5kb3cuXG4gKlxuICogQHBhcmFtIGNodW5rc1xuICogQHBhcmFtIHdpbmRvd1N0YXJ0SW5kZXhcbiAqIEBwYXJhbSB3aW5kb3dFbmRJbmRleFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRGaXJzdE92ZXJsYXBwaW5nQ2h1bmsoY2h1bmtzLCB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCkge1xuICAgIGNvbnN0IGhlbHBlciA9IGZ1bmN0aW9uIChjaHVua3MsIGNodW5rSW5kZXhMZWZ0LCBjaHVua0luZGV4UmlnaHQsIHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGxldCBtaWRkbGVDaHVua0VuZEluZGV4O1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSByZXR1cm4gdmFsdWUgdG8gLTFcbiAgICAgICAgcmVzdWx0ID0gLTE7XG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIGluZGV4IG9mIHRoZSBtaWRkbGUgY2h1bmsgYW5kIGdldCB0aGUgbWlkZGxlIGNodW5rXG4gICAgICAgIGNvbnN0IGNodW5rSW5kZXhNaWRkbGUgPSBNYXRoLmZsb29yKChjaHVua0luZGV4TGVmdCArIGNodW5rSW5kZXhSaWdodCkgLyAyKTtcbiAgICAgICAgY29uc3QgbWlkZGxlQ2h1bmsgPSBjaHVua3NbY2h1bmtJbmRleE1pZGRsZV07XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgdHdvIG9yIGZld2VyIGNodW5rc1xuICAgICAgICBpZiAoY2h1bmtJbmRleE1pZGRsZSA9PT0gY2h1bmtJbmRleExlZnQgfHwgY2h1bmtJbmRleE1pZGRsZSA9PT0gY2h1bmtJbmRleFJpZ2h0KSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGp1c3Qgb25lIGNodW5rLCBhbmQgaXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIHdpbmRvdyxcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGZvdW5kIHRoZSBjaHVuayB3ZSB3ZXJlIGxvb2tpbmcgZm9yXG4gICAgICAgICAgICBpZiAoY2h1bmtJbmRleExlZnQgPT09IGNodW5rSW5kZXhSaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGVDaHVuay5vdmVybGFwc1dpdGhXaW5kb3cod2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNodW5rSW5kZXhMZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgaGF2ZSB0d28gY2h1bmtzIGxlZnQgdG8gY2hlY2tcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgY2h1bmsgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIHdpbmRvdywgdGhhdCdzIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNodW5rIHdlIHdlcmUgbG9va2luZyBmb3JcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtzW2NodW5rSW5kZXhMZWZ0XS5vdmVybGFwc1dpdGhXaW5kb3cod2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNodW5rSW5kZXhMZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaHVua3NbY2h1bmtJbmRleFJpZ2h0XS5vdmVybGFwc1dpdGhXaW5kb3cod2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgaWYgdGhlIHNlY29uZCBjaHVuayBvdmVybGFwcyB3aXRoIHRoZSBzcGVjaWZpZWQgd2luZG93LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgdGhlIGNodW5rIHdlIHdlcmUgbG9va2luZyBmb3JcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2h1bmtJbmRleFJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG1pZGRsZSBjaHVuayBkb2VzIG5vdCBvdmVybGFwIHdpdGggdGhlIHNwZWNpZmllZCB3aW5kb3dcbiAgICAgICAgaWYgKCFtaWRkbGVDaHVuay5vdmVybGFwc1dpdGhXaW5kb3cod2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpKSB7XG4gICAgICAgICAgICBtaWRkbGVDaHVua0VuZEluZGV4ID0gbWlkZGxlQ2h1bmsuZ2V0RW5kSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB3aW5kb3cgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBtaWRkbGUgY2h1bmssXG4gICAgICAgICAgICAvLyByZWN1cnNlIG9uIHRoZSByaWdodCBoYWxmXG4gICAgICAgICAgICBpZiAod2luZG93U3RhcnRJbmRleCA+IG1pZGRsZUNodW5rRW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGNodW5rcywgY2h1bmtJbmRleE1pZGRsZSwgY2h1bmtJbmRleFJpZ2h0LCB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNlIG9uIHRoZSBsZWZ0IGhhbGZcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGNodW5rcywgY2h1bmtJbmRleExlZnQsIGNodW5rSW5kZXhNaWRkbGUsIHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBtaWRkbGUgY2h1bmsgb3ZlcmxhcHMgYnV0IHRoZSBjaHVuayBiZWZvcmUgaXQgZG9lcyBub3QsIHRoZVxuICAgICAgICAgICAgLy8gbWlkZGxlIGNodW5rIGlzIHRoZSBvbmUgd2Ugd2VyZSBsb29raW5nXG4gICAgICAgICAgICBpZiAoY2h1bmtJbmRleE1pZGRsZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICFjaHVua3NbY2h1bmtJbmRleE1pZGRsZSAtIDFdLm92ZXJsYXBzV2l0aFdpbmRvdyh3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmtJbmRleE1pZGRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2Ugb24gdGhlIGxlZnQgaGFsZlxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXIoY2h1bmtzLCBjaHVua0luZGV4TGVmdCwgY2h1bmtJbmRleE1pZGRsZSwgd2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaGVscGVyKGNodW5rcywgMCwgY2h1bmtzLmxlbmd0aCAtIDEsIHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY29sdW1ucyBpbiB0aGlzIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0W119XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sdW1ucztcbn07XG4vKipcbiAqIEdpdmVuIGEgY29sdW1uIGlkZW50aWZpZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uLiBUaGUgY29sdW1uXG4gKiBpZGVudGlmaWVyIGNhbiBiZSBlaXRoZXIgdGhlIGNvbHVtbiBuYW1lIChTdHJpbmcpIG9yIHRoZSBjb2x1bW4gaW5kZXhcbiAqIChOdW1iZXIpLiBJZiBhIGNvbHVtbiBuYW1lIGlzIHNwZWNpZmllZCBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBjb2x1bW5cbiAqIHdpdGggdGhhdCBuYW1lLCB0aGUgZmlyc3QgY29sdW1uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGNvbHVtbklkZW50aWZpZXJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldENvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW5JZGVudGlmaWVyKSB7XG4gICAgbGV0IGNvbHVtbkluZGV4O1xuICAgIC8vIGlmIHRoZSBjb2x1bW4gaWRlbnRpZmllciBpcyBhIHN0cmluZywgdHJlYXQgaXQgYXMgYSBjb2x1bW5cbiAgICAvLyBuYW1lIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNvbHVtblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgICAgIC8vIGlmIGEgdmFsaWQgY29sdW1uIG5hbWUgd2FzIHNwZWNpZmllZCwgZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY29sdW1uXG4gICAgICAgIC8vIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcywgY29sdW1uSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW5JZGVudGlmaWVyXVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChVdGlsLmlzTnVtYmVyKGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBjb2x1bW4gaWRlbnRpZmllciBpcyBhIG51bWJlciwgdHJlYXQgaXQgYXMgYSBjb2x1bW4gaW5kZXhcbiAgICAgICAgY29sdW1uSW5kZXggPSBjb2x1bW5JZGVudGlmaWVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29sdW1uc1tjb2x1bW5JbmRleF07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGF0ZW1lbnQgaWQgZ2VuZXJhdGVkIGJ5IHRoZSBzZXJ2ZXIgZm9yIHRoZSBzdGF0ZW1lbnQgdGhhdFxuICogcHJvZHVjZWQgdGhpcyByZXN1bHQuXG4gKlxuICogU2hvdWxkIHVzZSBnZXRRdWVyeUlkIGluc3RlYWQuXG4gKiBAZGVwcmVjYXRlZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRTdGF0ZW1lbnRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVlcnlJZDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHF1ZXJ5IGlkIGdlbmVyYXRlZCBieSB0aGUgc2VydmVyIGZvciB0aGUgc3RhdGVtZW50IHRoYXRcbiAqIHByb2R1Y2VkIHRoaXMgcmVzdWx0LlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0UXVlcnlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVlcnlJZDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoaXMgcmVzdWx0LlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0UmV0dXJuZWRSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXR1cm5lZFJvd3M7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkIGJ5IHRoZSBzdGF0ZW1lbnQgdGhhdCBwcm9kdWNlZCB0aGlzXG4gKiByZXN1bHQuIElmIHRoZSBzdGF0ZW1lbnQgaXNuJ3QgYSBETUwsIHdlIHJldHVybiAtMS5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldE51bVVwZGF0ZWRSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGluaXRpYWxpemUgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKCF0aGlzLl9udW1VcGRhdGVkUm93cykge1xuICAgICAgICBsZXQgbnVtVXBkYXRlZFJvd3MgPSAtMTtcbiAgICAgICAgLy8gdGhlIHVwZGF0ZWQtcm93cyBtZXRyaWMgb25seSBhcHBsaWVzIHRvIGRtbCdzXG4gICAgICAgIGNvbnN0IHN0YXRlbWVudFR5cGVJZCA9IHRoaXMuX3N0YXRlbWVudFR5cGVJZDtcbiAgICAgICAgaWYgKFN0YXRlbWVudFR5cGUuaXNEbWwoc3RhdGVtZW50VHlwZUlkKSkge1xuICAgICAgICAgICAgaWYgKFN0YXRlbWVudFR5cGUuaXNJbnNlcnQoc3RhdGVtZW50VHlwZUlkKSB8fFxuICAgICAgICAgICAgICAgIFN0YXRlbWVudFR5cGUuaXNVcGRhdGUoc3RhdGVtZW50VHlwZUlkKSB8fFxuICAgICAgICAgICAgICAgIFN0YXRlbWVudFR5cGUuaXNEZWxldGUoc3RhdGVtZW50VHlwZUlkKSB8fFxuICAgICAgICAgICAgICAgIFN0YXRlbWVudFR5cGUuaXNNZXJnZShzdGF0ZW1lbnRUeXBlSWQpIHx8XG4gICAgICAgICAgICAgICAgU3RhdGVtZW50VHlwZS5pc011bHRpVGFibGVJbnNlcnQoc3RhdGVtZW50VHlwZUlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IHRoaXMuX2NodW5rcztcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5fY29sdW1ucztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdGVtZW50IGlzIGEgZG1sLCB0aGUgcmVzdWx0IHNob3VsZCBiZSBzbWFsbCxcbiAgICAgICAgICAgICAgICAvLyBtZWFuaW5nIHdlIG9ubHkgaGF2ZSBvbmUgY2h1bmtcbiAgICAgICAgICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KGNodW5rcykgJiYgY2h1bmtzLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHVwIHRoZSB2YWx1ZXMgaW4gYWxsIHRoZSBjb2x1bW5zXG4gICAgICAgICAgICAgICAgbnVtVXBkYXRlZFJvd3MgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBjaHVua3NbMF0uZ2V0Um93cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvd0luZGV4ID0gMCwgcm93c0xlbmd0aCA9IHJvd3MubGVuZ3RoOyByb3dJbmRleCA8IHJvd3NMZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gcm93c1tyb3dJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbEluZGV4ID0gMCwgY29sc0xlbmd0aCA9IGNvbHVtbnMubGVuZ3RoOyBjb2xJbmRleCA8IGNvbHNMZW5ndGg7IGNvbEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVVwZGF0ZWRSb3dzICs9IE51bWJlcihyb3cuZ2V0Q29sdW1uVmFsdWUoY29sdW1uc1tjb2xJbmRleF0uZ2V0SWQoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlICdjb3B5JyBhbmQgJ3VubG9hZCdcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9udW1VcGRhdGVkUm93cyA9IG51bVVwZGF0ZWRSb3dzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbnVtVXBkYXRlZFJvd3M7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyB3ZSB3b3VsZCBoYXZlIGhhZCBpbiB0aGlzIHJlc3VsdCBpZiB0aGUgdmFsdWUgb2ZcbiAqIHRoZSBST1dTX1BFUl9SRVNVTFRTRVQgcGFyYW1ldGVyIHdhcyAwIGF0IHRoZSB0aW1lIHRoaXMgc3RhdGVtZW50IHdhc1xuICogZXhlY3V0ZWQuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRUb3RhbFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsUm93cztcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmFtZXRlcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVzdWx0LiBUaGVzZSBwYXJhbWV0ZXJzIGNvbnRhaW5cbiAqIGRpcmVjdGl2ZXMgYWJvdXQgaG93IHRvIGNvbnN1bWUgYW5kIHByZXNlbnQgdGhlIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0W119XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0UGFyYW1ldGVyc0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJzQXJyYXk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2YWx1ZXMgb2YgdGhlIGN1cnJlbnRcbiAqIHdhcmVob3VzZSwgY3VycmVudCBkYXRhYmFzZSwgYW5kIGFueSBvdGhlciBzZXNzaW9uLXJlbGF0ZWQgc3RhdGUgd2hlbiB0aGVcbiAqIHN0YXRlbWVudCB0aGF0IHByb2R1Y2VkIHRoaXMgcmVzdWx0IGZpbmlzaGVkIGV4ZWN1dGluZy5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldFNlc3Npb25TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvblN0YXRlO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdmVyc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXN1bHQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xufTtcbm1vZHVsZS5leHBvcnRzID0gUmVzdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdWx0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n/**\n * Creates a stream-like object that can be used to read the contents of an\n * array of chunks with the ability to prefetch chunks as we go. Every time the\n * contents of a new chunk become available, a 'data' event is fired. When there\n * are no more chunks to read, a 'close' event is fired to indicate that the\n * read operation is complete. If no chunks are specified in the options, the\n * stream asynchronously fires a 'close' event after it is returned.\n *\n * @param {Object} [options] An options object with the following properties:\n *   {Object[]} chunks       - The chunks to read.\n *   {Number}   prefetchSize - The number of chunks to prefetch every time a new\n *     chunk is read.\n *\n * @constructor\n */\nfunction ResultStream(options) {\n    // options should be an object\n    Errors.assertInternal(Util.isObject(options));\n    const chunks = options.chunks;\n    const prefetchSize = options.prefetchSize;\n    // chunks should be an array\n    Errors.assertInternal(Util.isArray(chunks));\n    // prefetch size should be non-negative\n    Errors.assertInternal(Util.isNumber(prefetchSize) && prefetchSize >= 0);\n    // Current chunk being streamed. Start with the first chunk.\n    let currChunk = 0;\n    const self = this;\n    /**\n     * Called when a chunk fires a 'loadcomplete' event.\n     *\n     * @param {Error} err\n     * @param {Chunk} chunk\n     */\n    const onLoadComplete = function (err, chunk) {\n        // unsubscribe from the 'loadcomplete' event\n        chunk.removeListener('loadcomplete', onLoadComplete);\n        // if the chunk load succeeded\n        if (!err) {\n            // Move on to the next chunk\n            currChunk++;\n            // emit an event to signal that new data is available\n            self.emit('data', chunk);\n        }\n        else {\n            // close the stream with an error; also, include a callback when emitting\n            // the event in case someone wants to fix the problem and ask us to\n            // continue from where we got interrupted\n            close(self, err, doLoad);\n        }\n    };\n    /**\n     * Identifies the next chunk to load and issues requests to fetch both its\n     * contents plus the contents of the next few chunks. If there are no more\n     * chunks to load, a 'close' event is fired on the stream to notify\n     * subscribers that all the chunks have been successfully read.\n     */\n    const doLoad = function () {\n        // All chunks were loaded, we're done\n        if (currChunk >= chunks.length) {\n            self.asyncClose();\n        }\n        else {\n            // Subscribe to the loadcomplete event on the current chunk being streamed to ensure the\n            // rows are returned in the correct order and not in the order chunk data are received\n            chunks[currChunk].on('loadcomplete', onLoadComplete);\n            // Fire off requests to load all the chunks in the buffer that aren't already loading\n            let chunk, index;\n            for (index = currChunk; index < chunks.length && index <= currChunk + prefetchSize; index++) {\n                chunk = chunks[index];\n                if (!chunk.isLoading()) {\n                    chunk.load();\n                }\n            }\n        }\n    };\n    /**\n     * Reads the next chunk of data in the result stream.\n     */\n    this.read = function () {\n        // TODO: if there are no more chunks to read, should we raise an error?\n        // TODO: what if we're already in the middle of a read?\n        // read the next chunk\n        doLoad();\n    };\n}\nUtil.inherits(ResultStream, EventEmitter);\n/**\n * Asynchronously closes this stream.\n *\n * @returns {ResultStream}\n */\nResultStream.prototype.asyncClose = function () {\n    // schedule an operation to close the stream in\n    // the next tick of the event loop\n    const self = this;\n    process.nextTick(function () {\n        close(self);\n    });\n    return this;\n};\n/**\n * Closes a given result stream.\n *\n * @param {ResultStream} stream The stream to close.\n * @param {Error} [err] The error, if any, to fire with the close event.\n * @param {Function} [callback] The callback, if any, to fire with the close\n *   event. This is in case someone wants to fix the problem and ask the stream\n *   to resume from the point of interruption.\n */\nfunction close(stream, err, callback) {\n    stream.emit('close', err, callback);\n}\nmodule.exports = ResultStream;\n//# sourceMappingURL=result_stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9yZXN1bHRfc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscUJBQXFCLDBEQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDJFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsTUFBTSxVQUFVO0FBQ2hCLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUE0RDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L3Jlc3VsdF9zdHJlYW0uanM/NzA4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbi8qKlxuICogQ3JlYXRlcyBhIHN0cmVhbS1saWtlIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgdGhlIGNvbnRlbnRzIG9mIGFuXG4gKiBhcnJheSBvZiBjaHVua3Mgd2l0aCB0aGUgYWJpbGl0eSB0byBwcmVmZXRjaCBjaHVua3MgYXMgd2UgZ28uIEV2ZXJ5IHRpbWUgdGhlXG4gKiBjb250ZW50cyBvZiBhIG5ldyBjaHVuayBiZWNvbWUgYXZhaWxhYmxlLCBhICdkYXRhJyBldmVudCBpcyBmaXJlZC4gV2hlbiB0aGVyZVxuICogYXJlIG5vIG1vcmUgY2h1bmtzIHRvIHJlYWQsIGEgJ2Nsb3NlJyBldmVudCBpcyBmaXJlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZVxuICogcmVhZCBvcGVyYXRpb24gaXMgY29tcGxldGUuIElmIG5vIGNodW5rcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zLCB0aGVcbiAqIHN0cmVhbSBhc3luY2hyb25vdXNseSBmaXJlcyBhICdjbG9zZScgZXZlbnQgYWZ0ZXIgaXQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAge09iamVjdFtdfSBjaHVua3MgICAgICAgLSBUaGUgY2h1bmtzIHRvIHJlYWQuXG4gKiAgIHtOdW1iZXJ9ICAgcHJlZmV0Y2hTaXplIC0gVGhlIG51bWJlciBvZiBjaHVua3MgdG8gcHJlZmV0Y2ggZXZlcnkgdGltZSBhIG5ld1xuICogICAgIGNodW5rIGlzIHJlYWQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlc3VsdFN0cmVhbShvcHRpb25zKSB7XG4gICAgLy8gb3B0aW9ucyBzaG91bGQgYmUgYW4gb2JqZWN0XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICAgIGNvbnN0IGNodW5rcyA9IG9wdGlvbnMuY2h1bmtzO1xuICAgIGNvbnN0IHByZWZldGNoU2l6ZSA9IG9wdGlvbnMucHJlZmV0Y2hTaXplO1xuICAgIC8vIGNodW5rcyBzaG91bGQgYmUgYW4gYXJyYXlcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KGNodW5rcykpO1xuICAgIC8vIHByZWZldGNoIHNpemUgc2hvdWxkIGJlIG5vbi1uZWdhdGl2ZVxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzTnVtYmVyKHByZWZldGNoU2l6ZSkgJiYgcHJlZmV0Y2hTaXplID49IDApO1xuICAgIC8vIEN1cnJlbnQgY2h1bmsgYmVpbmcgc3RyZWFtZWQuIFN0YXJ0IHdpdGggdGhlIGZpcnN0IGNodW5rLlxuICAgIGxldCBjdXJyQ2h1bmsgPSAwO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgY2h1bmsgZmlyZXMgYSAnbG9hZGNvbXBsZXRlJyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgICAqIEBwYXJhbSB7Q2h1bmt9IGNodW5rXG4gICAgICovXG4gICAgY29uc3Qgb25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoZXJyLCBjaHVuaykge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIHRoZSAnbG9hZGNvbXBsZXRlJyBldmVudFxuICAgICAgICBjaHVuay5yZW1vdmVMaXN0ZW5lcignbG9hZGNvbXBsZXRlJywgb25Mb2FkQ29tcGxldGUpO1xuICAgICAgICAvLyBpZiB0aGUgY2h1bmsgbG9hZCBzdWNjZWVkZWRcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgb24gdG8gdGhlIG5leHQgY2h1bmtcbiAgICAgICAgICAgIGN1cnJDaHVuaysrO1xuICAgICAgICAgICAgLy8gZW1pdCBhbiBldmVudCB0byBzaWduYWwgdGhhdCBuZXcgZGF0YSBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBzdHJlYW0gd2l0aCBhbiBlcnJvcjsgYWxzbywgaW5jbHVkZSBhIGNhbGxiYWNrIHdoZW4gZW1pdHRpbmdcbiAgICAgICAgICAgIC8vIHRoZSBldmVudCBpbiBjYXNlIHNvbWVvbmUgd2FudHMgdG8gZml4IHRoZSBwcm9ibGVtIGFuZCBhc2sgdXMgdG9cbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIGZyb20gd2hlcmUgd2UgZ290IGludGVycnVwdGVkXG4gICAgICAgICAgICBjbG9zZShzZWxmLCBlcnIsIGRvTG9hZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgdGhlIG5leHQgY2h1bmsgdG8gbG9hZCBhbmQgaXNzdWVzIHJlcXVlc3RzIHRvIGZldGNoIGJvdGggaXRzXG4gICAgICogY29udGVudHMgcGx1cyB0aGUgY29udGVudHMgb2YgdGhlIG5leHQgZmV3IGNodW5rcy4gSWYgdGhlcmUgYXJlIG5vIG1vcmVcbiAgICAgKiBjaHVua3MgdG8gbG9hZCwgYSAnY2xvc2UnIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBzdHJlYW0gdG8gbm90aWZ5XG4gICAgICogc3Vic2NyaWJlcnMgdGhhdCBhbGwgdGhlIGNodW5rcyBoYXZlIGJlZW4gc3VjY2Vzc2Z1bGx5IHJlYWQuXG4gICAgICovXG4gICAgY29uc3QgZG9Mb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBbGwgY2h1bmtzIHdlcmUgbG9hZGVkLCB3ZSdyZSBkb25lXG4gICAgICAgIGlmIChjdXJyQ2h1bmsgPj0gY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5hc3luY0Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGxvYWRjb21wbGV0ZSBldmVudCBvbiB0aGUgY3VycmVudCBjaHVuayBiZWluZyBzdHJlYW1lZCB0byBlbnN1cmUgdGhlXG4gICAgICAgICAgICAvLyByb3dzIGFyZSByZXR1cm5lZCBpbiB0aGUgY29ycmVjdCBvcmRlciBhbmQgbm90IGluIHRoZSBvcmRlciBjaHVuayBkYXRhIGFyZSByZWNlaXZlZFxuICAgICAgICAgICAgY2h1bmtzW2N1cnJDaHVua10ub24oJ2xvYWRjb21wbGV0ZScsIG9uTG9hZENvbXBsZXRlKTtcbiAgICAgICAgICAgIC8vIEZpcmUgb2ZmIHJlcXVlc3RzIHRvIGxvYWQgYWxsIHRoZSBjaHVua3MgaW4gdGhlIGJ1ZmZlciB0aGF0IGFyZW4ndCBhbHJlYWR5IGxvYWRpbmdcbiAgICAgICAgICAgIGxldCBjaHVuaywgaW5kZXg7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gY3VyckNodW5rOyBpbmRleCA8IGNodW5rcy5sZW5ndGggJiYgaW5kZXggPD0gY3VyckNodW5rICsgcHJlZmV0Y2hTaXplOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVua3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghY2h1bmsuaXNMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsubG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIG5leHQgY2h1bmsgb2YgZGF0YSBpbiB0aGUgcmVzdWx0IHN0cmVhbS5cbiAgICAgKi9cbiAgICB0aGlzLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IGlmIHRoZXJlIGFyZSBubyBtb3JlIGNodW5rcyB0byByZWFkLCBzaG91bGQgd2UgcmFpc2UgYW4gZXJyb3I/XG4gICAgICAgIC8vIFRPRE86IHdoYXQgaWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVhZD9cbiAgICAgICAgLy8gcmVhZCB0aGUgbmV4dCBjaHVua1xuICAgICAgICBkb0xvYWQoKTtcbiAgICB9O1xufVxuVXRpbC5pbmhlcml0cyhSZXN1bHRTdHJlYW0sIEV2ZW50RW1pdHRlcik7XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGNsb3NlcyB0aGlzIHN0cmVhbS5cbiAqXG4gKiBAcmV0dXJucyB7UmVzdWx0U3RyZWFtfVxuICovXG5SZXN1bHRTdHJlYW0ucHJvdG90eXBlLmFzeW5jQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2NoZWR1bGUgYW4gb3BlcmF0aW9uIHRvIGNsb3NlIHRoZSBzdHJlYW0gaW5cbiAgICAvLyB0aGUgbmV4dCB0aWNrIG9mIHRoZSBldmVudCBsb29wXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsb3NlKHNlbGYpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQ2xvc2VzIGEgZ2l2ZW4gcmVzdWx0IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1Jlc3VsdFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdG8gY2xvc2UuXG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyXSBUaGUgZXJyb3IsIGlmIGFueSwgdG8gZmlyZSB3aXRoIHRoZSBjbG9zZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrLCBpZiBhbnksIHRvIGZpcmUgd2l0aCB0aGUgY2xvc2VcbiAqICAgZXZlbnQuIFRoaXMgaXMgaW4gY2FzZSBzb21lb25lIHdhbnRzIHRvIGZpeCB0aGUgcHJvYmxlbSBhbmQgYXNrIHRoZSBzdHJlYW1cbiAqICAgdG8gcmVzdW1lIGZyb20gdGhlIHBvaW50IG9mIGludGVycnVwdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2xvc2Uoc3RyZWFtLCBlcnIsIGNhbGxiYWNrKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJywgZXJyLCBjYWxsYmFjayk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdFN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3VsdF9zdHJlYW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ResultStream = __webpack_require__(/*! ./result_stream */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js\");\nconst DataTypes = __webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst RowMode = __webpack_require__(/*! ./../../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\n/**\n * Creates a stream that can be used to read a statement result row by row.\n *\n * @param {Object} statement\n * @param {Object} context\n * @param {Object} options\n * @constructor\n */\nfunction RowStream(statement, context, options) {\n    // validate non-user-specified arguments\n    Errors.assertInternal(Util.exists(statement));\n    Errors.assertInternal(Util.exists(context));\n    // call Readable constructor\n    Readable.call(this, {\n        objectMode: true,\n        highWaterMark: context.connectionConfig.getRowStreamHighWaterMark(),\n    });\n    // extract streaming options\n    let start, end, fetchAsString, rowMode;\n    if (Util.isObject(options)) {\n        start = options.start;\n        end = options.end;\n        fetchAsString = options.fetchAsString;\n    }\n    // if a fetchAsString value is not specified in the stream options, try the\n    // statement and connection options (in that order)\n    if (!Util.exists(fetchAsString)) {\n        fetchAsString = context.fetchAsString;\n    }\n    if (!Util.exists(fetchAsString)) {\n        fetchAsString = context.connectionConfig.getFetchAsString();\n    }\n    if (!Util.exists(rowMode)) {\n        rowMode = context.rowMode || context.connectionConfig.getRowMode();\n    }\n    let resultStream = null, numResultStreamInterrupts = 0;\n    let rowBuffer = null, rowIndex = 0;\n    let columns, mapColumnIdToExtractFnName;\n    let initialized = false;\n    let previousChunk = null;\n    const self = this;\n    /**\n     * Reads the next row in the result.\n     *\n     * @private\n     */\n    this._read = function () {\n        // if the stream has been initialized, just read the next row\n        if (initialized) {\n            readNextRow();\n        }\n        else if (context.isFetchingResult) {\n            // if we're still fetching the result, wait for the operation to complete\n            context.on('statement-complete', init);\n        }\n        else if (context.result || isStatementErrorFatal(context)) {\n            // if we have a result or a fatal error, call init() in the next tick of\n            // the event loop\n            process.nextTick(init);\n        }\n        else {\n            if (typeof context.multiResultIds === 'undefined') {\n                // fetch the result again and call init() upon completion of the operation\n                context.refresh(init);\n            }\n            else {\n                //do nothing\n            }\n        }\n    };\n    /**\n     * Initializes this stream.\n     */\n    const init = function init() {\n        // the stream has now been initialized\n        initialized = true;\n        // if we have a result\n        if (context.result) {\n            // if no value was specified for the start index or if the specified start\n            // index is negative, default to 0, otherwise truncate the fractional part\n            start = !Util.isNumber(start) || start < 0 ? 0 : Math.floor(start);\n            // if no value was specified for the end index or if the end index is\n            // larger than the row index of the last row, default to the index of the\n            // last row, otherwise truncate the fractional part\n            const returnedRows = context.result.getReturnedRows();\n            end = !Util.isNumber(end) || end >= returnedRows ? returnedRows - 1 : Math.floor(end);\n            // find all the chunks that overlap with the specified range\n            const overlappingChunks = context.result.findOverlappingChunks(start, end);\n            // if no chunks overlap or start is greater than end, we're done\n            if (overlappingChunks.length === 0 || start > end) {\n                process.nextTick(close);\n            }\n            else {\n                // create a result stream from the overlapping chunks\n                resultStream = new ResultStream({\n                    chunks: overlappingChunks,\n                    prefetchSize: context.connectionConfig.getResultPrefetch(),\n                });\n                readNextRow();\n            }\n        }\n        else {\n            close(context.resultError);\n        }\n    };\n    /**\n     * Processes the row buffer.\n     */\n    const processRowBuffer = function processRowBuffer() {\n        // get the row to add to the read queue\n        let row = rowBuffer[rowIndex++];\n        // if we just read the last row in the row buffer, clear the row buffer and\n        // reset the row index so that we load the next chunk in the result stream\n        // when _read() is called\n        if (rowIndex === rowBuffer.length) {\n            rowBuffer = null;\n            rowIndex = 0;\n        }\n        // initialize the columns and column-related maps if necessary\n        if (!columns) {\n            columns = statement.getColumns();\n        }\n        if (!mapColumnIdToExtractFnName) {\n            mapColumnIdToExtractFnName = buildMapColumnExtractFnNames(columns, fetchAsString);\n        }\n        // add the next row to the read queue\n        process.nextTick(function () {\n            // check if there are still rows available in the rowBuffer\n            if (rowBuffer && rowIndex > 0) {\n                rowIndex--; // decrement the index to include the previous row in the while loop\n                // push() data to readable stream until highWaterMark threshold is reached or all rows are pushed\n                while (rowIndex < rowBuffer.length) {\n                    row = rowBuffer[rowIndex++];\n                    // if buffer has reached the threshold based on the highWaterMark value then\n                    // push() will return false and pause sending data to the buffer until the data is read from the buffer\n                    if (!self.push(externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode))) {\n                        break;\n                    }\n                }\n                // check if all rows in rowBuffer has been pushed to the readable stream\n                if (rowIndex === rowBuffer.length) {\n                    // reset the buffer and index\n                    rowBuffer = null;\n                    rowIndex = 0;\n                }\n            }\n            else {\n                // No more rows left in the buffer\n                // Push the last row in the buffer\n                self.push(externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode));\n            }\n        });\n    };\n    /**\n     * Called when the result stream reads a new chunk.\n     *\n     * @param {Chunk} chunk\n     */\n    const onResultStreamData = function onResultStreamData(chunk) {\n        // unsubscribe from the result stream's 'data' and 'close' events\n        resultStream.removeListener('data', onResultStreamData);\n        resultStream.removeListener('close', onResultStreamClose);\n        // get all the rows in the chunk that overlap with the requested window,\n        // and use the resulting array as the new row buffer\n        const chunkStart = chunk.getStartIndex();\n        const chunkEnd = chunk.getEndIndex();\n        rowBuffer = chunk\n            .getRows()\n            .slice(Math.max(chunkStart, start) - chunkStart, Math.min(chunkEnd, end) + 1 - chunkStart);\n        // reset the row index\n        rowIndex = 0;\n        // process the row buffer\n        processRowBuffer();\n        if (previousChunk && previousChunk !== chunk) {\n            previousChunk.clearRows();\n        }\n        previousChunk = chunk;\n    };\n    /**\n     * Called when there are no more chunks to read in the result stream or an\n     * error is encountered while trying to read the next chunk.\n     *\n     * @param err\n     * @param continueCallback\n     */\n    const onResultStreamClose = function onResultStreamClose(err, continueCallback) {\n        // if the error is retryable and\n        // the result stream hasn't been closed too many times\n        if (isResultStreamErrorRetryable(err) &&\n            numResultStreamInterrupts < context.connectionConfig.getResultStreamInterrupts()) {\n            numResultStreamInterrupts++;\n            // fetch the statement result again\n            context.refresh(function () {\n                if (context.resultError) {\n                    close(context.resultError);\n                }\n                else {\n                    continueCallback();\n                }\n            });\n        }\n        else {\n            close(err);\n        }\n    };\n    /**\n     * Closes the row stream.\n     *\n     * @param {Error} [err]\n     */\n    const close = function (err) {\n        // if we have a result stream, stop listening to events on it\n        if (resultStream) {\n            resultStream.removeListener('data', onResultStreamData);\n            resultStream.removeListener('close', onResultStreamClose);\n        }\n        // we're done, so time to clean up\n        rowBuffer = null;\n        rowIndex = 0;\n        resultStream = null;\n        numResultStreamInterrupts = 0;\n        if (previousChunk) {\n            previousChunk.clearRows();\n            previousChunk = null;\n        }\n        if (err) {\n            emitError(err);\n        }\n        else {\n            self.push(null);\n        }\n    };\n    /**\n     * Called when we're ready to read the next row in the result.\n     */\n    const readNextRow = function readNextRow() {\n        // if we have a row buffer, process it\n        if (rowBuffer) {\n            processRowBuffer();\n        }\n        else {\n            // subscribe to the result stream's 'data' and 'close' events\n            resultStream.on('data', onResultStreamData);\n            resultStream.on('close', onResultStreamClose);\n            // issue a request to fetch the next chunk in the result stream\n            resultStream.read();\n        }\n    };\n    /**\n     * Externalizes an error and emits it.\n     *\n     * @param {Error} err\n     */\n    const emitError = function emitError(err) {\n        self.emit('error', Errors.externalize(err));\n    };\n}\nUtil.inherits(RowStream, Readable);\n/**\n * Determines if a statement error is fatal.\n *\n * @returns {Boolean}\n * @param context\n */\nfunction isStatementErrorFatal(context) {\n    const error = context.resultError;\n    return ((Errors.isOperationFailedError(error) && error.sqlState) ||\n        isFileUploadError(error, context.type));\n}\nfunction isFileUploadError(error, contextType) {\n    return error && contextType === 'FILE_PRE_EXEC';\n}\n/**\n * Determines if a result stream error is a retryable error.\n *\n * @param {Error} error\n * @returns {Boolean}\n */\nfunction isResultStreamErrorRetryable(error) {\n    return ((Errors.isLargeResultSetError(error) && error.response && error.response.statusCode === 403) ||\n        (error && (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT')));\n}\n/**\n * Builds a map in which the keys are column ids and the values are the names of\n * the extract functions to use when retrieving row values for the corresponding\n * columns.\n *\n * @param {Object[]} columns\n * @param {String[]} fetchAsString the native types that should be retrieved as\n *   strings.\n *\n * @returns {Object}\n */\nfunction buildMapColumnExtractFnNames(columns, fetchAsString) {\n    const fnNameGetColumnValue = 'getColumnValue';\n    const fnNameGetColumnValueAsString = 'getColumnValueAsString';\n    let index, length, column;\n    const mapColumnIdToExtractFnName = {};\n    // if no native types need to be retrieved as strings, extract values normally\n    if (!Util.exists(fetchAsString)) {\n        for (index = 0, length = columns.length; index < length; index++) {\n            column = columns[index];\n            mapColumnIdToExtractFnName[column.getId()] = fnNameGetColumnValue;\n        }\n    }\n    else {\n        // build a map that contains all the native types that need to be\n        // retrieved as strings when extracting column values from rows\n        const nativeTypesMap = {};\n        for (index = 0, length = fetchAsString.length; index < length; index++) {\n            nativeTypesMap[fetchAsString[index].toUpperCase()] = true;\n        }\n        // for each column, pick the appropriate extract function\n        // based on whether the value needs to be retrieved as a string\n        for (index = 0, length = columns.length; index < length; index++) {\n            column = columns[index];\n            mapColumnIdToExtractFnName[column.getId()] = nativeTypesMap[DataTypes.toNativeType(column.getType())]\n                ? fnNameGetColumnValueAsString\n                : fnNameGetColumnValue;\n        }\n    }\n    return mapColumnIdToExtractFnName;\n}\n/**\n * Converts an internal representation of a result row to a format appropriate\n * for consumption by the outside world.\n *\n * @param {Object} row\n * @param {Object[]} columns\n * @param {Object} [mapColumnIdToExtractFnName]\n * @param {String?} rowMode - string value ('array', 'object' or 'object_with_renamed_duplicated_columns'). Default is 'object' when parameter isn't set.\n *\n * @returns {Object}\n */\nfunction externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode) {\n    const isArrayRowMode = rowMode === RowMode.ARRAY;\n    const externalizedRow = isArrayRowMode ? [] : {};\n    for (let index = 0, length = columns.length; index < length; index++) {\n        const column = columns[index];\n        const extractFnName = mapColumnIdToExtractFnName[column.getId()];\n        externalizedRow[isArrayRowMode ? index : column.getName()] = row[extractFnName](column.getId());\n    }\n    return externalizedRow;\n}\nmodule.exports = RowStream;\n//# sourceMappingURL=row_stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9yb3dfc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLHNEQUEwQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDJFQUFjO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLHVHQUFpQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBYztBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9yZXN1bHQvcm93X3N0cmVhbS5qcz81NWRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCdzdHJlYW0nKS5SZWFkYWJsZTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IFJlc3VsdFN0cmVhbSA9IHJlcXVpcmUoJy4vcmVzdWx0X3N0cmVhbScpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhX3R5cGVzJyk7XG5jb25zdCBSb3dNb2RlID0gcmVxdWlyZSgnLi8uLi8uLi9jb25zdGFudHMvcm93X21vZGUnKTtcbi8qKlxuICogQ3JlYXRlcyBhIHN0cmVhbSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgYSBzdGF0ZW1lbnQgcmVzdWx0IHJvdyBieSByb3cuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUm93U3RyZWFtKHN0YXRlbWVudCwgY29udGV4dCwgb3B0aW9ucykge1xuICAgIC8vIHZhbGlkYXRlIG5vbi11c2VyLXNwZWNpZmllZCBhcmd1bWVudHNcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMoc3RhdGVtZW50KSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKGNvbnRleHQpKTtcbiAgICAvLyBjYWxsIFJlYWRhYmxlIGNvbnN0cnVjdG9yXG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCB7XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRSb3dTdHJlYW1IaWdoV2F0ZXJNYXJrKCksXG4gICAgfSk7XG4gICAgLy8gZXh0cmFjdCBzdHJlYW1pbmcgb3B0aW9uc1xuICAgIGxldCBzdGFydCwgZW5kLCBmZXRjaEFzU3RyaW5nLCByb3dNb2RlO1xuICAgIGlmIChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgICAgICAgZW5kID0gb3B0aW9ucy5lbmQ7XG4gICAgICAgIGZldGNoQXNTdHJpbmcgPSBvcHRpb25zLmZldGNoQXNTdHJpbmc7XG4gICAgfVxuICAgIC8vIGlmIGEgZmV0Y2hBc1N0cmluZyB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBzdHJlYW0gb3B0aW9ucywgdHJ5IHRoZVxuICAgIC8vIHN0YXRlbWVudCBhbmQgY29ubmVjdGlvbiBvcHRpb25zIChpbiB0aGF0IG9yZGVyKVxuICAgIGlmICghVXRpbC5leGlzdHMoZmV0Y2hBc1N0cmluZykpIHtcbiAgICAgICAgZmV0Y2hBc1N0cmluZyA9IGNvbnRleHQuZmV0Y2hBc1N0cmluZztcbiAgICB9XG4gICAgaWYgKCFVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgICAgICBmZXRjaEFzU3RyaW5nID0gY29udGV4dC5jb25uZWN0aW9uQ29uZmlnLmdldEZldGNoQXNTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKCFVdGlsLmV4aXN0cyhyb3dNb2RlKSkge1xuICAgICAgICByb3dNb2RlID0gY29udGV4dC5yb3dNb2RlIHx8IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRSb3dNb2RlKCk7XG4gICAgfVxuICAgIGxldCByZXN1bHRTdHJlYW0gPSBudWxsLCBudW1SZXN1bHRTdHJlYW1JbnRlcnJ1cHRzID0gMDtcbiAgICBsZXQgcm93QnVmZmVyID0gbnVsbCwgcm93SW5kZXggPSAwO1xuICAgIGxldCBjb2x1bW5zLCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZTtcbiAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBsZXQgcHJldmlvdXNDaHVuayA9IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIG5leHQgcm93IGluIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHRoZSBzdHJlYW0gaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIGp1c3QgcmVhZCB0aGUgbmV4dCByb3dcbiAgICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZWFkTmV4dFJvdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRleHQuaXNGZXRjaGluZ1Jlc3VsdCkge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgZmV0Y2hpbmcgdGhlIHJlc3VsdCwgd2FpdCBmb3IgdGhlIG9wZXJhdGlvbiB0byBjb21wbGV0ZVxuICAgICAgICAgICAgY29udGV4dC5vbignc3RhdGVtZW50LWNvbXBsZXRlJywgaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5yZXN1bHQgfHwgaXNTdGF0ZW1lbnRFcnJvckZhdGFsKGNvbnRleHQpKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgcmVzdWx0IG9yIGEgZmF0YWwgZXJyb3IsIGNhbGwgaW5pdCgpIGluIHRoZSBuZXh0IHRpY2sgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBldmVudCBsb29wXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0Lm11bHRpUmVzdWx0SWRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIGZldGNoIHRoZSByZXN1bHQgYWdhaW4gYW5kIGNhbGwgaW5pdCgpIHVwb24gY29tcGxldGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWZyZXNoKGluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoaXMgc3RyZWFtLlxuICAgICAqL1xuICAgIGNvbnN0IGluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAvLyB0aGUgc3RyZWFtIGhhcyBub3cgYmVlbiBpbml0aWFsaXplZFxuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSByZXN1bHRcbiAgICAgICAgaWYgKGNvbnRleHQucmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBpZiBubyB2YWx1ZSB3YXMgc3BlY2lmaWVkIGZvciB0aGUgc3RhcnQgaW5kZXggb3IgaWYgdGhlIHNwZWNpZmllZCBzdGFydFxuICAgICAgICAgICAgLy8gaW5kZXggaXMgbmVnYXRpdmUsIGRlZmF1bHQgdG8gMCwgb3RoZXJ3aXNlIHRydW5jYXRlIHRoZSBmcmFjdGlvbmFsIHBhcnRcbiAgICAgICAgICAgIHN0YXJ0ID0gIVV0aWwuaXNOdW1iZXIoc3RhcnQpIHx8IHN0YXJ0IDwgMCA/IDAgOiBNYXRoLmZsb29yKHN0YXJ0KTtcbiAgICAgICAgICAgIC8vIGlmIG5vIHZhbHVlIHdhcyBzcGVjaWZpZWQgZm9yIHRoZSBlbmQgaW5kZXggb3IgaWYgdGhlIGVuZCBpbmRleCBpc1xuICAgICAgICAgICAgLy8gbGFyZ2VyIHRoYW4gdGhlIHJvdyBpbmRleCBvZiB0aGUgbGFzdCByb3csIGRlZmF1bHQgdG8gdGhlIGluZGV4IG9mIHRoZVxuICAgICAgICAgICAgLy8gbGFzdCByb3csIG90aGVyd2lzZSB0cnVuY2F0ZSB0aGUgZnJhY3Rpb25hbCBwYXJ0XG4gICAgICAgICAgICBjb25zdCByZXR1cm5lZFJvd3MgPSBjb250ZXh0LnJlc3VsdC5nZXRSZXR1cm5lZFJvd3MoKTtcbiAgICAgICAgICAgIGVuZCA9ICFVdGlsLmlzTnVtYmVyKGVuZCkgfHwgZW5kID49IHJldHVybmVkUm93cyA/IHJldHVybmVkUm93cyAtIDEgOiBNYXRoLmZsb29yKGVuZCk7XG4gICAgICAgICAgICAvLyBmaW5kIGFsbCB0aGUgY2h1bmtzIHRoYXQgb3ZlcmxhcCB3aXRoIHRoZSBzcGVjaWZpZWQgcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQ2h1bmtzID0gY29udGV4dC5yZXN1bHQuZmluZE92ZXJsYXBwaW5nQ2h1bmtzKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgLy8gaWYgbm8gY2h1bmtzIG92ZXJsYXAgb3Igc3RhcnQgaXMgZ3JlYXRlciB0aGFuIGVuZCwgd2UncmUgZG9uZVxuICAgICAgICAgICAgaWYgKG92ZXJsYXBwaW5nQ2h1bmtzLmxlbmd0aCA9PT0gMCB8fCBzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2xvc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgcmVzdWx0IHN0cmVhbSBmcm9tIHRoZSBvdmVybGFwcGluZyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJlYW0gPSBuZXcgUmVzdWx0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzOiBvdmVybGFwcGluZ0NodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hTaXplOiBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0UmVzdWx0UHJlZmV0Y2goKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWFkTmV4dFJvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xvc2UoY29udGV4dC5yZXN1bHRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgcm93IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBjb25zdCBwcm9jZXNzUm93QnVmZmVyID0gZnVuY3Rpb24gcHJvY2Vzc1Jvd0J1ZmZlcigpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSByb3cgdG8gYWRkIHRvIHRoZSByZWFkIHF1ZXVlXG4gICAgICAgIGxldCByb3cgPSByb3dCdWZmZXJbcm93SW5kZXgrK107XG4gICAgICAgIC8vIGlmIHdlIGp1c3QgcmVhZCB0aGUgbGFzdCByb3cgaW4gdGhlIHJvdyBidWZmZXIsIGNsZWFyIHRoZSByb3cgYnVmZmVyIGFuZFxuICAgICAgICAvLyByZXNldCB0aGUgcm93IGluZGV4IHNvIHRoYXQgd2UgbG9hZCB0aGUgbmV4dCBjaHVuayBpbiB0aGUgcmVzdWx0IHN0cmVhbVxuICAgICAgICAvLyB3aGVuIF9yZWFkKCkgaXMgY2FsbGVkXG4gICAgICAgIGlmIChyb3dJbmRleCA9PT0gcm93QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJvd0luZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBjb2x1bW5zIGFuZCBjb2x1bW4tcmVsYXRlZCBtYXBzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIWNvbHVtbnMpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBzdGF0ZW1lbnQuZ2V0Q29sdW1ucygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWUpIHtcbiAgICAgICAgICAgIG1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lID0gYnVpbGRNYXBDb2x1bW5FeHRyYWN0Rm5OYW1lcyhjb2x1bW5zLCBmZXRjaEFzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIG5leHQgcm93IHRvIHRoZSByZWFkIHF1ZXVlXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHN0aWxsIHJvd3MgYXZhaWxhYmxlIGluIHRoZSByb3dCdWZmZXJcbiAgICAgICAgICAgIGlmIChyb3dCdWZmZXIgJiYgcm93SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgcm93SW5kZXgtLTsgLy8gZGVjcmVtZW50IHRoZSBpbmRleCB0byBpbmNsdWRlIHRoZSBwcmV2aW91cyByb3cgaW4gdGhlIHdoaWxlIGxvb3BcbiAgICAgICAgICAgICAgICAvLyBwdXNoKCkgZGF0YSB0byByZWFkYWJsZSBzdHJlYW0gdW50aWwgaGlnaFdhdGVyTWFyayB0aHJlc2hvbGQgaXMgcmVhY2hlZCBvciBhbGwgcm93cyBhcmUgcHVzaGVkXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJvd0luZGV4IDwgcm93QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSByb3dCdWZmZXJbcm93SW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBoYXMgcmVhY2hlZCB0aGUgdGhyZXNob2xkIGJhc2VkIG9uIHRoZSBoaWdoV2F0ZXJNYXJrIHZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCgpIHdpbGwgcmV0dXJuIGZhbHNlIGFuZCBwYXVzZSBzZW5kaW5nIGRhdGEgdG8gdGhlIGJ1ZmZlciB1bnRpbCB0aGUgZGF0YSBpcyByZWFkIGZyb20gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYucHVzaChleHRlcm5hbGl6ZVJvdyhyb3csIGNvbHVtbnMsIG1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lLCByb3dNb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFsbCByb3dzIGluIHJvd0J1ZmZlciBoYXMgYmVlbiBwdXNoZWQgdG8gdGhlIHJlYWRhYmxlIHN0cmVhbVxuICAgICAgICAgICAgICAgIGlmIChyb3dJbmRleCA9PT0gcm93QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgYnVmZmVyIGFuZCBpbmRleFxuICAgICAgICAgICAgICAgICAgICByb3dCdWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByb3dJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbW9yZSByb3dzIGxlZnQgaW4gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgIC8vIFB1c2ggdGhlIGxhc3Qgcm93IGluIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICBzZWxmLnB1c2goZXh0ZXJuYWxpemVSb3cocm93LCBjb2x1bW5zLCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZSwgcm93TW9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSByZXN1bHQgc3RyZWFtIHJlYWRzIGEgbmV3IGNodW5rLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDaHVua30gY2h1bmtcbiAgICAgKi9cbiAgICBjb25zdCBvblJlc3VsdFN0cmVhbURhdGEgPSBmdW5jdGlvbiBvblJlc3VsdFN0cmVhbURhdGEoY2h1bmspIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSB0aGUgcmVzdWx0IHN0cmVhbSdzICdkYXRhJyBhbmQgJ2Nsb3NlJyBldmVudHNcbiAgICAgICAgcmVzdWx0U3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25SZXN1bHRTdHJlYW1EYXRhKTtcbiAgICAgICAgcmVzdWx0U3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uUmVzdWx0U3RyZWFtQ2xvc2UpO1xuICAgICAgICAvLyBnZXQgYWxsIHRoZSByb3dzIGluIHRoZSBjaHVuayB0aGF0IG92ZXJsYXAgd2l0aCB0aGUgcmVxdWVzdGVkIHdpbmRvdyxcbiAgICAgICAgLy8gYW5kIHVzZSB0aGUgcmVzdWx0aW5nIGFycmF5IGFzIHRoZSBuZXcgcm93IGJ1ZmZlclxuICAgICAgICBjb25zdCBjaHVua1N0YXJ0ID0gY2h1bmsuZ2V0U3RhcnRJbmRleCgpO1xuICAgICAgICBjb25zdCBjaHVua0VuZCA9IGNodW5rLmdldEVuZEluZGV4KCk7XG4gICAgICAgIHJvd0J1ZmZlciA9IGNodW5rXG4gICAgICAgICAgICAuZ2V0Um93cygpXG4gICAgICAgICAgICAuc2xpY2UoTWF0aC5tYXgoY2h1bmtTdGFydCwgc3RhcnQpIC0gY2h1bmtTdGFydCwgTWF0aC5taW4oY2h1bmtFbmQsIGVuZCkgKyAxIC0gY2h1bmtTdGFydCk7XG4gICAgICAgIC8vIHJlc2V0IHRoZSByb3cgaW5kZXhcbiAgICAgICAgcm93SW5kZXggPSAwO1xuICAgICAgICAvLyBwcm9jZXNzIHRoZSByb3cgYnVmZmVyXG4gICAgICAgIHByb2Nlc3NSb3dCdWZmZXIoKTtcbiAgICAgICAgaWYgKHByZXZpb3VzQ2h1bmsgJiYgcHJldmlvdXNDaHVuayAhPT0gY2h1bmspIHtcbiAgICAgICAgICAgIHByZXZpb3VzQ2h1bmsuY2xlYXJSb3dzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNDaHVuayA9IGNodW5rO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2h1bmtzIHRvIHJlYWQgaW4gdGhlIHJlc3VsdCBzdHJlYW0gb3IgYW5cbiAgICAgKiBlcnJvciBpcyBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gcmVhZCB0aGUgbmV4dCBjaHVuay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJcbiAgICAgKiBAcGFyYW0gY29udGludWVDYWxsYmFja1xuICAgICAqL1xuICAgIGNvbnN0IG9uUmVzdWx0U3RyZWFtQ2xvc2UgPSBmdW5jdGlvbiBvblJlc3VsdFN0cmVhbUNsb3NlKGVyciwgY29udGludWVDYWxsYmFjaykge1xuICAgICAgICAvLyBpZiB0aGUgZXJyb3IgaXMgcmV0cnlhYmxlIGFuZFxuICAgICAgICAvLyB0aGUgcmVzdWx0IHN0cmVhbSBoYXNuJ3QgYmVlbiBjbG9zZWQgdG9vIG1hbnkgdGltZXNcbiAgICAgICAgaWYgKGlzUmVzdWx0U3RyZWFtRXJyb3JSZXRyeWFibGUoZXJyKSAmJlxuICAgICAgICAgICAgbnVtUmVzdWx0U3RyZWFtSW50ZXJydXB0cyA8IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRTdHJlYW1JbnRlcnJ1cHRzKCkpIHtcbiAgICAgICAgICAgIG51bVJlc3VsdFN0cmVhbUludGVycnVwdHMrKztcbiAgICAgICAgICAgIC8vIGZldGNoIHRoZSBzdGF0ZW1lbnQgcmVzdWx0IGFnYWluXG4gICAgICAgICAgICBjb250ZXh0LnJlZnJlc2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnJlc3VsdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlKGNvbnRleHQucmVzdWx0RXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xvc2UoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSByb3cgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gW2Vycl1cbiAgICAgKi9cbiAgICBjb25zdCBjbG9zZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHJlc3VsdCBzdHJlYW0sIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiBpdFxuICAgICAgICBpZiAocmVzdWx0U3RyZWFtKSB7XG4gICAgICAgICAgICByZXN1bHRTdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvblJlc3VsdFN0cmVhbURhdGEpO1xuICAgICAgICAgICAgcmVzdWx0U3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uUmVzdWx0U3RyZWFtQ2xvc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlJ3JlIGRvbmUsIHNvIHRpbWUgdG8gY2xlYW4gdXBcbiAgICAgICAgcm93QnVmZmVyID0gbnVsbDtcbiAgICAgICAgcm93SW5kZXggPSAwO1xuICAgICAgICByZXN1bHRTdHJlYW0gPSBudWxsO1xuICAgICAgICBudW1SZXN1bHRTdHJlYW1JbnRlcnJ1cHRzID0gMDtcbiAgICAgICAgaWYgKHByZXZpb3VzQ2h1bmspIHtcbiAgICAgICAgICAgIHByZXZpb3VzQ2h1bmsuY2xlYXJSb3dzKCk7XG4gICAgICAgICAgICBwcmV2aW91c0NodW5rID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gd2UncmUgcmVhZHkgdG8gcmVhZCB0aGUgbmV4dCByb3cgaW4gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBjb25zdCByZWFkTmV4dFJvdyA9IGZ1bmN0aW9uIHJlYWROZXh0Um93KCkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgcm93IGJ1ZmZlciwgcHJvY2VzcyBpdFxuICAgICAgICBpZiAocm93QnVmZmVyKSB7XG4gICAgICAgICAgICBwcm9jZXNzUm93QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIHJlc3VsdCBzdHJlYW0ncyAnZGF0YScgYW5kICdjbG9zZScgZXZlbnRzXG4gICAgICAgICAgICByZXN1bHRTdHJlYW0ub24oJ2RhdGEnLCBvblJlc3VsdFN0cmVhbURhdGEpO1xuICAgICAgICAgICAgcmVzdWx0U3RyZWFtLm9uKCdjbG9zZScsIG9uUmVzdWx0U3RyZWFtQ2xvc2UpO1xuICAgICAgICAgICAgLy8gaXNzdWUgYSByZXF1ZXN0IHRvIGZldGNoIHRoZSBuZXh0IGNodW5rIGluIHRoZSByZXN1bHQgc3RyZWFtXG4gICAgICAgICAgICByZXN1bHRTdHJlYW0ucmVhZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRlcm5hbGl6ZXMgYW4gZXJyb3IgYW5kIGVtaXRzIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAgICovXG4gICAgY29uc3QgZW1pdEVycm9yID0gZnVuY3Rpb24gZW1pdEVycm9yKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgRXJyb3JzLmV4dGVybmFsaXplKGVycikpO1xuICAgIH07XG59XG5VdGlsLmluaGVyaXRzKFJvd1N0cmVhbSwgUmVhZGFibGUpO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgc3RhdGVtZW50IGVycm9yIGlzIGZhdGFsLlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaXNTdGF0ZW1lbnRFcnJvckZhdGFsKGNvbnRleHQpIHtcbiAgICBjb25zdCBlcnJvciA9IGNvbnRleHQucmVzdWx0RXJyb3I7XG4gICAgcmV0dXJuICgoRXJyb3JzLmlzT3BlcmF0aW9uRmFpbGVkRXJyb3IoZXJyb3IpICYmIGVycm9yLnNxbFN0YXRlKSB8fFxuICAgICAgICBpc0ZpbGVVcGxvYWRFcnJvcihlcnJvciwgY29udGV4dC50eXBlKSk7XG59XG5mdW5jdGlvbiBpc0ZpbGVVcGxvYWRFcnJvcihlcnJvciwgY29udGV4dFR5cGUpIHtcbiAgICByZXR1cm4gZXJyb3IgJiYgY29udGV4dFR5cGUgPT09ICdGSUxFX1BSRV9FWEVDJztcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHJlc3VsdCBzdHJlYW0gZXJyb3IgaXMgYSByZXRyeWFibGUgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Jlc3VsdFN0cmVhbUVycm9yUmV0cnlhYmxlKGVycm9yKSB7XG4gICAgcmV0dXJuICgoRXJyb3JzLmlzTGFyZ2VSZXN1bHRTZXRFcnJvcihlcnJvcikgJiYgZXJyb3IucmVzcG9uc2UgJiYgZXJyb3IucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDAzKSB8fFxuICAgICAgICAoZXJyb3IgJiYgKGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJyB8fCBlcnJvci5jb2RlID09PSAnRVRJTUVET1VUJykpKTtcbn1cbi8qKlxuICogQnVpbGRzIGEgbWFwIGluIHdoaWNoIHRoZSBrZXlzIGFyZSBjb2x1bW4gaWRzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgbmFtZXMgb2ZcbiAqIHRoZSBleHRyYWN0IGZ1bmN0aW9ucyB0byB1c2Ugd2hlbiByZXRyaWV2aW5nIHJvdyB2YWx1ZXMgZm9yIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBjb2x1bW5zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IGNvbHVtbnNcbiAqIEBwYXJhbSB7U3RyaW5nW119IGZldGNoQXNTdHJpbmcgdGhlIG5hdGl2ZSB0eXBlcyB0aGF0IHNob3VsZCBiZSByZXRyaWV2ZWQgYXNcbiAqICAgc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBidWlsZE1hcENvbHVtbkV4dHJhY3RGbk5hbWVzKGNvbHVtbnMsIGZldGNoQXNTdHJpbmcpIHtcbiAgICBjb25zdCBmbk5hbWVHZXRDb2x1bW5WYWx1ZSA9ICdnZXRDb2x1bW5WYWx1ZSc7XG4gICAgY29uc3QgZm5OYW1lR2V0Q29sdW1uVmFsdWVBc1N0cmluZyA9ICdnZXRDb2x1bW5WYWx1ZUFzU3RyaW5nJztcbiAgICBsZXQgaW5kZXgsIGxlbmd0aCwgY29sdW1uO1xuICAgIGNvbnN0IG1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lID0ge307XG4gICAgLy8gaWYgbm8gbmF0aXZlIHR5cGVzIG5lZWQgdG8gYmUgcmV0cmlldmVkIGFzIHN0cmluZ3MsIGV4dHJhY3QgdmFsdWVzIG5vcm1hbGx5XG4gICAgaWYgKCFVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gY29sdW1ucy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgIG1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lW2NvbHVtbi5nZXRJZCgpXSA9IGZuTmFtZUdldENvbHVtblZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBidWlsZCBhIG1hcCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgbmF0aXZlIHR5cGVzIHRoYXQgbmVlZCB0byBiZVxuICAgICAgICAvLyByZXRyaWV2ZWQgYXMgc3RyaW5ncyB3aGVuIGV4dHJhY3RpbmcgY29sdW1uIHZhbHVlcyBmcm9tIHJvd3NcbiAgICAgICAgY29uc3QgbmF0aXZlVHlwZXNNYXAgPSB7fTtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGZldGNoQXNTdHJpbmcubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgbmF0aXZlVHlwZXNNYXBbZmV0Y2hBc1N0cmluZ1tpbmRleF0udG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBlYWNoIGNvbHVtbiwgcGljayB0aGUgYXBwcm9wcmlhdGUgZXh0cmFjdCBmdW5jdGlvblxuICAgICAgICAvLyBiYXNlZCBvbiB3aGV0aGVyIHRoZSB2YWx1ZSBuZWVkcyB0byBiZSByZXRyaWV2ZWQgYXMgYSBzdHJpbmdcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGNvbHVtbnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZVtjb2x1bW4uZ2V0SWQoKV0gPSBuYXRpdmVUeXBlc01hcFtEYXRhVHlwZXMudG9OYXRpdmVUeXBlKGNvbHVtbi5nZXRUeXBlKCkpXVxuICAgICAgICAgICAgICAgID8gZm5OYW1lR2V0Q29sdW1uVmFsdWVBc1N0cmluZ1xuICAgICAgICAgICAgICAgIDogZm5OYW1lR2V0Q29sdW1uVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHJlc3VsdCByb3cgdG8gYSBmb3JtYXQgYXBwcm9wcmlhdGVcbiAqIGZvciBjb25zdW1wdGlvbiBieSB0aGUgb3V0c2lkZSB3b3JsZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcm93XG4gKiBAcGFyYW0ge09iamVjdFtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gW21hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lXVxuICogQHBhcmFtIHtTdHJpbmc/fSByb3dNb2RlIC0gc3RyaW5nIHZhbHVlICgnYXJyYXknLCAnb2JqZWN0JyBvciAnb2JqZWN0X3dpdGhfcmVuYW1lZF9kdXBsaWNhdGVkX2NvbHVtbnMnKS4gRGVmYXVsdCBpcyAnb2JqZWN0JyB3aGVuIHBhcmFtZXRlciBpc24ndCBzZXQuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZXh0ZXJuYWxpemVSb3cocm93LCBjb2x1bW5zLCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZSwgcm93TW9kZSkge1xuICAgIGNvbnN0IGlzQXJyYXlSb3dNb2RlID0gcm93TW9kZSA9PT0gUm93TW9kZS5BUlJBWTtcbiAgICBjb25zdCBleHRlcm5hbGl6ZWRSb3cgPSBpc0FycmF5Um93TW9kZSA/IFtdIDoge307XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBjb2x1bW5zLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tpbmRleF07XG4gICAgICAgIGNvbnN0IGV4dHJhY3RGbk5hbWUgPSBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZVtjb2x1bW4uZ2V0SWQoKV07XG4gICAgICAgIGV4dGVybmFsaXplZFJvd1tpc0FycmF5Um93TW9kZSA/IGluZGV4IDogY29sdW1uLmdldE5hbWUoKV0gPSByb3dbZXh0cmFjdEZuTmFtZV0oY29sdW1uLmdldElkKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZXJuYWxpemVkUm93O1xufVxubW9kdWxlLmV4cG9ydHMgPSBSb3dTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3dfc3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Moment = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst datetimeFormatConverter = __webpack_require__(/*! ./datetime_format_converter */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js\");\n/**\n * Creates a new SfTimestamp instance.\n *\n * @param {Number} epochSeconds the epoch time in seconds.\n * @param {Number} nanoSeconds the number of nano seconds (incremental, not\n *   epoch).\n * @param {Number} scale the precision for the fractional part of the timestamp.\n * @param {String | Number} [timezone] the timezone name as a string\n *   (e.g. 'America/New_York') or the timezone offset in minutes (e.g. -240).\n * @param {String} [format] the SQL format to use to format the timestamp.\n * @constructor\n */\nfunction SfTimestamp(epochSeconds, nanoSeconds, scale, timezone, format) {\n    // pick reasonable defaults for the inputs if needed\n    epochSeconds = Util.isNumber(epochSeconds) ? epochSeconds : 0;\n    nanoSeconds = Util.isNumber(nanoSeconds) ? nanoSeconds : 0;\n    scale = Util.isNumber(scale) ? scale : 0;\n    format = Util.isString(format) ? format : '';\n    // save any information we'll need later\n    this.epochSeconds = epochSeconds;\n    this.nanoSeconds = nanoSeconds;\n    this.scale = scale;\n    this.timezone = timezone;\n    this.format = format;\n    // Milliseconds are truncated to avoid rounding issues, and the decimal part is not useful since Moment only supports milliseconds precision\n    const milliseconds = Math.trunc(nanoSeconds / 1000000);\n    let moment = Moment(epochSeconds * 1000 + milliseconds);\n    // set the moment's timezone\n    if (Util.isString(timezone)) {\n        moment = moment.tz(timezone);\n    }\n    else if (Util.isNumber(timezone)) {\n        moment = moment.utcOffset(timezone);\n    }\n    // save the moment\n    this.moment = moment;\n}\n/**\n * Returns a string representing the specified SfTimestamp instance.\n *\n * @returns {String}\n */\nSfTimestamp.prototype.toString = function () {\n    // use cached value if possible\n    if (this._valueAsString) {\n        return this._valueAsString;\n    }\n    const moment = this.moment;\n    const nanoSeconds = this.nanoSeconds;\n    let scale = this.scale;\n    const formatSql = this.format;\n    // get an upper-case version of the input sql format\n    const formatSqlUpper = formatSql.toUpperCase();\n    const tags = datetimeFormatConverter.formatTagsMap();\n    // iterate over the format string\n    const length = formatSql.length;\n    let formatMoment = '';\n    for (let pos = 0; pos < length;) {\n        let tag = null;\n        let out = null;\n        // at each position, check if there's a tag at that position; if so, use\n        // 'out' as the replacement\n        for (let index = 0; index < tags.length; index++) {\n            if (formatSqlUpper.substr(pos).indexOf(tags[index][0]) === 0) {\n                tag = tags[index][0];\n                out = tags[index][1];\n                break;\n            }\n        }\n        // if we didn't find a match, just insert the character after escaping it\n        // (by wrapping it in square brackets)\n        if (out === null) {\n            formatMoment += '[' + formatSql[pos] + ']';\n            pos++;\n        }\n        else {\n            // we found one of our special tags\n            if (out === '') {\n                if (tag === 'TZH') {\n                    // format the moment to get the timezone string and extract the\n                    // hours; for example, '-0700' will be converted to '-07'\n                    out = moment.format('ZZ').substr(0, 3);\n                }\n                else if (tag === 'TZM') {\n                    // format the moment to get the timezone string and extract the\n                    // minutes; for example, '-0700' will be converted to '00\n                    out = moment.format('ZZ').substr(3);\n                }\n                else if (tag === 'FF') {\n                    // if 'FF' is followed by a digit, use the digit as the scale\n                    let digit = null;\n                    if (pos + tag.length < length) {\n                        const matches = formatSql[pos + tag.length].match(/[0-9]/);\n                        if (matches) {\n                            digit = matches[0];\n                        }\n                    }\n                    if (digit !== null) {\n                        scale = digit;\n                        pos++; // skip the digit as well\n                    }\n                    // if we need to include fractional seconds\n                    if (scale > 0) {\n                        // divide the nanoSeconds to get the requested number of\n                        // meaningful digits\n                        const scaled = Math.floor(nanoSeconds / Math.pow(10, 9 - scale));\n                        // pad with the appropriate number of leading zeros\n                        out = (new Array(9).join('0') + scaled).substr(-scale);\n                    }\n                }\n            }\n            // append the 'out' text to the moment format and update the position\n            formatMoment += out;\n            pos += tag.length;\n        }\n    }\n    // format the moment and cache the result\n    const timezone = this.timezone.name || this.timezone;\n    if (timezone) {\n        if (typeof timezone === 'number') {\n            this._valueAsString = moment.utcOffset(timezone).format(formatMoment);\n        }\n        else {\n            this._valueAsString = moment.tz(timezone).format(formatMoment);\n        }\n    }\n    else {\n        this._valueAsString = moment.format(formatMoment);\n    }\n    return this._valueAsString;\n};\n/**\n * Converts this SfTimestamp to an SfDate that's just a normal JavaScript Date\n * with some additional methods like getEpochSeconds(), getNanoSeconds(),\n * getTimezone(), etc.\n *\n * @returns {Date}\n */\nSfTimestamp.prototype.toSfDate = function () {\n    // create a Date from the moment\n    const date = this.moment.toDate();\n    const self = this;\n    date.getEpochSeconds = function () {\n        return self.epochSeconds;\n    };\n    date.getNanoSeconds = function () {\n        return self.nanoSeconds;\n    };\n    date.getScale = function () {\n        return self.scale;\n    };\n    date.getTimezone = function () {\n        return self.timezone;\n    };\n    date.getFormat = function () {\n        return self.format;\n    };\n    date.toJSON = function () {\n        return self.toString();\n    };\n    return date;\n};\n/**\n * Converts this SfTimestamp to an SfTime, which is just a JavaScript Object\n * with some methods: getMidnightSeconds(), getNanoSeconds(), etc.\n *\n * @returns {Object}\n */\nSfTimestamp.prototype.toSfTime = function () {\n    const self = this;\n    return {\n        getMidnightSeconds: function () {\n            return self.epochSeconds;\n        },\n        getNanoSeconds: function () {\n            return self.nanoSeconds;\n        },\n        getScale: function () {\n            return self.scale;\n        },\n        getFormat: function () {\n            return self.format;\n        },\n        toJSON: function () {\n            return self.toString();\n        },\n    };\n};\nmodule.exports = SfTimestamp;\n//# sourceMappingURL=sf_timestamp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9zZl90aW1lc3RhbXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBWTtBQUNqQyxnQ0FBZ0MsbUJBQU8sQ0FBQywrSEFBNkI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9zZl90aW1lc3RhbXAuanM/YTNmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IE1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IGRhdGV0aW1lRm9ybWF0Q29udmVydGVyID0gcmVxdWlyZSgnLi9kYXRldGltZV9mb3JtYXRfY29udmVydGVyJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU2ZUaW1lc3RhbXAgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVwb2NoU2Vjb25kcyB0aGUgZXBvY2ggdGltZSBpbiBzZWNvbmRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IG5hbm9TZWNvbmRzIHRoZSBudW1iZXIgb2YgbmFubyBzZWNvbmRzIChpbmNyZW1lbnRhbCwgbm90XG4gKiAgIGVwb2NoKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgcHJlY2lzaW9uIGZvciB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSB0aW1lc3RhbXAuXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW3RpbWV6b25lXSB0aGUgdGltZXpvbmUgbmFtZSBhcyBhIHN0cmluZ1xuICogICAoZS5nLiAnQW1lcmljYS9OZXdfWW9yaycpIG9yIHRoZSB0aW1lem9uZSBvZmZzZXQgaW4gbWludXRlcyAoZS5nLiAtMjQwKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZm9ybWF0XSB0aGUgU1FMIGZvcm1hdCB0byB1c2UgdG8gZm9ybWF0IHRoZSB0aW1lc3RhbXAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2ZUaW1lc3RhbXAoZXBvY2hTZWNvbmRzLCBuYW5vU2Vjb25kcywgc2NhbGUsIHRpbWV6b25lLCBmb3JtYXQpIHtcbiAgICAvLyBwaWNrIHJlYXNvbmFibGUgZGVmYXVsdHMgZm9yIHRoZSBpbnB1dHMgaWYgbmVlZGVkXG4gICAgZXBvY2hTZWNvbmRzID0gVXRpbC5pc051bWJlcihlcG9jaFNlY29uZHMpID8gZXBvY2hTZWNvbmRzIDogMDtcbiAgICBuYW5vU2Vjb25kcyA9IFV0aWwuaXNOdW1iZXIobmFub1NlY29uZHMpID8gbmFub1NlY29uZHMgOiAwO1xuICAgIHNjYWxlID0gVXRpbC5pc051bWJlcihzY2FsZSkgPyBzY2FsZSA6IDA7XG4gICAgZm9ybWF0ID0gVXRpbC5pc1N0cmluZyhmb3JtYXQpID8gZm9ybWF0IDogJyc7XG4gICAgLy8gc2F2ZSBhbnkgaW5mb3JtYXRpb24gd2UnbGwgbmVlZCBsYXRlclxuICAgIHRoaXMuZXBvY2hTZWNvbmRzID0gZXBvY2hTZWNvbmRzO1xuICAgIHRoaXMubmFub1NlY29uZHMgPSBuYW5vU2Vjb25kcztcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy50aW1lem9uZSA9IHRpbWV6b25lO1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgdHJ1bmNhdGVkIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcywgYW5kIHRoZSBkZWNpbWFsIHBhcnQgaXMgbm90IHVzZWZ1bCBzaW5jZSBNb21lbnQgb25seSBzdXBwb3J0cyBtaWxsaXNlY29uZHMgcHJlY2lzaW9uXG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gTWF0aC50cnVuYyhuYW5vU2Vjb25kcyAvIDEwMDAwMDApO1xuICAgIGxldCBtb21lbnQgPSBNb21lbnQoZXBvY2hTZWNvbmRzICogMTAwMCArIG1pbGxpc2Vjb25kcyk7XG4gICAgLy8gc2V0IHRoZSBtb21lbnQncyB0aW1lem9uZVxuICAgIGlmIChVdGlsLmlzU3RyaW5nKHRpbWV6b25lKSkge1xuICAgICAgICBtb21lbnQgPSBtb21lbnQudHoodGltZXpvbmUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChVdGlsLmlzTnVtYmVyKHRpbWV6b25lKSkge1xuICAgICAgICBtb21lbnQgPSBtb21lbnQudXRjT2Zmc2V0KHRpbWV6b25lKTtcbiAgICB9XG4gICAgLy8gc2F2ZSB0aGUgbW9tZW50XG4gICAgdGhpcy5tb21lbnQgPSBtb21lbnQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgU2ZUaW1lc3RhbXAgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuU2ZUaW1lc3RhbXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHVzZSBjYWNoZWQgdmFsdWUgaWYgcG9zc2libGVcbiAgICBpZiAodGhpcy5fdmFsdWVBc1N0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVBc1N0cmluZztcbiAgICB9XG4gICAgY29uc3QgbW9tZW50ID0gdGhpcy5tb21lbnQ7XG4gICAgY29uc3QgbmFub1NlY29uZHMgPSB0aGlzLm5hbm9TZWNvbmRzO1xuICAgIGxldCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgY29uc3QgZm9ybWF0U3FsID0gdGhpcy5mb3JtYXQ7XG4gICAgLy8gZ2V0IGFuIHVwcGVyLWNhc2UgdmVyc2lvbiBvZiB0aGUgaW5wdXQgc3FsIGZvcm1hdFxuICAgIGNvbnN0IGZvcm1hdFNxbFVwcGVyID0gZm9ybWF0U3FsLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgdGFncyA9IGRhdGV0aW1lRm9ybWF0Q29udmVydGVyLmZvcm1hdFRhZ3NNYXAoKTtcbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGZvcm1hdCBzdHJpbmdcbiAgICBjb25zdCBsZW5ndGggPSBmb3JtYXRTcWwubGVuZ3RoO1xuICAgIGxldCBmb3JtYXRNb21lbnQgPSAnJztcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW5ndGg7KSB7XG4gICAgICAgIGxldCB0YWcgPSBudWxsO1xuICAgICAgICBsZXQgb3V0ID0gbnVsbDtcbiAgICAgICAgLy8gYXQgZWFjaCBwb3NpdGlvbiwgY2hlY2sgaWYgdGhlcmUncyBhIHRhZyBhdCB0aGF0IHBvc2l0aW9uOyBpZiBzbywgdXNlXG4gICAgICAgIC8vICdvdXQnIGFzIHRoZSByZXBsYWNlbWVudFxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFncy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRTcWxVcHBlci5zdWJzdHIocG9zKS5pbmRleE9mKHRhZ3NbaW5kZXhdWzBdKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhZyA9IHRhZ3NbaW5kZXhdWzBdO1xuICAgICAgICAgICAgICAgIG91dCA9IHRhZ3NbaW5kZXhdWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbWF0Y2gsIGp1c3QgaW5zZXJ0IHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgZXNjYXBpbmcgaXRcbiAgICAgICAgLy8gKGJ5IHdyYXBwaW5nIGl0IGluIHNxdWFyZSBicmFja2V0cylcbiAgICAgICAgaWYgKG91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0TW9tZW50ICs9ICdbJyArIGZvcm1hdFNxbFtwb3NdICsgJ10nO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBmb3VuZCBvbmUgb2Ygb3VyIHNwZWNpYWwgdGFnc1xuICAgICAgICAgICAgaWYgKG91dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnVFpIJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXQgdGhlIG1vbWVudCB0byBnZXQgdGhlIHRpbWV6b25lIHN0cmluZyBhbmQgZXh0cmFjdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaG91cnM7IGZvciBleGFtcGxlLCAnLTA3MDAnIHdpbGwgYmUgY29udmVydGVkIHRvICctMDcnXG4gICAgICAgICAgICAgICAgICAgIG91dCA9IG1vbWVudC5mb3JtYXQoJ1paJykuc3Vic3RyKDAsIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YWcgPT09ICdUWk0nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdCB0aGUgbW9tZW50IHRvIGdldCB0aGUgdGltZXpvbmUgc3RyaW5nIGFuZCBleHRyYWN0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBtaW51dGVzOyBmb3IgZXhhbXBsZSwgJy0wNzAwJyB3aWxsIGJlIGNvbnZlcnRlZCB0byAnMDBcbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gbW9tZW50LmZvcm1hdCgnWlonKS5zdWJzdHIoMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ0ZGJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAnRkYnIGlzIGZvbGxvd2VkIGJ5IGEgZGlnaXQsIHVzZSB0aGUgZGlnaXQgYXMgdGhlIHNjYWxlXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0YWcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZm9ybWF0U3FsW3BvcyArIHRhZy5sZW5ndGhdLm1hdGNoKC9bMC05XS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdCA9IG1hdGNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IGRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7IC8vIHNraXAgdGhlIGRpZ2l0IGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZWVkIHRvIGluY2x1ZGUgZnJhY3Rpb25hbCBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdmlkZSB0aGUgbmFub1NlY29uZHMgdG8gZ2V0IHRoZSByZXF1ZXN0ZWQgbnVtYmVyIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFuaW5nZnVsIGRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkID0gTWF0aC5mbG9vcihuYW5vU2Vjb25kcyAvIE1hdGgucG93KDEwLCA5IC0gc2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gKG5ldyBBcnJheSg5KS5qb2luKCcwJykgKyBzY2FsZWQpLnN1YnN0cigtc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwZW5kIHRoZSAnb3V0JyB0ZXh0IHRvIHRoZSBtb21lbnQgZm9ybWF0IGFuZCB1cGRhdGUgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICBmb3JtYXRNb21lbnQgKz0gb3V0O1xuICAgICAgICAgICAgcG9zICs9IHRhZy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9ybWF0IHRoZSBtb21lbnQgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgICBjb25zdCB0aW1lem9uZSA9IHRoaXMudGltZXpvbmUubmFtZSB8fCB0aGlzLnRpbWV6b25lO1xuICAgIGlmICh0aW1lem9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWV6b25lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVBc1N0cmluZyA9IG1vbWVudC51dGNPZmZzZXQodGltZXpvbmUpLmZvcm1hdChmb3JtYXRNb21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVBc1N0cmluZyA9IG1vbWVudC50eih0aW1lem9uZSkuZm9ybWF0KGZvcm1hdE1vbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlQXNTdHJpbmcgPSBtb21lbnQuZm9ybWF0KGZvcm1hdE1vbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZUFzU3RyaW5nO1xufTtcbi8qKlxuICogQ29udmVydHMgdGhpcyBTZlRpbWVzdGFtcCB0byBhbiBTZkRhdGUgdGhhdCdzIGp1c3QgYSBub3JtYWwgSmF2YVNjcmlwdCBEYXRlXG4gKiB3aXRoIHNvbWUgYWRkaXRpb25hbCBtZXRob2RzIGxpa2UgZ2V0RXBvY2hTZWNvbmRzKCksIGdldE5hbm9TZWNvbmRzKCksXG4gKiBnZXRUaW1lem9uZSgpLCBldGMuXG4gKlxuICogQHJldHVybnMge0RhdGV9XG4gKi9cblNmVGltZXN0YW1wLnByb3RvdHlwZS50b1NmRGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjcmVhdGUgYSBEYXRlIGZyb20gdGhlIG1vbWVudFxuICAgIGNvbnN0IGRhdGUgPSB0aGlzLm1vbWVudC50b0RhdGUoKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBkYXRlLmdldEVwb2NoU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZXBvY2hTZWNvbmRzO1xuICAgIH07XG4gICAgZGF0ZS5nZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubmFub1NlY29uZHM7XG4gICAgfTtcbiAgICBkYXRlLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zY2FsZTtcbiAgICB9O1xuICAgIGRhdGUuZ2V0VGltZXpvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRpbWV6b25lO1xuICAgIH07XG4gICAgZGF0ZS5nZXRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmZvcm1hdDtcbiAgICB9O1xuICAgIGRhdGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIGRhdGU7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIFNmVGltZXN0YW1wIHRvIGFuIFNmVGltZSwgd2hpY2ggaXMganVzdCBhIEphdmFTY3JpcHQgT2JqZWN0XG4gKiB3aXRoIHNvbWUgbWV0aG9kczogZ2V0TWlkbmlnaHRTZWNvbmRzKCksIGdldE5hbm9TZWNvbmRzKCksIGV0Yy5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5TZlRpbWVzdGFtcC5wcm90b3R5cGUudG9TZlRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0TWlkbmlnaHRTZWNvbmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5lcG9jaFNlY29uZHM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE5hbm9TZWNvbmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5uYW5vU2Vjb25kcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNjYWxlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGb3JtYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi50b1N0cmluZygpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTZlRpbWVzdGFtcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNmX3RpbWVzdGFtcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nexports.isDml = function (statementTypeId) {\n    return statementTypeId >= 0x3000 && statementTypeId < 0x4000;\n};\nexports.isInsert = function (statementTypeId) {\n    return statementTypeId === 0x3100;\n};\nexports.isUpdate = function (statementTypeId) {\n    return statementTypeId === 0x3200;\n};\nexports.isDelete = function (statementTypeId) {\n    return statementTypeId === 0x3300;\n};\nexports.isMerge = function (statementTypeId) {\n    return statementTypeId === 0x3400;\n};\nexports.isMultiTableInsert = function (statementTypeId) {\n    return statementTypeId === 0x3500;\n};\nexports.isDdl = function (statementTypeId) {\n    return statementTypeId >= 0x6000;\n};\n//# sourceMappingURL=statement_type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9zdGF0ZW1lbnRfdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L3N0YXRlbWVudF90eXBlLmpzP2JmMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzRG1sID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnRUeXBlSWQgPj0gMHgzMDAwICYmIHN0YXRlbWVudFR5cGVJZCA8IDB4NDAwMDtcbn07XG5leHBvcnRzLmlzSW5zZXJ0ID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnRUeXBlSWQgPT09IDB4MzEwMDtcbn07XG5leHBvcnRzLmlzVXBkYXRlID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnRUeXBlSWQgPT09IDB4MzIwMDtcbn07XG5leHBvcnRzLmlzRGVsZXRlID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnRUeXBlSWQgPT09IDB4MzMwMDtcbn07XG5leHBvcnRzLmlzTWVyZ2UgPSBmdW5jdGlvbiAoc3RhdGVtZW50VHlwZUlkKSB7XG4gICAgcmV0dXJuIHN0YXRlbWVudFR5cGVJZCA9PT0gMHgzNDAwO1xufTtcbmV4cG9ydHMuaXNNdWx0aVRhYmxlSW5zZXJ0ID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnRUeXBlSWQgPT09IDB4MzUwMDtcbn07XG5leHBvcnRzLmlzRGRsID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnRUeXBlSWQgPj0gMHg2MDAwO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlbWVudF90eXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst resultContainsDuplicatedColumns = (rowtype) => {\n    const columnNames = rowtype.map((rt) => rt.name);\n    return columnNames.length !== new Set(columnNames).size;\n};\nfunction addOverriddenNamesForDuplicatedColumns(rowtype) {\n    //Prepare renamed columns for duplicates if row mode was set to 'object_with_renamed_duplicated_columns'\n    if (resultContainsDuplicatedColumns(rowtype)) {\n        const columnNames = new Set(rowtype.map((el) => el.name));\n        const quntityOfColumnNames = new Map();\n        for (let index = 0; index < rowtype.length; index++) {\n            const columnName = rowtype[index].name;\n            if (columnName) {\n                if (quntityOfColumnNames.has(columnName)) {\n                    let times = quntityOfColumnNames.get(columnName) + 1;\n                    let newColumnName = columnName + '_' + times;\n                    while (columnNames.has(newColumnName)) {\n                        times += 1;\n                        newColumnName = columnName + '_' + times;\n                    }\n                    quntityOfColumnNames.set(columnName, times);\n                    rowtype[index].overriddenName = newColumnName;\n                    columnNames.add(newColumnName);\n                }\n                else {\n                    quntityOfColumnNames.set(columnName, 1);\n                }\n            }\n        }\n    }\n}\nexports.addOverridenNamesForDuplicatedColumns = addOverriddenNamesForDuplicatedColumns;\n//# sourceMappingURL=unique_column_name_creator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC91bmlxdWVfY29sdW1uX25hbWVfY3JlYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9yZXN1bHQvdW5pcXVlX2NvbHVtbl9uYW1lX2NyZWF0b3IuanM/NGY3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHJlc3VsdENvbnRhaW5zRHVwbGljYXRlZENvbHVtbnMgPSAocm93dHlwZSkgPT4ge1xuICAgIGNvbnN0IGNvbHVtbk5hbWVzID0gcm93dHlwZS5tYXAoKHJ0KSA9PiBydC5uYW1lKTtcbiAgICByZXR1cm4gY29sdW1uTmFtZXMubGVuZ3RoICE9PSBuZXcgU2V0KGNvbHVtbk5hbWVzKS5zaXplO1xufTtcbmZ1bmN0aW9uIGFkZE92ZXJyaWRkZW5OYW1lc0ZvckR1cGxpY2F0ZWRDb2x1bW5zKHJvd3R5cGUpIHtcbiAgICAvL1ByZXBhcmUgcmVuYW1lZCBjb2x1bW5zIGZvciBkdXBsaWNhdGVzIGlmIHJvdyBtb2RlIHdhcyBzZXQgdG8gJ29iamVjdF93aXRoX3JlbmFtZWRfZHVwbGljYXRlZF9jb2x1bW5zJ1xuICAgIGlmIChyZXN1bHRDb250YWluc0R1cGxpY2F0ZWRDb2x1bW5zKHJvd3R5cGUpKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbk5hbWVzID0gbmV3IFNldChyb3d0eXBlLm1hcCgoZWwpID0+IGVsLm5hbWUpKTtcbiAgICAgICAgY29uc3QgcXVudGl0eU9mQ29sdW1uTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByb3d0eXBlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHJvd3R5cGVbaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICBpZiAoY29sdW1uTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChxdW50aXR5T2ZDb2x1bW5OYW1lcy5oYXMoY29sdW1uTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVzID0gcXVudGl0eU9mQ29sdW1uTmFtZXMuZ2V0KGNvbHVtbk5hbWUpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0NvbHVtbk5hbWUgPSBjb2x1bW5OYW1lICsgJ18nICsgdGltZXM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb2x1bW5OYW1lcy5oYXMobmV3Q29sdW1uTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW5OYW1lID0gY29sdW1uTmFtZSArICdfJyArIHRpbWVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHF1bnRpdHlPZkNvbHVtbk5hbWVzLnNldChjb2x1bW5OYW1lLCB0aW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIHJvd3R5cGVbaW5kZXhdLm92ZXJyaWRkZW5OYW1lID0gbmV3Q29sdW1uTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZXMuYWRkKG5ld0NvbHVtbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcXVudGl0eU9mQ29sdW1uTmFtZXMuc2V0KGNvbHVtbk5hbWUsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYWRkT3ZlcnJpZGVuTmFtZXNGb3JEdXBsaWNhdGVkQ29sdW1ucyA9IGFkZE92ZXJyaWRkZW5OYW1lc0ZvckR1cGxpY2F0ZWRDb2x1bW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlX2NvbHVtbl9uYW1lX2NyZWF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/statement.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Result = __webpack_require__(/*! ./result/result */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst RowStream = __webpack_require__(/*! ./result/row_stream */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst NativeTypes = (__webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\").NativeTypes);\nconst FileTransferAgent = __webpack_require__(/*! ../file_transfer_agent/file_transfer_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js\");\nconst Bind = __webpack_require__(/*! ./bind_uploader */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js\");\nconst RowMode = __webpack_require__(/*! ./../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\nconst states = {\n    FETCHING: 'fetching',\n    COMPLETE: 'complete',\n};\nconst statementTypes = {\n    ROW_PRE_EXEC: 'ROW_PRE_EXEC',\n    ROW_POST_EXEC: 'ROW_POST_EXEC',\n    FILE_PRE_EXEC: 'FILE_PRE_EXEC',\n    FILE_POST_EXEC: 'FILE_POST_EXEC',\n};\nconst queryCodes = {\n    QUERY_IN_PROGRESS: '333333', // GS code: the query is in progress\n    QUERY_IN_PROGRESS_ASYNC: '333334', // GS code: the query is detached\n};\nexports.createContext = function (options, services, connectionConfig) {\n    // create a statement context for a pre-exec statement\n    const context = createContextPreExec(options, services, connectionConfig);\n    context.type = statementTypes.FILE_PRE_EXEC;\n    // A hackish way to extend context with BaseStatement\n    new BaseStatement(options, context, services, connectionConfig);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersFile();\n    return context;\n};\n/**\n * Check the type of command to execute.\n *\n * @param {Object} options\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nexports.createStatementPreExec = function (options, services, connectionConfig) {\n    Logger.getInstance().debug('--createStatementPreExec');\n    // create a statement context for a pre-exec statement\n    const context = createContextPreExec(options, services, connectionConfig);\n    if (options.sqlText &&\n        (Util.isPutCommand(options.sqlText) || Util.isGetCommand(options.sqlText))) {\n        if (options.fileStream) {\n            context.fileStream = options.fileStream;\n            options.fileStream = null;\n        }\n        return createFileStatementPreExec(options, context, services, connectionConfig);\n    }\n    const numBinds = countBinding(context.binds);\n    Logger.getInstance().debug('numBinds = %d', numBinds);\n    let threshold = Parameters.getValue(Parameters.names.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD);\n    if (connectionConfig.getbindThreshold()) {\n        threshold = connectionConfig.getbindThreshold();\n    }\n    Logger.getInstance().debug('threshold = %d', threshold);\n    // check array binding,\n    if (numBinds > threshold) {\n        return createStageStatementpreExec(options, context, services, connectionConfig);\n    }\n    else {\n        return createRowStatementPreExec(options, context, services, connectionConfig);\n    }\n};\n/**\n * Executes a statement and returns a statement object that can be used to fetch\n * its result.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createRowStatementPreExec(statementOptions, statementContext, services, connectionConfig) {\n    // set the statement type\n    statementContext.type = statementTypes.ROW_PRE_EXEC;\n    return new RowStatementPreExec(statementOptions, statementContext, services, connectionConfig);\n}\n/**\n * Creates a statement object that can be used to fetch the result of a\n * previously executed statement.\n *\n * @param {Object} statementOptions\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nexports.createStatementPostExec = function (statementOptions, services, connectionConfig) {\n    // check for missing options\n    Errors.checkArgumentExists(Util.exists(statementOptions), ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_OPTIONS);\n    // check for invalid options\n    Errors.checkArgumentValid(Util.isObject(statementOptions), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_OPTIONS);\n    // check for missing query id\n    Errors.checkArgumentExists(Util.exists(statementOptions.queryId), ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID);\n    // check for invalid query id\n    Errors.checkArgumentValid(Util.isString(statementOptions.queryId), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID);\n    // check for invalid complete callback\n    const complete = statementOptions.complete;\n    if (Util.exists(complete)) {\n        Errors.checkArgumentValid(Util.isFunction(complete), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_COMPLETE);\n    }\n    // check for invalid streamResult\n    if (Util.exists(statementOptions.streamResult)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.streamResult), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT);\n    }\n    // check for invalid fetchAsString\n    const fetchAsString = statementOptions.fetchAsString;\n    if (Util.exists(fetchAsString)) {\n        // check that the value is an array\n        Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING);\n        // check that all the array elements are valid\n        const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n        Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n    }\n    const rowMode = statementOptions.rowMode;\n    if (Util.exists(rowMode)) {\n        RowMode.checkRowModeValid(rowMode);\n    }\n    const cwd = statementOptions.cwd;\n    if (Util.exists(cwd)) {\n        Errors.checkArgumentValid(Util.isString(cwd), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_CWD);\n    }\n    // validate non-user-specified arguments\n    Errors.assertInternal(Util.isObject(services));\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    // create a statement context\n    const statementContext = createStatementContext();\n    statementContext.queryId = statementOptions.queryId;\n    statementContext.complete = complete;\n    statementContext.streamResult = statementOptions.streamResult;\n    statementContext.fetchAsString = statementOptions.fetchAsString;\n    statementContext.multiResultIds = statementOptions.multiResultIds;\n    statementContext.multiSqlTexts = statementOptions.multiSqlTexts;\n    statementContext.multiCurId = statementOptions.multiCurId;\n    statementContext.rowMode = statementOptions.rowMode;\n    statementContext.cwd = statementOptions.cwd;\n    statementContext.sqlText = statementOptions.sqlText;\n    // set the statement type\n    statementContext.type =\n        statementContext.type === statementTypes.ROW_PRE_EXEC\n            ? statementTypes.ROW_POST_EXEC\n            : statementTypes.FILE_POST_EXEC;\n    return new StatementPostExec(statementOptions, statementContext, services, connectionConfig);\n};\n/**\n * Creates a new statement context object.\n *\n * @returns {Object}\n */\nfunction createStatementContext() {\n    return new EventEmitter();\n}\n/**\n * Creates a statement object that can be used to execute a PUT or GET file\n * operation.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createFileStatementPreExec(statementOptions, statementContext, services, connectionConfig) {\n    // set the statement type\n    statementContext.type = statementTypes.FILE_PRE_EXEC;\n    return new FileStatementPreExec(statementOptions, statementContext, services, connectionConfig);\n}\n/**\n * Creates a statement object that can be used to execute stage binding\n * operation.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createStageStatementpreExec(statementOptions, statementContext, services, connectionConfig) {\n    return new StageBindingStatementPreExec(statementOptions, statementContext, services, connectionConfig);\n}\n/**\n * Creates a statement context object for pre-exec statement.\n *\n * @param {Object} statementOptions\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createContextPreExec(statementOptions, services, connectionConfig) {\n    // check for missing options\n    Errors.checkArgumentExists(Util.exists(statementOptions), ErrorCodes.ERR_CONN_EXEC_STMT_MISSING_OPTIONS);\n    // check for invalid options\n    Errors.checkArgumentValid(Util.isObject(statementOptions), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_OPTIONS);\n    if (!Util.exists(statementOptions.requestId)) {\n        // check for missing sql text\n        Errors.checkArgumentExists(Util.exists(statementOptions.sqlText), ErrorCodes.ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT);\n        // check for invalid sql text\n        Errors.checkArgumentValid(Util.isString(statementOptions.sqlText), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT);\n    }\n    // check for invalid complete callback\n    const complete = statementOptions.complete;\n    if (Util.exists(complete)) {\n        Errors.checkArgumentValid(Util.isFunction(complete), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_COMPLETE);\n    }\n    // check for invalid streamResult\n    if (Util.exists(statementOptions.streamResult)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.streamResult), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT);\n    }\n    // check for invalid fetchAsString\n    const fetchAsString = statementOptions.fetchAsString;\n    if (Util.exists(fetchAsString)) {\n        // check that the value is an array\n        Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING);\n        // check that all the array elements are valid\n        const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n        Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n    }\n    // check for invalid requestId\n    if (Util.exists(statementOptions.requestId)) {\n        Errors.checkArgumentValid(Util.isString(statementOptions.requestId), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID);\n    }\n    // if parameters are specified, make sure the specified value is an object\n    if (Util.exists(statementOptions.parameters)) {\n        Errors.checkArgumentValid(Util.isObject(statementOptions.parameters), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_PARAMETERS);\n    }\n    // if binds are specified\n    const binds = statementOptions.binds;\n    if (Util.exists(binds)) {\n        // make sure the specified value is an array\n        Errors.checkArgumentValid(Util.isArray(binds), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_BINDS);\n        // make sure everything in the binds array is stringifiable\n        for (let index = 0, length = binds.length; index < length; index++) {\n            Errors.checkArgumentValid(JSON.stringify(binds[index]) !== undefined, ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES, binds[index]);\n        }\n    }\n    // if an internal option is specified, make sure it's boolean\n    if (Util.exists(statementOptions.internal)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.internal), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_INTERNAL);\n    }\n    const rowMode = statementOptions.rowMode;\n    if (Util.exists(rowMode)) {\n        RowMode.checkRowModeValid(rowMode);\n    }\n    // if an asyncExec flag is specified, make sure it's boolean\n    if (Util.exists(statementOptions.asyncExec)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.asyncExec), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC);\n    }\n    // if a describeOnly flag is specified, make sure it's boolean\n    if (Util.exists(statementOptions.describeOnly)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.describeOnly), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY);\n    }\n    // create a statement context\n    const statementContext = createStatementContext();\n    statementContext.sqlText = statementOptions.sqlText;\n    statementContext.complete = complete;\n    statementContext.streamResult = statementOptions.streamResult;\n    statementContext.fetchAsString = statementOptions.fetchAsString;\n    statementContext.multiResultIds = statementOptions.multiResultIds;\n    statementContext.multiCurId = statementOptions.multiCurId;\n    statementContext.rowMode = statementOptions.rowMode;\n    statementContext.asyncExec = statementOptions.asyncExec;\n    // if a binds array is specified, add it to the statement context\n    if (Util.exists(statementOptions.binds)) {\n        statementContext.binds = statementOptions.binds;\n    }\n    // if parameters are specified, add them to the statement context\n    if (Util.exists(statementOptions.parameters)) {\n        statementContext.parameters = statementOptions.parameters;\n    }\n    // if the internal flag is specified, add it to the statement context\n    if (Util.exists(statementOptions.internal)) {\n        statementContext.internal = statementOptions.internal;\n    }\n    if (Util.exists(statementOptions.cwd)) {\n        statementContext.cwd = statementOptions.cwd;\n    }\n    // if the describeOnly flag is specified, add it to the statement context\n    if (Util.exists(statementOptions.describeOnly)) {\n        statementContext.describeOnly = statementOptions.describeOnly;\n    }\n    // validate non-user-specified arguments\n    Errors.assertInternal(Util.isObject(services));\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    if (connectionConfig.queryTag) {\n        statementOptions.parameters = statementOptions.parameters || {};\n        statementOptions.parameters.QUERY_TAG = connectionConfig.queryTag;\n    }\n    // use request id passed by user\n    if (statementOptions.requestId) {\n        statementContext.requestId = statementOptions.requestId;\n        statementContext.resubmitRequest = true;\n    }\n    else {\n        // use a random uuid for the statement request id\n        statementContext.requestId = uuidv4();\n    }\n    return statementContext;\n}\n/**\n * Creates a new BaseStatement.\n *\n * @param statementOptions\n * @param context\n * @param services\n * @param connectionConfig\n * @constructor\n */\nfunction BaseStatement(statementOptions, context, services, connectionConfig) {\n    // call super\n    EventEmitter.call(this);\n    // validate input\n    Errors.assertInternal(Util.isObject(statementOptions));\n    Errors.assertInternal(Util.isObject(context));\n    context.services = services;\n    context.connectionConfig = connectionConfig;\n    context.isFetchingResult = true;\n    context.rowMode = statementOptions.rowMode || connectionConfig.getRowMode();\n    // TODO: add the parameters map to the statement context\n    const statement = this;\n    /**\n     * Returns this statement's SQL text.\n     *\n     * @returns {String}\n     */\n    this.getSqlText = function () {\n        return context.sqlText;\n    };\n    /**\n     * Returns the current status of this statement.\n     *\n     * @returns {String}\n     */\n    this.getStatus = function () {\n        return context.isFetchingResult ? states.FETCHING : states.COMPLETE;\n    };\n    /**\n     * Returns the columns produced by this statement.\n     *\n     * @returns {Object[]}\n     */\n    this.getColumns = function () {\n        return context.result ? context.result.getColumns() : undefined;\n    };\n    /**\n     * Given a column identifier, returns the corresponding column. The column\n     * identifier can be either the column name (String) or the column index\n     * (Number). If a column is specified and there is more than one column with\n     * that name, the first column with the specified name will be returned.\n     *\n     * @param {String | Number} columnIdentifier\n     *\n     * @returns {Object}\n     */\n    this.getColumn = function (columnIdentifier) {\n        return context.result ? context.result.getColumn(columnIdentifier) : undefined;\n    };\n    /**\n     * Returns the number of rows returned by this statement.\n     *\n     * @returns {Number}\n     */\n    this.getNumRows = function () {\n        return context.result ? context.result.getReturnedRows() : undefined;\n    };\n    /**\n     * Returns the number of rows updated by this statement.\n     *\n     * @returns {Number}\n     */\n    this.getNumUpdatedRows = function () {\n        return context.result ? context.result.getNumUpdatedRows() : undefined;\n    };\n    /**\n     * Returns an object that contains information about the values of the\n     * current warehouse, current database, etc., when this statement finished\n     * executing.\n     *\n     * @returns {Object}\n     */\n    this.getSessionState = function () {\n        return context.result ? context.result.getSessionState() : undefined;\n    };\n    /**\n     * Returns the request id that was used when the statement was issued.\n     *\n     * @returns {String}\n     */\n    this.getRequestId = function () {\n        return context.requestId;\n    };\n    /**\n     * Returns the query id generated by the server for this statement.\n     * If the statement is still executing and we don't know the query id\n     * yet, this method will return undefined.\n     *\n     * Should use getQueryId instead.\n     * @deprecated\n     * @returns {String}\n     */\n    this.getStatementId = function () {\n        return context.queryId;\n    };\n    /**\n     * Returns the query id generated by the server for this statement.\n     * If the statement is still executing and we don't know the query id\n     * yet, this method will return undefined.\n     *\n     * @returns {String}\n     */\n    this.getQueryId = function () {\n        return context.queryId;\n    };\n    /**\n     * Cancels this statement if possible.\n     *\n     * @param {Function} [callback]\n     */\n    this.cancel = function (callback) {\n        sendCancelStatement(context, statement, callback);\n    };\n    //Integration Testing purpose.\n    this.getQueryContextCacheSize = function () {\n        return services.sf.getQueryContextCacheSize();\n    };\n    this.getQueryContextDTOSize = function () {\n        return services.sf.getQueryContextDTO().entries.length;\n    };\n    /**\n     * Issues a request to get the statement result again.\n     *\n     * @param {Function} callback\n     */\n    context.refresh = function (callback) {\n        // pick the appropriate function to get the result based on whether we\n        // have the query id or request id (we should have at least one)\n        const sendRequestFn = context.queryId ? sendRequestPostExec : sendRequestPreExec;\n        // the current result error might be transient,\n        // so issue a request to get the result again\n        sendRequestFn(context, function (err, body) {\n            // refresh the result\n            context.onStatementRequestComp(err, body);\n            // if a callback was specified, invoke it\n            if (Util.isFunction(callback)) {\n                callback(context);\n            }\n        });\n    };\n    /**\n     * Called when the statement request is complete.\n     *\n     * @param err\n     * @param body\n     */\n    context.onStatementRequestComp = async function (err, body) {\n        // if we already have a result or a result error, we invoked the complete\n        // callback once, so don't invoke it again\n        const suppressComplete = context.result || context.resultError;\n        // clear the previous result error\n        context.resultError = null;\n        // if there was no error, call the success function\n        if (!err) {\n            await context.onStatementRequestSucc(body);\n        }\n        else {\n            // save the error\n            context.resultError = err;\n            // if we don't have a query id and we got a response from GS, extract\n            // the query id from the data\n            if (!context.queryId && Errors.isOperationFailedError(err) && err.data) {\n                context.queryId = err.data.queryId;\n            }\n        }\n        // we're no longer fetching the result\n        context.isFetchingResult = false;\n        if (!suppressComplete) {\n            // emit a complete event\n            context.emit('statement-complete', Errors.externalize(err), statement);\n            // if a complete function was specified, invoke it\n            if (Util.exists(context.complete)) {\n                invokeStatementComplete(statement, context);\n            }\n        }\n        else {\n            Logger.getInstance().debug('refreshed result of statement with %s', context.requestId\n                ? Util.format('request id = %s', context.requestId)\n                : Util.format('query id = %s', context.queryId));\n        }\n    };\n    /**\n     * Called when the statement request is successful. Subclasses must provide\n     * their own implementation.\n     */\n    context.onStatementRequestSucc = function () { };\n}\nUtil.inherits(BaseStatement, EventEmitter);\n/**\n * Invokes the statement complete callback.\n *\n * @param {Object} statement\n * @param {Object} context\n */\nfunction invokeStatementComplete(statement, context) {\n    // find out if the result will be streamed;\n    // if a value is not specified, get it from the connection\n    let streamResult = context.streamResult;\n    if (!Util.exists(streamResult)) {\n        streamResult = context.connectionConfig.getStreamResult();\n    }\n    // if the result will be streamed later or in asyncExec mode,\n    // invoke the complete callback right away\n    if (streamResult) {\n        context.complete(Errors.externalize(context.resultError), statement);\n    }\n    else if (context.asyncExec) {\n        // return the result object with the query ID inside.\n        context.complete(null, statement, context.result);\n    }\n    else {\n        process.nextTick(function () {\n            // aggregate all the rows into an array and pass this\n            // array to the complete callback as the last argument\n            const rows = [];\n            statement\n                .streamRows()\n                .on('readable', function () {\n                // read only when data is available\n                let row;\n                // while there are rows available to read, push row to results array\n                while ((row = this.read()) !== null) {\n                    rows.push(row);\n                }\n            })\n                .on('end', function () {\n                context.complete(null, statement, rows);\n            })\n                .on('error', function (err) {\n                context.complete(Errors.externalize(err), statement);\n            });\n        });\n    }\n}\n/**\n * Creates a new RowStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction RowStatementPreExec(statementOptions, context, services, connectionConfig) {\n    Logger.getInstance().debug('RowStatementPreExec');\n    // call super\n    BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersRow();\n    /**\n     * Called when the request to get the statement result is successful.\n     *\n     * @param {Object} body\n     */\n    context.onStatementRequestSucc = createOnStatementRequestSuccRow(this, context);\n    /**\n     * Fetches the rows in this statement's result and invokes the each()\n     * callback on each row. If start and end values are specified, the each()\n     * callback will only be invoked on rows in the specified range.\n     *\n     * @param {Object} options\n     */\n    this.fetchRows = createFnFetchRows(this, context);\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    // send a request to execute the statement\n    sendRequestPreExec(context, context.onStatementRequestComp);\n}\nUtil.inherits(RowStatementPreExec, BaseStatement);\n/**\n * Creates a function that can be used by row statements to process the response\n * when the request is successful.\n *\n * @param statement\n * @param context\n * @returns {Function}\n */\nfunction createOnStatementRequestSuccRow(statement, context) {\n    return function (body) {\n        // if we don't already have a result\n        if (!context.result) {\n            if (body.code === queryCodes.QUERY_IN_PROGRESS_ASYNC) {\n                context.result = {\n                    queryId: body.data.queryId,\n                };\n                return;\n            }\n            if (body.data.resultIds != null && body.data.resultIds.length > 0) {\n                //multi statements\n                this._resultIds = body.data.resultIds.split(',');\n                context.isMulti = true;\n                context.multiResultIds = this._resultIds;\n                context.multiSqlTexts = context.sqlText.split(';');\n                context.multiCurId = 0;\n                context.sqlText = context.multiSqlTexts[context.multiCurId];\n                context.queryId = this._resultIds[context.multiCurId];\n                exports.createStatementPostExec(context, context.services, context.connectionConfig);\n            }\n            else {\n                // build a result from the response\n                context.result = new Result({\n                    response: body,\n                    statement: statement,\n                    services: context.services,\n                    connectionConfig: context.connectionConfig,\n                    rowMode: context.rowMode,\n                });\n                context.queryId = context.result.getQueryId();\n                this.services.sf.deserializeQueryContext(context.result.getQueryContext());\n            }\n        }\n        else {\n            // refresh the existing result\n            context.result.refresh(body);\n        }\n        if (context.isMulti == null || context.isMulti === false) {\n            // only update the parameters if the statement isn't a post-exec statement\n            if (context.type !== statementTypes.ROW_POST_EXEC ||\n                context.type !== statementTypes.FILE_POST_EXEC) {\n                Parameters.update(context.result.getParametersArray());\n            }\n        }\n    };\n}\n/**\n * Creates a new FileStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction FileStatementPreExec(statementOptions, context, services, connectionConfig) {\n    // call super\n    BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersFile();\n    /**\n     * Called when the statement request is successful.\n     *\n     * @param {Object} body\n     */\n    context.onStatementRequestSucc = async function (body) {\n        await executeFileTransferRequest(context, body, this);\n    };\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    this.hasNext = hasNextResult(this, context);\n    this.NextResult = createNextReuslt(this, context);\n    /**\n     * Returns the file metadata generated by the statement.\n     *\n     * @returns {Object}\n     */\n    this.getFileMetadata = function () {\n        return context.fileMetadata;\n    };\n    // send a request to execute the file statement\n    sendRequestPreExec(context, context.onStatementRequestComp);\n}\nasync function executeFileTransferRequest(context, body, statement, fileTransferAgent) {\n    context.fileMetadata = body;\n    const fta = fileTransferAgent ?? new FileTransferAgent(context);\n    await fta.execute();\n    try {\n        // build a result from the response\n        const result = fta.result();\n        // init result and meta\n        body.data = {\n            rowset: result.rowset,\n            returned: result.rowset.length,\n            rowtype: result.rowtype,\n            parameters: [],\n        };\n        context.result = new Result({\n            response: body,\n            statement: statement,\n            services: context.services,\n            connectionConfig: context.connectionConfig,\n        });\n    }\n    catch (error) {\n        context.resultError = error;\n    }\n}\nexports.executeFileTransferRequest = executeFileTransferRequest;\nUtil.inherits(FileStatementPreExec, BaseStatement);\n/**\n * Creates a new StageBindingStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction StageBindingStatementPreExec(statementOptions, context, services, connectionConfig) {\n    // call super\n    BaseStatement.apply(this, arguments);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersFile();\n    /**\n     * Called when the statement request is successful. Subclasses must provide\n     * their own implementation.\n     */\n    context.onStatementRequestSucc = function () {\n        //do nothing\n    };\n    /**\n     * Called the stage binding request\n     *\n     * @param {Object} options\n     * @param {Object} context\n     * @param {Object} services\n     * @param {Object} connectionConfig\n     */\n    this.StageBindingRequest = async function (options, context, services, connectionConfig) {\n        try {\n            const bindUploaderRequestId = uuidv4();\n            const bind = new Bind.BindUploader(options, services, connectionConfig, bindUploaderRequestId);\n            context.bindStage = Bind.GetStageName(bindUploaderRequestId);\n            await bind.Upload(context.binds);\n            return createRowStatementPreExec(options, context, services, connectionConfig);\n        }\n        catch (error) {\n            context.bindStage = null;\n            return createRowStatementPreExec(options, context, services, connectionConfig);\n        }\n    };\n    /**\n     * Fetches the rows in this statement's result and invokes the each()\n     * callback on each row. If start and end values are specified, the each()\n     * callback will only be invoked on rows in the specified range.\n     *\n     * @param {Object} options\n     */\n    this.fetchRows = createFnFetchRows(this, context);\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    this.hasNext = hasNextResult(this, context);\n    this.NextResult = createNextReuslt(this, context);\n    this.StageBindingRequest(statementOptions, context, services, connectionConfig);\n}\nUtil.inherits(StageBindingStatementPreExec, BaseStatement);\n/**\n * Creates a new StatementPostExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction StatementPostExec(statementOptions, context, services, connectionConfig) {\n    // call super\n    BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersRow();\n    /**\n     * Called when the statement request is successful.\n     *\n     * @param {Object} body\n     */\n    context.onStatementRequestSucc = createOnStatementRequestSuccRow(this, context);\n    /**\n     * Fetches the rows in this statement's result and invokes the each()\n     * callback on each row. If startIndex and endIndex values are specified, the\n     * each() callback will only be invoked on rows in the requested range. The\n     * end() callback will be invoked when either all the requested rows have been\n     * successfully processed, or if an error was encountered while trying to\n     * fetch the requested rows.\n     *\n     * @param {Object} options\n     */\n    this.fetchRows = createFnFetchRows(this, context);\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    this.hasNext = hasNextResult(this, context);\n    this.NextResult = createNextReuslt(this, context);\n    // send a request to fetch the result\n    sendRequestPostExec(context, context.onStatementRequestComp);\n}\nUtil.inherits(StatementPostExec, BaseStatement);\n/**\n * Creates a function that fetches the rows in a statement's result and\n * invokes the each() callback on each row. If start and end values are\n * specified, the each() callback will only be invoked on rows in the\n * specified range.\n *\n * @param statement\n * @param context\n */\nfunction createFnFetchRows(statement, context) {\n    return function (options) {\n        // check for missing options\n        Errors.checkArgumentExists(Util.exists(options), ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_OPTIONS);\n        // check for invalid options\n        Errors.checkArgumentValid(Util.isObject(options), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_OPTIONS);\n        // check for missing each()\n        Errors.checkArgumentExists(Util.exists(options.each), ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_EACH);\n        // check for invalid each()\n        Errors.checkArgumentValid(Util.isFunction(options.each), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_EACH);\n        // check for missing end()\n        Errors.checkArgumentExists(Util.exists(options.end), ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_END);\n        // check for invalid end()\n        Errors.checkArgumentValid(Util.isFunction(options.end), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_END);\n        const rowMode = options.rowMode;\n        if (Util.exists(rowMode)) {\n            RowMode.checkRowModeValid(rowMode);\n        }\n        // if we're still trying to fetch the result, create an error of our own\n        // and invoke the end() callback\n        if (context.isFetchingResult) {\n            process.nextTick(function () {\n                options.end(Errors.createClientError(ErrorCodes.ERR_STMT_FETCH_ROWS_FETCHING_RESULT).externalize(), statement);\n            });\n        }\n        else if (context.resultError) {\n            // if there was an error the last time we tried to get the result\n            // if we have a fatal error, end the fetch rows operation since we're not\n            // going to be able to get any rows, either because the statement failed\n            // or because the result's been purged\n            if (Errors.isOperationFailedError(context.resultError) && context.resultError.sqlState) {\n                process.nextTick(function () {\n                    endFetchRows(options, statement, context);\n                });\n            }\n            else {\n                context.refresh(function () {\n                    // if there was no error, fetch rows from the result\n                    if (!context.resultError) {\n                        fetchRowsFromResult(options, statement, context);\n                    }\n                    else {\n                        // give up because it's unlikely we'll succeed if we retry again\n                        endFetchRows(options, statement, context);\n                    }\n                });\n            }\n        }\n        else {\n            fetchRowsFromResult(options, statement, context);\n        }\n    };\n}\n/**\n * Creates a function that streams the rows in a statement's result. If start\n * and end values are specified, only rows in the specified range are streamed.\n *\n * @param statement\n * @param context\n */\nfunction createFnStreamRows(statement, context) {\n    return function (options) {\n        // if some options are specified\n        if (Util.exists(options)) {\n            // check for invalid options\n            Errors.checkArgumentValid(Util.isObject(options), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_OPTIONS);\n            // check for invalid start\n            if (Util.exists(options.start)) {\n                Errors.checkArgumentValid(Util.isNumber(options.start), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_START);\n            }\n            // check for invalid end\n            if (Util.exists(options.end)) {\n                Errors.checkArgumentValid(Util.isNumber(options.end), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_END);\n            }\n            // check for invalid fetchAsString\n            const fetchAsString = options.fetchAsString;\n            if (Util.exists(fetchAsString)) {\n                // check that the value is an array\n                Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING);\n                // check that all the array elements are valid\n                const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n                Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n            }\n            const rowMode = context.rowMode;\n            if (Util.exists(rowMode)) {\n                RowMode.checkRowModeValid(rowMode);\n            }\n        }\n        return new RowStream(statement, context, options);\n    };\n}\n/**\n * Ends the fetchRows() operation.\n *\n * @param {Object} options the options passed to fetchRows().\n * @param {Object} statement\n * @param {Object} context\n */\nfunction endFetchRows(options, statement, context) {\n    options.end(Errors.externalize(context.resultError), statement);\n}\n/**\n * Fetches rows from the statement's result.\n *\n * @param {Object} options the options passed to fetchRows().\n * @param {Object} statement\n * @param {Object} context\n */\nfunction fetchRowsFromResult(options, statement, context) {\n    let numInterrupts = 0;\n    // forward to the result to get a FetchRowsOperation object\n    const operation = context.result.fetchRows(options);\n    // subscribe to the operation's 'complete' event\n    operation.on('complete', function (err, continueCallback) {\n        // we want to retry if the error is retryable and the\n        // result stream hasn't been closed too many times\n        if (Errors.isLargeResultSetError(err) &&\n            err.response &&\n            err.response.statusCode === 403 &&\n            numInterrupts < context.connectionConfig.getResultStreamInterrupts()) {\n            // increment the interrupt counter\n            numInterrupts++;\n            // issue a request to fetch the result again\n            sendRequestPostExec(context, function (err, body) {\n                // refresh the result\n                context.onStatementRequestComp(err, body);\n                // if there was no error, continue from where we got interrupted\n                if (!err) {\n                    continueCallback();\n                }\n            });\n        }\n        else {\n            endFetchRows(options, statement, context);\n        }\n    });\n}\n/**\n * Issues a request to cancel a statement.\n *\n * @param {Object} statementContext\n * @param {Object} statement\n * @param {Function} callback\n */\nfunction sendCancelStatement(statementContext, statement, callback) {\n    let url;\n    let json;\n    // use different rest endpoints based on whether the query id is available\n    if (statementContext.queryId) {\n        url = '/queries/' + statementContext.queryId + '/abort-request';\n    }\n    else {\n        url = '/queries/v1/abort-request';\n        json = {\n            requestId: statementContext.requestId,\n        };\n    }\n    // issue a request to cancel the statement\n    statementContext.services.sf.request({\n        method: 'POST',\n        url: url,\n        json: json,\n        callback: function (err) {\n            // if a callback was specified, invoke it\n            if (Util.isFunction(callback)) {\n                callback(Errors.externalize(err), statement);\n            }\n        },\n    });\n}\n/**\n * Issues a request to get the result of a statement that hasn't been previously\n * executed.\n *\n * @param statementContext\n * @param onResultAvailable\n */\nfunction sendRequestPreExec(statementContext, onResultAvailable) {\n    // get the request headers\n    const headers = statementContext.resultRequestHeaders;\n    // build the basic json for the request\n    const json = {\n        disableOfflineChunks: false,\n    };\n    json.sqlText = statementContext.sqlText;\n    if (statementContext.resubmitRequest && !json.sqlText) {\n        json.sqlText =\n            `SELECT 'Error retrieving query results for request id: ${statementContext.requestId}, ` +\n                \"please use RESULT_SCAN instead' AS ErrorMessage;\";\n    }\n    Logger.getInstance().debug('context.bindStage=' + statementContext.bindStage);\n    if (Util.exists(statementContext.bindStage)) {\n        json.bindStage = statementContext.bindStage;\n    }\n    else if (Util.exists(statementContext.binds)) {\n        // if binds are specified, build a binds map and include it in the request\n        json.bindings = buildBindsMap(statementContext.binds);\n    }\n    // include statement parameters if a value was specified\n    if (Util.exists(statementContext.parameters)) {\n        json.parameters = statementContext.parameters;\n        Logger.getInstance().debug('context.parameters=' + statementContext.parameters);\n    }\n    // include the internal flag if a value was specified\n    if (Util.exists(statementContext.internal)) {\n        json.isInternal = statementContext.internal;\n    }\n    if (!statementContext.disableQueryContextCache) {\n        json.queryContextDTO = statementContext.services.sf.getQueryContextDTO();\n    }\n    // include the asyncExec flag if a value was specified\n    if (Util.exists(statementContext.asyncExec)) {\n        json.asyncExec = statementContext.asyncExec;\n    }\n    // include describeOnly flag if a value was specified\n    if (Util.exists(statementContext.describeOnly)) {\n        json.describeOnly = statementContext.describeOnly;\n    }\n    // use the snowflake service to issue the request\n    sendSfRequest(statementContext, {\n        method: 'POST',\n        headers: headers,\n        url: Url.format({\n            pathname: '/queries/v1/query-request',\n            search: QueryString.stringify({\n                requestId: statementContext.requestId,\n            }),\n        }),\n        json: json,\n        callback: buildResultRequestCallback(statementContext, headers, onResultAvailable),\n    }, true);\n}\nthis.sendRequest = function (statementContext, onResultAvailable) {\n    // get the request headers\n    const headers = statementContext.resultRequestHeaders;\n    // build the basic json for the request\n    const json = {\n        disableOfflineChunks: false,\n        sqlText: statementContext.sqlText,\n    };\n    Logger.getInstance().debug('context.bindStage=' + statementContext.bindStage);\n    if (Util.exists(statementContext.bindStage)) {\n        json.bindStage = statementContext.bindStage;\n    }\n    else if (Util.exists(statementContext.binds)) {\n        // if binds are specified, build a binds map and include it in the request\n        json.bindings = buildBindsMap(statementContext.binds);\n    }\n    // include statement parameters if a value was specified\n    if (Util.exists(statementContext.parameters)) {\n        json.parameters = statementContext.parameters;\n    }\n    // include the internal flag if a value was specified\n    if (Util.exists(statementContext.internal)) {\n        json.isInternal = statementContext.internal;\n    }\n    if (!statementContext.disableQueryContextCache) {\n        json.queryContextDTO = statementContext.services.sf.getQueryContextDTO();\n    }\n    let options = {\n        method: 'POST',\n        headers: headers,\n        url: Url.format({\n            pathname: '/queries/v1/query-request',\n            search: QueryString.stringify({\n                requestId: statementContext.requestId,\n            }),\n        }),\n        json: json,\n        callback: buildResultRequestCallback(statementContext, headers, onResultAvailable),\n    };\n    const sf = statementContext.services.sf;\n    // clone the options\n    options = Util.apply({}, options);\n    return new Promise((resolve) => {\n        resolve(sf.postAsync(options));\n    });\n};\n/**\n * Converts a bind variables array to a map that can be included in the\n * POST-body when issuing a pre-exec statement request.\n *\n * @param bindsArray\n *\n * @returns {Object}\n */\nfunction buildBindsMap(bindsArray) {\n    const bindsMap = {};\n    const isArrayBinding = bindsArray.length > 0 && Util.isArray(bindsArray[0]);\n    const singleArray = isArrayBinding ? bindsArray[0] : bindsArray;\n    for (let index = 0, length = singleArray.length; index < length; index++) {\n        let value = singleArray[index];\n        // pick the appropriate logical data type based on the bind value\n        let type;\n        if (Util.isBoolean(value)) {\n            type = 'BOOLEAN';\n        }\n        else if (Util.isObject(value) || Util.isArray(value)) {\n            type = 'VARIANT';\n        }\n        else if (Util.isNumber(value)) {\n            if (Number(value) === value && value % 1 === 0) {\n                // if value is integer\n                type = 'FIXED';\n            }\n            else {\n                type = 'REAL';\n            }\n        }\n        else {\n            type = 'TEXT';\n        }\n        // convert non-null values to a string if necessary; we don't convert null\n        // because the client might want to run something like\n        //   sql text = update t set name = :1 where id = 1;, binds = [null]\n        // and converting null to a string would result in us executing\n        //   sql text = update t set name = 'null' where id = 1;\n        // instead of\n        //   sql text = update t set name = null where id = 1;\n        if (!isArrayBinding) {\n            if (value !== null && !Util.isString(value)) {\n                if (value instanceof Date) {\n                    value = value.toJSON();\n                }\n                else {\n                    value = JSON.stringify(value);\n                }\n            }\n        }\n        else {\n            value = [];\n            for (let rowIndex = 0; rowIndex < bindsArray.length; rowIndex++) {\n                let value0 = bindsArray[rowIndex][index];\n                if (value0 !== null && !Util.isString(value0)) {\n                    if (value0 instanceof Date) {\n                        value0 = value0.toJSON();\n                    }\n                    else {\n                        value0 = JSON.stringify(value0);\n                    }\n                }\n                value.push(value0);\n            }\n        }\n        // add an entry for the bind variable to the map\n        bindsMap[index + 1] = {\n            type: type,\n            value: value,\n        };\n    }\n    return bindsMap;\n}\n/**\n * Issues a request to get the result of a statement that has been previously\n * executed.\n *\n * @param statementContext\n * @param onResultAvailable\n */\nfunction sendRequestPostExec(statementContext, onResultAvailable) {\n    // get the request headers\n    const headers = statementContext.resultRequestHeaders;\n    // use the snowflake service to issue the request\n    sendSfRequest(statementContext, {\n        method: 'GET',\n        headers: headers,\n        url: Url.format({\n            pathname: '/queries/' + statementContext.queryId + '/result',\n            search: QueryString.stringify({\n                disableOfflineChunks: false,\n            }),\n        }),\n        callback: buildResultRequestCallback(statementContext, headers, onResultAvailable),\n    });\n}\n/**\n * Issues a statement-related request using the Snowflake service.\n *\n * @param {Object} statementContext the statement context.\n * @param {Object} options the request options.\n * @param {Boolean} [appendQueryParamOnRetry] whether retry=true should be\n *   appended to the url if the request is retried.\n */\nfunction sendSfRequest(statementContext, options, appendQueryParamOnRetry) {\n    const sf = statementContext.services.sf;\n    const connectionConfig = statementContext.connectionConfig;\n    // clone the options\n    options = Util.apply({}, options);\n    // get the original url and callback\n    const urlOrig = options.url;\n    const callbackOrig = options.callback;\n    let numRetries = 0;\n    const maxNumRetries = connectionConfig.getRetrySfMaxNumRetries();\n    let sleep = connectionConfig.getRetrySfStartingSleepTime();\n    let lastStatusCodeForRetry;\n    // create a function to send the request\n    const sendRequest = function () {\n        // if this is a retry and a query parameter should be appended to the url on\n        // retry, update the url\n        if (numRetries > 0 && appendQueryParamOnRetry) {\n            const retryOption = {\n                url: urlOrig,\n                retryCount: numRetries,\n                retryReason: lastStatusCodeForRetry,\n                includeRetryReason: connectionConfig.getIncludeRetryReason(),\n            };\n            options.url = Util.url.appendRetryParam(retryOption);\n        }\n        sf.request(options);\n    };\n    // replace the specified callback with a new one that retries\n    options.callback = async function (err) {\n        // if we haven't exceeded the maximum number of retries yet and the server\n        // came back with a retryable error code\n        if (numRetries < maxNumRetries &&\n            err &&\n            Util.isRetryableHttpError(err.response, false)) {\n            // increment the retry count\n            numRetries++;\n            lastStatusCodeForRetry = err.response ? err.response.statusCode : 0;\n            // use exponential backoff with decorrelated jitter to compute the\n            // next sleep time.\n            const cap = connectionConfig.getRetrySfMaxSleepTime();\n            sleep = Util.nextSleepTime(1, cap, sleep);\n            Logger.getInstance().debug('Retrying statement with request id %s, retry count = %s', statementContext.requestId, numRetries);\n            // wait the appropriate amount of time before retrying the request\n            setTimeout(sendRequest, sleep * 1000);\n        }\n        else {\n            // invoke the original callback\n            await callbackOrig.apply(this, arguments);\n        }\n    };\n    // issue the request\n    sendRequest();\n}\n/**\n * Builds a callback for use in an exec-statement or fetch-result request.\n *\n * @param statementContext\n * @param headers\n * @param onResultAvailable\n *\n * @returns {Function}\n */\nfunction buildResultRequestCallback(statementContext, headers, onResultAvailable) {\n    const callback = async function (err, body) {\n        if (err) {\n            await onResultAvailable.call(null, err, null);\n        }\n        else {\n            // extract the query id from the response and save it\n            statementContext.queryId = body.data.queryId;\n            // if the result is not ready yet, extract the result url from the response\n            // and issue a GET request to try to fetch the result again unless asyncExec is enabled.\n            if (body &&\n                (body.code === queryCodes.QUERY_IN_PROGRESS ||\n                    body.code === queryCodes.QUERY_IN_PROGRESS_ASYNC)) {\n                if (statementContext.asyncExec) {\n                    await onResultAvailable.call(null, err, body);\n                    return;\n                }\n                // extract the result url from the response and try to get the result\n                // again\n                sendSfRequest(statementContext, {\n                    method: 'GET',\n                    headers: headers,\n                    url: body.data.getResultUrl,\n                    callback: callback,\n                });\n            }\n            else {\n                await onResultAvailable.call(null, err, body);\n            }\n        }\n    };\n    return callback;\n}\n/**\n * Builds the request headers for a row statement request.\n *\n * @returns {Object}\n */\nfunction buildResultRequestHeadersRow() {\n    return {\n        Accept: 'application/snowflake',\n    };\n}\n/**\n * Builds the request headers for a file statement request.\n *\n * @returns {Object}\n */\nfunction buildResultRequestHeadersFile() {\n    return {\n        Accept: 'application/json',\n    };\n}\n/**\n * Count number of bindings\n *\n * @returns {int}\n */\nfunction countBinding(binds) {\n    if (!Util.isArray(binds)) {\n        return 0;\n    }\n    Logger.getInstance().debug('-- binds.length= %d', binds.length);\n    let count = 0;\n    for (let index = 0; index < binds.length; index++) {\n        if (binds[index] != null && Util.isArray(binds[index])) {\n            count += binds[index].length;\n        }\n    }\n    return count;\n}\nfunction hasNextResult(statement, context) {\n    return function () {\n        return context.multiResultIds != null && context.multiCurId + 1 < context.multiResultIds.length;\n    };\n}\nfunction createNextReuslt(statement, context) {\n    return function () {\n        if (hasNextResult(statement, context)) {\n            context.multiCurId++;\n            context.queryId = context.multiResultIds[context.multiCurId];\n            context.sqlText = context.multiSqlTexts[context.multiCurId];\n            exports.createStatementPostExec(context, context.services, context.connectionConfig);\n        }\n    };\n}\n//# sourceMappingURL=statement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3N0YXRlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsOERBQU07QUFDckMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxnR0FBaUI7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsd0dBQXFCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyxvQkFBb0IsMklBQTBDO0FBQzlELDBCQUEwQixtQkFBTyxDQUFDLDBJQUE0QztBQUM5RSxhQUFhLG1CQUFPLENBQUMsZ0dBQWlCO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLGtHQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMkJBQTJCO0FBQ2pHLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vc3RhdGVtZW50LmpzPzQyNGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoJ3V1aWQnKTtcbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgUXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0L3Jlc3VsdCcpO1xuY29uc3QgUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4uL3BhcmFtZXRlcnMnKTtcbmNvbnN0IFJvd1N0cmVhbSA9IHJlcXVpcmUoJy4vcmVzdWx0L3Jvd19zdHJlYW0nKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgTmF0aXZlVHlwZXMgPSByZXF1aXJlKCcuL3Jlc3VsdC9kYXRhX3R5cGVzJykuTmF0aXZlVHlwZXM7XG5jb25zdCBGaWxlVHJhbnNmZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ZpbGVfdHJhbnNmZXJfYWdlbnQvZmlsZV90cmFuc2Zlcl9hZ2VudCcpO1xuY29uc3QgQmluZCA9IHJlcXVpcmUoJy4vYmluZF91cGxvYWRlcicpO1xuY29uc3QgUm93TW9kZSA9IHJlcXVpcmUoJy4vLi4vY29uc3RhbnRzL3Jvd19tb2RlJyk7XG5jb25zdCBzdGF0ZXMgPSB7XG4gICAgRkVUQ0hJTkc6ICdmZXRjaGluZycsXG4gICAgQ09NUExFVEU6ICdjb21wbGV0ZScsXG59O1xuY29uc3Qgc3RhdGVtZW50VHlwZXMgPSB7XG4gICAgUk9XX1BSRV9FWEVDOiAnUk9XX1BSRV9FWEVDJyxcbiAgICBST1dfUE9TVF9FWEVDOiAnUk9XX1BPU1RfRVhFQycsXG4gICAgRklMRV9QUkVfRVhFQzogJ0ZJTEVfUFJFX0VYRUMnLFxuICAgIEZJTEVfUE9TVF9FWEVDOiAnRklMRV9QT1NUX0VYRUMnLFxufTtcbmNvbnN0IHF1ZXJ5Q29kZXMgPSB7XG4gICAgUVVFUllfSU5fUFJPR1JFU1M6ICczMzMzMzMnLCAvLyBHUyBjb2RlOiB0aGUgcXVlcnkgaXMgaW4gcHJvZ3Jlc3NcbiAgICBRVUVSWV9JTl9QUk9HUkVTU19BU1lOQzogJzMzMzMzNCcsIC8vIEdTIGNvZGU6IHRoZSBxdWVyeSBpcyBkZXRhY2hlZFxufTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIC8vIGNyZWF0ZSBhIHN0YXRlbWVudCBjb250ZXh0IGZvciBhIHByZS1leGVjIHN0YXRlbWVudFxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb250ZXh0UHJlRXhlYyhvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgY29udGV4dC50eXBlID0gc3RhdGVtZW50VHlwZXMuRklMRV9QUkVfRVhFQztcbiAgICAvLyBBIGhhY2tpc2ggd2F5IHRvIGV4dGVuZCBjb250ZXh0IHdpdGggQmFzZVN0YXRlbWVudFxuICAgIG5ldyBCYXNlU3RhdGVtZW50KG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAvLyBhZGQgdGhlIHJlc3VsdCByZXF1ZXN0IGhlYWRlcnMgdG8gdGhlIGNvbnRleHRcbiAgICBjb250ZXh0LnJlc3VsdFJlcXVlc3RIZWFkZXJzID0gYnVpbGRSZXN1bHRSZXF1ZXN0SGVhZGVyc0ZpbGUoKTtcbiAgICByZXR1cm4gY29udGV4dDtcbn07XG4vKipcbiAqIENoZWNrIHRoZSB0eXBlIG9mIGNvbW1hbmQgdG8gZXhlY3V0ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY3JlYXRlU3RhdGVtZW50UHJlRXhlYyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCctLWNyZWF0ZVN0YXRlbWVudFByZUV4ZWMnKTtcbiAgICAvLyBjcmVhdGUgYSBzdGF0ZW1lbnQgY29udGV4dCBmb3IgYSBwcmUtZXhlYyBzdGF0ZW1lbnRcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29udGV4dFByZUV4ZWMob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgIGlmIChvcHRpb25zLnNxbFRleHQgJiZcbiAgICAgICAgKFV0aWwuaXNQdXRDb21tYW5kKG9wdGlvbnMuc3FsVGV4dCkgfHwgVXRpbC5pc0dldENvbW1hbmQob3B0aW9ucy5zcWxUZXh0KSkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsZVN0cmVhbSkge1xuICAgICAgICAgICAgY29udGV4dC5maWxlU3RyZWFtID0gb3B0aW9ucy5maWxlU3RyZWFtO1xuICAgICAgICAgICAgb3B0aW9ucy5maWxlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRmlsZVN0YXRlbWVudFByZUV4ZWMob3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBudW1CaW5kcyA9IGNvdW50QmluZGluZyhjb250ZXh0LmJpbmRzKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnbnVtQmluZHMgPSAlZCcsIG51bUJpbmRzKTtcbiAgICBsZXQgdGhyZXNob2xkID0gUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLkNMSUVOVF9TVEFHRV9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCk7XG4gICAgaWYgKGNvbm5lY3Rpb25Db25maWcuZ2V0YmluZFRocmVzaG9sZCgpKSB7XG4gICAgICAgIHRocmVzaG9sZCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0YmluZFRocmVzaG9sZCgpO1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygndGhyZXNob2xkID0gJWQnLCB0aHJlc2hvbGQpO1xuICAgIC8vIGNoZWNrIGFycmF5IGJpbmRpbmcsXG4gICAgaWYgKG51bUJpbmRzID4gdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTdGFnZVN0YXRlbWVudHByZUV4ZWMob3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJvd1N0YXRlbWVudFByZUV4ZWMob3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbn07XG4vKipcbiAqIEV4ZWN1dGVzIGEgc3RhdGVtZW50IGFuZCByZXR1cm5zIGEgc3RhdGVtZW50IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGZldGNoXG4gKiBpdHMgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvd1N0YXRlbWVudFByZUV4ZWMoc3RhdGVtZW50T3B0aW9ucywgc3RhdGVtZW50Q29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvLyBzZXQgdGhlIHN0YXRlbWVudCB0eXBlXG4gICAgc3RhdGVtZW50Q29udGV4dC50eXBlID0gc3RhdGVtZW50VHlwZXMuUk9XX1BSRV9FWEVDO1xuICAgIHJldHVybiBuZXcgUm93U3RhdGVtZW50UHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZW1lbnQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZmV0Y2ggdGhlIHJlc3VsdCBvZiBhXG4gKiBwcmV2aW91c2x5IGV4ZWN1dGVkIHN0YXRlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY3JlYXRlU3RhdGVtZW50UG9zdEV4ZWMgPSBmdW5jdGlvbiAoc3RhdGVtZW50T3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBvcHRpb25zXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfT1BUSU9OUyk7XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgb3B0aW9uc1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChzdGF0ZW1lbnRPcHRpb25zKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9PUFRJT05TKTtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBxdWVyeSBpZFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMucXVlcnlJZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfUVVFUllfSUQpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHF1ZXJ5IGlkXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHN0YXRlbWVudE9wdGlvbnMucXVlcnlJZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfUVVFUllfSUQpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGNvbXBsZXRlIGNhbGxiYWNrXG4gICAgY29uc3QgY29tcGxldGUgPSBzdGF0ZW1lbnRPcHRpb25zLmNvbXBsZXRlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhjb21wbGV0ZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzRnVuY3Rpb24oY29tcGxldGUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NPTVBMRVRFKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgc3RyZWFtUmVzdWx0XG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMuc3RyZWFtUmVzdWx0KSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHN0YXRlbWVudE9wdGlvbnMuc3RyZWFtUmVzdWx0KSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9TVFJFQU1fUkVTVUxUKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgZmV0Y2hBc1N0cmluZ1xuICAgIGNvbnN0IGZldGNoQXNTdHJpbmcgPSBzdGF0ZW1lbnRPcHRpb25zLmZldGNoQXNTdHJpbmc7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGZldGNoQXNTdHJpbmcpKSB7XG4gICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0FycmF5KGZldGNoQXNTdHJpbmcpLCBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0ZFVENIX0FTX1NUUklORyk7XG4gICAgICAgIC8vIGNoZWNrIHRoYXQgYWxsIHRoZSBhcnJheSBlbGVtZW50cyBhcmUgdmFsaWRcbiAgICAgICAgY29uc3QgaW52YWxpZFZhbHVlSW5kZXggPSBOYXRpdmVUeXBlcy5maW5kSW52YWxpZFZhbHVlKGZldGNoQXNTdHJpbmcpO1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKGludmFsaWRWYWx1ZUluZGV4ID09PSAtMSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdfVkFMVUVTLCBKU09OLnN0cmluZ2lmeShmZXRjaEFzU3RyaW5nW2ludmFsaWRWYWx1ZUluZGV4XSkpO1xuICAgIH1cbiAgICBjb25zdCByb3dNb2RlID0gc3RhdGVtZW50T3B0aW9ucy5yb3dNb2RlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhyb3dNb2RlKSkge1xuICAgICAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICAgIH1cbiAgICBjb25zdCBjd2QgPSBzdGF0ZW1lbnRPcHRpb25zLmN3ZDtcbiAgICBpZiAoVXRpbC5leGlzdHMoY3dkKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcoY3dkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9DV0QpO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSBub24tdXNlci1zcGVjaWZpZWQgYXJndW1lbnRzXG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qoc2VydmljZXMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25uZWN0aW9uQ29uZmlnKSk7XG4gICAgLy8gY3JlYXRlIGEgc3RhdGVtZW50IGNvbnRleHRcbiAgICBjb25zdCBzdGF0ZW1lbnRDb250ZXh0ID0gY3JlYXRlU3RhdGVtZW50Q29udGV4dCgpO1xuICAgIHN0YXRlbWVudENvbnRleHQucXVlcnlJZCA9IHN0YXRlbWVudE9wdGlvbnMucXVlcnlJZDtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgc3RhdGVtZW50Q29udGV4dC5zdHJlYW1SZXN1bHQgPSBzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdDtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LmZldGNoQXNTdHJpbmcgPSBzdGF0ZW1lbnRPcHRpb25zLmZldGNoQXNTdHJpbmc7XG4gICAgc3RhdGVtZW50Q29udGV4dC5tdWx0aVJlc3VsdElkcyA9IHN0YXRlbWVudE9wdGlvbnMubXVsdGlSZXN1bHRJZHM7XG4gICAgc3RhdGVtZW50Q29udGV4dC5tdWx0aVNxbFRleHRzID0gc3RhdGVtZW50T3B0aW9ucy5tdWx0aVNxbFRleHRzO1xuICAgIHN0YXRlbWVudENvbnRleHQubXVsdGlDdXJJZCA9IHN0YXRlbWVudE9wdGlvbnMubXVsdGlDdXJJZDtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnJvd01vZGUgPSBzdGF0ZW1lbnRPcHRpb25zLnJvd01vZGU7XG4gICAgc3RhdGVtZW50Q29udGV4dC5jd2QgPSBzdGF0ZW1lbnRPcHRpb25zLmN3ZDtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnNxbFRleHQgPSBzdGF0ZW1lbnRPcHRpb25zLnNxbFRleHQ7XG4gICAgLy8gc2V0IHRoZSBzdGF0ZW1lbnQgdHlwZVxuICAgIHN0YXRlbWVudENvbnRleHQudHlwZSA9XG4gICAgICAgIHN0YXRlbWVudENvbnRleHQudHlwZSA9PT0gc3RhdGVtZW50VHlwZXMuUk9XX1BSRV9FWEVDXG4gICAgICAgICAgICA/IHN0YXRlbWVudFR5cGVzLlJPV19QT1NUX0VYRUNcbiAgICAgICAgICAgIDogc3RhdGVtZW50VHlwZXMuRklMRV9QT1NUX0VYRUM7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZW1lbnRQb3N0RXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHN0YXRlbWVudCBjb250ZXh0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZW1lbnRDb250ZXh0KCkge1xuICAgIHJldHVybiBuZXcgRXZlbnRFbWl0dGVyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZW1lbnQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSBhIFBVVCBvciBHRVQgZmlsZVxuICogb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVTdGF0ZW1lbnRQcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gc2V0IHRoZSBzdGF0ZW1lbnQgdHlwZVxuICAgIHN0YXRlbWVudENvbnRleHQudHlwZSA9IHN0YXRlbWVudFR5cGVzLkZJTEVfUFJFX0VYRUM7XG4gICAgcmV0dXJuIG5ldyBGaWxlU3RhdGVtZW50UHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZW1lbnQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSBzdGFnZSBiaW5kaW5nXG4gKiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhZ2VTdGF0ZW1lbnRwcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBTdGFnZUJpbmRpbmdTdGF0ZW1lbnRQcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHN0YXRlbWVudCBjb250ZXh0IG9iamVjdCBmb3IgcHJlLWV4ZWMgc3RhdGVtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dFByZUV4ZWMoc3RhdGVtZW50T3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBvcHRpb25zXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX01JU1NJTkdfT1BUSU9OUyk7XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgb3B0aW9uc1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChzdGF0ZW1lbnRPcHRpb25zKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9PUFRJT05TKTtcbiAgICBpZiAoIVV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMucmVxdWVzdElkKSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBzcWwgdGV4dFxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnNxbFRleHQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9NSVNTSU5HX1NRTF9URVhUKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgc3FsIHRleHRcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHN0YXRlbWVudE9wdGlvbnMuc3FsVGV4dCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfU1FMX1RFWFQpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBjb21wbGV0ZSBjYWxsYmFja1xuICAgIGNvbnN0IGNvbXBsZXRlID0gc3RhdGVtZW50T3B0aW9ucy5jb21wbGV0ZTtcbiAgICBpZiAoVXRpbC5leGlzdHMoY29tcGxldGUpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Z1bmN0aW9uKGNvbXBsZXRlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9DT01QTEVURSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHN0cmVhbVJlc3VsdFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdCkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfU1RSRUFNX1JFU1VMVCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZldGNoQXNTdHJpbmdcbiAgICBjb25zdCBmZXRjaEFzU3RyaW5nID0gc3RhdGVtZW50T3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgIGlmIChVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNBcnJheShmZXRjaEFzU3RyaW5nKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkcpO1xuICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCB0aGUgYXJyYXkgZWxlbWVudHMgYXJlIHZhbGlkXG4gICAgICAgIGNvbnN0IGludmFsaWRWYWx1ZUluZGV4ID0gTmF0aXZlVHlwZXMuZmluZEludmFsaWRWYWx1ZShmZXRjaEFzU3RyaW5nKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChpbnZhbGlkVmFsdWVJbmRleCA9PT0gLTEsIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUywgSlNPTi5zdHJpbmdpZnkoZmV0Y2hBc1N0cmluZ1tpbnZhbGlkVmFsdWVJbmRleF0pKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcmVxdWVzdElkXG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMucmVxdWVzdElkKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcoc3RhdGVtZW50T3B0aW9ucy5yZXF1ZXN0SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1JFUVVFU1RfSUQpO1xuICAgIH1cbiAgICAvLyBpZiBwYXJhbWV0ZXJzIGFyZSBzcGVjaWZpZWQsIG1ha2Ugc3VyZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChzdGF0ZW1lbnRPcHRpb25zLnBhcmFtZXRlcnMpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1BBUkFNRVRFUlMpO1xuICAgIH1cbiAgICAvLyBpZiBiaW5kcyBhcmUgc3BlY2lmaWVkXG4gICAgY29uc3QgYmluZHMgPSBzdGF0ZW1lbnRPcHRpb25zLmJpbmRzO1xuICAgIGlmIChVdGlsLmV4aXN0cyhiaW5kcykpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQXJyYXkoYmluZHMpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0JJTkRTKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgaW4gdGhlIGJpbmRzIGFycmF5IGlzIHN0cmluZ2lmaWFibGVcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBiaW5kcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKEpTT04uc3RyaW5naWZ5KGJpbmRzW2luZGV4XSkgIT09IHVuZGVmaW5lZCwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9CSU5EX1ZBTFVFUywgYmluZHNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBhbiBpbnRlcm5hbCBvcHRpb24gaXMgc3BlY2lmaWVkLCBtYWtlIHN1cmUgaXQncyBib29sZWFuXG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMuaW50ZXJuYWwpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oc3RhdGVtZW50T3B0aW9ucy5pbnRlcm5hbCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfSU5URVJOQUwpO1xuICAgIH1cbiAgICBjb25zdCByb3dNb2RlID0gc3RhdGVtZW50T3B0aW9ucy5yb3dNb2RlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhyb3dNb2RlKSkge1xuICAgICAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICAgIH1cbiAgICAvLyBpZiBhbiBhc3luY0V4ZWMgZmxhZyBpcyBzcGVjaWZpZWQsIG1ha2Ugc3VyZSBpdCdzIGJvb2xlYW5cbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5hc3luY0V4ZWMpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oc3RhdGVtZW50T3B0aW9ucy5hc3luY0V4ZWMpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0FTWU5DX0VYRUMpO1xuICAgIH1cbiAgICAvLyBpZiBhIGRlc2NyaWJlT25seSBmbGFnIGlzIHNwZWNpZmllZCwgbWFrZSBzdXJlIGl0J3MgYm9vbGVhblxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmRlc2NyaWJlT25seSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihzdGF0ZW1lbnRPcHRpb25zLmRlc2NyaWJlT25seSksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfREVTQ1JJQkVfT05MWSk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIHN0YXRlbWVudCBjb250ZXh0XG4gICAgY29uc3Qgc3RhdGVtZW50Q29udGV4dCA9IGNyZWF0ZVN0YXRlbWVudENvbnRleHQoKTtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnNxbFRleHQgPSBzdGF0ZW1lbnRPcHRpb25zLnNxbFRleHQ7XG4gICAgc3RhdGVtZW50Q29udGV4dC5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIHN0YXRlbWVudENvbnRleHQuc3RyZWFtUmVzdWx0ID0gc3RhdGVtZW50T3B0aW9ucy5zdHJlYW1SZXN1bHQ7XG4gICAgc3RhdGVtZW50Q29udGV4dC5mZXRjaEFzU3RyaW5nID0gc3RhdGVtZW50T3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgIHN0YXRlbWVudENvbnRleHQubXVsdGlSZXN1bHRJZHMgPSBzdGF0ZW1lbnRPcHRpb25zLm11bHRpUmVzdWx0SWRzO1xuICAgIHN0YXRlbWVudENvbnRleHQubXVsdGlDdXJJZCA9IHN0YXRlbWVudE9wdGlvbnMubXVsdGlDdXJJZDtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnJvd01vZGUgPSBzdGF0ZW1lbnRPcHRpb25zLnJvd01vZGU7XG4gICAgc3RhdGVtZW50Q29udGV4dC5hc3luY0V4ZWMgPSBzdGF0ZW1lbnRPcHRpb25zLmFzeW5jRXhlYztcbiAgICAvLyBpZiBhIGJpbmRzIGFycmF5IGlzIHNwZWNpZmllZCwgYWRkIGl0IHRvIHRoZSBzdGF0ZW1lbnQgY29udGV4dFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmJpbmRzKSkge1xuICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LmJpbmRzID0gc3RhdGVtZW50T3B0aW9ucy5iaW5kcztcbiAgICB9XG4gICAgLy8gaWYgcGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkLCBhZGQgdGhlbSB0byB0aGUgc3RhdGVtZW50IGNvbnRleHRcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzKSkge1xuICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LnBhcmFtZXRlcnMgPSBzdGF0ZW1lbnRPcHRpb25zLnBhcmFtZXRlcnM7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBpbnRlcm5hbCBmbGFnIGlzIHNwZWNpZmllZCwgYWRkIGl0IHRvIHRoZSBzdGF0ZW1lbnQgY29udGV4dFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmludGVybmFsKSkge1xuICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LmludGVybmFsID0gc3RhdGVtZW50T3B0aW9ucy5pbnRlcm5hbDtcbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMuY3dkKSkge1xuICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LmN3ZCA9IHN0YXRlbWVudE9wdGlvbnMuY3dkO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgZGVzY3JpYmVPbmx5IGZsYWcgaXMgc3BlY2lmaWVkLCBhZGQgaXQgdG8gdGhlIHN0YXRlbWVudCBjb250ZXh0XG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMuZGVzY3JpYmVPbmx5KSkge1xuICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LmRlc2NyaWJlT25seSA9IHN0YXRlbWVudE9wdGlvbnMuZGVzY3JpYmVPbmx5O1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSBub24tdXNlci1zcGVjaWZpZWQgYXJndW1lbnRzXG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qoc2VydmljZXMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25uZWN0aW9uQ29uZmlnKSk7XG4gICAgaWYgKGNvbm5lY3Rpb25Db25maWcucXVlcnlUYWcpIHtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzID0gc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzIHx8IHt9O1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLnBhcmFtZXRlcnMuUVVFUllfVEFHID0gY29ubmVjdGlvbkNvbmZpZy5xdWVyeVRhZztcbiAgICB9XG4gICAgLy8gdXNlIHJlcXVlc3QgaWQgcGFzc2VkIGJ5IHVzZXJcbiAgICBpZiAoc3RhdGVtZW50T3B0aW9ucy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWQgPSBzdGF0ZW1lbnRPcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5yZXN1Ym1pdFJlcXVlc3QgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGEgcmFuZG9tIHV1aWQgZm9yIHRoZSBzdGF0ZW1lbnQgcmVxdWVzdCBpZFxuICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LnJlcXVlc3RJZCA9IHV1aWR2NCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVtZW50Q29udGV4dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBCYXNlU3RhdGVtZW50LlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHBhcmFtIHNlcnZpY2VzXG4gKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJhc2VTdGF0ZW1lbnQoc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvLyBjYWxsIHN1cGVyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChzdGF0ZW1lbnRPcHRpb25zKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29udGV4dCkpO1xuICAgIGNvbnRleHQuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcgPSBjb25uZWN0aW9uQ29uZmlnO1xuICAgIGNvbnRleHQuaXNGZXRjaGluZ1Jlc3VsdCA9IHRydWU7XG4gICAgY29udGV4dC5yb3dNb2RlID0gc3RhdGVtZW50T3B0aW9ucy5yb3dNb2RlIHx8IGNvbm5lY3Rpb25Db25maWcuZ2V0Um93TW9kZSgpO1xuICAgIC8vIFRPRE86IGFkZCB0aGUgcGFyYW1ldGVycyBtYXAgdG8gdGhlIHN0YXRlbWVudCBjb250ZXh0XG4gICAgY29uc3Qgc3RhdGVtZW50ID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgc3RhdGVtZW50J3MgU1FMIHRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3FsVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuc3FsVGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoaXMgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuaXNGZXRjaGluZ1Jlc3VsdCA/IHN0YXRlcy5GRVRDSElORyA6IHN0YXRlcy5DT01QTEVURTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbHVtbnMgcHJvZHVjZWQgYnkgdGhpcyBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgdGhpcy5nZXRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5yZXN1bHQgPyBjb250ZXh0LnJlc3VsdC5nZXRDb2x1bW5zKCkgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGNvbHVtbiBpZGVudGlmaWVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbi4gVGhlIGNvbHVtblxuICAgICAqIGlkZW50aWZpZXIgY2FuIGJlIGVpdGhlciB0aGUgY29sdW1uIG5hbWUgKFN0cmluZykgb3IgdGhlIGNvbHVtbiBpbmRleFxuICAgICAqIChOdW1iZXIpLiBJZiBhIGNvbHVtbiBpcyBzcGVjaWZpZWQgYW5kIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29sdW1uIHdpdGhcbiAgICAgKiB0aGF0IG5hbWUsIHRoZSBmaXJzdCBjb2x1bW4gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBjb2x1bW5JZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzdWx0ID8gY29udGV4dC5yZXN1bHQuZ2V0Q29sdW1uKGNvbHVtbklkZW50aWZpZXIpIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgcmV0dXJuZWQgYnkgdGhpcyBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TnVtUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzdWx0ID8gY29udGV4dC5yZXN1bHQuZ2V0UmV0dXJuZWRSb3dzKCkgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkIGJ5IHRoaXMgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldE51bVVwZGF0ZWRSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5yZXN1bHQgPyBjb250ZXh0LnJlc3VsdC5nZXROdW1VcGRhdGVkUm93cygpIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmFsdWVzIG9mIHRoZVxuICAgICAqIGN1cnJlbnQgd2FyZWhvdXNlLCBjdXJyZW50IGRhdGFiYXNlLCBldGMuLCB3aGVuIHRoaXMgc3RhdGVtZW50IGZpbmlzaGVkXG4gICAgICogZXhlY3V0aW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldFNlc3Npb25TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzdWx0ID8gY29udGV4dC5yZXN1bHQuZ2V0U2Vzc2lvblN0YXRlKCkgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXF1ZXN0IGlkIHRoYXQgd2FzIHVzZWQgd2hlbiB0aGUgc3RhdGVtZW50IHdhcyBpc3N1ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UmVxdWVzdElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5yZXF1ZXN0SWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBxdWVyeSBpZCBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBmb3IgdGhpcyBzdGF0ZW1lbnQuXG4gICAgICogSWYgdGhlIHN0YXRlbWVudCBpcyBzdGlsbCBleGVjdXRpbmcgYW5kIHdlIGRvbid0IGtub3cgdGhlIHF1ZXJ5IGlkXG4gICAgICogeWV0LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBTaG91bGQgdXNlIGdldFF1ZXJ5SWQgaW5zdGVhZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRTdGF0ZW1lbnRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlJZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHF1ZXJ5IGlkIGdlbmVyYXRlZCBieSB0aGUgc2VydmVyIGZvciB0aGlzIHN0YXRlbWVudC5cbiAgICAgKiBJZiB0aGUgc3RhdGVtZW50IGlzIHN0aWxsIGV4ZWN1dGluZyBhbmQgd2UgZG9uJ3Qga25vdyB0aGUgcXVlcnkgaWRcbiAgICAgKiB5ZXQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRRdWVyeUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5xdWVyeUlkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGlzIHN0YXRlbWVudCBpZiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBzZW5kQ2FuY2VsU3RhdGVtZW50KGNvbnRleHQsIHN0YXRlbWVudCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy9JbnRlZ3JhdGlvbiBUZXN0aW5nIHB1cnBvc2UuXG4gICAgdGhpcy5nZXRRdWVyeUNvbnRleHRDYWNoZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlcy5zZi5nZXRRdWVyeUNvbnRleHRDYWNoZVNpemUoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UXVlcnlDb250ZXh0RFRPU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzLnNmLmdldFF1ZXJ5Q29udGV4dERUTygpLmVudHJpZXMubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXNzdWVzIGEgcmVxdWVzdCB0byBnZXQgdGhlIHN0YXRlbWVudCByZXN1bHQgYWdhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNvbnRleHQucmVmcmVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAvLyBwaWNrIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvbiB0byBnZXQgdGhlIHJlc3VsdCBiYXNlZCBvbiB3aGV0aGVyIHdlXG4gICAgICAgIC8vIGhhdmUgdGhlIHF1ZXJ5IGlkIG9yIHJlcXVlc3QgaWQgKHdlIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSlcbiAgICAgICAgY29uc3Qgc2VuZFJlcXVlc3RGbiA9IGNvbnRleHQucXVlcnlJZCA/IHNlbmRSZXF1ZXN0UG9zdEV4ZWMgOiBzZW5kUmVxdWVzdFByZUV4ZWM7XG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHJlc3VsdCBlcnJvciBtaWdodCBiZSB0cmFuc2llbnQsXG4gICAgICAgIC8vIHNvIGlzc3VlIGEgcmVxdWVzdCB0byBnZXQgdGhlIHJlc3VsdCBhZ2FpblxuICAgICAgICBzZW5kUmVxdWVzdEZuKGNvbnRleHQsIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIHJlc3VsdFxuICAgICAgICAgICAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RDb21wKGVyciwgYm9keSk7XG4gICAgICAgICAgICAvLyBpZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIGludm9rZSBpdFxuICAgICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdGVtZW50IHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyXG4gICAgICogQHBhcmFtIGJvZHlcbiAgICAgKi9cbiAgICBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdENvbXAgPSBhc3luYyBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHJlc3VsdCBvciBhIHJlc3VsdCBlcnJvciwgd2UgaW52b2tlZCB0aGUgY29tcGxldGVcbiAgICAgICAgLy8gY2FsbGJhY2sgb25jZSwgc28gZG9uJ3QgaW52b2tlIGl0IGFnYWluXG4gICAgICAgIGNvbnN0IHN1cHByZXNzQ29tcGxldGUgPSBjb250ZXh0LnJlc3VsdCB8fCBjb250ZXh0LnJlc3VsdEVycm9yO1xuICAgICAgICAvLyBjbGVhciB0aGUgcHJldmlvdXMgcmVzdWx0IGVycm9yXG4gICAgICAgIGNvbnRleHQucmVzdWx0RXJyb3IgPSBudWxsO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgbm8gZXJyb3IsIGNhbGwgdGhlIHN1Y2Nlc3MgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyhib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhdmUgdGhlIGVycm9yXG4gICAgICAgICAgICBjb250ZXh0LnJlc3VsdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhIHF1ZXJ5IGlkIGFuZCB3ZSBnb3QgYSByZXNwb25zZSBmcm9tIEdTLCBleHRyYWN0XG4gICAgICAgICAgICAvLyB0aGUgcXVlcnkgaWQgZnJvbSB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnF1ZXJ5SWQgJiYgRXJyb3JzLmlzT3BlcmF0aW9uRmFpbGVkRXJyb3IoZXJyKSAmJiBlcnIuZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucXVlcnlJZCA9IGVyci5kYXRhLnF1ZXJ5SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UncmUgbm8gbG9uZ2VyIGZldGNoaW5nIHRoZSByZXN1bHRcbiAgICAgICAgY29udGV4dC5pc0ZldGNoaW5nUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmICghc3VwcHJlc3NDb21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gZW1pdCBhIGNvbXBsZXRlIGV2ZW50XG4gICAgICAgICAgICBjb250ZXh0LmVtaXQoJ3N0YXRlbWVudC1jb21wbGV0ZScsIEVycm9ycy5leHRlcm5hbGl6ZShlcnIpLCBzdGF0ZW1lbnQpO1xuICAgICAgICAgICAgLy8gaWYgYSBjb21wbGV0ZSBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkLCBpbnZva2UgaXRcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhjb250ZXh0LmNvbXBsZXRlKSkge1xuICAgICAgICAgICAgICAgIGludm9rZVN0YXRlbWVudENvbXBsZXRlKHN0YXRlbWVudCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygncmVmcmVzaGVkIHJlc3VsdCBvZiBzdGF0ZW1lbnQgd2l0aCAlcycsIGNvbnRleHQucmVxdWVzdElkXG4gICAgICAgICAgICAgICAgPyBVdGlsLmZvcm1hdCgncmVxdWVzdCBpZCA9ICVzJywgY29udGV4dC5yZXF1ZXN0SWQpXG4gICAgICAgICAgICAgICAgOiBVdGlsLmZvcm1hdCgncXVlcnkgaWQgPSAlcycsIGNvbnRleHQucXVlcnlJZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdGVtZW50IHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC4gU3ViY2xhc3NlcyBtdXN0IHByb3ZpZGVcbiAgICAgKiB0aGVpciBvd24gaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RTdWNjID0gZnVuY3Rpb24gKCkgeyB9O1xufVxuVXRpbC5pbmhlcml0cyhCYXNlU3RhdGVtZW50LCBFdmVudEVtaXR0ZXIpO1xuLyoqXG4gKiBJbnZva2VzIHRoZSBzdGF0ZW1lbnQgY29tcGxldGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaW52b2tlU3RhdGVtZW50Q29tcGxldGUoc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gICAgLy8gZmluZCBvdXQgaWYgdGhlIHJlc3VsdCB3aWxsIGJlIHN0cmVhbWVkO1xuICAgIC8vIGlmIGEgdmFsdWUgaXMgbm90IHNwZWNpZmllZCwgZ2V0IGl0IGZyb20gdGhlIGNvbm5lY3Rpb25cbiAgICBsZXQgc3RyZWFtUmVzdWx0ID0gY29udGV4dC5zdHJlYW1SZXN1bHQ7XG4gICAgaWYgKCFVdGlsLmV4aXN0cyhzdHJlYW1SZXN1bHQpKSB7XG4gICAgICAgIHN0cmVhbVJlc3VsdCA9IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRTdHJlYW1SZXN1bHQoKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJlc3VsdCB3aWxsIGJlIHN0cmVhbWVkIGxhdGVyIG9yIGluIGFzeW5jRXhlYyBtb2RlLFxuICAgIC8vIGludm9rZSB0aGUgY29tcGxldGUgY2FsbGJhY2sgcmlnaHQgYXdheVxuICAgIGlmIChzdHJlYW1SZXN1bHQpIHtcbiAgICAgICAgY29udGV4dC5jb21wbGV0ZShFcnJvcnMuZXh0ZXJuYWxpemUoY29udGV4dC5yZXN1bHRFcnJvciksIHN0YXRlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQuYXN5bmNFeGVjKSB7XG4gICAgICAgIC8vIHJldHVybiB0aGUgcmVzdWx0IG9iamVjdCB3aXRoIHRoZSBxdWVyeSBJRCBpbnNpZGUuXG4gICAgICAgIGNvbnRleHQuY29tcGxldGUobnVsbCwgc3RhdGVtZW50LCBjb250ZXh0LnJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGFnZ3JlZ2F0ZSBhbGwgdGhlIHJvd3MgaW50byBhbiBhcnJheSBhbmQgcGFzcyB0aGlzXG4gICAgICAgICAgICAvLyBhcnJheSB0byB0aGUgY29tcGxldGUgY2FsbGJhY2sgYXMgdGhlIGxhc3QgYXJndW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlbWVudFxuICAgICAgICAgICAgICAgIC5zdHJlYW1Sb3dzKClcbiAgICAgICAgICAgICAgICAub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHJlYWQgb25seSB3aGVuIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgbGV0IHJvdztcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSB0aGVyZSBhcmUgcm93cyBhdmFpbGFibGUgdG8gcmVhZCwgcHVzaCByb3cgdG8gcmVzdWx0cyBhcnJheVxuICAgICAgICAgICAgICAgIHdoaWxlICgocm93ID0gdGhpcy5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wbGV0ZShudWxsLCBzdGF0ZW1lbnQsIHJvd3MpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcGxldGUoRXJyb3JzLmV4dGVybmFsaXplKGVyciksIHN0YXRlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJvd1N0YXRlbWVudFByZUV4ZWMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUm93U3RhdGVtZW50UHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdSb3dTdGF0ZW1lbnRQcmVFeGVjJyk7XG4gICAgLy8gY2FsbCBzdXBlclxuICAgIEJhc2VTdGF0ZW1lbnQuYXBwbHkodGhpcywgW3N0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnXSk7XG4gICAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gICAgY29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycyA9IGJ1aWxkUmVzdWx0UmVxdWVzdEhlYWRlcnNSb3coKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCB0byBnZXQgdGhlIHN0YXRlbWVudCByZXN1bHQgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAgICovXG4gICAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RTdWNjID0gY3JlYXRlT25TdGF0ZW1lbnRSZXF1ZXN0U3VjY1Jvdyh0aGlzLCBjb250ZXh0KTtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSByb3dzIGluIHRoaXMgc3RhdGVtZW50J3MgcmVzdWx0IGFuZCBpbnZva2VzIHRoZSBlYWNoKClcbiAgICAgKiBjYWxsYmFjayBvbiBlYWNoIHJvdy4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlIHNwZWNpZmllZCwgdGhlIGVhY2goKVxuICAgICAqIGNhbGxiYWNrIHdpbGwgb25seSBiZSBpbnZva2VkIG9uIHJvd3MgaW4gdGhlIHNwZWNpZmllZCByYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5mZXRjaFJvd3MgPSBjcmVhdGVGbkZldGNoUm93cyh0aGlzLCBjb250ZXh0KTtcbiAgICAvKipcbiAgICAgKiBTdHJlYW1zIHRoZSByb3dzIGluIHRoaXMgc3RhdGVtZW50J3MgcmVzdWx0LiBJZiBzdGFydCBhbmQgZW5kIHZhbHVlcyBhcmVcbiAgICAgKiBzcGVjaWZpZWQsIG9ubHkgcm93cyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlIGFyZSBzdHJlYW1lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5zdHJlYW1Sb3dzID0gY3JlYXRlRm5TdHJlYW1Sb3dzKHRoaXMsIGNvbnRleHQpO1xuICAgIC8vIHNlbmQgYSByZXF1ZXN0IHRvIGV4ZWN1dGUgdGhlIHN0YXRlbWVudFxuICAgIHNlbmRSZXF1ZXN0UHJlRXhlYyhjb250ZXh0LCBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdENvbXApO1xufVxuVXRpbC5pbmhlcml0cyhSb3dTdGF0ZW1lbnRQcmVFeGVjLCBCYXNlU3RhdGVtZW50KTtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgYnkgcm93IHN0YXRlbWVudHMgdG8gcHJvY2VzcyB0aGUgcmVzcG9uc2VcbiAqIHdoZW4gdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50XG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVPblN0YXRlbWVudFJlcXVlc3RTdWNjUm93KHN0YXRlbWVudCwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSByZXN1bHRcbiAgICAgICAgaWYgKCFjb250ZXh0LnJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGJvZHkuY29kZSA9PT0gcXVlcnlDb2Rlcy5RVUVSWV9JTl9QUk9HUkVTU19BU1lOQykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeUlkOiBib2R5LmRhdGEucXVlcnlJZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib2R5LmRhdGEucmVzdWx0SWRzICE9IG51bGwgJiYgYm9keS5kYXRhLnJlc3VsdElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy9tdWx0aSBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0SWRzID0gYm9keS5kYXRhLnJlc3VsdElkcy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaXNNdWx0aSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tdWx0aVJlc3VsdElkcyA9IHRoaXMuX3Jlc3VsdElkcztcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm11bHRpU3FsVGV4dHMgPSBjb250ZXh0LnNxbFRleHQuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm11bHRpQ3VySWQgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3FsVGV4dCA9IGNvbnRleHQubXVsdGlTcWxUZXh0c1tjb250ZXh0Lm11bHRpQ3VySWRdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucXVlcnlJZCA9IHRoaXMuX3Jlc3VsdElkc1tjb250ZXh0Lm11bHRpQ3VySWRdO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuY3JlYXRlU3RhdGVtZW50UG9zdEV4ZWMoY29udGV4dCwgY29udGV4dC5zZXJ2aWNlcywgY29udGV4dC5jb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgcmVzdWx0IGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN1bHQgPSBuZXcgUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudDogc3RhdGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlczogY29udGV4dC5zZXJ2aWNlcyxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZzogY29udGV4dC5jb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICByb3dNb2RlOiBjb250ZXh0LnJvd01vZGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5xdWVyeUlkID0gY29udGV4dC5yZXN1bHQuZ2V0UXVlcnlJZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZXMuc2YuZGVzZXJpYWxpemVRdWVyeUNvbnRleHQoY29udGV4dC5yZXN1bHQuZ2V0UXVlcnlDb250ZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgZXhpc3RpbmcgcmVzdWx0XG4gICAgICAgICAgICBjb250ZXh0LnJlc3VsdC5yZWZyZXNoKGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmlzTXVsdGkgPT0gbnVsbCB8fCBjb250ZXh0LmlzTXVsdGkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0aGUgcGFyYW1ldGVycyBpZiB0aGUgc3RhdGVtZW50IGlzbid0IGEgcG9zdC1leGVjIHN0YXRlbWVudFxuICAgICAgICAgICAgaWYgKGNvbnRleHQudHlwZSAhPT0gc3RhdGVtZW50VHlwZXMuUk9XX1BPU1RfRVhFQyB8fFxuICAgICAgICAgICAgICAgIGNvbnRleHQudHlwZSAhPT0gc3RhdGVtZW50VHlwZXMuRklMRV9QT1NUX0VYRUMpIHtcbiAgICAgICAgICAgICAgICBQYXJhbWV0ZXJzLnVwZGF0ZShjb250ZXh0LnJlc3VsdC5nZXRQYXJhbWV0ZXJzQXJyYXkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEZpbGVTdGF0ZW1lbnRQcmVFeGVjIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGVTdGF0ZW1lbnRQcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gY2FsbCBzdXBlclxuICAgIEJhc2VTdGF0ZW1lbnQuYXBwbHkodGhpcywgW3N0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnXSk7XG4gICAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gICAgY29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycyA9IGJ1aWxkUmVzdWx0UmVxdWVzdEhlYWRlcnNGaWxlKCk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlbWVudCByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgICAqL1xuICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyA9IGFzeW5jIGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGF3YWl0IGV4ZWN1dGVGaWxlVHJhbnNmZXJSZXF1ZXN0KGNvbnRleHQsIGJvZHksIHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RyZWFtcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdC4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlXG4gICAgICogc3BlY2lmaWVkLCBvbmx5IHJvd3MgaW4gdGhlIHNwZWNpZmllZCByYW5nZSBhcmUgc3RyZWFtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtUm93cyA9IGNyZWF0ZUZuU3RyZWFtUm93cyh0aGlzLCBjb250ZXh0KTtcbiAgICB0aGlzLmhhc05leHQgPSBoYXNOZXh0UmVzdWx0KHRoaXMsIGNvbnRleHQpO1xuICAgIHRoaXMuTmV4dFJlc3VsdCA9IGNyZWF0ZU5leHRSZXVzbHQodGhpcywgY29udGV4dCk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlsZSBtZXRhZGF0YSBnZW5lcmF0ZWQgYnkgdGhlIHN0YXRlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRGaWxlTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmZpbGVNZXRhZGF0YTtcbiAgICB9O1xuICAgIC8vIHNlbmQgYSByZXF1ZXN0IHRvIGV4ZWN1dGUgdGhlIGZpbGUgc3RhdGVtZW50XG4gICAgc2VuZFJlcXVlc3RQcmVFeGVjKGNvbnRleHQsIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0Q29tcCk7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlRmlsZVRyYW5zZmVyUmVxdWVzdChjb250ZXh0LCBib2R5LCBzdGF0ZW1lbnQsIGZpbGVUcmFuc2ZlckFnZW50KSB7XG4gICAgY29udGV4dC5maWxlTWV0YWRhdGEgPSBib2R5O1xuICAgIGNvbnN0IGZ0YSA9IGZpbGVUcmFuc2ZlckFnZW50ID8/IG5ldyBGaWxlVHJhbnNmZXJBZ2VudChjb250ZXh0KTtcbiAgICBhd2FpdCBmdGEuZXhlY3V0ZSgpO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGJ1aWxkIGEgcmVzdWx0IGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZ0YS5yZXN1bHQoKTtcbiAgICAgICAgLy8gaW5pdCByZXN1bHQgYW5kIG1ldGFcbiAgICAgICAgYm9keS5kYXRhID0ge1xuICAgICAgICAgICAgcm93c2V0OiByZXN1bHQucm93c2V0LFxuICAgICAgICAgICAgcmV0dXJuZWQ6IHJlc3VsdC5yb3dzZXQubGVuZ3RoLFxuICAgICAgICAgICAgcm93dHlwZTogcmVzdWx0LnJvd3R5cGUsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29udGV4dC5yZXN1bHQgPSBuZXcgUmVzdWx0KHtcbiAgICAgICAgICAgIHJlc3BvbnNlOiBib2R5LFxuICAgICAgICAgICAgc3RhdGVtZW50OiBzdGF0ZW1lbnQsXG4gICAgICAgICAgICBzZXJ2aWNlczogY29udGV4dC5zZXJ2aWNlcyxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Db25maWc6IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250ZXh0LnJlc3VsdEVycm9yID0gZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5leGVjdXRlRmlsZVRyYW5zZmVyUmVxdWVzdCA9IGV4ZWN1dGVGaWxlVHJhbnNmZXJSZXF1ZXN0O1xuVXRpbC5pbmhlcml0cyhGaWxlU3RhdGVtZW50UHJlRXhlYywgQmFzZVN0YXRlbWVudCk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3RhZ2VCaW5kaW5nU3RhdGVtZW50UHJlRXhlYyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdGFnZUJpbmRpbmdTdGF0ZW1lbnRQcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gY2FsbCBzdXBlclxuICAgIEJhc2VTdGF0ZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBhZGQgdGhlIHJlc3VsdCByZXF1ZXN0IGhlYWRlcnMgdG8gdGhlIGNvbnRleHRcbiAgICBjb250ZXh0LnJlc3VsdFJlcXVlc3RIZWFkZXJzID0gYnVpbGRSZXN1bHRSZXF1ZXN0SGVhZGVyc0ZpbGUoKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdGVtZW50IHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC4gU3ViY2xhc3NlcyBtdXN0IHByb3ZpZGVcbiAgICAgKiB0aGVpciBvd24gaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RTdWNjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2RvIG5vdGhpbmdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB0aGUgc3RhZ2UgYmluZGluZyByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAgICAgKi9cbiAgICB0aGlzLlN0YWdlQmluZGluZ1JlcXVlc3QgPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRVcGxvYWRlclJlcXVlc3RJZCA9IHV1aWR2NCgpO1xuICAgICAgICAgICAgY29uc3QgYmluZCA9IG5ldyBCaW5kLkJpbmRVcGxvYWRlcihvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZywgYmluZFVwbG9hZGVyUmVxdWVzdElkKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmluZFN0YWdlID0gQmluZC5HZXRTdGFnZU5hbWUoYmluZFVwbG9hZGVyUmVxdWVzdElkKTtcbiAgICAgICAgICAgIGF3YWl0IGJpbmQuVXBsb2FkKGNvbnRleHQuYmluZHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJvd1N0YXRlbWVudFByZUV4ZWMob3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29udGV4dC5iaW5kU3RhZ2UgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJvd1N0YXRlbWVudFByZUV4ZWMob3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSByb3dzIGluIHRoaXMgc3RhdGVtZW50J3MgcmVzdWx0IGFuZCBpbnZva2VzIHRoZSBlYWNoKClcbiAgICAgKiBjYWxsYmFjayBvbiBlYWNoIHJvdy4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlIHNwZWNpZmllZCwgdGhlIGVhY2goKVxuICAgICAqIGNhbGxiYWNrIHdpbGwgb25seSBiZSBpbnZva2VkIG9uIHJvd3MgaW4gdGhlIHNwZWNpZmllZCByYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5mZXRjaFJvd3MgPSBjcmVhdGVGbkZldGNoUm93cyh0aGlzLCBjb250ZXh0KTtcbiAgICAvKipcbiAgICAgKiBTdHJlYW1zIHRoZSByb3dzIGluIHRoaXMgc3RhdGVtZW50J3MgcmVzdWx0LiBJZiBzdGFydCBhbmQgZW5kIHZhbHVlcyBhcmVcbiAgICAgKiBzcGVjaWZpZWQsIG9ubHkgcm93cyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlIGFyZSBzdHJlYW1lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5zdHJlYW1Sb3dzID0gY3JlYXRlRm5TdHJlYW1Sb3dzKHRoaXMsIGNvbnRleHQpO1xuICAgIHRoaXMuaGFzTmV4dCA9IGhhc05leHRSZXN1bHQodGhpcywgY29udGV4dCk7XG4gICAgdGhpcy5OZXh0UmVzdWx0ID0gY3JlYXRlTmV4dFJldXNsdCh0aGlzLCBjb250ZXh0KTtcbiAgICB0aGlzLlN0YWdlQmluZGluZ1JlcXVlc3Qoc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xufVxuVXRpbC5pbmhlcml0cyhTdGFnZUJpbmRpbmdTdGF0ZW1lbnRQcmVFeGVjLCBCYXNlU3RhdGVtZW50KTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTdGF0ZW1lbnRQb3N0RXhlYyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdGF0ZW1lbnRQb3N0RXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIC8vIGNhbGwgc3VwZXJcbiAgICBCYXNlU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZ10pO1xuICAgIC8vIGFkZCB0aGUgcmVzdWx0IHJlcXVlc3QgaGVhZGVycyB0byB0aGUgY29udGV4dFxuICAgIGNvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnMgPSBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzUm93KCk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlbWVudCByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgICAqL1xuICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyA9IGNyZWF0ZU9uU3RhdGVtZW50UmVxdWVzdFN1Y2NSb3codGhpcywgY29udGV4dCk7XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdCBhbmQgaW52b2tlcyB0aGUgZWFjaCgpXG4gICAgICogY2FsbGJhY2sgb24gZWFjaCByb3cuIElmIHN0YXJ0SW5kZXggYW5kIGVuZEluZGV4IHZhbHVlcyBhcmUgc3BlY2lmaWVkLCB0aGVcbiAgICAgKiBlYWNoKCkgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGludm9rZWQgb24gcm93cyBpbiB0aGUgcmVxdWVzdGVkIHJhbmdlLiBUaGVcbiAgICAgKiBlbmQoKSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbiBlaXRoZXIgYWxsIHRoZSByZXF1ZXN0ZWQgcm93cyBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkLCBvciBpZiBhbiBlcnJvciB3YXMgZW5jb3VudGVyZWQgd2hpbGUgdHJ5aW5nIHRvXG4gICAgICogZmV0Y2ggdGhlIHJlcXVlc3RlZCByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmZldGNoUm93cyA9IGNyZWF0ZUZuRmV0Y2hSb3dzKHRoaXMsIGNvbnRleHQpO1xuICAgIC8qKlxuICAgICAqIFN0cmVhbXMgdGhlIHJvd3MgaW4gdGhpcyBzdGF0ZW1lbnQncyByZXN1bHQuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZVxuICAgICAqIHNwZWNpZmllZCwgb25seSByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYXJlIHN0cmVhbWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLnN0cmVhbVJvd3MgPSBjcmVhdGVGblN0cmVhbVJvd3ModGhpcywgY29udGV4dCk7XG4gICAgdGhpcy5oYXNOZXh0ID0gaGFzTmV4dFJlc3VsdCh0aGlzLCBjb250ZXh0KTtcbiAgICB0aGlzLk5leHRSZXN1bHQgPSBjcmVhdGVOZXh0UmV1c2x0KHRoaXMsIGNvbnRleHQpO1xuICAgIC8vIHNlbmQgYSByZXF1ZXN0IHRvIGZldGNoIHRoZSByZXN1bHRcbiAgICBzZW5kUmVxdWVzdFBvc3RFeGVjKGNvbnRleHQsIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0Q29tcCk7XG59XG5VdGlsLmluaGVyaXRzKFN0YXRlbWVudFBvc3RFeGVjLCBCYXNlU3RhdGVtZW50KTtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyB0aGUgcm93cyBpbiBhIHN0YXRlbWVudCdzIHJlc3VsdCBhbmRcbiAqIGludm9rZXMgdGhlIGVhY2goKSBjYWxsYmFjayBvbiBlYWNoIHJvdy4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlXG4gKiBzcGVjaWZpZWQsIHRoZSBlYWNoKCkgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGludm9rZWQgb24gcm93cyBpbiB0aGVcbiAqIHNwZWNpZmllZCByYW5nZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50XG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBjcmVhdGVGbkZldGNoUm93cyhzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3B0aW9uc1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zKSwgRXJyb3JDb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX01JU1NJTkdfT1BUSU9OUyk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpLCBFcnJvckNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9PUFRJT05TKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgZWFjaCgpXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKG9wdGlvbnMuZWFjaCksIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX0VBQ0gpO1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBlYWNoKClcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzRnVuY3Rpb24ob3B0aW9ucy5lYWNoKSwgRXJyb3JDb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfRUFDSCk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIGVuZCgpXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKG9wdGlvbnMuZW5kKSwgRXJyb3JDb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX01JU1NJTkdfRU5EKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgZW5kKClcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzRnVuY3Rpb24ob3B0aW9ucy5lbmQpLCBFcnJvckNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9FTkQpO1xuICAgICAgICBjb25zdCByb3dNb2RlID0gb3B0aW9ucy5yb3dNb2RlO1xuICAgICAgICBpZiAoVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICAgICAgICAgIFJvd01vZGUuY2hlY2tSb3dNb2RlVmFsaWQocm93TW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgdHJ5aW5nIHRvIGZldGNoIHRoZSByZXN1bHQsIGNyZWF0ZSBhbiBlcnJvciBvZiBvdXIgb3duXG4gICAgICAgIC8vIGFuZCBpbnZva2UgdGhlIGVuZCgpIGNhbGxiYWNrXG4gICAgICAgIGlmIChjb250ZXh0LmlzRmV0Y2hpbmdSZXN1bHQpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZW5kKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfRkVUQ0hJTkdfUkVTVUxUKS5leHRlcm5hbGl6ZSgpLCBzdGF0ZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5yZXN1bHRFcnJvcikge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHRoZSBsYXN0IHRpbWUgd2UgdHJpZWQgdG8gZ2V0IHRoZSByZXN1bHRcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBmYXRhbCBlcnJvciwgZW5kIHRoZSBmZXRjaCByb3dzIG9wZXJhdGlvbiBzaW5jZSB3ZSdyZSBub3RcbiAgICAgICAgICAgIC8vIGdvaW5nIHRvIGJlIGFibGUgdG8gZ2V0IGFueSByb3dzLCBlaXRoZXIgYmVjYXVzZSB0aGUgc3RhdGVtZW50IGZhaWxlZFxuICAgICAgICAgICAgLy8gb3IgYmVjYXVzZSB0aGUgcmVzdWx0J3MgYmVlbiBwdXJnZWRcbiAgICAgICAgICAgIGlmIChFcnJvcnMuaXNPcGVyYXRpb25GYWlsZWRFcnJvcihjb250ZXh0LnJlc3VsdEVycm9yKSAmJiBjb250ZXh0LnJlc3VsdEVycm9yLnNxbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZEZldGNoUm93cyhvcHRpb25zLCBzdGF0ZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWZyZXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIGVycm9yLCBmZXRjaCByb3dzIGZyb20gdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucmVzdWx0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoUm93c0Zyb21SZXN1bHQob3B0aW9ucywgc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdpdmUgdXAgYmVjYXVzZSBpdCdzIHVubGlrZWx5IHdlJ2xsIHN1Y2NlZWQgaWYgd2UgcmV0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEZldGNoUm93cyhvcHRpb25zLCBzdGF0ZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmZXRjaFJvd3NGcm9tUmVzdWx0KG9wdGlvbnMsIHN0YXRlbWVudCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBzdHJlYW1zIHRoZSByb3dzIGluIGEgc3RhdGVtZW50J3MgcmVzdWx0LiBJZiBzdGFydFxuICogYW5kIGVuZCB2YWx1ZXMgYXJlIHNwZWNpZmllZCwgb25seSByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYXJlIHN0cmVhbWVkLlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZuU3RyZWFtUm93cyhzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gaWYgc29tZSBvcHRpb25zIGFyZSBzcGVjaWZpZWRcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBvcHRpb25zXG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3Qob3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX09QVElPTlMpO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgc3RhcnRcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc051bWJlcihvcHRpb25zLnN0YXJ0KSwgRXJyb3JDb2Rlcy5FUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX1NUQVJUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGVuZFxuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuZW5kKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc051bWJlcihvcHRpb25zLmVuZCksIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9FTkQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgZmV0Y2hBc1N0cmluZ1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hBc1N0cmluZyA9IG9wdGlvbnMuZmV0Y2hBc1N0cmluZztcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQXJyYXkoZmV0Y2hBc1N0cmluZyksIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkcpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgYWxsIHRoZSBhcnJheSBlbGVtZW50cyBhcmUgdmFsaWRcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVmFsdWVJbmRleCA9IE5hdGl2ZVR5cGVzLmZpbmRJbnZhbGlkVmFsdWUoZmV0Y2hBc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChpbnZhbGlkVmFsdWVJbmRleCA9PT0gLTEsIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdfVkFMVUVTLCBKU09OLnN0cmluZ2lmeShmZXRjaEFzU3RyaW5nW2ludmFsaWRWYWx1ZUluZGV4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93TW9kZSA9IGNvbnRleHQucm93TW9kZTtcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhyb3dNb2RlKSkge1xuICAgICAgICAgICAgICAgIFJvd01vZGUuY2hlY2tSb3dNb2RlVmFsaWQocm93TW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSb3dTdHJlYW0oc3RhdGVtZW50LCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9O1xufVxuLyoqXG4gKiBFbmRzIHRoZSBmZXRjaFJvd3MoKSBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGZldGNoUm93cygpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZW5kRmV0Y2hSb3dzKG9wdGlvbnMsIHN0YXRlbWVudCwgY29udGV4dCkge1xuICAgIG9wdGlvbnMuZW5kKEVycm9ycy5leHRlcm5hbGl6ZShjb250ZXh0LnJlc3VsdEVycm9yKSwgc3RhdGVtZW50KTtcbn1cbi8qKlxuICogRmV0Y2hlcyByb3dzIGZyb20gdGhlIHN0YXRlbWVudCdzIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gZmV0Y2hSb3dzKCkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBmZXRjaFJvd3NGcm9tUmVzdWx0KG9wdGlvbnMsIHN0YXRlbWVudCwgY29udGV4dCkge1xuICAgIGxldCBudW1JbnRlcnJ1cHRzID0gMDtcbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXN1bHQgdG8gZ2V0IGEgRmV0Y2hSb3dzT3BlcmF0aW9uIG9iamVjdFxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGNvbnRleHQucmVzdWx0LmZldGNoUm93cyhvcHRpb25zKTtcbiAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIG9wZXJhdGlvbidzICdjb21wbGV0ZScgZXZlbnRcbiAgICBvcGVyYXRpb24ub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVyciwgY29udGludWVDYWxsYmFjaykge1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHJldHJ5IGlmIHRoZSBlcnJvciBpcyByZXRyeWFibGUgYW5kIHRoZVxuICAgICAgICAvLyByZXN1bHQgc3RyZWFtIGhhc24ndCBiZWVuIGNsb3NlZCB0b28gbWFueSB0aW1lc1xuICAgICAgICBpZiAoRXJyb3JzLmlzTGFyZ2VSZXN1bHRTZXRFcnJvcihlcnIpICYmXG4gICAgICAgICAgICBlcnIucmVzcG9uc2UgJiZcbiAgICAgICAgICAgIGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDMgJiZcbiAgICAgICAgICAgIG51bUludGVycnVwdHMgPCBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0UmVzdWx0U3RyZWFtSW50ZXJydXB0cygpKSB7XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGludGVycnVwdCBjb3VudGVyXG4gICAgICAgICAgICBudW1JbnRlcnJ1cHRzKys7XG4gICAgICAgICAgICAvLyBpc3N1ZSBhIHJlcXVlc3QgdG8gZmV0Y2ggdGhlIHJlc3VsdCBhZ2FpblxuICAgICAgICAgICAgc2VuZFJlcXVlc3RQb3N0RXhlYyhjb250ZXh0LCBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RDb21wKGVyciwgYm9keSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIGVycm9yLCBjb250aW51ZSBmcm9tIHdoZXJlIHdlIGdvdCBpbnRlcnJ1cHRlZFxuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZEZldGNoUm93cyhvcHRpb25zLCBzdGF0ZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIElzc3VlcyBhIHJlcXVlc3QgdG8gY2FuY2VsIGEgc3RhdGVtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBzZW5kQ2FuY2VsU3RhdGVtZW50KHN0YXRlbWVudENvbnRleHQsIHN0YXRlbWVudCwgY2FsbGJhY2spIHtcbiAgICBsZXQgdXJsO1xuICAgIGxldCBqc29uO1xuICAgIC8vIHVzZSBkaWZmZXJlbnQgcmVzdCBlbmRwb2ludHMgYmFzZWQgb24gd2hldGhlciB0aGUgcXVlcnkgaWQgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHN0YXRlbWVudENvbnRleHQucXVlcnlJZCkge1xuICAgICAgICB1cmwgPSAnL3F1ZXJpZXMvJyArIHN0YXRlbWVudENvbnRleHQucXVlcnlJZCArICcvYWJvcnQtcmVxdWVzdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgPSAnL3F1ZXJpZXMvdjEvYWJvcnQtcmVxdWVzdCc7XG4gICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHN0YXRlbWVudENvbnRleHQucmVxdWVzdElkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBpc3N1ZSBhIHJlcXVlc3QgdG8gY2FuY2VsIHRoZSBzdGF0ZW1lbnRcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnNlcnZpY2VzLnNmLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGpzb246IGpzb24sXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyBpZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIGludm9rZSBpdFxuICAgICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcnMuZXh0ZXJuYWxpemUoZXJyKSwgc3RhdGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogSXNzdWVzIGEgcmVxdWVzdCB0byBnZXQgdGhlIHJlc3VsdCBvZiBhIHN0YXRlbWVudCB0aGF0IGhhc24ndCBiZWVuIHByZXZpb3VzbHlcbiAqIGV4ZWN1dGVkLlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRDb250ZXh0XG4gKiBAcGFyYW0gb25SZXN1bHRBdmFpbGFibGVcbiAqL1xuZnVuY3Rpb24gc2VuZFJlcXVlc3RQcmVFeGVjKHN0YXRlbWVudENvbnRleHQsIG9uUmVzdWx0QXZhaWxhYmxlKSB7XG4gICAgLy8gZ2V0IHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICBjb25zdCBoZWFkZXJzID0gc3RhdGVtZW50Q29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycztcbiAgICAvLyBidWlsZCB0aGUgYmFzaWMganNvbiBmb3IgdGhlIHJlcXVlc3RcbiAgICBjb25zdCBqc29uID0ge1xuICAgICAgICBkaXNhYmxlT2ZmbGluZUNodW5rczogZmFsc2UsXG4gICAgfTtcbiAgICBqc29uLnNxbFRleHQgPSBzdGF0ZW1lbnRDb250ZXh0LnNxbFRleHQ7XG4gICAgaWYgKHN0YXRlbWVudENvbnRleHQucmVzdWJtaXRSZXF1ZXN0ICYmICFqc29uLnNxbFRleHQpIHtcbiAgICAgICAganNvbi5zcWxUZXh0ID1cbiAgICAgICAgICAgIGBTRUxFQ1QgJ0Vycm9yIHJldHJpZXZpbmcgcXVlcnkgcmVzdWx0cyBmb3IgcmVxdWVzdCBpZDogJHtzdGF0ZW1lbnRDb250ZXh0LnJlcXVlc3RJZH0sIGAgK1xuICAgICAgICAgICAgICAgIFwicGxlYXNlIHVzZSBSRVNVTFRfU0NBTiBpbnN0ZWFkJyBBUyBFcnJvck1lc3NhZ2U7XCI7XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdjb250ZXh0LmJpbmRTdGFnZT0nICsgc3RhdGVtZW50Q29udGV4dC5iaW5kU3RhZ2UpO1xuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmJpbmRTdGFnZSkpIHtcbiAgICAgICAganNvbi5iaW5kU3RhZ2UgPSBzdGF0ZW1lbnRDb250ZXh0LmJpbmRTdGFnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5iaW5kcykpIHtcbiAgICAgICAgLy8gaWYgYmluZHMgYXJlIHNwZWNpZmllZCwgYnVpbGQgYSBiaW5kcyBtYXAgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcXVlc3RcbiAgICAgICAganNvbi5iaW5kaW5ncyA9IGJ1aWxkQmluZHNNYXAoc3RhdGVtZW50Q29udGV4dC5iaW5kcyk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgc3RhdGVtZW50IHBhcmFtZXRlcnMgaWYgYSB2YWx1ZSB3YXMgc3BlY2lmaWVkXG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQucGFyYW1ldGVycykpIHtcbiAgICAgICAganNvbi5wYXJhbWV0ZXJzID0gc3RhdGVtZW50Q29udGV4dC5wYXJhbWV0ZXJzO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnY29udGV4dC5wYXJhbWV0ZXJzPScgKyBzdGF0ZW1lbnRDb250ZXh0LnBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIHRoZSBpbnRlcm5hbCBmbGFnIGlmIGEgdmFsdWUgd2FzIHNwZWNpZmllZFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmludGVybmFsKSkge1xuICAgICAgICBqc29uLmlzSW50ZXJuYWwgPSBzdGF0ZW1lbnRDb250ZXh0LmludGVybmFsO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlbWVudENvbnRleHQuZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlKSB7XG4gICAgICAgIGpzb24ucXVlcnlDb250ZXh0RFRPID0gc3RhdGVtZW50Q29udGV4dC5zZXJ2aWNlcy5zZi5nZXRRdWVyeUNvbnRleHREVE8oKTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSB0aGUgYXN5bmNFeGVjIGZsYWcgaWYgYSB2YWx1ZSB3YXMgc3BlY2lmaWVkXG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuYXN5bmNFeGVjKSkge1xuICAgICAgICBqc29uLmFzeW5jRXhlYyA9IHN0YXRlbWVudENvbnRleHQuYXN5bmNFeGVjO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIGRlc2NyaWJlT25seSBmbGFnIGlmIGEgdmFsdWUgd2FzIHNwZWNpZmllZFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmRlc2NyaWJlT25seSkpIHtcbiAgICAgICAganNvbi5kZXNjcmliZU9ubHkgPSBzdGF0ZW1lbnRDb250ZXh0LmRlc2NyaWJlT25seTtcbiAgICB9XG4gICAgLy8gdXNlIHRoZSBzbm93Zmxha2Ugc2VydmljZSB0byBpc3N1ZSB0aGUgcmVxdWVzdFxuICAgIHNlbmRTZlJlcXVlc3Qoc3RhdGVtZW50Q29udGV4dCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgdXJsOiBVcmwuZm9ybWF0KHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiAnL3F1ZXJpZXMvdjEvcXVlcnktcmVxdWVzdCcsXG4gICAgICAgICAgICBzZWFyY2g6IFF1ZXJ5U3RyaW5nLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiBzdGF0ZW1lbnRDb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgICAganNvbjoganNvbixcbiAgICAgICAgY2FsbGJhY2s6IGJ1aWxkUmVzdWx0UmVxdWVzdENhbGxiYWNrKHN0YXRlbWVudENvbnRleHQsIGhlYWRlcnMsIG9uUmVzdWx0QXZhaWxhYmxlKSxcbiAgICB9LCB0cnVlKTtcbn1cbnRoaXMuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoc3RhdGVtZW50Q29udGV4dCwgb25SZXN1bHRBdmFpbGFibGUpIHtcbiAgICAvLyBnZXQgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgIGNvbnN0IGhlYWRlcnMgPSBzdGF0ZW1lbnRDb250ZXh0LnJlc3VsdFJlcXVlc3RIZWFkZXJzO1xuICAgIC8vIGJ1aWxkIHRoZSBiYXNpYyBqc29uIGZvciB0aGUgcmVxdWVzdFxuICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgIGRpc2FibGVPZmZsaW5lQ2h1bmtzOiBmYWxzZSxcbiAgICAgICAgc3FsVGV4dDogc3RhdGVtZW50Q29udGV4dC5zcWxUZXh0LFxuICAgIH07XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ2NvbnRleHQuYmluZFN0YWdlPScgKyBzdGF0ZW1lbnRDb250ZXh0LmJpbmRTdGFnZSk7XG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuYmluZFN0YWdlKSkge1xuICAgICAgICBqc29uLmJpbmRTdGFnZSA9IHN0YXRlbWVudENvbnRleHQuYmluZFN0YWdlO1xuICAgIH1cbiAgICBlbHNlIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmJpbmRzKSkge1xuICAgICAgICAvLyBpZiBiaW5kcyBhcmUgc3BlY2lmaWVkLCBidWlsZCBhIGJpbmRzIG1hcCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVxdWVzdFxuICAgICAgICBqc29uLmJpbmRpbmdzID0gYnVpbGRCaW5kc01hcChzdGF0ZW1lbnRDb250ZXh0LmJpbmRzKTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSBzdGF0ZW1lbnQgcGFyYW1ldGVycyBpZiBhIHZhbHVlIHdhcyBzcGVjaWZpZWRcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5wYXJhbWV0ZXJzKSkge1xuICAgICAgICBqc29uLnBhcmFtZXRlcnMgPSBzdGF0ZW1lbnRDb250ZXh0LnBhcmFtZXRlcnM7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgdGhlIGludGVybmFsIGZsYWcgaWYgYSB2YWx1ZSB3YXMgc3BlY2lmaWVkXG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuaW50ZXJuYWwpKSB7XG4gICAgICAgIGpzb24uaXNJbnRlcm5hbCA9IHN0YXRlbWVudENvbnRleHQuaW50ZXJuYWw7XG4gICAgfVxuICAgIGlmICghc3RhdGVtZW50Q29udGV4dC5kaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUpIHtcbiAgICAgICAganNvbi5xdWVyeUNvbnRleHREVE8gPSBzdGF0ZW1lbnRDb250ZXh0LnNlcnZpY2VzLnNmLmdldFF1ZXJ5Q29udGV4dERUTygpO1xuICAgIH1cbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHVybDogVXJsLmZvcm1hdCh7XG4gICAgICAgICAgICBwYXRobmFtZTogJy9xdWVyaWVzL3YxL3F1ZXJ5LXJlcXVlc3QnLFxuICAgICAgICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogc3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICAgIGpzb246IGpzb24sXG4gICAgICAgIGNhbGxiYWNrOiBidWlsZFJlc3VsdFJlcXVlc3RDYWxsYmFjayhzdGF0ZW1lbnRDb250ZXh0LCBoZWFkZXJzLCBvblJlc3VsdEF2YWlsYWJsZSksXG4gICAgfTtcbiAgICBjb25zdCBzZiA9IHN0YXRlbWVudENvbnRleHQuc2VydmljZXMuc2Y7XG4gICAgLy8gY2xvbmUgdGhlIG9wdGlvbnNcbiAgICBvcHRpb25zID0gVXRpbC5hcHBseSh7fSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmUoc2YucG9zdEFzeW5jKG9wdGlvbnMpKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYmluZCB2YXJpYWJsZXMgYXJyYXkgdG8gYSBtYXAgdGhhdCBjYW4gYmUgaW5jbHVkZWQgaW4gdGhlXG4gKiBQT1NULWJvZHkgd2hlbiBpc3N1aW5nIGEgcHJlLWV4ZWMgc3RhdGVtZW50IHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIGJpbmRzQXJyYXlcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBidWlsZEJpbmRzTWFwKGJpbmRzQXJyYXkpIHtcbiAgICBjb25zdCBiaW5kc01hcCA9IHt9O1xuICAgIGNvbnN0IGlzQXJyYXlCaW5kaW5nID0gYmluZHNBcnJheS5sZW5ndGggPiAwICYmIFV0aWwuaXNBcnJheShiaW5kc0FycmF5WzBdKTtcbiAgICBjb25zdCBzaW5nbGVBcnJheSA9IGlzQXJyYXlCaW5kaW5nID8gYmluZHNBcnJheVswXSA6IGJpbmRzQXJyYXk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBzaW5nbGVBcnJheS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNpbmdsZUFycmF5W2luZGV4XTtcbiAgICAgICAgLy8gcGljayB0aGUgYXBwcm9wcmlhdGUgbG9naWNhbCBkYXRhIHR5cGUgYmFzZWQgb24gdGhlIGJpbmQgdmFsdWVcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGlmIChVdGlsLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnQk9PTEVBTic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbC5pc09iamVjdCh2YWx1ZSkgfHwgVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdHlwZSA9ICdWQVJJQU5UJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVdGlsLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IHZhbHVlICYmIHZhbHVlICUgMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIGludGVnZXJcbiAgICAgICAgICAgICAgICB0eXBlID0gJ0ZJWEVEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnUkVBTCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gJ1RFWFQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgbm9uLW51bGwgdmFsdWVzIHRvIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeTsgd2UgZG9uJ3QgY29udmVydCBudWxsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNsaWVudCBtaWdodCB3YW50IHRvIHJ1biBzb21ldGhpbmcgbGlrZVxuICAgICAgICAvLyAgIHNxbCB0ZXh0ID0gdXBkYXRlIHQgc2V0IG5hbWUgPSA6MSB3aGVyZSBpZCA9IDE7LCBiaW5kcyA9IFtudWxsXVxuICAgICAgICAvLyBhbmQgY29udmVydGluZyBudWxsIHRvIGEgc3RyaW5nIHdvdWxkIHJlc3VsdCBpbiB1cyBleGVjdXRpbmdcbiAgICAgICAgLy8gICBzcWwgdGV4dCA9IHVwZGF0ZSB0IHNldCBuYW1lID0gJ251bGwnIHdoZXJlIGlkID0gMTtcbiAgICAgICAgLy8gaW5zdGVhZCBvZlxuICAgICAgICAvLyAgIHNxbCB0ZXh0ID0gdXBkYXRlIHQgc2V0IG5hbWUgPSBudWxsIHdoZXJlIGlkID0gMTtcbiAgICAgICAgaWYgKCFpc0FycmF5QmluZGluZykge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFVdGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgYmluZHNBcnJheS5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUwID0gYmluZHNBcnJheVtyb3dJbmRleF1baW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZTAgIT09IG51bGwgJiYgIVV0aWwuaXNTdHJpbmcodmFsdWUwKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUwIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUwID0gdmFsdWUwLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUwID0gSlNPTi5zdHJpbmdpZnkodmFsdWUwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbHVlMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGFuIGVudHJ5IGZvciB0aGUgYmluZCB2YXJpYWJsZSB0byB0aGUgbWFwXG4gICAgICAgIGJpbmRzTWFwW2luZGV4ICsgMV0gPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYmluZHNNYXA7XG59XG4vKipcbiAqIElzc3VlcyBhIHJlcXVlc3QgdG8gZ2V0IHRoZSByZXN1bHQgb2YgYSBzdGF0ZW1lbnQgdGhhdCBoYXMgYmVlbiBwcmV2aW91c2x5XG4gKiBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIG9uUmVzdWx0QXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0UG9zdEV4ZWMoc3RhdGVtZW50Q29udGV4dCwgb25SZXN1bHRBdmFpbGFibGUpIHtcbiAgICAvLyBnZXQgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgIGNvbnN0IGhlYWRlcnMgPSBzdGF0ZW1lbnRDb250ZXh0LnJlc3VsdFJlcXVlc3RIZWFkZXJzO1xuICAgIC8vIHVzZSB0aGUgc25vd2ZsYWtlIHNlcnZpY2UgdG8gaXNzdWUgdGhlIHJlcXVlc3RcbiAgICBzZW5kU2ZSZXF1ZXN0KHN0YXRlbWVudENvbnRleHQsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgdXJsOiBVcmwuZm9ybWF0KHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiAnL3F1ZXJpZXMvJyArIHN0YXRlbWVudENvbnRleHQucXVlcnlJZCArICcvcmVzdWx0JyxcbiAgICAgICAgICAgIHNlYXJjaDogUXVlcnlTdHJpbmcuc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlT2ZmbGluZUNodW5rczogZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICAgIGNhbGxiYWNrOiBidWlsZFJlc3VsdFJlcXVlc3RDYWxsYmFjayhzdGF0ZW1lbnRDb250ZXh0LCBoZWFkZXJzLCBvblJlc3VsdEF2YWlsYWJsZSksXG4gICAgfSk7XG59XG4vKipcbiAqIElzc3VlcyBhIHN0YXRlbWVudC1yZWxhdGVkIHJlcXVlc3QgdXNpbmcgdGhlIFNub3dmbGFrZSBzZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRDb250ZXh0IHRoZSBzdGF0ZW1lbnQgY29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthcHBlbmRRdWVyeVBhcmFtT25SZXRyeV0gd2hldGhlciByZXRyeT10cnVlIHNob3VsZCBiZVxuICogICBhcHBlbmRlZCB0byB0aGUgdXJsIGlmIHRoZSByZXF1ZXN0IGlzIHJldHJpZWQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRTZlJlcXVlc3Qoc3RhdGVtZW50Q29udGV4dCwgb3B0aW9ucywgYXBwZW5kUXVlcnlQYXJhbU9uUmV0cnkpIHtcbiAgICBjb25zdCBzZiA9IHN0YXRlbWVudENvbnRleHQuc2VydmljZXMuc2Y7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHN0YXRlbWVudENvbnRleHQuY29ubmVjdGlvbkNvbmZpZztcbiAgICAvLyBjbG9uZSB0aGUgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBVdGlsLmFwcGx5KHt9LCBvcHRpb25zKTtcbiAgICAvLyBnZXQgdGhlIG9yaWdpbmFsIHVybCBhbmQgY2FsbGJhY2tcbiAgICBjb25zdCB1cmxPcmlnID0gb3B0aW9ucy51cmw7XG4gICAgY29uc3QgY2FsbGJhY2tPcmlnID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBsZXQgbnVtUmV0cmllcyA9IDA7XG4gICAgY29uc3QgbWF4TnVtUmV0cmllcyA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZk1heE51bVJldHJpZXMoKTtcbiAgICBsZXQgc2xlZXAgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5U2ZTdGFydGluZ1NsZWVwVGltZSgpO1xuICAgIGxldCBsYXN0U3RhdHVzQ29kZUZvclJldHJ5O1xuICAgIC8vIGNyZWF0ZSBhIGZ1bmN0aW9uIHRvIHNlbmQgdGhlIHJlcXVlc3RcbiAgICBjb25zdCBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHJldHJ5IGFuZCBhIHF1ZXJ5IHBhcmFtZXRlciBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIHVybCBvblxuICAgICAgICAvLyByZXRyeSwgdXBkYXRlIHRoZSB1cmxcbiAgICAgICAgaWYgKG51bVJldHJpZXMgPiAwICYmIGFwcGVuZFF1ZXJ5UGFyYW1PblJldHJ5KSB7XG4gICAgICAgICAgICBjb25zdCByZXRyeU9wdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybE9yaWcsXG4gICAgICAgICAgICAgICAgcmV0cnlDb3VudDogbnVtUmV0cmllcyxcbiAgICAgICAgICAgICAgICByZXRyeVJlYXNvbjogbGFzdFN0YXR1c0NvZGVGb3JSZXRyeSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlUmV0cnlSZWFzb246IGNvbm5lY3Rpb25Db25maWcuZ2V0SW5jbHVkZVJldHJ5UmVhc29uKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBVdGlsLnVybC5hcHBlbmRSZXRyeVBhcmFtKHJldHJ5T3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzZi5yZXF1ZXN0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgLy8gcmVwbGFjZSB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIHdpdGggYSBuZXcgb25lIHRoYXQgcmV0cmllc1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBhc3luYyBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmVuJ3QgZXhjZWVkZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgeWV0IGFuZCB0aGUgc2VydmVyXG4gICAgICAgIC8vIGNhbWUgYmFjayB3aXRoIGEgcmV0cnlhYmxlIGVycm9yIGNvZGVcbiAgICAgICAgaWYgKG51bVJldHJpZXMgPCBtYXhOdW1SZXRyaWVzICYmXG4gICAgICAgICAgICBlcnIgJiZcbiAgICAgICAgICAgIFV0aWwuaXNSZXRyeWFibGVIdHRwRXJyb3IoZXJyLnJlc3BvbnNlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgcmV0cnkgY291bnRcbiAgICAgICAgICAgIG51bVJldHJpZXMrKztcbiAgICAgICAgICAgIGxhc3RTdGF0dXNDb2RlRm9yUmV0cnkgPSBlcnIucmVzcG9uc2UgPyBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA6IDA7XG4gICAgICAgICAgICAvLyB1c2UgZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIGRlY29ycmVsYXRlZCBqaXR0ZXIgdG8gY29tcHV0ZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgc2xlZXAgdGltZS5cbiAgICAgICAgICAgIGNvbnN0IGNhcCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZk1heFNsZWVwVGltZSgpO1xuICAgICAgICAgICAgc2xlZXAgPSBVdGlsLm5leHRTbGVlcFRpbWUoMSwgY2FwLCBzbGVlcCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmV0cnlpbmcgc3RhdGVtZW50IHdpdGggcmVxdWVzdCBpZCAlcywgcmV0cnkgY291bnQgPSAlcycsIHN0YXRlbWVudENvbnRleHQucmVxdWVzdElkLCBudW1SZXRyaWVzKTtcbiAgICAgICAgICAgIC8vIHdhaXQgdGhlIGFwcHJvcHJpYXRlIGFtb3VudCBvZiB0aW1lIGJlZm9yZSByZXRyeWluZyB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgc2V0VGltZW91dChzZW5kUmVxdWVzdCwgc2xlZXAgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGludm9rZSB0aGUgb3JpZ2luYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrT3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBpc3N1ZSB0aGUgcmVxdWVzdFxuICAgIHNlbmRSZXF1ZXN0KCk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIGNhbGxiYWNrIGZvciB1c2UgaW4gYW4gZXhlYy1zdGF0ZW1lbnQgb3IgZmV0Y2gtcmVzdWx0IHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHN0YXRlbWVudENvbnRleHRcbiAqIEBwYXJhbSBoZWFkZXJzXG4gKiBAcGFyYW0gb25SZXN1bHRBdmFpbGFibGVcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUmVzdWx0UmVxdWVzdENhbGxiYWNrKHN0YXRlbWVudENvbnRleHQsIGhlYWRlcnMsIG9uUmVzdWx0QXZhaWxhYmxlKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBhc3luYyBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IG9uUmVzdWx0QXZhaWxhYmxlLmNhbGwobnVsbCwgZXJyLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgdGhlIHF1ZXJ5IGlkIGZyb20gdGhlIHJlc3BvbnNlIGFuZCBzYXZlIGl0XG4gICAgICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LnF1ZXJ5SWQgPSBib2R5LmRhdGEucXVlcnlJZDtcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZXN1bHQgaXMgbm90IHJlYWR5IHlldCwgZXh0cmFjdCB0aGUgcmVzdWx0IHVybCBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgLy8gYW5kIGlzc3VlIGEgR0VUIHJlcXVlc3QgdG8gdHJ5IHRvIGZldGNoIHRoZSByZXN1bHQgYWdhaW4gdW5sZXNzIGFzeW5jRXhlYyBpcyBlbmFibGVkLlxuICAgICAgICAgICAgaWYgKGJvZHkgJiZcbiAgICAgICAgICAgICAgICAoYm9keS5jb2RlID09PSBxdWVyeUNvZGVzLlFVRVJZX0lOX1BST0dSRVNTIHx8XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuY29kZSA9PT0gcXVlcnlDb2Rlcy5RVUVSWV9JTl9QUk9HUkVTU19BU1lOQykpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVtZW50Q29udGV4dC5hc3luY0V4ZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25SZXN1bHRBdmFpbGFibGUuY2FsbChudWxsLCBlcnIsIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgdGhlIHJlc3VsdCB1cmwgZnJvbSB0aGUgcmVzcG9uc2UgYW5kIHRyeSB0byBnZXQgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIC8vIGFnYWluXG4gICAgICAgICAgICAgICAgc2VuZFNmUmVxdWVzdChzdGF0ZW1lbnRDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYm9keS5kYXRhLmdldFJlc3VsdFVybCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25SZXN1bHRBdmFpbGFibGUuY2FsbChudWxsLCBlcnIsIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG59XG4vKipcbiAqIEJ1aWxkcyB0aGUgcmVxdWVzdCBoZWFkZXJzIGZvciBhIHJvdyBzdGF0ZW1lbnQgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzUm93KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL3Nub3dmbGFrZScsXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGRzIHRoZSByZXF1ZXN0IGhlYWRlcnMgZm9yIGEgZmlsZSBzdGF0ZW1lbnQgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzRmlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB9O1xufVxuLyoqXG4gKiBDb3VudCBudW1iZXIgb2YgYmluZGluZ3NcbiAqXG4gKiBAcmV0dXJucyB7aW50fVxuICovXG5mdW5jdGlvbiBjb3VudEJpbmRpbmcoYmluZHMpIHtcbiAgICBpZiAoIVV0aWwuaXNBcnJheShiaW5kcykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCctLSBiaW5kcy5sZW5ndGg9ICVkJywgYmluZHMubGVuZ3RoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBiaW5kcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKGJpbmRzW2luZGV4XSAhPSBudWxsICYmIFV0aWwuaXNBcnJheShiaW5kc1tpbmRleF0pKSB7XG4gICAgICAgICAgICBjb3VudCArPSBiaW5kc1tpbmRleF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGhhc05leHRSZXN1bHQoc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQubXVsdGlSZXN1bHRJZHMgIT0gbnVsbCAmJiBjb250ZXh0Lm11bHRpQ3VySWQgKyAxIDwgY29udGV4dC5tdWx0aVJlc3VsdElkcy5sZW5ndGg7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5leHRSZXVzbHQoc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGhhc05leHRSZXN1bHQoc3RhdGVtZW50LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgY29udGV4dC5tdWx0aUN1cklkKys7XG4gICAgICAgICAgICBjb250ZXh0LnF1ZXJ5SWQgPSBjb250ZXh0Lm11bHRpUmVzdWx0SWRzW2NvbnRleHQubXVsdGlDdXJJZF07XG4gICAgICAgICAgICBjb250ZXh0LnNxbFRleHQgPSBjb250ZXh0Lm11bHRpU3FsVGV4dHNbY29udGV4dC5tdWx0aUN1cklkXTtcbiAgICAgICAgICAgIGV4cG9ydHMuY3JlYXRlU3RhdGVtZW50UG9zdEV4ZWMoY29udGV4dCwgY29udGV4dC5zZXJ2aWNlcywgY29udGV4dC5jb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZW1lbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nexports.HEARTBEAT_FREQUENCY_MASTER_VALIDITY = 14400;\n//# sourceMappingURL=connection_constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvY29ubmVjdGlvbl9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiwyQ0FBMkM7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbnN0YW50cy9jb25uZWN0aW9uX2NvbnN0YW50cy5qcz9iOWM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5IRUFSVEJFQVRfRlJFUVVFTkNZX01BU1RFUl9WQUxJRElUWSA9IDE0NDAwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbl9jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// 400001\nexports[400001] = 'An internal error has occurred. Please contact Snowflake support.';\nexports[400002] = 'You are using an unsupported version of Node.js. Please use %s or above.';\n// 401001\nexports[401001] = 'Network error. Could not reach Snowflake.';\nexports[401002] = 'Request to Snowflake failed.';\nexports[401003] = 'Snowflake responded with non-JSON content.';\nexports[401004] = 'Request to Snowflake failed.  Invalid token';\n// 402001\nexports[402001] = 'Network error. Could not reach S3/Blob.';\nexports[402002] = 'Request to S3/Blob failed.';\n// 403001\nexports[403001] =\n    'Invalid logLevel. The specified value must be one of these five levels: error, warn, debug, info and trace.';\nexports[403002] = 'Invalid disableOCSPChecks option. The specified value must be a boolean.';\nexports[403003] =\n    'Invalid OCSP mode. The specified value must be FAIL_CLOSED, FAIL_OPEN, or INSECURE_MODE.';\nexports[403004] = 'Invalid custom JSON parser. The specified value must be a function.';\nexports[403005] = 'Invalid custom XML parser. The specified value must be a function.';\nexports[403006] = 'Invalid keep alive value. The specified value must be a boolean.';\nexports[403007] =\n    'Invalid custom credential manager value. The specified value must be an object, and it should have three methods: write, read, remove';\nexports[403008] = 'Invalid useEnvProxy value. The specified value must be a boolean.';\n// 404001\nexports[404001] = 'Connection options must be specified.';\nexports[404002] = 'Invalid connection options. The specified value must be an object.';\nexports[404003] = 'A user name must be specified.';\nexports[404004] = 'Invalid user name. The specified value must be a string.';\nexports[404005] = 'A password must be specified.';\nexports[404006] = 'Invalid password. The specified value must be a string.';\nexports[404007] = 'An account must be specified.';\nexports[404008] = 'Invalid account. The specified value must be a string.';\nexports[404009] = 'An accessUrl must be specified.';\nexports[404010] = 'Invalid accessUrl. The specified value must be a string.';\nexports[404011] = 'Invalid warehouse. The specified value must be a string.';\nexports[404012] = 'Invalid database. The specified value must be a string.';\nexports[404013] = 'Invalid schema. The specified value must be a string.';\nexports[404014] = 'Invalid role. The specified value must be a string.';\nexports[404015] = 'A proxyHost must be specified';\nexports[404016] = 'Invalid proxyHost. The specified value must be a string.';\nexports[404017] = 'A proxyPort must be specified.';\nexports[404018] = 'Invalid proxyPort. The specified value must be a number.';\nexports[404019] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[404020] = 'Invalid fetchAsString option. The specified value must be an Array.';\nexports[404021] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[404022] = 'Invalid region. The specified value must be a string.';\nexports[404023] = 'Invalid clientSessionKeepAlive. The specified value must be a boolean.';\nexports[404024] =\n    'Invalid clientSessionKeepAliveHeartbeatFrequency. The specified value must be a number.';\nexports[404025] = 'Invalid jsTreatIntegerAsBigInt. The specified value must be a boolean';\nexports[404026] =\n    'Invalid private key. The specified value must be a string in pem format of type pkcs8';\nexports[404027] = 'Invalid private key file location. The specified value must be a string';\nexports[404028] = 'Invalid private key passphrase. The specified value must be a string';\nexports[404029] = 'Invalid oauth token. The specified value must be a string';\nexports[404030] =\n    'Invalid validate default parameters value. The specified value must be a boolean';\nexports[404031] =\n    'Invalid application value. The specified value must be a string that starts with a letter and a length between 1-50';\nexports[404032] = 'A proxyUser must be specified';\nexports[404033] = 'Invalid proxyUser. The specified value must be a string.';\nexports[404034] = 'A proxyPassword must be specified.';\nexports[404035] = 'Invalid proxyPassword. The specified value must be a string.';\nexports[404036] = 'Invalid noProxy. The specified value must be a string.';\nexports[404037] = 'Invalid arrayBindingThreshold. The specified value must be a number.';\nexports[404038] = 'Invalid gcsUseDownscopedCredential. The specified value must be a boolean.';\nexports[404039] = 'Invalid forceStageBindError. The specified value must be a number.';\nexports[404040] = 'Invalid browser timeout value. The specified value must be a positive number.';\nexports[404041] = 'Invalid disableQueryContextCache. The specified value must be a boolean.';\nexports[404042] = 'Invalid includeRetryReason. The specified value must be a boolean.';\nexports[404043] = 'Invalid clientConfigFile value. The specified value must be a string.';\nexports[404044] = 'Invalid retryTimeout value. The specified value must be a number.';\nexports[404045] = 'Invalid account. The specified value must be a valid subdomain string.';\nexports[404046] = 'Invalid region. The specified value must be a valid subdomain string.';\nexports[404047] = 'Invalid disableConsoleLogin. The specified value must be a boolean';\nexports[404048] = 'Invalid disableGCPTokenUpload. The specified value must be a boolean';\nexports[404048] = 'Invalid forceGCPUseDownscopedCredential. The specified value must be a boolean';\nexports[404049] = 'Invalid clientStoreTemporaryCredential. The specified value must be a boolean.';\nexports[404050] = 'Invalid representNullAsStringNull. The specified value must be a boolean';\nexports[404051] = 'Invalid disableSamlURLCheck. The specified value must be a boolean';\nexports[404052] = 'Invalid clientRequestMFAToken. The specified value must be a boolean.';\nexports[404053] = 'A host must be specified.';\nexports[404054] = 'Invalid host. The specified value must be a string.';\nexports[404055] = 'Invalid passcodeInPassword. The specified value must be a boolean';\nexports[404056] = 'Invalid passcode. The specified value must be a string';\nexports[404057] = 'A password or token must be specified.';\nexports[404058] =\n    'Invalid oauth authorization URL. The specified value must be a valid URL starting with the https or http protocol.';\nexports[404059] = 'Invalid oauth client id. The specified value must not be an empty string';\nexports[404060] = 'Invalid oauth client secret. The specified value must not be an empty string';\nexports[404061] =\n    'Invalid oauth token request URL. The specified value must be a valid URL starting with the https or http protocol.';\nexports[404062] = 'Invalid authenticator: WORKLOAD_IDENTITY parameters. %s';\nexports[404063] = 'Invalid query tag. The specified value must be a string;';\n// 405001\nexports[405001] = 'Invalid callback. The specified value must be a function.';\n// 405501\nexports[405501] = 'Connection already in progress.';\nexports[405502] = 'Already connected.';\nexports[405503] = 'Connection already terminated. Cannot connect again.';\nexports[405504] =\n    'connect() does not work with external browser or okta authenticators, call connectAsync() instead';\nexports[405505] = 'Configuration from client config file failed';\nexports[405506] = 'Wrong authorization type';\nexports[405507] = 'Authenticator not allowed';\n// 406001\nexports[406001] = 'Invalid callback. The specified value must be a function.';\n// 406501\nexports[406501] = 'Not connected, so nothing to destroy.';\nexports[406502] = 'Already disconnected.';\n// 407001\nexports[407001] = 'Unable to perform operation because a connection was never established.';\nexports[407002] = 'Unable to perform operation using terminated connection.';\n// 408001\nexports[408001] = 'A serializedConnection must be specified.';\nexports[408002] = 'Invalid serializedConnection. The specified value must be a string.';\nexports[408003] =\n    \"Invalid serializedConnection. The value must be a string obtained by calling another connection's serialize() method.\";\n// 409001\nexports[409001] = 'Execute options must be specified.';\nexports[409002] = 'Invalid execute options. The specified value must be an object.';\nexports[409003] = 'A sqlText value must be specified.';\nexports[409004] = 'Invalid sqlText. The specified value must be a string.';\nexports[409005] = 'Invalid internal flag. The specified value must be a boolean.';\nexports[409006] = 'Invalid parameters. The specified value must be an object.';\nexports[409007] = 'Invalid binds. The specified value must be an array.';\nexports[409008] = 'Invalid bind variable: %s. Only stringifiable values are supported.';\nexports[409009] = 'Invalid complete callback. The specified value must be a function.';\nexports[409010] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[409011] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[409012] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[409013] = 'Invalid requestId. The specified value must be a string.';\nexports[409014] = 'Invalid asyncExec. The specified value must be a boolean.';\nexports[409015] = 'Invalid describeOnly. The specified value must be a boolean.';\n// 410001\nexports[410001] = 'Fetch-result options must be specified.';\nexports[410002] = 'Invalid options. The specified value must be an object.';\nexports[410003] = 'A query id/statement id must be specified.';\nexports[410004] = 'Invalid query id/statement id. The specified value must be a string.';\nexports[410005] = 'Invalid complete callback. The specified value must be a function.';\nexports[410006] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[410007] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[410008] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[410009] =\n    'Invalid cwd (current working directory) type: %s. The specified value must be a string.';\n// 411001\nexports[411001] = 'Invalid options. The specified value must be an object.';\nexports[411002] = 'Invalid start index. The specified value must be a number.';\nexports[411003] = 'Invalid end index. The specified value must be a number.';\nexports[411004] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[411005] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[411006] =\n    'Invalid row mode value. The specified value should be array or object or object_with_renamed_duplicated_columns';\nexports[412001] = 'Certificate is REVOKED.';\nexports[412002] = 'Certificate status is UNKNOWN.';\nexports[412003] = 'Not recognize signature algorithm.';\nexports[412004] = 'Invalid signature.';\nexports[412005] = 'No OCSP response data is attached.';\nexports[412006] = 'Invalid validity.';\nexports[412007] = 'Could not verify the certificate revocation status.';\nexports[412008] = 'Not two elements are in the cache.';\nexports[412009] = 'Cache entry expired.';\nexports[412010] = 'Failed to parse OCSP response.';\nexports[412011] = 'Invalid Signing Certificate validity.';\nexports[412012] = 'Timeout OCSP responder.';\nexports[412013] = 'Timeout OCSP Cache server.';\nexports[412014] = 'Failed to obtain OCSP response: %s';\nexports[413001] = 'CRL validation failed.';\n// 450001\nexports[450001] = 'Fetch-row options must be specified.';\nexports[450002] = 'Invalid options. The specified value must be an object.';\nexports[450003] = 'An each() callback must be specified.';\nexports[450004] = 'Invalid each() callback. The specified value must be a function.';\nexports[450005] = 'An end() callback must be specified.';\nexports[450006] = 'Invalid end() callback. The specified value must be a function.';\nexports[450007] = 'Operation failed because the statement is still in progress.';\n// 460001\nexports[460001] = 'Invalid queryId: %s';\nexports[460002] = 'Cannot retrieve data. No information returned from server for query %s';\nexports[460003] = 'Status of query %s is %s, results are unavailable';\n//# sourceMappingURL=error_messages.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvZXJyb3JfbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZSw0REFBNEQ7QUFDM0U7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29uc3RhbnRzL2Vycm9yX21lc3NhZ2VzLmpzPzkzMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyA0MDAwMDFcbmV4cG9ydHNbNDAwMDAxXSA9ICdBbiBpbnRlcm5hbCBlcnJvciBoYXMgb2NjdXJyZWQuIFBsZWFzZSBjb250YWN0IFNub3dmbGFrZSBzdXBwb3J0Lic7XG5leHBvcnRzWzQwMDAwMl0gPSAnWW91IGFyZSB1c2luZyBhbiB1bnN1cHBvcnRlZCB2ZXJzaW9uIG9mIE5vZGUuanMuIFBsZWFzZSB1c2UgJXMgb3IgYWJvdmUuJztcbi8vIDQwMTAwMVxuZXhwb3J0c1s0MDEwMDFdID0gJ05ldHdvcmsgZXJyb3IuIENvdWxkIG5vdCByZWFjaCBTbm93Zmxha2UuJztcbmV4cG9ydHNbNDAxMDAyXSA9ICdSZXF1ZXN0IHRvIFNub3dmbGFrZSBmYWlsZWQuJztcbmV4cG9ydHNbNDAxMDAzXSA9ICdTbm93Zmxha2UgcmVzcG9uZGVkIHdpdGggbm9uLUpTT04gY29udGVudC4nO1xuZXhwb3J0c1s0MDEwMDRdID0gJ1JlcXVlc3QgdG8gU25vd2ZsYWtlIGZhaWxlZC4gIEludmFsaWQgdG9rZW4nO1xuLy8gNDAyMDAxXG5leHBvcnRzWzQwMjAwMV0gPSAnTmV0d29yayBlcnJvci4gQ291bGQgbm90IHJlYWNoIFMzL0Jsb2IuJztcbmV4cG9ydHNbNDAyMDAyXSA9ICdSZXF1ZXN0IHRvIFMzL0Jsb2IgZmFpbGVkLic7XG4vLyA0MDMwMDFcbmV4cG9ydHNbNDAzMDAxXSA9XG4gICAgJ0ludmFsaWQgbG9nTGV2ZWwuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBvbmUgb2YgdGhlc2UgZml2ZSBsZXZlbHM6IGVycm9yLCB3YXJuLCBkZWJ1ZywgaW5mbyBhbmQgdHJhY2UuJztcbmV4cG9ydHNbNDAzMDAyXSA9ICdJbnZhbGlkIGRpc2FibGVPQ1NQQ2hlY2tzIG9wdGlvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDMwMDNdID1cbiAgICAnSW52YWxpZCBPQ1NQIG1vZGUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBGQUlMX0NMT1NFRCwgRkFJTF9PUEVOLCBvciBJTlNFQ1VSRV9NT0RFLic7XG5leHBvcnRzWzQwMzAwNF0gPSAnSW52YWxpZCBjdXN0b20gSlNPTiBwYXJzZXIuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5leHBvcnRzWzQwMzAwNV0gPSAnSW52YWxpZCBjdXN0b20gWE1MIHBhcnNlci4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgZnVuY3Rpb24uJztcbmV4cG9ydHNbNDAzMDA2XSA9ICdJbnZhbGlkIGtlZXAgYWxpdmUgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDAzMDA3XSA9XG4gICAgJ0ludmFsaWQgY3VzdG9tIGNyZWRlbnRpYWwgbWFuYWdlciB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCwgYW5kIGl0IHNob3VsZCBoYXZlIHRocmVlIG1ldGhvZHM6IHdyaXRlLCByZWFkLCByZW1vdmUnO1xuZXhwb3J0c1s0MDMwMDhdID0gJ0ludmFsaWQgdXNlRW52UHJveHkgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbi8vIDQwNDAwMVxuZXhwb3J0c1s0MDQwMDFdID0gJ0Nvbm5lY3Rpb24gb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMDJdID0gJ0ludmFsaWQgY29ubmVjdGlvbiBvcHRpb25zLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Lic7XG5leHBvcnRzWzQwNDAwM10gPSAnQSB1c2VyIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDA0XSA9ICdJbnZhbGlkIHVzZXIgbmFtZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAwNV0gPSAnQSBwYXNzd29yZCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMDZdID0gJ0ludmFsaWQgcGFzc3dvcmQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMDddID0gJ0FuIGFjY291bnQgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDA4XSA9ICdJbnZhbGlkIGFjY291bnQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMDldID0gJ0FuIGFjY2Vzc1VybCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMTBdID0gJ0ludmFsaWQgYWNjZXNzVXJsLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDExXSA9ICdJbnZhbGlkIHdhcmVob3VzZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxMl0gPSAnSW52YWxpZCBkYXRhYmFzZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxM10gPSAnSW52YWxpZCBzY2hlbWEuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMTRdID0gJ0ludmFsaWQgcm9sZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxNV0gPSAnQSBwcm94eUhvc3QgbXVzdCBiZSBzcGVjaWZpZWQnO1xuZXhwb3J0c1s0MDQwMTZdID0gJ0ludmFsaWQgcHJveHlIb3N0LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDE3XSA9ICdBIHByb3h5UG9ydCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMThdID0gJ0ludmFsaWQgcHJveHlQb3J0LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDA0MDE5XSA9ICdJbnZhbGlkIHN0cmVhbVJlc3VsdCBmbGFnLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDAyMF0gPSAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIG9wdGlvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIEFycmF5Lic7XG5leHBvcnRzWzQwNDAyMV0gPVxuICAgICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdHlwZTogJXMuIFRoZSBzdXBwb3J0ZWQgdHlwZXMgYXJlOiBTdHJpbmcsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgQnVmZmVyLCBhbmQgSlNPTi4nO1xuZXhwb3J0c1s0MDQwMjJdID0gJ0ludmFsaWQgcmVnaW9uLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDIzXSA9ICdJbnZhbGlkIGNsaWVudFNlc3Npb25LZWVwQWxpdmUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA0MDI0XSA9XG4gICAgJ0ludmFsaWQgY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLic7XG5leHBvcnRzWzQwNDAyNV0gPSAnSW52YWxpZCBqc1RyZWF0SW50ZWdlckFzQmlnSW50LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDI2XSA9XG4gICAgJ0ludmFsaWQgcHJpdmF0ZSBrZXkuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiBwZW0gZm9ybWF0IG9mIHR5cGUgcGtjczgnO1xuZXhwb3J0c1s0MDQwMjddID0gJ0ludmFsaWQgcHJpdmF0ZSBrZXkgZmlsZSBsb2NhdGlvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nJztcbmV4cG9ydHNbNDA0MDI4XSA9ICdJbnZhbGlkIHByaXZhdGUga2V5IHBhc3NwaHJhc2UuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyc7XG5leHBvcnRzWzQwNDAyOV0gPSAnSW52YWxpZCBvYXV0aCB0b2tlbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nJztcbmV4cG9ydHNbNDA0MDMwXSA9XG4gICAgJ0ludmFsaWQgdmFsaWRhdGUgZGVmYXVsdCBwYXJhbWV0ZXJzIHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDMxXSA9XG4gICAgJ0ludmFsaWQgYXBwbGljYXRpb24gdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyB0aGF0IHN0YXJ0cyB3aXRoIGEgbGV0dGVyIGFuZCBhIGxlbmd0aCBiZXR3ZWVuIDEtNTAnO1xuZXhwb3J0c1s0MDQwMzJdID0gJ0EgcHJveHlVc2VyIG11c3QgYmUgc3BlY2lmaWVkJztcbmV4cG9ydHNbNDA0MDMzXSA9ICdJbnZhbGlkIHByb3h5VXNlci4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAzNF0gPSAnQSBwcm94eVBhc3N3b3JkIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQwNDAzNV0gPSAnSW52YWxpZCBwcm94eVBhc3N3b3JkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDM2XSA9ICdJbnZhbGlkIG5vUHJveHkuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMzddID0gJ0ludmFsaWQgYXJyYXlCaW5kaW5nVGhyZXNob2xkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDA0MDM4XSA9ICdJbnZhbGlkIGdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDAzOV0gPSAnSW52YWxpZCBmb3JjZVN0YWdlQmluZEVycm9yLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDA0MDQwXSA9ICdJbnZhbGlkIGJyb3dzZXIgdGltZW91dCB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLic7XG5leHBvcnRzWzQwNDA0MV0gPSAnSW52YWxpZCBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA0MDQyXSA9ICdJbnZhbGlkIGluY2x1ZGVSZXRyeVJlYXNvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDQwNDNdID0gJ0ludmFsaWQgY2xpZW50Q29uZmlnRmlsZSB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDA0NF0gPSAnSW52YWxpZCByZXRyeVRpbWVvdXQgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nO1xuZXhwb3J0c1s0MDQwNDVdID0gJ0ludmFsaWQgYWNjb3VudC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgc3ViZG9tYWluIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwNDZdID0gJ0ludmFsaWQgcmVnaW9uLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBzdWJkb21haW4gc3RyaW5nLic7XG5leHBvcnRzWzQwNDA0N10gPSAnSW52YWxpZCBkaXNhYmxlQ29uc29sZUxvZ2luLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDQ4XSA9ICdJbnZhbGlkIGRpc2FibGVHQ1BUb2tlblVwbG9hZC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDA0OF0gPSAnSW52YWxpZCBmb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDQ5XSA9ICdJbnZhbGlkIGNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDQwNTBdID0gJ0ludmFsaWQgcmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDA1MV0gPSAnSW52YWxpZCBkaXNhYmxlU2FtbFVSTENoZWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDUyXSA9ICdJbnZhbGlkIGNsaWVudFJlcXVlc3RNRkFUb2tlbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDQwNTNdID0gJ0EgaG9zdCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwNTRdID0gJ0ludmFsaWQgaG9zdC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDA1NV0gPSAnSW52YWxpZCBwYXNzY29kZUluUGFzc3dvcmQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4nO1xuZXhwb3J0c1s0MDQwNTZdID0gJ0ludmFsaWQgcGFzc2NvZGUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyc7XG5leHBvcnRzWzQwNDA1N10gPSAnQSBwYXNzd29yZCBvciB0b2tlbiBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwNThdID1cbiAgICAnSW52YWxpZCBvYXV0aCBhdXRob3JpemF0aW9uIFVSTC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgVVJMIHN0YXJ0aW5nIHdpdGggdGhlIGh0dHBzIG9yIGh0dHAgcHJvdG9jb2wuJztcbmV4cG9ydHNbNDA0MDU5XSA9ICdJbnZhbGlkIG9hdXRoIGNsaWVudCBpZC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnO1xuZXhwb3J0c1s0MDQwNjBdID0gJ0ludmFsaWQgb2F1dGggY2xpZW50IHNlY3JldC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnO1xuZXhwb3J0c1s0MDQwNjFdID1cbiAgICAnSW52YWxpZCBvYXV0aCB0b2tlbiByZXF1ZXN0IFVSTC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgVVJMIHN0YXJ0aW5nIHdpdGggdGhlIGh0dHBzIG9yIGh0dHAgcHJvdG9jb2wuJztcbmV4cG9ydHNbNDA0MDYyXSA9ICdJbnZhbGlkIGF1dGhlbnRpY2F0b3I6IFdPUktMT0FEX0lERU5USVRZIHBhcmFtZXRlcnMuICVzJztcbmV4cG9ydHNbNDA0MDYzXSA9ICdJbnZhbGlkIHF1ZXJ5IHRhZy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nOyc7XG4vLyA0MDUwMDFcbmV4cG9ydHNbNDA1MDAxXSA9ICdJbnZhbGlkIGNhbGxiYWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuLy8gNDA1NTAxXG5leHBvcnRzWzQwNTUwMV0gPSAnQ29ubmVjdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzLic7XG5leHBvcnRzWzQwNTUwMl0gPSAnQWxyZWFkeSBjb25uZWN0ZWQuJztcbmV4cG9ydHNbNDA1NTAzXSA9ICdDb25uZWN0aW9uIGFscmVhZHkgdGVybWluYXRlZC4gQ2Fubm90IGNvbm5lY3QgYWdhaW4uJztcbmV4cG9ydHNbNDA1NTA0XSA9XG4gICAgJ2Nvbm5lY3QoKSBkb2VzIG5vdCB3b3JrIHdpdGggZXh0ZXJuYWwgYnJvd3NlciBvciBva3RhIGF1dGhlbnRpY2F0b3JzLCBjYWxsIGNvbm5lY3RBc3luYygpIGluc3RlYWQnO1xuZXhwb3J0c1s0MDU1MDVdID0gJ0NvbmZpZ3VyYXRpb24gZnJvbSBjbGllbnQgY29uZmlnIGZpbGUgZmFpbGVkJztcbmV4cG9ydHNbNDA1NTA2XSA9ICdXcm9uZyBhdXRob3JpemF0aW9uIHR5cGUnO1xuZXhwb3J0c1s0MDU1MDddID0gJ0F1dGhlbnRpY2F0b3Igbm90IGFsbG93ZWQnO1xuLy8gNDA2MDAxXG5leHBvcnRzWzQwNjAwMV0gPSAnSW52YWxpZCBjYWxsYmFjay4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgZnVuY3Rpb24uJztcbi8vIDQwNjUwMVxuZXhwb3J0c1s0MDY1MDFdID0gJ05vdCBjb25uZWN0ZWQsIHNvIG5vdGhpbmcgdG8gZGVzdHJveS4nO1xuZXhwb3J0c1s0MDY1MDJdID0gJ0FscmVhZHkgZGlzY29ubmVjdGVkLic7XG4vLyA0MDcwMDFcbmV4cG9ydHNbNDA3MDAxXSA9ICdVbmFibGUgdG8gcGVyZm9ybSBvcGVyYXRpb24gYmVjYXVzZSBhIGNvbm5lY3Rpb24gd2FzIG5ldmVyIGVzdGFibGlzaGVkLic7XG5leHBvcnRzWzQwNzAwMl0gPSAnVW5hYmxlIHRvIHBlcmZvcm0gb3BlcmF0aW9uIHVzaW5nIHRlcm1pbmF0ZWQgY29ubmVjdGlvbi4nO1xuLy8gNDA4MDAxXG5leHBvcnRzWzQwODAwMV0gPSAnQSBzZXJpYWxpemVkQ29ubmVjdGlvbiBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDgwMDJdID0gJ0ludmFsaWQgc2VyaWFsaXplZENvbm5lY3Rpb24uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDgwMDNdID1cbiAgICBcIkludmFsaWQgc2VyaWFsaXplZENvbm5lY3Rpb24uIFRoZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9idGFpbmVkIGJ5IGNhbGxpbmcgYW5vdGhlciBjb25uZWN0aW9uJ3Mgc2VyaWFsaXplKCkgbWV0aG9kLlwiO1xuLy8gNDA5MDAxXG5leHBvcnRzWzQwOTAwMV0gPSAnRXhlY3V0ZSBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQwOTAwMl0gPSAnSW52YWxpZCBleGVjdXRlIG9wdGlvbnMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJztcbmV4cG9ydHNbNDA5MDAzXSA9ICdBIHNxbFRleHQgdmFsdWUgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA5MDA0XSA9ICdJbnZhbGlkIHNxbFRleHQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDkwMDVdID0gJ0ludmFsaWQgaW50ZXJuYWwgZmxhZy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDkwMDZdID0gJ0ludmFsaWQgcGFyYW1ldGVycy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdC4nO1xuZXhwb3J0c1s0MDkwMDddID0gJ0ludmFsaWQgYmluZHMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBhcnJheS4nO1xuZXhwb3J0c1s0MDkwMDhdID0gJ0ludmFsaWQgYmluZCB2YXJpYWJsZTogJXMuIE9ubHkgc3RyaW5naWZpYWJsZSB2YWx1ZXMgYXJlIHN1cHBvcnRlZC4nO1xuZXhwb3J0c1s0MDkwMDldID0gJ0ludmFsaWQgY29tcGxldGUgY2FsbGJhY2suIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5leHBvcnRzWzQwOTAxMF0gPSAnSW52YWxpZCBzdHJlYW1SZXN1bHQgZmxhZy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDkwMTFdID0gJ0ludmFsaWQgZmV0Y2hBc1N0cmluZyB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIEFycmF5Lic7XG5leHBvcnRzWzQwOTAxMl0gPVxuICAgICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdHlwZTogJXMuIFRoZSBzdXBwb3J0ZWQgdHlwZXMgYXJlOiBTdHJpbmcsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgQnVmZmVyLCBhbmQgSlNPTi4nO1xuZXhwb3J0c1s0MDkwMTNdID0gJ0ludmFsaWQgcmVxdWVzdElkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA5MDE0XSA9ICdJbnZhbGlkIGFzeW5jRXhlYy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDkwMTVdID0gJ0ludmFsaWQgZGVzY3JpYmVPbmx5LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG4vLyA0MTAwMDFcbmV4cG9ydHNbNDEwMDAxXSA9ICdGZXRjaC1yZXN1bHQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MTAwMDJdID0gJ0ludmFsaWQgb3B0aW9ucy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdC4nO1xuZXhwb3J0c1s0MTAwMDNdID0gJ0EgcXVlcnkgaWQvc3RhdGVtZW50IGlkIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQxMDAwNF0gPSAnSW52YWxpZCBxdWVyeSBpZC9zdGF0ZW1lbnQgaWQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MTAwMDVdID0gJ0ludmFsaWQgY29tcGxldGUgY2FsbGJhY2suIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5leHBvcnRzWzQxMDAwNl0gPSAnSW52YWxpZCBzdHJlYW1SZXN1bHQgZmxhZy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MTAwMDddID0gJ0ludmFsaWQgZmV0Y2hBc1N0cmluZyB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIEFycmF5Lic7XG5leHBvcnRzWzQxMDAwOF0gPVxuICAgICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdHlwZTogJXMuIFRoZSBzdXBwb3J0ZWQgdHlwZXMgYXJlOiBTdHJpbmcsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgQnVmZmVyLCBhbmQgSlNPTi4nO1xuZXhwb3J0c1s0MTAwMDldID1cbiAgICAnSW52YWxpZCBjd2QgKGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkpIHR5cGU6ICVzLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbi8vIDQxMTAwMVxuZXhwb3J0c1s0MTEwMDFdID0gJ0ludmFsaWQgb3B0aW9ucy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdC4nO1xuZXhwb3J0c1s0MTEwMDJdID0gJ0ludmFsaWQgc3RhcnQgaW5kZXguIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nO1xuZXhwb3J0c1s0MTEwMDNdID0gJ0ludmFsaWQgZW5kIGluZGV4LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDExMDA0XSA9ICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBBcnJheS4nO1xuZXhwb3J0c1s0MTEwMDVdID1cbiAgICAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIHR5cGU6ICVzLiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZTogU3RyaW5nLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIEJ1ZmZlciwgYW5kIEpTT04uJztcbmV4cG9ydHNbNDExMDA2XSA9XG4gICAgJ0ludmFsaWQgcm93IG1vZGUgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgc2hvdWxkIGJlIGFycmF5IG9yIG9iamVjdCBvciBvYmplY3Rfd2l0aF9yZW5hbWVkX2R1cGxpY2F0ZWRfY29sdW1ucyc7XG5leHBvcnRzWzQxMjAwMV0gPSAnQ2VydGlmaWNhdGUgaXMgUkVWT0tFRC4nO1xuZXhwb3J0c1s0MTIwMDJdID0gJ0NlcnRpZmljYXRlIHN0YXR1cyBpcyBVTktOT1dOLic7XG5leHBvcnRzWzQxMjAwM10gPSAnTm90IHJlY29nbml6ZSBzaWduYXR1cmUgYWxnb3JpdGhtLic7XG5leHBvcnRzWzQxMjAwNF0gPSAnSW52YWxpZCBzaWduYXR1cmUuJztcbmV4cG9ydHNbNDEyMDA1XSA9ICdObyBPQ1NQIHJlc3BvbnNlIGRhdGEgaXMgYXR0YWNoZWQuJztcbmV4cG9ydHNbNDEyMDA2XSA9ICdJbnZhbGlkIHZhbGlkaXR5Lic7XG5leHBvcnRzWzQxMjAwN10gPSAnQ291bGQgbm90IHZlcmlmeSB0aGUgY2VydGlmaWNhdGUgcmV2b2NhdGlvbiBzdGF0dXMuJztcbmV4cG9ydHNbNDEyMDA4XSA9ICdOb3QgdHdvIGVsZW1lbnRzIGFyZSBpbiB0aGUgY2FjaGUuJztcbmV4cG9ydHNbNDEyMDA5XSA9ICdDYWNoZSBlbnRyeSBleHBpcmVkLic7XG5leHBvcnRzWzQxMjAxMF0gPSAnRmFpbGVkIHRvIHBhcnNlIE9DU1AgcmVzcG9uc2UuJztcbmV4cG9ydHNbNDEyMDExXSA9ICdJbnZhbGlkIFNpZ25pbmcgQ2VydGlmaWNhdGUgdmFsaWRpdHkuJztcbmV4cG9ydHNbNDEyMDEyXSA9ICdUaW1lb3V0IE9DU1AgcmVzcG9uZGVyLic7XG5leHBvcnRzWzQxMjAxM10gPSAnVGltZW91dCBPQ1NQIENhY2hlIHNlcnZlci4nO1xuZXhwb3J0c1s0MTIwMTRdID0gJ0ZhaWxlZCB0byBvYnRhaW4gT0NTUCByZXNwb25zZTogJXMnO1xuZXhwb3J0c1s0MTMwMDFdID0gJ0NSTCB2YWxpZGF0aW9uIGZhaWxlZC4nO1xuLy8gNDUwMDAxXG5leHBvcnRzWzQ1MDAwMV0gPSAnRmV0Y2gtcm93IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDUwMDAyXSA9ICdJbnZhbGlkIG9wdGlvbnMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJztcbmV4cG9ydHNbNDUwMDAzXSA9ICdBbiBlYWNoKCkgY2FsbGJhY2sgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDUwMDA0XSA9ICdJbnZhbGlkIGVhY2goKSBjYWxsYmFjay4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgZnVuY3Rpb24uJztcbmV4cG9ydHNbNDUwMDA1XSA9ICdBbiBlbmQoKSBjYWxsYmFjayBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0NTAwMDZdID0gJ0ludmFsaWQgZW5kKCkgY2FsbGJhY2suIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5leHBvcnRzWzQ1MDAwN10gPSAnT3BlcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBzdGF0ZW1lbnQgaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuJztcbi8vIDQ2MDAwMVxuZXhwb3J0c1s0NjAwMDFdID0gJ0ludmFsaWQgcXVlcnlJZDogJXMnO1xuZXhwb3J0c1s0NjAwMDJdID0gJ0Nhbm5vdCByZXRyaWV2ZSBkYXRhLiBObyBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIHNlcnZlciBmb3IgcXVlcnkgJXMnO1xuZXhwb3J0c1s0NjAwMDNdID0gJ1N0YXR1cyBvZiBxdWVyeSAlcyBpcyAlcywgcmVzdWx0cyBhcmUgdW5hdmFpbGFibGUnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JfbWVzc2FnZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst code = {};\ncode.INCORRECT_USERNAME_PASSWORD = '390100';\ncode.SESSION_TOKEN_INVALID = '390104';\ncode.GONE_SESSION = '390111';\ncode.SESSION_TOKEN_EXPIRED = '390112';\ncode.OAUTH_TOKEN_EXPIRED = '390318';\ncode.MASTER_TOKEN_EXPIRED = '390114';\ncode.ID_TOKEN_INVALID = '390195';\nexports.code = code;\n//# sourceMappingURL=gs_errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvZ3NfZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29uc3RhbnRzL2dzX2Vycm9ycy5qcz82ZDE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY29kZSA9IHt9O1xuY29kZS5JTkNPUlJFQ1RfVVNFUk5BTUVfUEFTU1dPUkQgPSAnMzkwMTAwJztcbmNvZGUuU0VTU0lPTl9UT0tFTl9JTlZBTElEID0gJzM5MDEwNCc7XG5jb2RlLkdPTkVfU0VTU0lPTiA9ICczOTAxMTEnO1xuY29kZS5TRVNTSU9OX1RPS0VOX0VYUElSRUQgPSAnMzkwMTEyJztcbmNvZGUuT0FVVEhfVE9LRU5fRVhQSVJFRCA9ICczOTAzMTgnO1xuY29kZS5NQVNURVJfVE9LRU5fRVhQSVJFRCA9ICczOTAxMTQnO1xuY29kZS5JRF9UT0tFTl9JTlZBTElEID0gJzM5MDE5NSc7XG5leHBvcnRzLmNvZGUgPSBjb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3NfZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/query_status.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/query_status.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst code = {};\ncode.RUNNING = 'RUNNING';\ncode.ABORTING = 'ABORTING';\ncode.SUCCESS = 'SUCCESS';\ncode.FAILED_WITH_ERROR = 'FAILED_WITH_ERROR';\ncode.ABORTED = 'ABORTED';\ncode.QUEUED = 'QUEUED';\ncode.FAILED_WITH_INCIDENT = 'FAILED_WITH_INCIDENT';\ncode.DISCONNECTED = 'DISCONNECTED';\ncode.RESUMING_WAREHOUSE = 'RESUMING_WAREHOUSE';\n// purposeful typo.Is present in QueryDTO.java\ncode.QUEUED_REPARING_WAREHOUSE = 'QUEUED_REPARING_WAREHOUSE';\ncode.RESTARTED = 'RESTARTED';\ncode.BLOCKED = 'BLOCKED';\ncode.NO_DATA = 'NO_DATA';\ncode.NO_QUERY_DATA = 'NO_QUERY_DATA';\n// All running query statuses\nconst runningStatuses = [\n    code.RUNNING,\n    code.RESUMING_WAREHOUSE,\n    code.QUEUED,\n    code.QUEUED_REPARING_WAREHOUSE,\n    code.NO_DATA,\n];\n// All error query statuses\nconst errorStatuses = [\n    code.ABORTING,\n    code.FAILED_WITH_ERROR,\n    code.ABORTED,\n    code.FAILED_WITH_INCIDENT,\n    code.DISCONNECTED,\n    code.BLOCKED,\n];\nexports.code = code;\nexports.runningStatuses = runningStatuses;\nexports.errorStatuses = errorStatuses;\n//# sourceMappingURL=query_status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvcXVlcnlfc3RhdHVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbnN0YW50cy9xdWVyeV9zdGF0dXMuanM/NTE1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvZGUgPSB7fTtcbmNvZGUuUlVOTklORyA9ICdSVU5OSU5HJztcbmNvZGUuQUJPUlRJTkcgPSAnQUJPUlRJTkcnO1xuY29kZS5TVUNDRVNTID0gJ1NVQ0NFU1MnO1xuY29kZS5GQUlMRURfV0lUSF9FUlJPUiA9ICdGQUlMRURfV0lUSF9FUlJPUic7XG5jb2RlLkFCT1JURUQgPSAnQUJPUlRFRCc7XG5jb2RlLlFVRVVFRCA9ICdRVUVVRUQnO1xuY29kZS5GQUlMRURfV0lUSF9JTkNJREVOVCA9ICdGQUlMRURfV0lUSF9JTkNJREVOVCc7XG5jb2RlLkRJU0NPTk5FQ1RFRCA9ICdESVNDT05ORUNURUQnO1xuY29kZS5SRVNVTUlOR19XQVJFSE9VU0UgPSAnUkVTVU1JTkdfV0FSRUhPVVNFJztcbi8vIHB1cnBvc2VmdWwgdHlwby5JcyBwcmVzZW50IGluIFF1ZXJ5RFRPLmphdmFcbmNvZGUuUVVFVUVEX1JFUEFSSU5HX1dBUkVIT1VTRSA9ICdRVUVVRURfUkVQQVJJTkdfV0FSRUhPVVNFJztcbmNvZGUuUkVTVEFSVEVEID0gJ1JFU1RBUlRFRCc7XG5jb2RlLkJMT0NLRUQgPSAnQkxPQ0tFRCc7XG5jb2RlLk5PX0RBVEEgPSAnTk9fREFUQSc7XG5jb2RlLk5PX1FVRVJZX0RBVEEgPSAnTk9fUVVFUllfREFUQSc7XG4vLyBBbGwgcnVubmluZyBxdWVyeSBzdGF0dXNlc1xuY29uc3QgcnVubmluZ1N0YXR1c2VzID0gW1xuICAgIGNvZGUuUlVOTklORyxcbiAgICBjb2RlLlJFU1VNSU5HX1dBUkVIT1VTRSxcbiAgICBjb2RlLlFVRVVFRCxcbiAgICBjb2RlLlFVRVVFRF9SRVBBUklOR19XQVJFSE9VU0UsXG4gICAgY29kZS5OT19EQVRBLFxuXTtcbi8vIEFsbCBlcnJvciBxdWVyeSBzdGF0dXNlc1xuY29uc3QgZXJyb3JTdGF0dXNlcyA9IFtcbiAgICBjb2RlLkFCT1JUSU5HLFxuICAgIGNvZGUuRkFJTEVEX1dJVEhfRVJST1IsXG4gICAgY29kZS5BQk9SVEVELFxuICAgIGNvZGUuRkFJTEVEX1dJVEhfSU5DSURFTlQsXG4gICAgY29kZS5ESVNDT05ORUNURUQsXG4gICAgY29kZS5CTE9DS0VELFxuXTtcbmV4cG9ydHMuY29kZSA9IGNvZGU7XG5leHBvcnRzLnJ1bm5pbmdTdGF0dXNlcyA9IHJ1bm5pbmdTdGF0dXNlcztcbmV4cG9ydHMuZXJyb3JTdGF0dXNlcyA9IGVycm9yU3RhdHVzZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeV9zdGF0dXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/query_status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst ARRAY = 'array';\nconst OBJECT = 'object';\nconst OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS = 'object_with_renamed_duplicated_columns';\nconst isValidRowMode = (rowMode) => [ARRAY, OBJECT, OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS].includes(rowMode);\nconst checkRowModeValid = (rowMode) => {\n    Errors.checkArgumentValid(isValidRowMode(rowMode), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE, JSON.stringify(rowMode));\n};\nexports.ARRAY = ARRAY;\nexports.OBJECT = OBJECT;\nexports.OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS = OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS;\nexports.isValidRowMode = isValidRowMode;\nexports.checkRowModeValid = checkRowModeValid;\n//# sourceMappingURL=row_mode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvcm93X21vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjO0FBQ2QsOENBQThDO0FBQzlDLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbnN0YW50cy9yb3dfbW9kZS5qcz9kODc2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgQVJSQVkgPSAnYXJyYXknO1xuY29uc3QgT0JKRUNUID0gJ29iamVjdCc7XG5jb25zdCBPQkpFQ1RfV0lUSF9SRU5BTUVEX0RVUExJQ0FURURfQ09MVU1OUyA9ICdvYmplY3Rfd2l0aF9yZW5hbWVkX2R1cGxpY2F0ZWRfY29sdW1ucyc7XG5jb25zdCBpc1ZhbGlkUm93TW9kZSA9IChyb3dNb2RlKSA9PiBbQVJSQVksIE9CSkVDVCwgT0JKRUNUX1dJVEhfUkVOQU1FRF9EVVBMSUNBVEVEX0NPTFVNTlNdLmluY2x1ZGVzKHJvd01vZGUpO1xuY29uc3QgY2hlY2tSb3dNb2RlVmFsaWQgPSAocm93TW9kZSkgPT4ge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoaXNWYWxpZFJvd01vZGUocm93TW9kZSksIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9ST1dfTU9ERSwgSlNPTi5zdHJpbmdpZnkocm93TW9kZSkpO1xufTtcbmV4cG9ydHMuQVJSQVkgPSBBUlJBWTtcbmV4cG9ydHMuT0JKRUNUID0gT0JKRUNUO1xuZXhwb3J0cy5PQkpFQ1RfV0lUSF9SRU5BTUVEX0RVUExJQ0FURURfQ09MVU1OUyA9IE9CSkVDVF9XSVRIX1JFTkFNRURfRFVQTElDQVRFRF9DT0xVTU5TO1xuZXhwb3J0cy5pc1ZhbGlkUm93TW9kZSA9IGlzVmFsaWRSb3dNb2RlO1xuZXhwb3J0cy5jaGVja1Jvd01vZGVWYWxpZCA9IGNoZWNrUm93TW9kZVZhbGlkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm93X21vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nexports.paramsNames = Object.freeze({\n    SF_REQUEST_GUID: 'request_guid',\n    SF_REQUEST_ID: 'requestId',\n    SF_TOKEN: 'token',\n    SF_WAREHOUSE_NAME: 'warehouse',\n    SF_DB_NAME: 'databaseName',\n    SF_SCHEMA_NAME: 'schemaName',\n});\n//# sourceMappingURL=sf_params.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvc2ZfcGFyYW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29uc3RhbnRzL3NmX3BhcmFtcy5qcz80MDZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5wYXJhbXNOYW1lcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIFNGX1JFUVVFU1RfR1VJRDogJ3JlcXVlc3RfZ3VpZCcsXG4gICAgU0ZfUkVRVUVTVF9JRDogJ3JlcXVlc3RJZCcsXG4gICAgU0ZfVE9LRU46ICd0b2tlbicsXG4gICAgU0ZfV0FSRUhPVVNFX05BTUU6ICd3YXJlaG91c2UnLFxuICAgIFNGX0RCX05BTUU6ICdkYXRhYmFzZU5hbWUnLFxuICAgIFNGX1NDSEVNQV9OQU1FOiAnc2NoZW1hTmFtZScsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNmX3BhcmFtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/core.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/core.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Connection = __webpack_require__(/*! ./connection/connection */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection.js\");\nconst ConnectionConfig = __webpack_require__(/*! ./connection/connection_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js\");\nconst ConnectionContext = __webpack_require__(/*! ./connection/connection_context */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js\");\nconst GenericPool = __webpack_require__(/*! generic-pool */ \"(rsc)/./node_modules/generic-pool/index.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst LoggerCore = __webpack_require__(/*! ./logger/core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\nconst DataTypes = __webpack_require__(/*! ./connection/result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst GlobalConfig = __webpack_require__(/*! ./global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst GlobalConfigTyped = (__webpack_require__(/*! ./global_config_typed */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\")[\"default\"]);\nconst { loadConnectionConfiguration } = __webpack_require__(/*! ./configuration/connection_configuration */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js\");\n/**\n * Creates a new instance of the Snowflake core module.\n *\n * @param {Object} options\n *\n * @returns {Object}\n * @constructor\n */\nfunction Core(options) {\n    // validate input\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.exists(options.httpClient || options.httpClientClass));\n    Errors.assertInternal(Util.exists(options.loggerClass));\n    // set the logger instance\n    Logger.setInstance(new options.loggerClass());\n    Logger.getInstance().trace('Logger was initialized.');\n    // if a connection class is specified, it must be an object or function\n    let connectionClass = options.connectionClass;\n    if (Util.exists(connectionClass)) {\n        Errors.assertInternal(Util.isObject(connectionClass) || Util.isFunction(connectionClass));\n        Logger.getInstance().debug('Connection class provided in driver core options will be used.');\n    }\n    else {\n        // fall back to Connection\n        connectionClass = Connection;\n        Logger.getInstance().debug('Connection class was not overridden. Default connection class will be used.');\n    }\n    const qaMode = options.qaMode;\n    const clientInfo = options.client;\n    const ocspModes = GlobalConfig.ocspModes;\n    /**\n     * Creates a new Connection instance.\n     *\n     * @param {Object} connectionOptions\n     * @param {Object} [config]\n     *\n     * @returns {Object}\n     */\n    const createConnection = function createConnection(connectionOptions, config) {\n        // create a new ConnectionConfig and skip credential-validation if a config\n        // object has been specified; this is because if a config object has been\n        // specified, we're trying to deserialize a connection and the account name,\n        // username and password don't need to be specified because the config\n        // object already contains the tokens we need\n        // Alternatively, if the connectionOptions includes token information then we will use that\n        // instead of the username/password\n        Logger.getInstance().info('Creating new connection object');\n        if (connectionOptions == null) {\n            Logger.getInstance().info('Connection options were not specified. Loading connection configuration.');\n            try {\n                connectionOptions = loadConnectionConfiguration();\n            }\n            catch (error) {\n                Logger.getInstance().error('Unable to load the connection configuration. Error: %s', error.message);\n                Errors.checkArgumentExists(Util.exists(connectionOptions), ErrorCodes.ERR_CONN_CREATE_MISSING_OPTIONS);\n            }\n        }\n        const validateCredentials = !config && connectionOptions && !connectionOptions.sessionToken;\n        const connectionConfig = new ConnectionConfig(connectionOptions, validateCredentials, qaMode, clientInfo);\n        Logger.getInstance().debug('Connection configuration object created');\n        // if an http client was specified in the options passed to the module, use\n        // it, otherwise create a new HttpClient\n        const httpClient = options.httpClient || new options.httpClientClass(connectionConfig);\n        Logger.getInstance().debug('HttpClient setup finished');\n        const connection = new connectionClass(new ConnectionContext(connectionConfig, httpClient, config));\n        Logger.getInstance().info('Connection[id: %s] - connection object created successfully.', connection.getId());\n        return connection;\n    };\n    const instance = {\n        ocspModes: ocspModes,\n        ErrorCode: ErrorCodes,\n        /**\n         * Creates a connection object that can be used to communicate with\n         * Snowflake.\n         *\n         * @param {Object} options\n         *\n         * @returns {Object}\n         */\n        createConnection: function (options) {\n            return createConnection(options);\n        },\n        /**\n         * Creates a connection pool for Snowflake connections\n         *\n         * @param {Object} connectionOptions\n         * @param {Object} poolOptions\n         *\n         * @returns {Object}\n         */\n        createPool: function (connectionOptions, poolOptions) {\n            return createPool(connectionOptions, poolOptions);\n        },\n        /**\n         * Deserializes a serialized connection.\n         *\n         * @param {Object} options\n         * @param {String} serializedConnection\n         *\n         * @returns {Object}\n         */\n        deserializeConnection: function (options, serializedConnection) {\n            // check for missing serializedConfig\n            Logger.getInstance().trace('Deserializing connection');\n            Errors.checkArgumentExists(Util.exists(serializedConnection), ErrorCodes.ERR_CONN_DESERIALIZE_MISSING_CONFIG);\n            // check for invalid serializedConfig\n            Errors.checkArgumentValid(Util.isString(serializedConnection), ErrorCodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE);\n            Logger.getInstance().debug('Deserializing connection from string object');\n            // try to json-parse serializedConfig\n            let config;\n            try {\n                config = JSON.parse(serializedConnection);\n            }\n            finally {\n                // if serializedConfig can't be parsed to json, throw an error\n                Errors.checkArgumentValid(Util.isObject(config), ErrorCodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM);\n            }\n            Logger.getInstance().debug('Connection deserialized successfully');\n            return createConnection(options, config);\n        },\n        /**\n         * Serializes a given connection.\n         *\n         * @param {Object} connection\n         *\n         * @returns {String} a serialized version of the connection.\n         */\n        serializeConnection: function (connection) {\n            Logger.getInstance().trace('Connection[id: %s] - serializing connection.', connection.getId());\n            return connection ? connection.serialize() : connection;\n        },\n        /**\n         * Configures this instance of the Snowflake core module.\n         *\n         * @param {Object} options\n         */\n        configure: function (options) {\n            Logger.getInstance().debug('Configuring Snowflake core module.');\n            const logLevel = extractLogLevel(options);\n            const logFilePath = options.logFilePath;\n            const additionalLogToConsole = options.additionalLogToConsole;\n            if (logLevel != null || logFilePath) {\n                Logger.getInstance().configure({\n                    level: logLevel,\n                    filePath: logFilePath,\n                    additionalLogToConsole: additionalLogToConsole,\n                });\n                Logger.getInstance().info('Configuring logger with level: %s, filePath: %s, additionalLogToConsole: %s', logLevel, logFilePath, additionalLogToConsole);\n            }\n            GlobalConfigTyped.setValues(options);\n            const disableOCSPChecks = options.disableOCSPChecks;\n            if (Util.exists(disableOCSPChecks)) {\n                // check that the specified value is a boolean\n                Errors.checkArgumentValid(Util.isBoolean(disableOCSPChecks), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS);\n                GlobalConfig.setDisableOCSPChecks(disableOCSPChecks);\n                Logger.getInstance().debug('Setting disableOCSPChecks to value from core options: %s', disableOCSPChecks);\n            }\n            const ocspFailOpen = options.ocspFailOpen;\n            if (Util.exists(ocspFailOpen)) {\n                Errors.checkArgumentValid(Util.isBoolean(ocspFailOpen), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE);\n                GlobalConfig.setOcspFailOpen(ocspFailOpen);\n                Logger.getInstance().debug('Setting ocspFailOpen to value from core options: %s ', ocspFailOpen);\n            }\n            const jsonColumnVariantParser = options.jsonColumnVariantParser;\n            if (Util.exists(jsonColumnVariantParser)) {\n                Errors.checkArgumentValid(Util.isFunction(jsonColumnVariantParser), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER);\n                GlobalConfig.setJsonColumnVariantParser(jsonColumnVariantParser);\n                Logger.getInstance().debug('Setting JSON Column Variant Parser to value from core options');\n            }\n            const xmlColumnVariantParser = options.xmlColumnVariantParser;\n            const xmlParserConfig = options.xmlParserConfig;\n            if (Util.exists(xmlColumnVariantParser)) {\n                Errors.checkArgumentValid(Util.isFunction(xmlColumnVariantParser), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER);\n                GlobalConfig.setXmlColumnVariantParser(xmlColumnVariantParser);\n                Logger.getInstance().debug('Setting XML Column Variant Parser to value from core options');\n            }\n            else if (Util.exists(xmlParserConfig)) {\n                GlobalConfig.createXmlColumnVariantParserWithParameters(xmlParserConfig);\n                Logger.getInstance().debug('Creating XML Column Variant Parser with parameters from core options');\n            }\n            const keepAlive = options.keepAlive;\n            if (Util.exists(keepAlive)) {\n                Errors.checkArgumentValid(Util.isBoolean(keepAlive), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE);\n                GlobalConfig.setKeepAlive(keepAlive);\n                Logger.getInstance().debug('Setting keepAlive to value from core options: %s', keepAlive);\n            }\n            const useEnvProxy = options.useEnvProxy;\n            if (Util.exists(useEnvProxy)) {\n                Errors.checkArgumentValid(Util.isBoolean(useEnvProxy), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY);\n                GlobalConfig.setEnvProxy(useEnvProxy);\n            }\n            const customCredentialManager = options.customCredentialManager;\n            if (Util.exists(customCredentialManager)) {\n                Errors.checkArgumentValid(Util.isObject(customCredentialManager), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER);\n                GlobalConfig.setCustomCredentialManager(customCredentialManager);\n                Logger.getInstance().debug('Setting customCredentialManager to value from core options %s', customCredentialManager);\n            }\n        },\n    };\n    function extractLogLevel(options) {\n        const logTag = options.logLevel;\n        if (Util.exists(logTag)) {\n            Errors.checkArgumentValid(LoggerCore.isValidLogTag(logTag), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL);\n            return LoggerCore.logTagToLevel(logTag);\n        }\n        return null;\n    }\n    // add some read-only constants\n    const nativeTypeValues = DataTypes.NativeTypes.values;\n    Object.defineProperties(instance, {\n        STRING: { value: nativeTypeValues.STRING },\n        BOOLEAN: { value: nativeTypeValues.BOOLEAN },\n        NUMBER: { value: nativeTypeValues.NUMBER },\n        DATE: { value: nativeTypeValues.DATE },\n        OBJECT: { value: nativeTypeValues.OBJECT },\n        ARRAY: { value: nativeTypeValues.ARRAY },\n        MAP: { value: nativeTypeValues.MAP },\n        JSON: { value: nativeTypeValues.JSON },\n    });\n    /**\n     * Factory for Snowflake connections based on Generic Pool\n     *\n     * @param {Object} connectionOptions\n     *\n     * @returns {null}\n     */\n    function ConnectionFactory(connectionOptions) {\n        /**\n         * Creates a new connection instance.\n         *\n         * @returns {Object}\n         */\n        this.create = function () {\n            Logger.getInstance().debug('Creating new connection from factory.');\n            const connection = new createConnection(connectionOptions);\n            return new Promise((resolve, reject) => {\n                connection.connect(function (err, conn) {\n                    if (err) {\n                        Logger.getInstance().error('Connection[id: %s] - Unable to connect. Error: %s', conn.getId(), err.message);\n                        reject(new Error(err.message));\n                    }\n                    else {\n                        Logger.getInstance().debug('Connection[id: %s] - connected successfully. Callback called.', conn.getId());\n                        resolve(conn);\n                    }\n                });\n            });\n        };\n        /**\n         * Destroys the specified connection instance.\n         *\n         * @param {Object} connection\n         *\n         * @returns {Object}\n         */\n        this.destroy = function (connection) {\n            Logger.getInstance().debug('Destroying connection instance.');\n            return new Promise((resolve) => {\n                connection.destroy(function (err, conn) {\n                    if (err) {\n                        Logger.getInstance().error('Connection[id: %s] - disconnecting failed with error: %s', conn.getId(), err.message);\n                    }\n                    else {\n                        Logger.getInstance().debug('Connection[id: %s] - connection disconnected successfully. Callback called.', conn.getId());\n                    }\n                    resolve();\n                });\n            });\n        };\n        /**\n         * Returns the status of the connection.\n         *\n         * @param {Object} connection\n         *\n         * @returns {Boolean}\n         */\n        this.validate = async function (connection) {\n            Logger.getInstance().debug('Connection[id: %s] - validating connection instance', connection.getId());\n            return await connection.isValidAsync();\n        };\n    }\n    /**\n     * Creates a connection pool for Snowflake connections\n     *\n     * @param {Object} connectionOptions\n     * @param {Object} poolOptions\n     *\n     * @returns {Object}\n     */\n    const createPool = function createPool(connectionOptions, poolOptions) {\n        Logger.getInstance().info('Creating connection pool with provided options');\n        const connectionPool = GenericPool.createPool(new ConnectionFactory(connectionOptions), poolOptions);\n        Logger.getInstance().debug('Base for connection pool created');\n        // avoid infinite loop if factory creation fails\n        connectionPool.on('factoryCreateError', function (err) {\n            Logger.getInstance().error('Connection pool factory creation failed: %s', err.message);\n            const clientResourceRequest = connectionPool._waitingClientsQueue.dequeue();\n            if (clientResourceRequest) {\n                clientResourceRequest.reject(err);\n            }\n        });\n        Logger.getInstance().info('Connection pool object created successfully');\n        return connectionPool;\n    };\n    return instance;\n}\nmodule.exports = Core;\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG1FQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHFHQUF5QjtBQUNwRCx5QkFBeUIsbUJBQU8sQ0FBQyxtSEFBZ0M7QUFDakUsMEJBQTBCLG1CQUFPLENBQUMscUhBQWlDO0FBQ25FLG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBZTtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxtSEFBZ0M7QUFDMUQscUJBQXFCLG1CQUFPLENBQUMscUZBQWlCO0FBQzlDLDBCQUEwQixtSUFBd0M7QUFDbEUsUUFBUSw4QkFBOEIsRUFBRSxtQkFBTyxDQUFDLHVJQUEwQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQsbUJBQW1CLGlDQUFpQztBQUNwRCxrQkFBa0IsZ0NBQWdDO0FBQ2xELGdCQUFnQiw4QkFBOEI7QUFDOUMsa0JBQWtCLGdDQUFnQztBQUNsRCxpQkFBaUIsK0JBQStCO0FBQ2hELGVBQWUsNkJBQTZCO0FBQzVDLGdCQUFnQiw4QkFBOEI7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb3JlLmpzPzljZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IENvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbicpO1xuY29uc3QgQ29ubmVjdGlvbkNvbmZpZyA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9jb25uZWN0aW9uX2NvbmZpZycpO1xuY29uc3QgQ29ubmVjdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9jb250ZXh0Jyk7XG5jb25zdCBHZW5lcmljUG9vbCA9IHJlcXVpcmUoJ2dlbmVyaWMtcG9vbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbmNvbnN0IExvZ2dlckNvcmUgPSByZXF1aXJlKCcuL2xvZ2dlci9jb3JlJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vcmVzdWx0L2RhdGFfdHlwZXMnKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgR2xvYmFsQ29uZmlnVHlwZWQgPSByZXF1aXJlKCcuL2dsb2JhbF9jb25maWdfdHlwZWQnKS5kZWZhdWx0O1xuY29uc3QgeyBsb2FkQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4vY29uZmlndXJhdGlvbi9jb25uZWN0aW9uX2NvbmZpZ3VyYXRpb24nKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgU25vd2ZsYWtlIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb3JlKG9wdGlvbnMpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMob3B0aW9ucy5odHRwQ2xpZW50IHx8IG9wdGlvbnMuaHR0cENsaWVudENsYXNzKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKG9wdGlvbnMubG9nZ2VyQ2xhc3MpKTtcbiAgICAvLyBzZXQgdGhlIGxvZ2dlciBpbnN0YW5jZVxuICAgIExvZ2dlci5zZXRJbnN0YW5jZShuZXcgb3B0aW9ucy5sb2dnZXJDbGFzcygpKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnTG9nZ2VyIHdhcyBpbml0aWFsaXplZC4nKTtcbiAgICAvLyBpZiBhIGNvbm5lY3Rpb24gY2xhc3MgaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGFuIG9iamVjdCBvciBmdW5jdGlvblxuICAgIGxldCBjb25uZWN0aW9uQ2xhc3MgPSBvcHRpb25zLmNvbm5lY3Rpb25DbGFzcztcbiAgICBpZiAoVXRpbC5leGlzdHMoY29ubmVjdGlvbkNsYXNzKSkge1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25uZWN0aW9uQ2xhc3MpIHx8IFV0aWwuaXNGdW5jdGlvbihjb25uZWN0aW9uQ2xhc3MpKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb24gY2xhc3MgcHJvdmlkZWQgaW4gZHJpdmVyIGNvcmUgb3B0aW9ucyB3aWxsIGJlIHVzZWQuJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gQ29ubmVjdGlvblxuICAgICAgICBjb25uZWN0aW9uQ2xhc3MgPSBDb25uZWN0aW9uO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbiBjbGFzcyB3YXMgbm90IG92ZXJyaWRkZW4uIERlZmF1bHQgY29ubmVjdGlvbiBjbGFzcyB3aWxsIGJlIHVzZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHFhTW9kZSA9IG9wdGlvbnMucWFNb2RlO1xuICAgIGNvbnN0IGNsaWVudEluZm8gPSBvcHRpb25zLmNsaWVudDtcbiAgICBjb25zdCBvY3NwTW9kZXMgPSBHbG9iYWxDb25maWcub2NzcE1vZGVzO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdCBjcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uT3B0aW9ucywgY29uZmlnKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBDb25uZWN0aW9uQ29uZmlnIGFuZCBza2lwIGNyZWRlbnRpYWwtdmFsaWRhdGlvbiBpZiBhIGNvbmZpZ1xuICAgICAgICAvLyBvYmplY3QgaGFzIGJlZW4gc3BlY2lmaWVkOyB0aGlzIGlzIGJlY2F1c2UgaWYgYSBjb25maWcgb2JqZWN0IGhhcyBiZWVuXG4gICAgICAgIC8vIHNwZWNpZmllZCwgd2UncmUgdHJ5aW5nIHRvIGRlc2VyaWFsaXplIGEgY29ubmVjdGlvbiBhbmQgdGhlIGFjY291bnQgbmFtZSxcbiAgICAgICAgLy8gdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGRvbid0IG5lZWQgdG8gYmUgc3BlY2lmaWVkIGJlY2F1c2UgdGhlIGNvbmZpZ1xuICAgICAgICAvLyBvYmplY3QgYWxyZWFkeSBjb250YWlucyB0aGUgdG9rZW5zIHdlIG5lZWRcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmVseSwgaWYgdGhlIGNvbm5lY3Rpb25PcHRpb25zIGluY2x1ZGVzIHRva2VuIGluZm9ybWF0aW9uIHRoZW4gd2Ugd2lsbCB1c2UgdGhhdFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSB1c2VybmFtZS9wYXNzd29yZFxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDcmVhdGluZyBuZXcgY29ubmVjdGlvbiBvYmplY3QnKTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25PcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb24gb3B0aW9ucyB3ZXJlIG5vdCBzcGVjaWZpZWQuIExvYWRpbmcgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uLicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucyA9IGxvYWRDb25uZWN0aW9uQ29uZmlndXJhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1VuYWJsZSB0byBsb2FkIHRoZSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24uIEVycm9yOiAlcycsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKGNvbm5lY3Rpb25PcHRpb25zKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19PUFRJT05TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZGF0ZUNyZWRlbnRpYWxzID0gIWNvbmZpZyAmJiBjb25uZWN0aW9uT3B0aW9ucyAmJiAhY29ubmVjdGlvbk9wdGlvbnMuc2Vzc2lvblRva2VuO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gbmV3IENvbm5lY3Rpb25Db25maWcoY29ubmVjdGlvbk9wdGlvbnMsIHZhbGlkYXRlQ3JlZGVudGlhbHMsIHFhTW9kZSwgY2xpZW50SW5mbyk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNyZWF0ZWQnKTtcbiAgICAgICAgLy8gaWYgYW4gaHR0cCBjbGllbnQgd2FzIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIG1vZHVsZSwgdXNlXG4gICAgICAgIC8vIGl0LCBvdGhlcndpc2UgY3JlYXRlIGEgbmV3IEh0dHBDbGllbnRcbiAgICAgICAgY29uc3QgaHR0cENsaWVudCA9IG9wdGlvbnMuaHR0cENsaWVudCB8fCBuZXcgb3B0aW9ucy5odHRwQ2xpZW50Q2xhc3MoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdIdHRwQ2xpZW50IHNldHVwIGZpbmlzaGVkJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgY29ubmVjdGlvbkNsYXNzKG5ldyBDb25uZWN0aW9uQ29udGV4dChjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBjb25maWcpKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIC0gY29ubmVjdGlvbiBvYmplY3QgY3JlYXRlZCBzdWNjZXNzZnVsbHkuJywgY29ubmVjdGlvbi5nZXRJZCgpKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICAgICAgb2NzcE1vZGVzOiBvY3NwTW9kZXMsXG4gICAgICAgIEVycm9yQ29kZTogRXJyb3JDb2RlcyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb25uZWN0aW9uIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbW11bmljYXRlIHdpdGhcbiAgICAgICAgICogU25vd2ZsYWtlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ29ubmVjdGlvbjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvbm5lY3Rpb24gcG9vbCBmb3IgU25vd2ZsYWtlIGNvbm5lY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uT3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9vbE9wdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVBvb2w6IGZ1bmN0aW9uIChjb25uZWN0aW9uT3B0aW9ucywgcG9vbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQb29sKGNvbm5lY3Rpb25PcHRpb25zLCBwb29sT3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXNlcmlhbGl6ZXMgYSBzZXJpYWxpemVkIGNvbm5lY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJpYWxpemVkQ29ubmVjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzZXJpYWxpemVDb25uZWN0aW9uOiBmdW5jdGlvbiAob3B0aW9ucywgc2VyaWFsaXplZENvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIHNlcmlhbGl6ZWRDb25maWdcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdEZXNlcmlhbGl6aW5nIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHNlcmlhbGl6ZWRDb25uZWN0aW9uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9ERVNFUklBTElaRV9NSVNTSU5HX0NPTkZJRyk7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBzZXJpYWxpemVkQ29uZmlnXG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcoc2VyaWFsaXplZENvbm5lY3Rpb24pLCBFcnJvckNvZGVzLkVSUl9DT05OX0RFU0VSSUFMSVpFX0lOVkFMSURfQ09ORklHX1RZUEUpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Rlc2VyaWFsaXppbmcgY29ubmVjdGlvbiBmcm9tIHN0cmluZyBvYmplY3QnKTtcbiAgICAgICAgICAgIC8vIHRyeSB0byBqc29uLXBhcnNlIHNlcmlhbGl6ZWRDb25maWdcbiAgICAgICAgICAgIGxldCBjb25maWc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZENvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc2VyaWFsaXplZENvbmZpZyBjYW4ndCBiZSBwYXJzZWQgdG8ganNvbiwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3QoY29uZmlnKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9ERVNFUklBTElaRV9JTlZBTElEX0NPTkZJR19GT1JNKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uIGRlc2VyaWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXJpYWxpemVzIGEgZ2l2ZW4gY29ubmVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBzZXJpYWxpemVDb25uZWN0aW9uOiBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHNlcmlhbGl6aW5nIGNvbm5lY3Rpb24uJywgY29ubmVjdGlvbi5nZXRJZCgpKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uID8gY29ubmVjdGlvbi5zZXJpYWxpemUoKSA6IGNvbm5lY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoaXMgaW5zdGFuY2Ugb2YgdGhlIFNub3dmbGFrZSBjb3JlIG1vZHVsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25maWd1cmluZyBTbm93Zmxha2UgY29yZSBtb2R1bGUuJyk7XG4gICAgICAgICAgICBjb25zdCBsb2dMZXZlbCA9IGV4dHJhY3RMb2dMZXZlbChvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0ZpbGVQYXRoID0gb3B0aW9ucy5sb2dGaWxlUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxMb2dUb0NvbnNvbGUgPSBvcHRpb25zLmFkZGl0aW9uYWxMb2dUb0NvbnNvbGU7XG4gICAgICAgICAgICBpZiAobG9nTGV2ZWwgIT0gbnVsbCB8fCBsb2dGaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsb2dMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IGxvZ0ZpbGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsTG9nVG9Db25zb2xlOiBhZGRpdGlvbmFsTG9nVG9Db25zb2xlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0NvbmZpZ3VyaW5nIGxvZ2dlciB3aXRoIGxldmVsOiAlcywgZmlsZVBhdGg6ICVzLCBhZGRpdGlvbmFsTG9nVG9Db25zb2xlOiAlcycsIGxvZ0xldmVsLCBsb2dGaWxlUGF0aCwgYWRkaXRpb25hbExvZ1RvQ29uc29sZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBHbG9iYWxDb25maWdUeXBlZC5zZXRWYWx1ZXMob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBkaXNhYmxlT0NTUENoZWNrcyA9IG9wdGlvbnMuZGlzYWJsZU9DU1BDaGVja3M7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoZGlzYWJsZU9DU1BDaGVja3MpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhblxuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oZGlzYWJsZU9DU1BDaGVja3MpLCBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfRElTQUJMRV9PQ1NQX0NIRUNLUyk7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLnNldERpc2FibGVPQ1NQQ2hlY2tzKGRpc2FibGVPQ1NQQ2hlY2tzKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnU2V0dGluZyBkaXNhYmxlT0NTUENoZWNrcyB0byB2YWx1ZSBmcm9tIGNvcmUgb3B0aW9uczogJXMnLCBkaXNhYmxlT0NTUENoZWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvY3NwRmFpbE9wZW4gPSBvcHRpb25zLm9jc3BGYWlsT3BlbjtcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhvY3NwRmFpbE9wZW4pKSB7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihvY3NwRmFpbE9wZW4pLCBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfT0NTUF9NT0RFKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxDb25maWcuc2V0T2NzcEZhaWxPcGVuKG9jc3BGYWlsT3Blbik7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1NldHRpbmcgb2NzcEZhaWxPcGVuIHRvIHZhbHVlIGZyb20gY29yZSBvcHRpb25zOiAlcyAnLCBvY3NwRmFpbE9wZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QganNvbkNvbHVtblZhcmlhbnRQYXJzZXIgPSBvcHRpb25zLmpzb25Db2x1bW5WYXJpYW50UGFyc2VyO1xuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKGpzb25Db2x1bW5WYXJpYW50UGFyc2VyKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Z1bmN0aW9uKGpzb25Db2x1bW5WYXJpYW50UGFyc2VyKSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0pTT05fUEFSU0VSKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxDb25maWcuc2V0SnNvbkNvbHVtblZhcmlhbnRQYXJzZXIoanNvbkNvbHVtblZhcmlhbnRQYXJzZXIpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIEpTT04gQ29sdW1uIFZhcmlhbnQgUGFyc2VyIHRvIHZhbHVlIGZyb20gY29yZSBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB4bWxDb2x1bW5WYXJpYW50UGFyc2VyID0gb3B0aW9ucy54bWxDb2x1bW5WYXJpYW50UGFyc2VyO1xuICAgICAgICAgICAgY29uc3QgeG1sUGFyc2VyQ29uZmlnID0gb3B0aW9ucy54bWxQYXJzZXJDb25maWc7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoeG1sQ29sdW1uVmFyaWFudFBhcnNlcikpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNGdW5jdGlvbih4bWxDb2x1bW5WYXJpYW50UGFyc2VyKSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1hNTF9QQVJTRVIpO1xuICAgICAgICAgICAgICAgIEdsb2JhbENvbmZpZy5zZXRYbWxDb2x1bW5WYXJpYW50UGFyc2VyKHhtbENvbHVtblZhcmlhbnRQYXJzZXIpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIFhNTCBDb2x1bW4gVmFyaWFudCBQYXJzZXIgdG8gdmFsdWUgZnJvbSBjb3JlIG9wdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFV0aWwuZXhpc3RzKHhtbFBhcnNlckNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBHbG9iYWxDb25maWcuY3JlYXRlWG1sQ29sdW1uVmFyaWFudFBhcnNlcldpdGhQYXJhbWV0ZXJzKHhtbFBhcnNlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0NyZWF0aW5nIFhNTCBDb2x1bW4gVmFyaWFudCBQYXJzZXIgd2l0aCBwYXJhbWV0ZXJzIGZyb20gY29yZSBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZWVwQWxpdmUgPSBvcHRpb25zLmtlZXBBbGl2ZTtcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhrZWVwQWxpdmUpKSB7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihrZWVwQWxpdmUpLCBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfS0VFUF9BTElWRSk7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLnNldEtlZXBBbGl2ZShrZWVwQWxpdmUpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIGtlZXBBbGl2ZSB0byB2YWx1ZSBmcm9tIGNvcmUgb3B0aW9uczogJXMnLCBrZWVwQWxpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXNlRW52UHJveHkgPSBvcHRpb25zLnVzZUVudlByb3h5O1xuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHVzZUVudlByb3h5KSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4odXNlRW52UHJveHkpLCBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfVVNFX0VOVl9QUk9YWSk7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLnNldEVudlByb3h5KHVzZUVudlByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyID0gb3B0aW9ucy5jdXN0b21DcmVkZW50aWFsTWFuYWdlcjtcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhjdXN0b21DcmVkZW50aWFsTWFuYWdlcikpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3QoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIpLCBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfQ1VTVE9NX0NSRURFTlRJQUxfTUFOQUdFUik7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLnNldEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnU2V0dGluZyBjdXN0b21DcmVkZW50aWFsTWFuYWdlciB0byB2YWx1ZSBmcm9tIGNvcmUgb3B0aW9ucyAlcycsIGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RMb2dMZXZlbChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxvZ1RhZyA9IG9wdGlvbnMubG9nTGV2ZWw7XG4gICAgICAgIGlmIChVdGlsLmV4aXN0cyhsb2dUYWcpKSB7XG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKExvZ2dlckNvcmUuaXNWYWxpZExvZ1RhZyhsb2dUYWcpLCBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfTE9HX0xFVkVMKTtcbiAgICAgICAgICAgIHJldHVybiBMb2dnZXJDb3JlLmxvZ1RhZ1RvTGV2ZWwobG9nVGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gYWRkIHNvbWUgcmVhZC1vbmx5IGNvbnN0YW50c1xuICAgIGNvbnN0IG5hdGl2ZVR5cGVWYWx1ZXMgPSBEYXRhVHlwZXMuTmF0aXZlVHlwZXMudmFsdWVzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGluc3RhbmNlLCB7XG4gICAgICAgIFNUUklORzogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5TVFJJTkcgfSxcbiAgICAgICAgQk9PTEVBTjogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5CT09MRUFOIH0sXG4gICAgICAgIE5VTUJFUjogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5OVU1CRVIgfSxcbiAgICAgICAgREFURTogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5EQVRFIH0sXG4gICAgICAgIE9CSkVDVDogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5PQkpFQ1QgfSxcbiAgICAgICAgQVJSQVk6IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuQVJSQVkgfSxcbiAgICAgICAgTUFQOiB7IHZhbHVlOiBuYXRpdmVUeXBlVmFsdWVzLk1BUCB9LFxuICAgICAgICBKU09OOiB7IHZhbHVlOiBuYXRpdmVUeXBlVmFsdWVzLkpTT04gfSxcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IGZvciBTbm93Zmxha2UgY29ubmVjdGlvbnMgYmFzZWQgb24gR2VuZXJpYyBQb29sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbk9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25GYWN0b3J5KGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDcmVhdGluZyBuZXcgY29ubmVjdGlvbiBmcm9tIGZhY3RvcnkuJyk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IGNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3QoZnVuY3Rpb24gKGVyciwgY29ubikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gVW5hYmxlIHRvIGNvbm5lY3QuIEVycm9yOiAlcycsIGNvbm4uZ2V0SWQoKSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnIubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RlZCBzdWNjZXNzZnVsbHkuIENhbGxiYWNrIGNhbGxlZC4nLCBjb25uLmdldElkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjb25uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgc3BlY2lmaWVkIGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Rlc3Ryb3lpbmcgY29ubmVjdGlvbiBpbnN0YW5jZS4nKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uZGVzdHJveShmdW5jdGlvbiAoZXJyLCBjb25uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBkaXNjb25uZWN0aW5nIGZhaWxlZCB3aXRoIGVycm9yOiAlcycsIGNvbm4uZ2V0SWQoKSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3Rpb24gZGlzY29ubmVjdGVkIHN1Y2Nlc3NmdWxseS4gQ2FsbGJhY2sgY2FsbGVkLicsIGNvbm4uZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gdmFsaWRhdGluZyBjb25uZWN0aW9uIGluc3RhbmNlJywgY29ubmVjdGlvbi5nZXRJZCgpKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLmlzVmFsaWRBc3luYygpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29ubmVjdGlvbiBwb29sIGZvciBTbm93Zmxha2UgY29ubmVjdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb29sT3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdCBjcmVhdGVQb29sID0gZnVuY3Rpb24gY3JlYXRlUG9vbChjb25uZWN0aW9uT3B0aW9ucywgcG9vbE9wdGlvbnMpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ3JlYXRpbmcgY29ubmVjdGlvbiBwb29sIHdpdGggcHJvdmlkZWQgb3B0aW9ucycpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uUG9vbCA9IEdlbmVyaWNQb29sLmNyZWF0ZVBvb2wobmV3IENvbm5lY3Rpb25GYWN0b3J5KGNvbm5lY3Rpb25PcHRpb25zKSwgcG9vbE9wdGlvbnMpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQmFzZSBmb3IgY29ubmVjdGlvbiBwb29sIGNyZWF0ZWQnKTtcbiAgICAgICAgLy8gYXZvaWQgaW5maW5pdGUgbG9vcCBpZiBmYWN0b3J5IGNyZWF0aW9uIGZhaWxzXG4gICAgICAgIGNvbm5lY3Rpb25Qb29sLm9uKCdmYWN0b3J5Q3JlYXRlRXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbiBwb29sIGZhY3RvcnkgY3JlYXRpb24gZmFpbGVkOiAlcycsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFJlc291cmNlUmVxdWVzdCA9IGNvbm5lY3Rpb25Qb29sLl93YWl0aW5nQ2xpZW50c1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIGlmIChjbGllbnRSZXNvdXJjZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRSZXNvdXJjZVJlcXVlc3QucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uIHBvb2wgb2JqZWN0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uUG9vbDtcbiAgICB9O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/disk_cache.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDefaultCacheDir = getDefaultCacheDir;\nexports.isFileNotFoundError = isFileNotFoundError;\nexports.createCacheDirIfNotExists = createCacheDirIfNotExists;\nexports.writeCacheFile = writeCacheFile;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst promises_1 = __importDefault(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst os_1 = __importDefault(__webpack_require__(/*! os */ \"os\"));\n// NOTE:\n// Besides this file, there are other entrypoints implementing reading/writing cache files:\n// - global_config.js\n// - authentication/secure_storage/json_credential_manager.js\n//\n// We should refactor the code so every place is using utils from this file\nfunction getDefaultCacheDir() {\n    switch (process.platform) {\n        case 'win32':\n            return path_1.default.join(os_1.default.homedir(), 'AppData', 'Local', 'Snowflake', 'Caches');\n        case 'linux':\n            return path_1.default.join(os_1.default.homedir(), '.cache', 'snowflake');\n        case 'darwin':\n            return path_1.default.join(os_1.default.homedir(), 'Library');\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`);\n    }\n}\nfunction isFileNotFoundError(error) {\n    return error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT';\n}\nasync function createCacheDirIfNotExists(cacheDir) {\n    const options = { recursive: true };\n    if (process.platform !== 'win32') {\n        options.mode = 0o755;\n    }\n    await promises_1.default.mkdir(cacheDir, options);\n    if (process.platform !== 'win32') {\n        await promises_1.default.chmod(cacheDir, 0o700);\n    }\n}\nasync function writeCacheFile(filePath, content) {\n    const dirName = path_1.default.dirname(filePath);\n    await createCacheDirIfNotExists(dirName);\n    await promises_1.default.writeFile(filePath, content);\n    if (process.platform !== 'win32') {\n        await promises_1.default.chmod(filePath, 0o600);\n    }\n}\n//# sourceMappingURL=disk_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9kaXNrX2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLCtCQUErQixtQkFBTyxDQUFDLGtCQUFNO0FBQzdDLG1DQUFtQyxtQkFBTyxDQUFDLGdDQUFhO0FBQ3hELDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZGlza19jYWNoZS5qcz9iZTE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREZWZhdWx0Q2FjaGVEaXIgPSBnZXREZWZhdWx0Q2FjaGVEaXI7XG5leHBvcnRzLmlzRmlsZU5vdEZvdW5kRXJyb3IgPSBpc0ZpbGVOb3RGb3VuZEVycm9yO1xuZXhwb3J0cy5jcmVhdGVDYWNoZURpcklmTm90RXhpc3RzID0gY3JlYXRlQ2FjaGVEaXJJZk5vdEV4aXN0cztcbmV4cG9ydHMud3JpdGVDYWNoZUZpbGUgPSB3cml0ZUNhY2hlRmlsZTtcbmNvbnN0IHBhdGhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGF0aFwiKSk7XG5jb25zdCBwcm9taXNlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmcy9wcm9taXNlc1wiKSk7XG5jb25zdCBvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJvc1wiKSk7XG4vLyBOT1RFOlxuLy8gQmVzaWRlcyB0aGlzIGZpbGUsIHRoZXJlIGFyZSBvdGhlciBlbnRyeXBvaW50cyBpbXBsZW1lbnRpbmcgcmVhZGluZy93cml0aW5nIGNhY2hlIGZpbGVzOlxuLy8gLSBnbG9iYWxfY29uZmlnLmpzXG4vLyAtIGF1dGhlbnRpY2F0aW9uL3NlY3VyZV9zdG9yYWdlL2pzb25fY3JlZGVudGlhbF9tYW5hZ2VyLmpzXG4vL1xuLy8gV2Ugc2hvdWxkIHJlZmFjdG9yIHRoZSBjb2RlIHNvIGV2ZXJ5IHBsYWNlIGlzIHVzaW5nIHV0aWxzIGZyb20gdGhpcyBmaWxlXG5mdW5jdGlvbiBnZXREZWZhdWx0Q2FjaGVEaXIoKSB7XG4gICAgc3dpdGNoIChwcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgICAgIGNhc2UgJ3dpbjMyJzpcbiAgICAgICAgICAgIHJldHVybiBwYXRoXzEuZGVmYXVsdC5qb2luKG9zXzEuZGVmYXVsdC5ob21lZGlyKCksICdBcHBEYXRhJywgJ0xvY2FsJywgJ1Nub3dmbGFrZScsICdDYWNoZXMnKTtcbiAgICAgICAgY2FzZSAnbGludXgnOlxuICAgICAgICAgICAgcmV0dXJuIHBhdGhfMS5kZWZhdWx0LmpvaW4ob3NfMS5kZWZhdWx0LmhvbWVkaXIoKSwgJy5jYWNoZScsICdzbm93Zmxha2UnKTtcbiAgICAgICAgY2FzZSAnZGFyd2luJzpcbiAgICAgICAgICAgIHJldHVybiBwYXRoXzEuZGVmYXVsdC5qb2luKG9zXzEuZGVmYXVsdC5ob21lZGlyKCksICdMaWJyYXJ5Jyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBsYXRmb3JtOiAke3Byb2Nlc3MucGxhdGZvcm19YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNGaWxlTm90Rm91bmRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdjb2RlJyBpbiBlcnJvciAmJiBlcnJvci5jb2RlID09PSAnRU5PRU5UJztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlRGlySWZOb3RFeGlzdHMoY2FjaGVEaXIpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyByZWN1cnNpdmU6IHRydWUgfTtcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xuICAgICAgICBvcHRpb25zLm1vZGUgPSAwbzc1NTtcbiAgICB9XG4gICAgYXdhaXQgcHJvbWlzZXNfMS5kZWZhdWx0Lm1rZGlyKGNhY2hlRGlyLCBvcHRpb25zKTtcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xuICAgICAgICBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQuY2htb2QoY2FjaGVEaXIsIDBvNzAwKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZUNhY2hlRmlsZShmaWxlUGF0aCwgY29udGVudCkge1xuICAgIGNvbnN0IGRpck5hbWUgPSBwYXRoXzEuZGVmYXVsdC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICBhd2FpdCBjcmVhdGVDYWNoZURpcklmTm90RXhpc3RzKGRpck5hbWUpO1xuICAgIGF3YWl0IHByb21pc2VzXzEuZGVmYXVsdC53cml0ZUZpbGUoZmlsZVBhdGgsIGNvbnRlbnQpO1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICAgIGF3YWl0IHByb21pc2VzXzEuZGVmYXVsdC5jaG1vZChmaWxlUGF0aCwgMG82MDApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc2tfY2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/error_code.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/error_code.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"ERR_INTERNAL_ASSERT_FAILED\"] = 400001] = \"ERR_INTERNAL_ASSERT_FAILED\";\n    ErrorCode[ErrorCode[\"ERR_UNSUPPORTED_NODE_JS_VERSION\"] = 400002] = \"ERR_UNSUPPORTED_NODE_JS_VERSION\";\n    // 401001\n    ErrorCode[ErrorCode[\"ERR_SF_NETWORK_COULD_NOT_CONNECT\"] = 401001] = \"ERR_SF_NETWORK_COULD_NOT_CONNECT\";\n    ErrorCode[ErrorCode[\"ERR_SF_RESPONSE_FAILURE\"] = 401002] = \"ERR_SF_RESPONSE_FAILURE\";\n    ErrorCode[ErrorCode[\"ERR_SF_RESPONSE_NOT_JSON\"] = 401003] = \"ERR_SF_RESPONSE_NOT_JSON\";\n    ErrorCode[ErrorCode[\"ERR_SF_RESPONSE_INVALID_TOKEN\"] = 401004] = \"ERR_SF_RESPONSE_INVALID_TOKEN\";\n    // 402001\n    ErrorCode[ErrorCode[\"ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT\"] = 402001] = \"ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT\";\n    ErrorCode[ErrorCode[\"ERR_LARGE_RESULT_SET_RESPONSE_FAILURE\"] = 402002] = \"ERR_LARGE_RESULT_SET_RESPONSE_FAILURE\";\n    // 403001\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL\"] = 403001] = \"ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS\"] = 403002] = \"ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE\"] = 403003] = \"ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER\"] = 403004] = \"ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER\"] = 403005] = \"ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE\"] = 403006] = \"ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER\"] = 403007] = \"ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY\"] = 403008] = \"ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY\";\n    // 404001\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_OPTIONS\"] = 404001] = \"ERR_CONN_CREATE_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OPTIONS\"] = 404002] = \"ERR_CONN_CREATE_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_USERNAME\"] = 404003] = \"ERR_CONN_CREATE_MISSING_USERNAME\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_USERNAME\"] = 404004] = \"ERR_CONN_CREATE_INVALID_USERNAME\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PASSWORD\"] = 404005] = \"ERR_CONN_CREATE_MISSING_PASSWORD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PASSWORD\"] = 404006] = \"ERR_CONN_CREATE_INVALID_PASSWORD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_ACCOUNT\"] = 404007] = \"ERR_CONN_CREATE_MISSING_ACCOUNT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ACCOUNT\"] = 404008] = \"ERR_CONN_CREATE_INVALID_ACCOUNT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_ACCESS_URL\"] = 404009] = \"ERR_CONN_CREATE_MISSING_ACCESS_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ACCESS_URL\"] = 404010] = \"ERR_CONN_CREATE_INVALID_ACCESS_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_WAREHOUSE\"] = 404011] = \"ERR_CONN_CREATE_INVALID_WAREHOUSE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DATABASE\"] = 404012] = \"ERR_CONN_CREATE_INVALID_DATABASE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_SCHEMA\"] = 404013] = \"ERR_CONN_CREATE_INVALID_SCHEMA\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ROLE\"] = 404014] = \"ERR_CONN_CREATE_INVALID_ROLE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_HOST\"] = 404015] = \"ERR_CONN_CREATE_MISSING_PROXY_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_HOST\"] = 404016] = \"ERR_CONN_CREATE_INVALID_PROXY_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_PORT\"] = 404017] = \"ERR_CONN_CREATE_MISSING_PROXY_PORT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_PORT\"] = 404018] = \"ERR_CONN_CREATE_INVALID_PROXY_PORT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_STREAM_RESULT\"] = 404019] = \"ERR_CONN_CREATE_INVALID_STREAM_RESULT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING\"] = 404020] = \"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES\"] = 404021] = \"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_REGION\"] = 404022] = \"ERR_CONN_CREATE_INVALID_REGION\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_KEEP_ALIVE\"] = 404023] = \"ERR_CONN_CREATE_INVALID_KEEP_ALIVE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ\"] = 404024] = \"ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT\"] = 404025] = \"ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PRIVATE_KEY\"] = 404026] = \"ERR_CONN_CREATE_INVALID_PRIVATE_KEY\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH\"] = 404027] = \"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS\"] = 404028] = \"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OAUTH_TOKEN\"] = 404029] = \"ERR_CONN_CREATE_INVALID_OAUTH_TOKEN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS\"] = 404030] = \"ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_APPLICATION\"] = 404031] = \"ERR_CONN_CREATE_INVALID_APPLICATION\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_USER\"] = 404032] = \"ERR_CONN_CREATE_MISSING_PROXY_USER\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_USER\"] = 404033] = \"ERR_CONN_CREATE_INVALID_PROXY_USER\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_PASS\"] = 404034] = \"ERR_CONN_CREATE_MISSING_PROXY_PASS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_PASS\"] = 404035] = \"ERR_CONN_CREATE_INVALID_PROXY_PASS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_NO_PROXY\"] = 404036] = \"ERR_CONN_CREATE_INVALID_NO_PROXY\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD\"] = 404037] = \"ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL\"] = 404038] = \"ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR\"] = 404039] = \"ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT\"] = 404040] = \"ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE\"] = 404041] = \"ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON\"] = 404042] = \"ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE\"] = 404043] = \"ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_RETRY_TIMEOUT\"] = 404044] = \"ERR_CONN_CREATE_INVALID_RETRY_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX\"] = 404045] = \"ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_REGION_REGEX\"] = 404046] = \"ERR_CONN_CREATE_INVALID_REGION_REGEX\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN\"] = 404047] = \"ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL\"] = 404048] = \"ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL\"] = 404049] = \"ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL\"] = 404050] = \"ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK\"] = 404051] = \"ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN\"] = 404052] = \"ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_HOST\"] = 404053] = \"ERR_CONN_CREATE_MISSING_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_HOST\"] = 404054] = \"ERR_CONN_CREATE_INVALID_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD\"] = 404055] = \"ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PASSCODE\"] = 404056] = \"ERR_CONN_CREATE_INVALID_PASSCODE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PASSWORD_AND_TOKEN\"] = 404057] = \"ERR_CONN_CREATE_MISSING_PASSWORD_AND_TOKEN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL\"] = 404058] = \"ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID\"] = 404059] = \"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET\"] = 404060] = \"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL\"] = 404061] = \"ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS\"] = 404062] = \"ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_QUERY_TAG\"] = 404063] = \"ERR_CONN_CREATE_INVALID_QUERY_TAG\";\n    // 405001\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_INVALID_CALLBACK\"] = 405001] = \"ERR_CONN_CONNECT_INVALID_CALLBACK\";\n    // 405501\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_STATUS_CONNECTING\"] = 405501] = \"ERR_CONN_CONNECT_STATUS_CONNECTING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_STATUS_CONNECTED\"] = 405502] = \"ERR_CONN_CONNECT_STATUS_CONNECTED\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_STATUS_DISCONNECTED\"] = 405503] = \"ERR_CONN_CONNECT_STATUS_DISCONNECTED\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_AUTH_CONNECT\"] = 405504] = \"ERR_CONN_CREATE_INVALID_AUTH_CONNECT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG\"] = 405505] = \"ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED\"] = 405506] = \"ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_AUTH_NOT_ALLOWED\"] = 405507] = \"ERR_CONN_CREATE_AUTH_NOT_ALLOWED\";\n    // 406001\n    ErrorCode[ErrorCode[\"ERR_CONN_DESTROY_INVALID_CALLBACK\"] = 406001] = \"ERR_CONN_DESTROY_INVALID_CALLBACK\";\n    // 406501\n    ErrorCode[ErrorCode[\"ERR_CONN_DESTROY_STATUS_PRISTINE\"] = 406501] = \"ERR_CONN_DESTROY_STATUS_PRISTINE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_DESTROY_STATUS_DISCONNECTED\"] = 406502] = \"ERR_CONN_DESTROY_STATUS_DISCONNECTED\";\n    // 407001\n    ErrorCode[ErrorCode[\"ERR_CONN_REQUEST_STATUS_PRISTINE\"] = 407001] = \"ERR_CONN_REQUEST_STATUS_PRISTINE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_REQUEST_STATUS_DISCONNECTED\"] = 407002] = \"ERR_CONN_REQUEST_STATUS_DISCONNECTED\";\n    // 408001\n    ErrorCode[ErrorCode[\"ERR_CONN_DESERIALIZE_MISSING_CONFIG\"] = 408001] = \"ERR_CONN_DESERIALIZE_MISSING_CONFIG\";\n    ErrorCode[ErrorCode[\"ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE\"] = 408002] = \"ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM\"] = 408003] = \"ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM\";\n    // 409001\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_MISSING_OPTIONS\"] = 409001] = \"ERR_CONN_EXEC_STMT_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_OPTIONS\"] = 409002] = \"ERR_CONN_EXEC_STMT_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT\"] = 409003] = \"ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT\"] = 409004] = \"ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_INTERNAL\"] = 409005] = \"ERR_CONN_EXEC_STMT_INVALID_INTERNAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_PARAMETERS\"] = 409006] = \"ERR_CONN_EXEC_STMT_INVALID_PARAMETERS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_BINDS\"] = 409007] = \"ERR_CONN_EXEC_STMT_INVALID_BINDS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES\"] = 409008] = \"ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_COMPLETE\"] = 409009] = \"ERR_CONN_EXEC_STMT_INVALID_COMPLETE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT\"] = 409010] = \"ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING\"] = 409011] = \"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES\"] = 409012] = \"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID\"] = 409013] = \"ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC\"] = 409014] = \"ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY\"] = 409015] = \"ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY\";\n    // 410001\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_MISSING_OPTIONS\"] = 410001] = \"ERR_CONN_FETCH_RESULT_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_OPTIONS\"] = 410002] = \"ERR_CONN_FETCH_RESULT_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID\"] = 410003] = \"ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID\"] = 410004] = \"ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_COMPLETE\"] = 410005] = \"ERR_CONN_FETCH_RESULT_INVALID_COMPLETE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT\"] = 410006] = \"ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING\"] = 410007] = \"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES\"] = 410008] = \"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_CWD\"] = 410009] = \"ERR_CONN_FETCH_RESULT_INVALID_CWD\";\n    // 411001\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_OPTIONS\"] = 411001] = \"ERR_STMT_STREAM_ROWS_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_START\"] = 411002] = \"ERR_STMT_STREAM_ROWS_INVALID_START\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_END\"] = 411003] = \"ERR_STMT_STREAM_ROWS_INVALID_END\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING\"] = 411004] = \"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES\"] = 411005] = \"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE\"] = 411006] = \"ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE\";\n    // 412001\n    ErrorCode[ErrorCode[\"ERR_OCSP_REVOKED\"] = 412001] = \"ERR_OCSP_REVOKED\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_UNKNOWN\"] = 412002] = \"ERR_OCSP_UNKNOWN\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_NO_SIGNATURE_ALGORITHM\"] = 412003] = \"ERR_OCSP_NO_SIGNATURE_ALGORITHM\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_INVALID_SIGNATURE\"] = 412004] = \"ERR_OCSP_INVALID_SIGNATURE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_NO_RESPONSE\"] = 412005] = \"ERR_OCSP_NO_RESPONSE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_INVALID_VALIDITY\"] = 412006] = \"ERR_OCSP_INVALID_VALIDITY\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_UNKNOWN_STATE\"] = 412007] = \"ERR_OCSP_UNKNOWN_STATE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_NOT_TWO_ELEMENTS\"] = 412008] = \"ERR_OCSP_NOT_TWO_ELEMENTS\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_CACHE_EXPIRED\"] = 412009] = \"ERR_OCSP_CACHE_EXPIRED\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_FAILED_PARSE_RESPONSE\"] = 412010] = \"ERR_OCSP_FAILED_PARSE_RESPONSE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_INVALID_CERTIFICATE_VALIDITY\"] = 412011] = \"ERR_OCSP_INVALID_CERTIFICATE_VALIDITY\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_RESPONDER_TIMEOUT\"] = 412012] = \"ERR_OCSP_RESPONDER_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_CACHE_SERVER_TIMEOUT\"] = 412013] = \"ERR_OCSP_CACHE_SERVER_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE\"] = 412014] = \"ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE\";\n    ErrorCode[ErrorCode[\"ERR_CRL_ERROR\"] = 413001] = \"ERR_CRL_ERROR\";\n    // 450001\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_MISSING_OPTIONS\"] = 450001] = \"ERR_STMT_FETCH_ROWS_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_INVALID_OPTIONS\"] = 450002] = \"ERR_STMT_FETCH_ROWS_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_MISSING_EACH\"] = 450003] = \"ERR_STMT_FETCH_ROWS_MISSING_EACH\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_INVALID_EACH\"] = 450004] = \"ERR_STMT_FETCH_ROWS_INVALID_EACH\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_MISSING_END\"] = 450005] = \"ERR_STMT_FETCH_ROWS_MISSING_END\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_INVALID_END\"] = 450006] = \"ERR_STMT_FETCH_ROWS_INVALID_END\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_FETCHING_RESULT\"] = 450007] = \"ERR_STMT_FETCH_ROWS_FETCHING_RESULT\";\n    // 460001\n    ErrorCode[ErrorCode[\"ERR_GET_RESPONSE_QUERY_INVALID_UUID\"] = 460001] = \"ERR_GET_RESPONSE_QUERY_INVALID_UUID\";\n    ErrorCode[ErrorCode[\"ERR_GET_RESULTS_QUERY_ID_NO_DATA\"] = 460002] = \"ERR_GET_RESULTS_QUERY_ID_NO_DATA\";\n    ErrorCode[ErrorCode[\"ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS\"] = 460003] = \"ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS\";\n})(ErrorCode || (ErrorCode = {}));\nexports[\"default\"] = ErrorCode;\n//# sourceMappingURL=error_code.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9lcnJvcl9jb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Vycm9yX2NvZGUuanM/Y2EwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfSU5URVJOQUxfQVNTRVJUX0ZBSUxFRFwiXSA9IDQwMDAwMV0gPSBcIkVSUl9JTlRFUk5BTF9BU1NFUlRfRkFJTEVEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9VTlNVUFBPUlRFRF9OT0RFX0pTX1ZFUlNJT05cIl0gPSA0MDAwMDJdID0gXCJFUlJfVU5TVVBQT1JURURfTk9ERV9KU19WRVJTSU9OXCI7XG4gICAgLy8gNDAxMDAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TRl9ORVRXT1JLX0NPVUxEX05PVF9DT05ORUNUXCJdID0gNDAxMDAxXSA9IFwiRVJSX1NGX05FVFdPUktfQ09VTERfTk9UX0NPTk5FQ1RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkVcIl0gPSA0MDEwMDJdID0gXCJFUlJfU0ZfUkVTUE9OU0VfRkFJTFVSRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU0ZfUkVTUE9OU0VfTk9UX0pTT05cIl0gPSA0MDEwMDNdID0gXCJFUlJfU0ZfUkVTUE9OU0VfTk9UX0pTT05cIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NGX1JFU1BPTlNFX0lOVkFMSURfVE9LRU5cIl0gPSA0MDEwMDRdID0gXCJFUlJfU0ZfUkVTUE9OU0VfSU5WQUxJRF9UT0tFTlwiO1xuICAgIC8vIDQwMjAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfTEFSR0VfUkVTVUxUX1NFVF9ORVRXT1JLX0NPVUxEX05PVF9DT05ORUNUXCJdID0gNDAyMDAxXSA9IFwiRVJSX0xBUkdFX1JFU1VMVF9TRVRfTkVUV09SS19DT1VMRF9OT1RfQ09OTkVDVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfTEFSR0VfUkVTVUxUX1NFVF9SRVNQT05TRV9GQUlMVVJFXCJdID0gNDAyMDAyXSA9IFwiRVJSX0xBUkdFX1JFU1VMVF9TRVRfUkVTUE9OU0VfRkFJTFVSRVwiO1xuICAgIC8vIDQwMzAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0xPR19MRVZFTFwiXSA9IDQwMzAwMV0gPSBcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfTE9HX0xFVkVMXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfRElTQUJMRV9PQ1NQX0NIRUNLU1wiXSA9IDQwMzAwMl0gPSBcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfRElTQUJMRV9PQ1NQX0NIRUNLU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX09DU1BfTU9ERVwiXSA9IDQwMzAwM10gPSBcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfT0NTUF9NT0RFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfSlNPTl9QQVJTRVJcIl0gPSA0MDMwMDRdID0gXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0pTT05fUEFSU0VSXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfWE1MX1BBUlNFUlwiXSA9IDQwMzAwNV0gPSBcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfWE1MX1BBUlNFUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0tFRVBfQUxJVkVcIl0gPSA0MDMwMDZdID0gXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0tFRVBfQUxJVkVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9DVVNUT01fQ1JFREVOVElBTF9NQU5BR0VSXCJdID0gNDAzMDA3XSA9IFwiRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9DVVNUT01fQ1JFREVOVElBTF9NQU5BR0VSXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfVVNFX0VOVl9QUk9YWVwiXSA9IDQwMzAwOF0gPSBcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfVVNFX0VOVl9QUk9YWVwiO1xuICAgIC8vIDQwNDAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19PUFRJT05TXCJdID0gNDA0MDAxXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfT1BUSU9OU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PUFRJT05TXCJdID0gNDA0MDAyXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1BUSU9OU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19VU0VSTkFNRVwiXSA9IDQwNDAwM10gPSBcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1VTRVJOQU1FXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1VTRVJOQU1FXCJdID0gNDA0MDA0XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfVVNFUk5BTUVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUEFTU1dPUkRcIl0gPSA0MDQwMDVdID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QQVNTV09SRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRFwiXSA9IDQwNDAwNl0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BBU1NXT1JEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ09VTlRcIl0gPSA0MDQwMDddID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19BQ0NPVU5UXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ09VTlRcIl0gPSA0MDQwMDhdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NPVU5UXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ0VTU19VUkxcIl0gPSA0MDQwMDldID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19BQ0NFU1NfVVJMXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ0VTU19VUkxcIl0gPSA0MDQwMTBdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NFU1NfVVJMXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1dBUkVIT1VTRVwiXSA9IDQwNDAxMV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1dBUkVIT1VTRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9EQVRBQkFTRVwiXSA9IDQwNDAxMl0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RBVEFCQVNFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1NDSEVNQVwiXSA9IDQwNDAxM10gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1NDSEVNQVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9ST0xFXCJdID0gNDA0MDE0XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUk9MRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9IT1NUXCJdID0gNDA0MDE1XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfSE9TVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9IT1NUXCJdID0gNDA0MDE2XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfSE9TVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9QT1JUXCJdID0gNDA0MDE3XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfUE9SVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9QT1JUXCJdID0gNDA0MDE4XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfUE9SVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9TVFJFQU1fUkVTVUxUXCJdID0gNDA0MDE5XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfU1RSRUFNX1JFU1VMVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdcIl0gPSA0MDQwMjBdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFU1wiXSA9IDQwNDAyMV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVHSU9OXCJdID0gNDA0MDIyXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVHSU9OXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0tFRVBfQUxJVkVcIl0gPSA0MDQwMjNdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0tFRVBfQUxJVkVfSEVBUlRCRUFUX0ZSRVFcIl0gPSA0MDQwMjRdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5UXCJdID0gNDA0MDI1XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfVFJFQVRfSU5URUdFUl9BU19CSUdJTlRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlcIl0gPSA0MDQwMjZdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUklWQVRFX0tFWVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUklWQVRFX0tFWV9QQVRIXCJdID0gNDA0MDI3XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFUSFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUklWQVRFX0tFWV9QQVNTXCJdID0gNDA0MDI4XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFTU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PQVVUSF9UT0tFTlwiXSA9IDQwNDAyOV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09BVVRIX1RPS0VOXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1ZBTElEQVRFX0RFRkFVTFRfUEFSQU1FVEVSU1wiXSA9IDQwNDAzMF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1ZBTElEQVRFX0RFRkFVTFRfUEFSQU1FVEVSU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUFBMSUNBVElPTlwiXSA9IDQwNDAzMV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FQUExJQ0FUSU9OXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1VTRVJcIl0gPSA0MDQwMzJdID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9VU0VSXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX1VTRVJcIl0gPSA0MDQwMzNdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9VU0VSXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1BBU1NcIl0gPSA0MDQwMzRdID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9QQVNTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX1BBU1NcIl0gPSA0MDQwMzVdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9QQVNTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX05PX1BST1hZXCJdID0gNDA0MDM2XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfTk9fUFJPWFlcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVJSQVlfQklORElOR19USFJFU0hPTERcIl0gPSA0MDQwMzddID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9HQ1NfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTFwiXSA9IDQwNDAzOF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0dDU19VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZPUkNFX1NUQUdFX0JJTkRfRVJST1JcIl0gPSA0MDQwMzldID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GT1JDRV9TVEFHRV9CSU5EX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0JST1dTRVJfVElNRU9VVFwiXSA9IDQwNDA0MF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0JST1dTRVJfVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9ESVNBQkxFRF9RVUVSWV9DT05URVhUX0NBQ0hFXCJdID0gNDA0MDQxXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRURfUVVFUllfQ09OVEVYVF9DQUNIRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9JTkNMVURFX1JFVFJZX1JFQVNPTlwiXSA9IDQwNDA0Ml0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0lOQ0xVREVfUkVUUllfUkVBU09OXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9DT05GSUdfRklMRVwiXSA9IDQwNDA0M10gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9DT05GSUdfRklMRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRVRSWV9USU1FT1VUXCJdID0gNDA0MDQ0XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVUUllfVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NPVU5UX1JFR0VYXCJdID0gNDA0MDQ1XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDT1VOVF9SRUdFWFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRUdJT05fUkVHRVhcIl0gPSA0MDQwNDZdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRUdJT05fUkVHRVhcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRV9DT05TT0xFX0xPR0lOXCJdID0gNDA0MDQ3XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRV9DT05TT0xFX0xPR0lOXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZPUkNFX0dDUF9VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMXCJdID0gNDA0MDQ4XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUxcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQ0xJRU5UX1NUT1JFX1RFTVBPUkFSWV9DUkVERU5USUFMXCJdID0gNDA0MDQ5XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQ0xJRU5UX1NUT1JFX1RFTVBPUkFSWV9DUkVERU5USUFMXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JFUFJFU0VOVF9OVUxMX0FTX1NUUklOR19OVUxMXCJdID0gNDA0MDUwXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVQUkVTRU5UX05VTExfQVNfU1RSSU5HX05VTExcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRV9TQU1MX1VSTF9DSEVDS1wiXSA9IDQwNDA1MV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVfU0FNTF9VUkxfQ0hFQ0tcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQ0xJRU5UX1JFUVVFU1RfTUZBX1RPS0VOXCJdID0gNDA0MDUyXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQ0xJRU5UX1JFUVVFU1RfTUZBX1RPS0VOXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0hPU1RcIl0gPSA0MDQwNTNdID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19IT1NUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0hPU1RcIl0gPSA0MDQwNTRdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9IT1NUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BBU1NDT0RFX0lOX1BBU1NXT1JEXCJdID0gNDA0MDU1XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU0NPREVfSU5fUEFTU1dPUkRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU0NPREVcIl0gPSA0MDQwNTZdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTQ09ERVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QQVNTV09SRF9BTkRfVE9LRU5cIl0gPSA0MDQwNTddID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QQVNTV09SRF9BTkRfVE9LRU5cIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQVVUSE9SSVpBVElPTl9VUkxcIl0gPSA0MDQwNThdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PVUFUSF9BVVRIT1JJWkFUSU9OX1VSTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PVUFUSF9DTElFTlRfSURcIl0gPSA0MDQwNTldID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PVUFUSF9DTElFTlRfSURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQ0xJRU5UX1NFQ1JFVFwiXSA9IDQwNDA2MF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9TRUNSRVRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfVE9LRU5fUkVRVUVTVF9VUkxcIl0gPSA0MDQwNjFdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PVUFUSF9UT0tFTl9SRVFVRVNUX1VSTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9XT1JLTE9BRF9JREVOVElUWV9QQVJBTUVURVJTXCJdID0gNDA0MDYyXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfV09SS0xPQURfSURFTlRJVFlfUEFSQU1FVEVSU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9RVUVSWV9UQUdcIl0gPSA0MDQwNjNdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9RVUVSWV9UQUdcIjtcbiAgICAvLyA0MDUwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ09OTkVDVF9JTlZBTElEX0NBTExCQUNLXCJdID0gNDA1MDAxXSA9IFwiRVJSX0NPTk5fQ09OTkVDVF9JTlZBTElEX0NBTExCQUNLXCI7XG4gICAgLy8gNDA1NTAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NPTk5FQ1RfU1RBVFVTX0NPTk5FQ1RJTkdcIl0gPSA0MDU1MDFdID0gXCJFUlJfQ09OTl9DT05ORUNUX1NUQVRVU19DT05ORUNUSU5HXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NPTk5FQ1RfU1RBVFVTX0NPTk5FQ1RFRFwiXSA9IDQwNTUwMl0gPSBcIkVSUl9DT05OX0NPTk5FQ1RfU1RBVFVTX0NPTk5FQ1RFRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DT05ORUNUX1NUQVRVU19ESVNDT05ORUNURURcIl0gPSA0MDU1MDNdID0gXCJFUlJfQ09OTl9DT05ORUNUX1NUQVRVU19ESVNDT05ORUNURURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVVUSF9DT05ORUNUXCJdID0gNDA1NTA0XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVVUSF9DT05ORUNUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NPTk5FQ1RfSU5WQUxJRF9DTElFTlRfQ09ORklHXCJdID0gNDA1NTA1XSA9IFwiRVJSX0NPTk5fQ09OTkVDVF9JTlZBTElEX0NMSUVOVF9DT05GSUdcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVVUSF9VTlNVUFBPUlRFRFwiXSA9IDQwNTUwNl0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FVVEhfVU5TVVBQT1JURURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0FVVEhfTk9UX0FMTE9XRURcIl0gPSA0MDU1MDddID0gXCJFUlJfQ09OTl9DUkVBVEVfQVVUSF9OT1RfQUxMT1dFRFwiO1xuICAgIC8vIDQwNjAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9ERVNUUk9ZX0lOVkFMSURfQ0FMTEJBQ0tcIl0gPSA0MDYwMDFdID0gXCJFUlJfQ09OTl9ERVNUUk9ZX0lOVkFMSURfQ0FMTEJBQ0tcIjtcbiAgICAvLyA0MDY1MDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfUFJJU1RJTkVcIl0gPSA0MDY1MDFdID0gXCJFUlJfQ09OTl9ERVNUUk9ZX1NUQVRVU19QUklTVElORVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9ERVNUUk9ZX1NUQVRVU19ESVNDT05ORUNURURcIl0gPSA0MDY1MDJdID0gXCJFUlJfQ09OTl9ERVNUUk9ZX1NUQVRVU19ESVNDT05ORUNURURcIjtcbiAgICAvLyA0MDcwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fUkVRVUVTVF9TVEFUVVNfUFJJU1RJTkVcIl0gPSA0MDcwMDFdID0gXCJFUlJfQ09OTl9SRVFVRVNUX1NUQVRVU19QUklTVElORVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9SRVFVRVNUX1NUQVRVU19ESVNDT05ORUNURURcIl0gPSA0MDcwMDJdID0gXCJFUlJfQ09OTl9SRVFVRVNUX1NUQVRVU19ESVNDT05ORUNURURcIjtcbiAgICAvLyA0MDgwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fREVTRVJJQUxJWkVfTUlTU0lOR19DT05GSUdcIl0gPSA0MDgwMDFdID0gXCJFUlJfQ09OTl9ERVNFUklBTElaRV9NSVNTSU5HX0NPTkZJR1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9ERVNFUklBTElaRV9JTlZBTElEX0NPTkZJR19UWVBFXCJdID0gNDA4MDAyXSA9IFwiRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfVFlQRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9ERVNFUklBTElaRV9JTlZBTElEX0NPTkZJR19GT1JNXCJdID0gNDA4MDAzXSA9IFwiRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfRk9STVwiO1xuICAgIC8vIDQwOTAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfTUlTU0lOR19PUFRJT05TXCJdID0gNDA5MDAxXSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX01JU1NJTkdfT1BUSU9OU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9PUFRJT05TXCJdID0gNDA5MDAyXSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfT1BUSU9OU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfTUlTU0lOR19TUUxfVEVYVFwiXSA9IDQwOTAwM10gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9NSVNTSU5HX1NRTF9URVhUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1NRTF9URVhUXCJdID0gNDA5MDA0XSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfU1FMX1RFWFRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfSU5URVJOQUxcIl0gPSA0MDkwMDVdID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9JTlRFUk5BTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9QQVJBTUVURVJTXCJdID0gNDA5MDA2XSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfUEFSQU1FVEVSU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9CSU5EU1wiXSA9IDQwOTAwN10gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0JJTkRTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0JJTkRfVkFMVUVTXCJdID0gNDA5MDA4XSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQklORF9WQUxVRVNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQ09NUExFVEVcIl0gPSA0MDkwMDldID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9DT01QTEVURVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9TVFJFQU1fUkVTVUxUXCJdID0gNDA5MDEwXSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfU1RSRUFNX1JFU1VMVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdcIl0gPSA0MDkwMTFdID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFU1wiXSA9IDQwOTAxMl0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfUkVRVUVTVF9JRFwiXSA9IDQwOTAxM10gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1JFUVVFU1RfSURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQVNZTkNfRVhFQ1wiXSA9IDQwOTAxNF0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0FTWU5DX0VYRUNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfREVTQ1JJQkVfT05MWVwiXSA9IDQwOTAxNV0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0RFU0NSSUJFX09OTFlcIjtcbiAgICAvLyA0MTAwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfT1BUSU9OU1wiXSA9IDQxMDAwMV0gPSBcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfT1BUSU9OU1wiXSA9IDQxMDAwMl0gPSBcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfUVVFUllfSURcIl0gPSA0MTAwMDNdID0gXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfTUlTU0lOR19RVUVSWV9JRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9RVUVSWV9JRFwiXSA9IDQxMDAwNF0gPSBcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX1FVRVJZX0lEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NPTVBMRVRFXCJdID0gNDEwMDA1XSA9IFwiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfQ09NUExFVEVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfU1RSRUFNX1JFU1VMVFwiXSA9IDQxMDAwNl0gPSBcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX1NUUkVBTV9SRVNVTFRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HXCJdID0gNDEwMDA3XSA9IFwiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVNcIl0gPSA0MTAwMDhdID0gXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdfVkFMVUVTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NXRFwiXSA9IDQxMDAwOV0gPSBcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NXRFwiO1xuICAgIC8vIDQxMTAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX09QVElPTlNcIl0gPSA0MTEwMDFdID0gXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9TVEFSVFwiXSA9IDQxMTAwMl0gPSBcIkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfU1RBUlRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9FTkRcIl0gPSA0MTEwMDNdID0gXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX0VORFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX0ZFVENIX0FTX1NUUklOR1wiXSA9IDQxMTAwNF0gPSBcIkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFU1wiXSA9IDQxMTAwNV0gPSBcIkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX1JPV19NT0RFXCJdID0gNDExMDA2XSA9IFwiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9ST1dfTU9ERVwiO1xuICAgIC8vIDQxMjAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9SRVZPS0VEXCJdID0gNDEyMDAxXSA9IFwiRVJSX09DU1BfUkVWT0tFRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9VTktOT1dOXCJdID0gNDEyMDAyXSA9IFwiRVJSX09DU1BfVU5LTk9XTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9OT19TSUdOQVRVUkVfQUxHT1JJVEhNXCJdID0gNDEyMDAzXSA9IFwiRVJSX09DU1BfTk9fU0lHTkFUVVJFX0FMR09SSVRITVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9JTlZBTElEX1NJR05BVFVSRVwiXSA9IDQxMjAwNF0gPSBcIkVSUl9PQ1NQX0lOVkFMSURfU0lHTkFUVVJFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX05PX1JFU1BPTlNFXCJdID0gNDEyMDA1XSA9IFwiRVJSX09DU1BfTk9fUkVTUE9OU0VcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfSU5WQUxJRF9WQUxJRElUWVwiXSA9IDQxMjAwNl0gPSBcIkVSUl9PQ1NQX0lOVkFMSURfVkFMSURJVFlcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfVU5LTk9XTl9TVEFURVwiXSA9IDQxMjAwN10gPSBcIkVSUl9PQ1NQX1VOS05PV05fU1RBVEVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfTk9UX1RXT19FTEVNRU5UU1wiXSA9IDQxMjAwOF0gPSBcIkVSUl9PQ1NQX05PVF9UV09fRUxFTUVOVFNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfQ0FDSEVfRVhQSVJFRFwiXSA9IDQxMjAwOV0gPSBcIkVSUl9PQ1NQX0NBQ0hFX0VYUElSRURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfRkFJTEVEX1BBUlNFX1JFU1BPTlNFXCJdID0gNDEyMDEwXSA9IFwiRVJSX09DU1BfRkFJTEVEX1BBUlNFX1JFU1BPTlNFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX0lOVkFMSURfQ0VSVElGSUNBVEVfVkFMSURJVFlcIl0gPSA0MTIwMTFdID0gXCJFUlJfT0NTUF9JTlZBTElEX0NFUlRJRklDQVRFX1ZBTElESVRZXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX1JFU1BPTkRFUl9USU1FT1VUXCJdID0gNDEyMDEyXSA9IFwiRVJSX09DU1BfUkVTUE9OREVSX1RJTUVPVVRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfQ0FDSEVfU0VSVkVSX1RJTUVPVVRcIl0gPSA0MTIwMTNdID0gXCJFUlJfT0NTUF9DQUNIRV9TRVJWRVJfVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9GQUlMRURfT0JUQUlOX09DU1BfUkVTUE9OU0VcIl0gPSA0MTIwMTRdID0gXCJFUlJfT0NTUF9GQUlMRURfT0JUQUlOX09DU1BfUkVTUE9OU0VcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NSTF9FUlJPUlwiXSA9IDQxMzAwMV0gPSBcIkVSUl9DUkxfRVJST1JcIjtcbiAgICAvLyA0NTAwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX09QVElPTlNcIl0gPSA0NTAwMDFdID0gXCJFUlJfU1RNVF9GRVRDSF9ST1dTX01JU1NJTkdfT1BUSU9OU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfT1BUSU9OU1wiXSA9IDQ1MDAwMl0gPSBcIkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9PUFRJT05TXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TVE1UX0ZFVENIX1JPV1NfTUlTU0lOR19FQUNIXCJdID0gNDUwMDAzXSA9IFwiRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX0VBQ0hcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX0VBQ0hcIl0gPSA0NTAwMDRdID0gXCJFUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfRUFDSFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9GRVRDSF9ST1dTX01JU1NJTkdfRU5EXCJdID0gNDUwMDA1XSA9IFwiRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX0VORFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfRU5EXCJdID0gNDUwMDA2XSA9IFwiRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX0VORFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9GRVRDSF9ST1dTX0ZFVENISU5HX1JFU1VMVFwiXSA9IDQ1MDAwN10gPSBcIkVSUl9TVE1UX0ZFVENIX1JPV1NfRkVUQ0hJTkdfUkVTVUxUXCI7XG4gICAgLy8gNDYwMDAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9HRVRfUkVTUE9OU0VfUVVFUllfSU5WQUxJRF9VVUlEXCJdID0gNDYwMDAxXSA9IFwiRVJSX0dFVF9SRVNQT05TRV9RVUVSWV9JTlZBTElEX1VVSURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0dFVF9SRVNVTFRTX1FVRVJZX0lEX05PX0RBVEFcIl0gPSA0NjAwMDJdID0gXCJFUlJfR0VUX1JFU1VMVFNfUVVFUllfSURfTk9fREFUQVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0VUX1JFU1VMVFNfUVVFUllfSURfTk9UX1NVQ0NFU1NfU1RBVFVTXCJdID0gNDYwMDAzXSA9IFwiRVJSX0dFVF9SRVNVTFRTX1FVRVJZX0lEX05PVF9TVUNDRVNTX1NUQVRVU1wiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JfY29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/error_code.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst errorMessages = __webpack_require__(/*! ./constants/error_messages */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js\");\nconst ErrorCode = (__webpack_require__(/*! ./error_code */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/error_code.js\")[\"default\"]);\n/**\n * @deprecated Use `ErrorCode` instead\n */\nexports.codes = ErrorCode;\nexports.ErrorCode = ErrorCode;\n/**\n * A map in which the keys are the error codes and the values are the\n * corresponding SQL-states.\n */\nconst errCodeToSqlState = (exports.mapErrorCodeToSqlState = {\n    405501: '08002',\n    405502: '08002',\n    405503: '08003',\n    407001: '08003',\n    407002: '08003',\n});\n/**\n * An enumeration of all the different types of errors we create.\n */\nconst errorTypes = {\n    // internal synchronous errors\n    InternalAssertError: 'InternalAssertError',\n    // external synchronous errors\n    MissingParameterError: 'MissingParameterError',\n    InvalidParameterError: 'InvalidParameterError',\n    // external asynchronous errors\n    NetworkError: 'NetworkError',\n    RequestFailedError: 'RequestFailedError',\n    UnexpectedContentError: 'UnexpectedContentError',\n    OperationFailedError: 'OperationFailedError',\n    LargeResultSetError: 'LargeResultSetError',\n    ClientError: 'ClientError',\n    OCSPError: 'OCSPError',\n    CRLError: 'CRLError',\n};\n/**\n * Ensures the truth of an expression. Used to catch internal programming\n * errors. If the given expression is false, an InternalAssertError will be\n * thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {String} [message] a message for the error should the check fail.\n */\nexports.assertInternal = function (expression, message) {\n    if (!expression) {\n        throw createError(errorTypes.InternalAssertError, {\n            code: ErrorCode.ERR_INTERNAL_ASSERT_FAILED,\n            message: message,\n            synchronous: true,\n        });\n    }\n};\n// TODO:\n// Consider removing MissingParameterError + checkArgumentExits + checkArgumentValid\n// to reduce amount of error types we have. Use createInvalidParameterError instead.\n/**\n * Ensures the truth of an expression. Used to make sure all required arguments\n * are passed in to a method. If the specified expression is false, a\n * MissingParameterError will be thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {Number} errorCode a code for the error should the check fail.\n *\n * @throws will throw an MissingParameter error if the expression is false.\n */\nexports.checkArgumentExists = function (expression, errorCode) {\n    if (!expression) {\n        throw createError(errorTypes.MissingParameterError, {\n            code: errorCode,\n            messageArgs: Array.prototype.slice.call(arguments, 2),\n            synchronous: true,\n        });\n    }\n};\n/**\n * Ensures the truth of an expression. Used for validating arguments to methods.\n * If the specified expression is false, an InvalidParameterError will be\n * thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {Number} errorCode a code for the error should the check fail.\n *\n * @throws will throw an InvalidParameter error if the expression is false.\n */\nexports.checkArgumentValid = function (expression, errorCode) {\n    if (!expression) {\n        throw createError(errorTypes.InvalidParameterError, {\n            code: errorCode,\n            messageArgs: Array.prototype.slice.call(arguments, 2),\n            synchronous: true,\n        });\n    }\n};\n/**\n * Creates a new InvalidParameterError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {messageArgs} array of error massages\n * @returns {Error}\n */\nexports.createInvalidParameterError = function (errorCode, ...messageArgs) {\n    return createError(errorTypes.InvalidParameterError, {\n        code: errorCode,\n        messageArgs: messageArgs,\n        synchronous: true,\n    });\n};\n/**\n * Creates a new NetworkError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Error} cause the underlying cause of the network error.\n *\n * @returns {Error}\n */\nexports.createNetworkError = function (errorCode, cause) {\n    return createError(errorTypes.NetworkError, {\n        code: errorCode,\n        cause: cause,\n    });\n};\n/**\n * Creates a new RequestFailedError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} response the response sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createRequestFailedError = function (errorCode, response) {\n    return createError(errorTypes.RequestFailedError, {\n        code: errorCode,\n        response: response,\n    });\n};\n/**\n * Creates a new UnexpectedContentError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {String} responseBody the response body sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createUnexpectedContentError = function (errorCode, responseBody) {\n    return createError(errorTypes.UnexpectedContentError, {\n        code: errorCode,\n        responseBody: responseBody,\n    });\n};\n/**\n * Creates a new OperationFailedError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} data the data sent by Global Services.\n * @param {String} message the error message sent by Global Services.\n * @param {String} sqlState the sql state sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createOperationFailedError = function (errorCode, data, message, sqlState) {\n    return createError(errorTypes.OperationFailedError, {\n        code: errorCode,\n        data: data,\n        message: message,\n        sqlState: sqlState,\n    });\n};\n/**\n * Creates a new LargeResultSetError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} response the response sent by S3/Blob.\n *\n * @returns {Error}\n */\nexports.createLargeResultSetError = function (errorCode, response) {\n    return createError(errorTypes.LargeResultSetError, {\n        code: errorCode,\n        response: response,\n    });\n};\n/**\n * Creates a new ClientError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} [isFatal] whether the error is fatal.\n *\n * @return {Error}\n */\nexports.createClientError = function (errorCode, isFatal) {\n    return createError(errorTypes.ClientError, {\n        code: errorCode,\n        isFatal: isFatal,\n        messageArgs: Array.prototype.slice.call(arguments, 2),\n    });\n};\n/**\n * Creates a OCSPError\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {String} message\n * @returns {Error}\n */\nexports.createOCSPError = function (errorCode) {\n    return createError(errorTypes.OCSPError, {\n        code: errorCode,\n        messageArgs: Array.prototype.slice.call(arguments, 1),\n    });\n};\n/**\n * Wraps an error into CrlError. Allows to catch any errors coming from CRL validation.\n *\n * @param {Error} originalError\n * @returns {Error}\n */\nexports.createCrlError = function (originalError) {\n    const error = createError(errorTypes.CRLError, {\n        code: ErrorCode.ERR_CRL_ERROR,\n        cause: originalError,\n    });\n    return error;\n};\n/**\n * Creates a new error by combining the error messages from the json parser and xml parser\n *\n * @param {Object} jsonParseError contains the JSON parse error message\n * @param {Object} xmlParseError contains the XML parse error message\n * @returns {Error}\n */\nexports.VariantParseError = function (jsonParseError, xmlParseError) {\n    const errMessage = 'VariantParseError: Variant cannot be parsed neither as JSON nor as XML:\\n' +\n        ` - JSON parse error message: ${jsonParseError.message}\\n` +\n        ` - XML parse error message: ${xmlParseError.message}`;\n    return new Error(errMessage);\n};\n/**\n * Determines if a given error is an InternalAssertError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isInternalAssertError = function (error) {\n    return isErrorOfType(error, errorTypes.InternalAssertError);\n};\n/**\n * Determines if a given error is a MissingParameterError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isMissingParameterError = function (error) {\n    return isErrorOfType(error, errorTypes.MissingParameterError);\n};\n/**\n * Determines if a given error is an InvalidParameterError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isInvalidParameterError = function (error) {\n    return isErrorOfType(error, errorTypes.InvalidParameterError);\n};\n/**\n * Determines if a given error is a NetworkError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isNetworkError = function (error) {\n    return isErrorOfType(error, errorTypes.NetworkError);\n};\n/**\n * Determines if a given error is a RequestFailedError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isRequestFailedError = function (error) {\n    return isErrorOfType(error, errorTypes.RequestFailedError);\n};\n/**\n * Determines if a given error is an UnexpectedContentError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isUnexpectedContentError = function (error) {\n    return isErrorOfType(error, errorTypes.UnexpectedContentError);\n};\n/**\n * Determines if a given error is an OperationFailedError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isOperationFailedError = function (error) {\n    return isErrorOfType(error, errorTypes.OperationFailedError);\n};\n/**\n * Determines if a given error is an LargeResultSetError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isLargeResultSetError = function (error) {\n    return isErrorOfType(error, errorTypes.LargeResultSetError);\n};\n/**\n * Externalizes an error.\n *\n * @param {Error} error\n *\n * @returns {Error}\n */\nexports.externalize = function (error) {\n    return error && error.externalize ? error.externalize() : error;\n};\n/**\n * Determines if a given error is of a specific type.\n *\n * @param {Error} error\n * @param {String} type\n *\n * @returns {Boolean}\n */\nfunction isErrorOfType(error, type) {\n    return error && error.name === type;\n}\n/**\n * Creates a generic error.\n *\n * @param {String} name\n * @param {Object} options\n *\n * @returns {Error}\n */\nfunction createError(name, options) {\n    // TODO: validate that name is a string and options is an object\n    // TODO: this code is a bit of a mess and needs to be cleaned up\n    // create a new error\n    const error = new Error();\n    // set its name\n    error.name = name;\n    // set the error code\n    let code;\n    error.code = code = options.code;\n    // if no error message was specified in the options\n    let message = options.message ?? options.cause?.message;\n    if (!message) {\n        // use the error code to get the error message template\n        const messageTemplate = errorMessages[code];\n        // if some error message arguments were specified, substitute them into the\n        // error message template to get the full error message, otherwise just use\n        // the error message template as the error message\n        let messageArgs = options.messageArgs;\n        if (messageArgs) {\n            messageArgs = messageArgs.slice();\n            messageArgs.unshift(messageTemplate);\n            message = Util.format.apply(Util, messageArgs);\n        }\n        else {\n            message = messageTemplate;\n        }\n    }\n    error.message = message;\n    // if no sql state was specified in the options, use the error code to try to\n    // get the appropriate sql state\n    let sqlState = options.sqlState;\n    if (!sqlState) {\n        sqlState = errCodeToSqlState[code];\n    }\n    error.sqlState = sqlState;\n    // set the error data\n    error.data = options.data;\n    // set the error response and response body\n    error.response = options.response;\n    error.responseBody = options.responseBody;\n    // set the error cause\n    error.cause = options.cause;\n    // set the error's fatal flag\n    error.isFatal = options.isFatal;\n    // if the error is not synchronous, add an externalize() method\n    if (!options.synchronous) {\n        error.externalize = function () {\n            const propNames = [\n                'name',\n                'code',\n                'message',\n                'sqlState',\n                'data',\n                'response',\n                'responseBody',\n                'cause',\n                'isFatal',\n                'stack',\n            ];\n            const externalizedError = new Error();\n            let propName, propValue;\n            for (let index = 0, length = propNames.length; index < length; index++) {\n                propName = propNames[index];\n                propValue = this[propName];\n                if (Util.exists(propValue)) {\n                    externalizedError[propName] = propValue;\n                }\n            }\n            return externalizedError;\n        };\n    }\n    return error;\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsbUVBQVE7QUFDN0Isc0JBQXNCLG1CQUFPLENBQUMsMkdBQTRCO0FBQzFELGtCQUFrQixpSEFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHdDQUF3Qyx1QkFBdUI7QUFDL0QsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Vycm9ycy5qcz80MDdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2Vycm9yX21lc3NhZ2VzJyk7XG5jb25zdCBFcnJvckNvZGUgPSByZXF1aXJlKCcuL2Vycm9yX2NvZGUnKS5kZWZhdWx0O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYEVycm9yQ29kZWAgaW5zdGVhZFxuICovXG5leHBvcnRzLmNvZGVzID0gRXJyb3JDb2RlO1xuZXhwb3J0cy5FcnJvckNvZGUgPSBFcnJvckNvZGU7XG4vKipcbiAqIEEgbWFwIGluIHdoaWNoIHRoZSBrZXlzIGFyZSB0aGUgZXJyb3IgY29kZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZVxuICogY29ycmVzcG9uZGluZyBTUUwtc3RhdGVzLlxuICovXG5jb25zdCBlcnJDb2RlVG9TcWxTdGF0ZSA9IChleHBvcnRzLm1hcEVycm9yQ29kZVRvU3FsU3RhdGUgPSB7XG4gICAgNDA1NTAxOiAnMDgwMDInLFxuICAgIDQwNTUwMjogJzA4MDAyJyxcbiAgICA0MDU1MDM6ICcwODAwMycsXG4gICAgNDA3MDAxOiAnMDgwMDMnLFxuICAgIDQwNzAwMjogJzA4MDAzJyxcbn0pO1xuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiBhbGwgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBlcnJvcnMgd2UgY3JlYXRlLlxuICovXG5jb25zdCBlcnJvclR5cGVzID0ge1xuICAgIC8vIGludGVybmFsIHN5bmNocm9ub3VzIGVycm9yc1xuICAgIEludGVybmFsQXNzZXJ0RXJyb3I6ICdJbnRlcm5hbEFzc2VydEVycm9yJyxcbiAgICAvLyBleHRlcm5hbCBzeW5jaHJvbm91cyBlcnJvcnNcbiAgICBNaXNzaW5nUGFyYW1ldGVyRXJyb3I6ICdNaXNzaW5nUGFyYW1ldGVyRXJyb3InLFxuICAgIEludmFsaWRQYXJhbWV0ZXJFcnJvcjogJ0ludmFsaWRQYXJhbWV0ZXJFcnJvcicsXG4gICAgLy8gZXh0ZXJuYWwgYXN5bmNocm9ub3VzIGVycm9yc1xuICAgIE5ldHdvcmtFcnJvcjogJ05ldHdvcmtFcnJvcicsXG4gICAgUmVxdWVzdEZhaWxlZEVycm9yOiAnUmVxdWVzdEZhaWxlZEVycm9yJyxcbiAgICBVbmV4cGVjdGVkQ29udGVudEVycm9yOiAnVW5leHBlY3RlZENvbnRlbnRFcnJvcicsXG4gICAgT3BlcmF0aW9uRmFpbGVkRXJyb3I6ICdPcGVyYXRpb25GYWlsZWRFcnJvcicsXG4gICAgTGFyZ2VSZXN1bHRTZXRFcnJvcjogJ0xhcmdlUmVzdWx0U2V0RXJyb3InLFxuICAgIENsaWVudEVycm9yOiAnQ2xpZW50RXJyb3InLFxuICAgIE9DU1BFcnJvcjogJ09DU1BFcnJvcicsXG4gICAgQ1JMRXJyb3I6ICdDUkxFcnJvcicsXG59O1xuLyoqXG4gKiBFbnN1cmVzIHRoZSB0cnV0aCBvZiBhbiBleHByZXNzaW9uLiBVc2VkIHRvIGNhdGNoIGludGVybmFsIHByb2dyYW1taW5nXG4gKiBlcnJvcnMuIElmIHRoZSBnaXZlbiBleHByZXNzaW9uIGlzIGZhbHNlLCBhbiBJbnRlcm5hbEFzc2VydEVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4cHJlc3Npb24gYSBib29sZWFuIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIGEgbWVzc2FnZSBmb3IgdGhlIGVycm9yIHNob3VsZCB0aGUgY2hlY2sgZmFpbC5cbiAqL1xuZXhwb3J0cy5hc3NlcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuSW50ZXJuYWxBc3NlcnRFcnJvciwge1xuICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkVSUl9JTlRFUk5BTF9BU1NFUlRfRkFJTEVELFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIHN5bmNocm9ub3VzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuLy8gVE9ETzpcbi8vIENvbnNpZGVyIHJlbW92aW5nIE1pc3NpbmdQYXJhbWV0ZXJFcnJvciArIGNoZWNrQXJndW1lbnRFeGl0cyArIGNoZWNrQXJndW1lbnRWYWxpZFxuLy8gdG8gcmVkdWNlIGFtb3VudCBvZiBlcnJvciB0eXBlcyB3ZSBoYXZlLiBVc2UgY3JlYXRlSW52YWxpZFBhcmFtZXRlckVycm9yIGluc3RlYWQuXG4vKipcbiAqIEVuc3VyZXMgdGhlIHRydXRoIG9mIGFuIGV4cHJlc3Npb24uIFVzZWQgdG8gbWFrZSBzdXJlIGFsbCByZXF1aXJlZCBhcmd1bWVudHNcbiAqIGFyZSBwYXNzZWQgaW4gdG8gYSBtZXRob2QuIElmIHRoZSBzcGVjaWZpZWQgZXhwcmVzc2lvbiBpcyBmYWxzZSwgYVxuICogTWlzc2luZ1BhcmFtZXRlckVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhwcmVzc2lvbiBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgYSBjb2RlIGZvciB0aGUgZXJyb3Igc2hvdWxkIHRoZSBjaGVjayBmYWlsLlxuICpcbiAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBNaXNzaW5nUGFyYW1ldGVyIGVycm9yIGlmIHRoZSBleHByZXNzaW9uIGlzIGZhbHNlLlxuICovXG5leHBvcnRzLmNoZWNrQXJndW1lbnRFeGlzdHMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgZXJyb3JDb2RlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuTWlzc2luZ1BhcmFtZXRlckVycm9yLCB7XG4gICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlQXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICAgIHN5bmNocm9ub3VzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBFbnN1cmVzIHRoZSB0cnV0aCBvZiBhbiBleHByZXNzaW9uLiBVc2VkIGZvciB2YWxpZGF0aW5nIGFyZ3VtZW50cyB0byBtZXRob2RzLlxuICogSWYgdGhlIHNwZWNpZmllZCBleHByZXNzaW9uIGlzIGZhbHNlLCBhbiBJbnZhbGlkUGFyYW1ldGVyRXJyb3Igd2lsbCBiZVxuICogdGhyb3duLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhwcmVzc2lvbiBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgYSBjb2RlIGZvciB0aGUgZXJyb3Igc2hvdWxkIHRoZSBjaGVjayBmYWlsLlxuICpcbiAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBJbnZhbGlkUGFyYW1ldGVyIGVycm9yIGlmIHRoZSBleHByZXNzaW9uIGlzIGZhbHNlLlxuICovXG5leHBvcnRzLmNoZWNrQXJndW1lbnRWYWxpZCA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBlcnJvckNvZGUpIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5JbnZhbGlkUGFyYW1ldGVyRXJyb3IsIHtcbiAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgIG1lc3NhZ2VBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgc3luY2hyb25vdXM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgSW52YWxpZFBhcmFtZXRlckVycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHttZXNzYWdlQXJnc30gYXJyYXkgb2YgZXJyb3IgbWFzc2FnZXNcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVJbnZhbGlkUGFyYW1ldGVyRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCAuLi5tZXNzYWdlQXJncykge1xuICAgIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLkludmFsaWRQYXJhbWV0ZXJFcnJvciwge1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIG1lc3NhZ2VBcmdzOiBtZXNzYWdlQXJncyxcbiAgICAgICAgc3luY2hyb25vdXM6IHRydWUsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE5ldHdvcmtFcnJvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7RXJyb3J9IGNhdXNlIHRoZSB1bmRlcmx5aW5nIGNhdXNlIG9mIHRoZSBuZXR3b3JrIGVycm9yLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVOZXR3b3JrRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBjYXVzZSkge1xuICAgIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLk5ldHdvcmtFcnJvciwge1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIGNhdXNlOiBjYXVzZSxcbiAgICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVxdWVzdEZhaWxlZEVycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIHRoZSByZXNwb25zZSBzZW50IGJ5IEdsb2JhbCBTZXJ2aWNlcy5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlUmVxdWVzdEZhaWxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5SZXF1ZXN0RmFpbGVkRXJyb3IsIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVuZXhwZWN0ZWRDb250ZW50RXJyb3IuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yQ29kZSB0aGUgZXJyb3IgY29kZSB0byB1c2Ugd2hlbiBidWlsZGluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzcG9uc2VCb2R5IHRoZSByZXNwb25zZSBib2R5IHNlbnQgYnkgR2xvYmFsIFNlcnZpY2VzLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVVbmV4cGVjdGVkQ29udGVudEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuVW5leHBlY3RlZENvbnRlbnRFcnJvciwge1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIHJlc3BvbnNlQm9keTogcmVzcG9uc2VCb2R5LFxuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25GYWlsZWRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHNlbnQgYnkgR2xvYmFsIFNlcnZpY2VzLlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdGhlIGVycm9yIG1lc3NhZ2Ugc2VudCBieSBHbG9iYWwgU2VydmljZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3FsU3RhdGUgdGhlIHNxbCBzdGF0ZSBzZW50IGJ5IEdsb2JhbCBTZXJ2aWNlcy5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlT3BlcmF0aW9uRmFpbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBkYXRhLCBtZXNzYWdlLCBzcWxTdGF0ZSkge1xuICAgIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLk9wZXJhdGlvbkZhaWxlZEVycm9yLCB7XG4gICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc3FsU3RhdGU6IHNxbFN0YXRlLFxuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMYXJnZVJlc3VsdFNldEVycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIHRoZSByZXNwb25zZSBzZW50IGJ5IFMzL0Jsb2IuXG4gKlxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZUxhcmdlUmVzdWx0U2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCByZXNwb25zZSkge1xuICAgIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLkxhcmdlUmVzdWx0U2V0RXJyb3IsIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IENsaWVudEVycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R9IFtpc0ZhdGFsXSB3aGV0aGVyIHRoZSBlcnJvciBpcyBmYXRhbC5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVDbGllbnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIGlzRmF0YWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5DbGllbnRFcnJvciwge1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIGlzRmF0YWw6IGlzRmF0YWwsXG4gICAgICAgIG1lc3NhZ2VBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIE9DU1BFcnJvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVPQ1NQRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuT0NTUEVycm9yLCB7XG4gICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgbWVzc2FnZUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgfSk7XG59O1xuLyoqXG4gKiBXcmFwcyBhbiBlcnJvciBpbnRvIENybEVycm9yLiBBbGxvd3MgdG8gY2F0Y2ggYW55IGVycm9ycyBjb21pbmcgZnJvbSBDUkwgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBvcmlnaW5hbEVycm9yXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlQ3JsRXJyb3IgPSBmdW5jdGlvbiAob3JpZ2luYWxFcnJvcikge1xuICAgIGNvbnN0IGVycm9yID0gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5DUkxFcnJvciwge1xuICAgICAgICBjb2RlOiBFcnJvckNvZGUuRVJSX0NSTF9FUlJPUixcbiAgICAgICAgY2F1c2U6IG9yaWdpbmFsRXJyb3IsXG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBlcnJvciBieSBjb21iaW5pbmcgdGhlIGVycm9yIG1lc3NhZ2VzIGZyb20gdGhlIGpzb24gcGFyc2VyIGFuZCB4bWwgcGFyc2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25QYXJzZUVycm9yIGNvbnRhaW5zIHRoZSBKU09OIHBhcnNlIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB4bWxQYXJzZUVycm9yIGNvbnRhaW5zIHRoZSBYTUwgcGFyc2UgZXJyb3IgbWVzc2FnZVxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLlZhcmlhbnRQYXJzZUVycm9yID0gZnVuY3Rpb24gKGpzb25QYXJzZUVycm9yLCB4bWxQYXJzZUVycm9yKSB7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9ICdWYXJpYW50UGFyc2VFcnJvcjogVmFyaWFudCBjYW5ub3QgYmUgcGFyc2VkIG5laXRoZXIgYXMgSlNPTiBub3IgYXMgWE1MOlxcbicgK1xuICAgICAgICBgIC0gSlNPTiBwYXJzZSBlcnJvciBtZXNzYWdlOiAke2pzb25QYXJzZUVycm9yLm1lc3NhZ2V9XFxuYCArXG4gICAgICAgIGAgLSBYTUwgcGFyc2UgZXJyb3IgbWVzc2FnZTogJHt4bWxQYXJzZUVycm9yLm1lc3NhZ2V9YDtcbiAgICByZXR1cm4gbmV3IEVycm9yKGVyck1lc3NhZ2UpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGFuIEludGVybmFsQXNzZXJ0RXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0ludGVybmFsQXNzZXJ0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvck9mVHlwZShlcnJvciwgZXJyb3JUeXBlcy5JbnRlcm5hbEFzc2VydEVycm9yKTtcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhIE1pc3NpbmdQYXJhbWV0ZXJFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzTWlzc2luZ1BhcmFtZXRlckVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3JPZlR5cGUoZXJyb3IsIGVycm9yVHlwZXMuTWlzc2luZ1BhcmFtZXRlckVycm9yKTtcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhbiBJbnZhbGlkUGFyYW1ldGVyRXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0ludmFsaWRQYXJhbWV0ZXJFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLkludmFsaWRQYXJhbWV0ZXJFcnJvcik7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYSBOZXR3b3JrRXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc05ldHdvcmtFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLk5ldHdvcmtFcnJvcik7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYSBSZXF1ZXN0RmFpbGVkRXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1JlcXVlc3RGYWlsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLlJlcXVlc3RGYWlsZWRFcnJvcik7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYW4gVW5leHBlY3RlZENvbnRlbnRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVW5leHBlY3RlZENvbnRlbnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLlVuZXhwZWN0ZWRDb250ZW50RXJyb3IpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGFuIE9wZXJhdGlvbkZhaWxlZEVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNPcGVyYXRpb25GYWlsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLk9wZXJhdGlvbkZhaWxlZEVycm9yKTtcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhbiBMYXJnZVJlc3VsdFNldEVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNMYXJnZVJlc3VsdFNldEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3JPZlR5cGUoZXJyb3IsIGVycm9yVHlwZXMuTGFyZ2VSZXN1bHRTZXRFcnJvcik7XG59O1xuLyoqXG4gKiBFeHRlcm5hbGl6ZXMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuZXh0ZXJuYWxpemUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IuZXh0ZXJuYWxpemUgPyBlcnJvci5leHRlcm5hbGl6ZSgpIDogZXJyb3I7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Vycm9yT2ZUeXBlKGVycm9yLCB0eXBlKSB7XG4gICAgcmV0dXJuIGVycm9yICYmIGVycm9yLm5hbWUgPT09IHR5cGU7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBnZW5lcmljIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IobmFtZSwgb3B0aW9ucykge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIHRoYXQgbmFtZSBpcyBhIHN0cmluZyBhbmQgb3B0aW9ucyBpcyBhbiBvYmplY3RcbiAgICAvLyBUT0RPOiB0aGlzIGNvZGUgaXMgYSBiaXQgb2YgYSBtZXNzIGFuZCBuZWVkcyB0byBiZSBjbGVhbmVkIHVwXG4gICAgLy8gY3JlYXRlIGEgbmV3IGVycm9yXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAvLyBzZXQgaXRzIG5hbWVcbiAgICBlcnJvci5uYW1lID0gbmFtZTtcbiAgICAvLyBzZXQgdGhlIGVycm9yIGNvZGVcbiAgICBsZXQgY29kZTtcbiAgICBlcnJvci5jb2RlID0gY29kZSA9IG9wdGlvbnMuY29kZTtcbiAgICAvLyBpZiBubyBlcnJvciBtZXNzYWdlIHdhcyBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnNcbiAgICBsZXQgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSA/PyBvcHRpb25zLmNhdXNlPy5tZXNzYWdlO1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAvLyB1c2UgdGhlIGVycm9yIGNvZGUgdG8gZ2V0IHRoZSBlcnJvciBtZXNzYWdlIHRlbXBsYXRlXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUZW1wbGF0ZSA9IGVycm9yTWVzc2FnZXNbY29kZV07XG4gICAgICAgIC8vIGlmIHNvbWUgZXJyb3IgbWVzc2FnZSBhcmd1bWVudHMgd2VyZSBzcGVjaWZpZWQsIHN1YnN0aXR1dGUgdGhlbSBpbnRvIHRoZVxuICAgICAgICAvLyBlcnJvciBtZXNzYWdlIHRlbXBsYXRlIHRvIGdldCB0aGUgZnVsbCBlcnJvciBtZXNzYWdlLCBvdGhlcndpc2UganVzdCB1c2VcbiAgICAgICAgLy8gdGhlIGVycm9yIG1lc3NhZ2UgdGVtcGxhdGUgYXMgdGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgbGV0IG1lc3NhZ2VBcmdzID0gb3B0aW9ucy5tZXNzYWdlQXJncztcbiAgICAgICAgaWYgKG1lc3NhZ2VBcmdzKSB7XG4gICAgICAgICAgICBtZXNzYWdlQXJncyA9IG1lc3NhZ2VBcmdzLnNsaWNlKCk7XG4gICAgICAgICAgICBtZXNzYWdlQXJncy51bnNoaWZ0KG1lc3NhZ2VUZW1wbGF0ZSk7XG4gICAgICAgICAgICBtZXNzYWdlID0gVXRpbC5mb3JtYXQuYXBwbHkoVXRpbCwgbWVzc2FnZUFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAvLyBpZiBubyBzcWwgc3RhdGUgd2FzIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucywgdXNlIHRoZSBlcnJvciBjb2RlIHRvIHRyeSB0b1xuICAgIC8vIGdldCB0aGUgYXBwcm9wcmlhdGUgc3FsIHN0YXRlXG4gICAgbGV0IHNxbFN0YXRlID0gb3B0aW9ucy5zcWxTdGF0ZTtcbiAgICBpZiAoIXNxbFN0YXRlKSB7XG4gICAgICAgIHNxbFN0YXRlID0gZXJyQ29kZVRvU3FsU3RhdGVbY29kZV07XG4gICAgfVxuICAgIGVycm9yLnNxbFN0YXRlID0gc3FsU3RhdGU7XG4gICAgLy8gc2V0IHRoZSBlcnJvciBkYXRhXG4gICAgZXJyb3IuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAvLyBzZXQgdGhlIGVycm9yIHJlc3BvbnNlIGFuZCByZXNwb25zZSBib2R5XG4gICAgZXJyb3IucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIGVycm9yLnJlc3BvbnNlQm9keSA9IG9wdGlvbnMucmVzcG9uc2VCb2R5O1xuICAgIC8vIHNldCB0aGUgZXJyb3IgY2F1c2VcbiAgICBlcnJvci5jYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG4gICAgLy8gc2V0IHRoZSBlcnJvcidzIGZhdGFsIGZsYWdcbiAgICBlcnJvci5pc0ZhdGFsID0gb3B0aW9ucy5pc0ZhdGFsO1xuICAgIC8vIGlmIHRoZSBlcnJvciBpcyBub3Qgc3luY2hyb25vdXMsIGFkZCBhbiBleHRlcm5hbGl6ZSgpIG1ldGhvZFxuICAgIGlmICghb3B0aW9ucy5zeW5jaHJvbm91cykge1xuICAgICAgICBlcnJvci5leHRlcm5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lcyA9IFtcbiAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgJ2NvZGUnLFxuICAgICAgICAgICAgICAgICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAnc3FsU3RhdGUnLFxuICAgICAgICAgICAgICAgICdkYXRhJyxcbiAgICAgICAgICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZUJvZHknLFxuICAgICAgICAgICAgICAgICdjYXVzZScsXG4gICAgICAgICAgICAgICAgJ2lzRmF0YWwnLFxuICAgICAgICAgICAgICAgICdzdGFjaycsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxpemVkRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGxldCBwcm9wTmFtZSwgcHJvcFZhbHVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBwcm9wTmFtZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMocHJvcFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbGl6ZWRFcnJvcltwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsaXplZEVycm9yO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AZURE = __webpack_require__(/*! @azure/storage-blob */ \"(rsc)/./node_modules/@azure/storage-blob/dist-esm/storage-blob/src/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").FileHeader);\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst { isBypassProxy } = __webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst EXPIRED_TOKEN = 'ExpiredToken';\n// Azure Location\nfunction AzureLocation(containerName, path) {\n    return {\n        containerName: containerName,\n        path: path,\n    };\n}\n/**\n * Creates an Azure utility object.\n *\n * @param {module} azure\n * @param {module} filestream\n *\n * @returns {Object}\n * @constructor\n */\nfunction AzureUtil(connectionConfig) {\n    /**\n     * Create a blob service client using an Azure SAS token.\n     *\n     * @param {Object} stageInfo\n     *\n     * @returns {String}\n     */\n    this.createClient = function (stageInfo) {\n        const stageCredentials = stageInfo['creds'];\n        const sasToken = stageCredentials['AZURE_SAS_TOKEN'];\n        const account = stageInfo['storageAccount'];\n        const connectionString = `https://${account}.blob.core.windows.net${sasToken}`;\n        let proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'Azure Util');\n        if (proxy && !isBypassProxy(proxy, connectionString)) {\n            Logger().debug(`The destination host is: ${ProxyUtil.getHostFromURL(connectionString)} and the proxy host is: ${proxy.host}`);\n            Logger().trace(`Initializing the proxy information for the Azure Client: ${ProxyUtil.describeProxy(proxy)}`);\n            proxy = ProxyUtil.getAzureProxy(proxy);\n        }\n        ProxyUtil.hideEnvironmentProxy();\n        const blobServiceClient = new AZURE.BlobServiceClient(connectionString, null, {\n            proxyOptions: proxy,\n        });\n        ProxyUtil.restoreEnvironmentProxy();\n        return blobServiceClient;\n    };\n    /**\n     * Extract the container name and path from the metadata's stage location.\n     *\n     * @param {String} stageLocation\n     *\n     * @returns {Object}\n     */\n    this.extractContainerNameAndPath = function (stageLocation) {\n        // expand '~' and '~user' expressions\n        if (process.platform !== 'win32') {\n            stageLocation = expandTilde(stageLocation);\n        }\n        let containerName = stageLocation;\n        let path;\n        // split stage location as bucket name and path\n        if (stageLocation.includes('/')) {\n            containerName = stageLocation.substring(0, stageLocation.indexOf('/'));\n            path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n            if (path && !path.endsWith('/')) {\n                path += '/';\n            }\n        }\n        return AzureLocation(containerName, path);\n    };\n    /**\n     * Create file header based on file being uploaded or not.\n     *\n     * @param {Object} meta\n     * @param {String} filename\n     *\n     * @returns {Object}\n     */\n    this.getFileHeader = async function (meta, filename) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n        const containerClient = client.getContainerClient(azureLocation.containerName);\n        const blobClient = containerClient.getBlobClient(azureLocation.path + filename);\n        let blobDetails;\n        try {\n            await blobClient.getProperties().then(function (data) {\n                blobDetails = data;\n            });\n        }\n        catch (err) {\n            if (err['code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else if (err['statusCode'] === 404) {\n                meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                return FileHeader(null, null, null);\n            }\n            else if (err['statusCode'] === 400) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else {\n                meta['resultStatus'] = resultStatus.ERROR;\n                return null;\n            }\n        }\n        meta['resultStatus'] = resultStatus.UPLOADED;\n        let encryptionMetadata = null;\n        if (blobDetails.metadata['encryptiondata']) {\n            const encryptionData = JSON.parse(blobDetails.metadata['encryptiondata']);\n            encryptionMetadata = EncryptionMetadata(encryptionData['WrappedContentKey']['EncryptedKey'], encryptionData['ContentEncryptionIV'], blobDetails.metadata['matdesc']);\n        }\n        return FileHeader(blobDetails.metadata['sfcdigest'], blobDetails.contentLength, encryptionMetadata);\n    };\n    /**\n     * Create the file metadata then upload the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     * @param {Number} maxConcurrency\n     *\n     * @returns {null}\n     */\n    this.uploadFile = async function (dataFile, meta, encryptionMetadata, maxConcurrency) {\n        const fileStream = fs.readFileSync(dataFile);\n        await this.uploadFileStream(fileStream, meta, encryptionMetadata, maxConcurrency);\n    };\n    /**\n     * Create the file metadata then upload the file stream.\n     *\n     * @param {String} fileStream\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     *\n     * @returns {null}\n     */\n    this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n        const azureMetadata = {\n            sfcdigest: meta['SHA256_DIGEST'],\n        };\n        if (encryptionMetadata) {\n            azureMetadata['encryptiondata'] = JSON.stringify({\n                EncryptionMode: 'FullBlob',\n                WrappedContentKey: {\n                    KeyId: 'symmKey1',\n                    EncryptedKey: encryptionMetadata.key,\n                    Algorithm: 'AES_CBC_256',\n                },\n                EncryptionAgent: {\n                    Protocol: '1.0',\n                    EncryptionAlgorithm: 'AES_CBC_128',\n                },\n                ContentEncryptionIV: encryptionMetadata.iv,\n                KeyWrappingMetadata: {\n                    EncryptionLibrary: 'Java 5.3.0',\n                },\n            });\n            azureMetadata['matdesc'] = encryptionMetadata.matDesc;\n        }\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n        const blobName = azureLocation.path + meta['dstFileName'];\n        const containerClient = client.getContainerClient(azureLocation.containerName);\n        const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n        try {\n            await blockBlobClient.upload(fileStream, fileStream.length, {\n                metadata: azureMetadata,\n                blobHTTPHeaders: {\n                    blobContentEncoding: 'UTF-8',\n                    blobContentType: 'application/octet-stream',\n                },\n            });\n        }\n        catch (err) {\n            if (err['statusCode'] === 403 && detectAzureTokenExpireError(err)) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return;\n            }\n            else {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.NEED_RETRY;\n            }\n            return;\n        }\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n    };\n    /**\n     * Download the file blob then write the file.\n     *\n     * @param {Object} meta\n     * @param fullDstPath\n     *\n     * @returns {null}\n     */\n    this.nativeDownloadFile = async function (meta, fullDstPath) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n        const blobName = azureLocation.path + meta['srcFileName'];\n        const containerClient = client.getContainerClient(azureLocation.containerName);\n        const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n        try {\n            const downloadBlockBlobResponse = await blockBlobClient.download(0);\n            const readableStream = downloadBlockBlobResponse.readableStreamBody;\n            Logger().debug(`Sent Get Request to ${blockBlobClient.url.split('?')[0]}, destination: ${fullDstPath}, http status: ${downloadBlockBlobResponse.originalResponse._response.status}`);\n            await new Promise((resolve, reject) => {\n                const writer = fs.createWriteStream(fullDstPath);\n                readableStream.on('data', (data) => {\n                    writer.write(data);\n                });\n                readableStream.on('end', () => {\n                    writer.end(resolve);\n                });\n                readableStream.on('error', reject);\n            });\n        }\n        catch (err) {\n            if (err['statusCode'] === 403 && detectAzureTokenExpireError(err)) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return;\n            }\n            else {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.NEED_RETRY;\n            }\n            return;\n        }\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n    };\n    /**\n     * Detect if the Azure token has expired.\n     *\n     * @param {Object} err\n     *\n     * @returns {Boolean}\n     */\n    function detectAzureTokenExpireError(err) {\n        if (err['statusCode'] !== 403) {\n            return false;\n        }\n        const errstr = err.toString();\n        return (errstr.includes('Signature not valid in the specified time frame') ||\n            errstr.includes('Server failed to authenticate the request.'));\n    }\n}\nmodule.exports = AzureUtil;\n//# sourceMappingURL=azure_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2F6dXJlX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixjQUFjLG1CQUFPLENBQUMsd0dBQXFCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLDJCQUEyQixpSkFBNEM7QUFDdkUsbUJBQW1CLGdIQUFrQztBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQyxxQkFBcUIsa0hBQW9DO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFlO0FBQ3pDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyw4RUFBYztBQUNoRCxlQUFlLDBHQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRLHdCQUF3QixTQUFTO0FBQ3JGO0FBQ0E7QUFDQSx1REFBdUQsNENBQTRDLHlCQUF5QixXQUFXO0FBQ3ZJLHVGQUF1RiwrQkFBK0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQ0FBa0MsaUJBQWlCLFlBQVksaUJBQWlCLDREQUE0RDtBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvYXp1cmVfdXRpbC5qcz9jZTZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQVpVUkUgPSByZXF1aXJlKCdAYXp1cmUvc3RvcmFnZS1ibG9iJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBFbmNyeXB0aW9uTWV0YWRhdGEgPSByZXF1aXJlKCcuL2VuY3J5cHRfdXRpbCcpLkVuY3J5cHRpb25NZXRhZGF0YTtcbmNvbnN0IEZpbGVIZWFkZXIgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5GaWxlSGVhZGVyO1xuY29uc3QgZXhwYW5kVGlsZGUgPSByZXF1aXJlKCdleHBhbmQtdGlsZGUnKTtcbmNvbnN0IHJlc3VsdFN0YXR1cyA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLnJlc3VsdFN0YXR1cztcbmNvbnN0IFByb3h5VXRpbCA9IHJlcXVpcmUoJy4uL3Byb3h5X3V0aWwnKTtcbmNvbnN0IHsgaXNCeXBhc3NQcm94eSB9ID0gcmVxdWlyZSgnLi4vaHR0cC9ub2RlJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKS5kZWZhdWx0O1xuY29uc3QgRVhQSVJFRF9UT0tFTiA9ICdFeHBpcmVkVG9rZW4nO1xuLy8gQXp1cmUgTG9jYXRpb25cbmZ1bmN0aW9uIEF6dXJlTG9jYXRpb24oY29udGFpbmVyTmFtZSwgcGF0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRhaW5lck5hbWU6IGNvbnRhaW5lck5hbWUsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBenVyZSB1dGlsaXR5IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZX0gYXp1cmVcbiAqIEBwYXJhbSB7bW9kdWxlfSBmaWxlc3RyZWFtXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBenVyZVV0aWwoY29ubmVjdGlvbkNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGJsb2Igc2VydmljZSBjbGllbnQgdXNpbmcgYW4gQXp1cmUgU0FTIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWdlSW5mb1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIChzdGFnZUluZm8pIHtcbiAgICAgICAgY29uc3Qgc3RhZ2VDcmVkZW50aWFscyA9IHN0YWdlSW5mb1snY3JlZHMnXTtcbiAgICAgICAgY29uc3Qgc2FzVG9rZW4gPSBzdGFnZUNyZWRlbnRpYWxzWydBWlVSRV9TQVNfVE9LRU4nXTtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHN0YWdlSW5mb1snc3RvcmFnZUFjY291bnQnXTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblN0cmluZyA9IGBodHRwczovLyR7YWNjb3VudH0uYmxvYi5jb3JlLndpbmRvd3MubmV0JHtzYXNUb2tlbn1gO1xuICAgICAgICBsZXQgcHJveHkgPSBQcm94eVV0aWwuZ2V0UHJveHkoY29ubmVjdGlvbkNvbmZpZy5nZXRQcm94eSgpLCAnQXp1cmUgVXRpbCcpO1xuICAgICAgICBpZiAocHJveHkgJiYgIWlzQnlwYXNzUHJveHkocHJveHksIGNvbm5lY3Rpb25TdHJpbmcpKSB7XG4gICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgVGhlIGRlc3RpbmF0aW9uIGhvc3QgaXM6ICR7UHJveHlVdGlsLmdldEhvc3RGcm9tVVJMKGNvbm5lY3Rpb25TdHJpbmcpfSBhbmQgdGhlIHByb3h5IGhvc3QgaXM6ICR7cHJveHkuaG9zdH1gKTtcbiAgICAgICAgICAgIExvZ2dlcigpLnRyYWNlKGBJbml0aWFsaXppbmcgdGhlIHByb3h5IGluZm9ybWF0aW9uIGZvciB0aGUgQXp1cmUgQ2xpZW50OiAke1Byb3h5VXRpbC5kZXNjcmliZVByb3h5KHByb3h5KX1gKTtcbiAgICAgICAgICAgIHByb3h5ID0gUHJveHlVdGlsLmdldEF6dXJlUHJveHkocHJveHkpO1xuICAgICAgICB9XG4gICAgICAgIFByb3h5VXRpbC5oaWRlRW52aXJvbm1lbnRQcm94eSgpO1xuICAgICAgICBjb25zdCBibG9iU2VydmljZUNsaWVudCA9IG5ldyBBWlVSRS5CbG9iU2VydmljZUNsaWVudChjb25uZWN0aW9uU3RyaW5nLCBudWxsLCB7XG4gICAgICAgICAgICBwcm94eU9wdGlvbnM6IHByb3h5LFxuICAgICAgICB9KTtcbiAgICAgICAgUHJveHlVdGlsLnJlc3RvcmVFbnZpcm9ubWVudFByb3h5KCk7XG4gICAgICAgIHJldHVybiBibG9iU2VydmljZUNsaWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIGNvbnRhaW5lciBuYW1lIGFuZCBwYXRoIGZyb20gdGhlIG1ldGFkYXRhJ3Mgc3RhZ2UgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhZ2VMb2NhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dHJhY3RDb250YWluZXJOYW1lQW5kUGF0aCA9IGZ1bmN0aW9uIChzdGFnZUxvY2F0aW9uKSB7XG4gICAgICAgIC8vIGV4cGFuZCAnficgYW5kICd+dXNlcicgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIHN0YWdlTG9jYXRpb24gPSBleHBhbmRUaWxkZShzdGFnZUxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyTmFtZSA9IHN0YWdlTG9jYXRpb247XG4gICAgICAgIGxldCBwYXRoO1xuICAgICAgICAvLyBzcGxpdCBzdGFnZSBsb2NhdGlvbiBhcyBidWNrZXQgbmFtZSBhbmQgcGF0aFxuICAgICAgICBpZiAoc3RhZ2VMb2NhdGlvbi5pbmNsdWRlcygnLycpKSB7XG4gICAgICAgICAgICBjb250YWluZXJOYW1lID0gc3RhZ2VMb2NhdGlvbi5zdWJzdHJpbmcoMCwgc3RhZ2VMb2NhdGlvbi5pbmRleE9mKCcvJykpO1xuICAgICAgICAgICAgcGF0aCA9IHN0YWdlTG9jYXRpb24uc3Vic3RyaW5nKHN0YWdlTG9jYXRpb24uaW5kZXhPZignLycpICsgMSwgc3RhZ2VMb2NhdGlvbi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHBhdGggJiYgIXBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBenVyZUxvY2F0aW9uKGNvbnRhaW5lck5hbWUsIHBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZpbGUgaGVhZGVyIGJhc2VkIG9uIGZpbGUgYmVpbmcgdXBsb2FkZWQgb3Igbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRGaWxlSGVhZGVyID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEsIGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuICAgICAgICBjb25zdCBhenVyZUxvY2F0aW9uID0gdGhpcy5leHRyYWN0Q29udGFpbmVyTmFtZUFuZFBhdGgoc3RhZ2VJbmZvWydsb2NhdGlvbiddKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyQ2xpZW50ID0gY2xpZW50LmdldENvbnRhaW5lckNsaWVudChhenVyZUxvY2F0aW9uLmNvbnRhaW5lck5hbWUpO1xuICAgICAgICBjb25zdCBibG9iQ2xpZW50ID0gY29udGFpbmVyQ2xpZW50LmdldEJsb2JDbGllbnQoYXp1cmVMb2NhdGlvbi5wYXRoICsgZmlsZW5hbWUpO1xuICAgICAgICBsZXQgYmxvYkRldGFpbHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBibG9iQ2xpZW50LmdldFByb3BlcnRpZXMoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgYmxvYkRldGFpbHMgPSBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyclsnY29kZSddID09PSBFWFBJUkVEX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJbJ3N0YXR1c0NvZGUnXSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTk9UX0ZPVU5EX0ZJTEU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbGVIZWFkZXIobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJbJ3N0YXR1c0NvZGUnXSA9PT0gNDAwKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5VUExPQURFRDtcbiAgICAgICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIGlmIChibG9iRGV0YWlscy5tZXRhZGF0YVsnZW5jcnlwdGlvbmRhdGEnXSkge1xuICAgICAgICAgICAgY29uc3QgZW5jcnlwdGlvbkRhdGEgPSBKU09OLnBhcnNlKGJsb2JEZXRhaWxzLm1ldGFkYXRhWydlbmNyeXB0aW9uZGF0YSddKTtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YSA9IEVuY3J5cHRpb25NZXRhZGF0YShlbmNyeXB0aW9uRGF0YVsnV3JhcHBlZENvbnRlbnRLZXknXVsnRW5jcnlwdGVkS2V5J10sIGVuY3J5cHRpb25EYXRhWydDb250ZW50RW5jcnlwdGlvbklWJ10sIGJsb2JEZXRhaWxzLm1ldGFkYXRhWydtYXRkZXNjJ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaWxlSGVhZGVyKGJsb2JEZXRhaWxzLm1ldGFkYXRhWydzZmNkaWdlc3QnXSwgYmxvYkRldGFpbHMuY29udGVudExlbmd0aCwgZW5jcnlwdGlvbk1ldGFkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhDb25jdXJyZW5jeVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGxvYWRGaWxlID0gYXN5bmMgZnVuY3Rpb24gKGRhdGFGaWxlLCBtZXRhLCBlbmNyeXB0aW9uTWV0YWRhdGEsIG1heENvbmN1cnJlbmN5KSB7XG4gICAgICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUZpbGUpO1xuICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEZpbGVTdHJlYW0oZmlsZVN0cmVhbSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGZpbGUgbWV0YWRhdGEgdGhlbiB1cGxvYWQgdGhlIGZpbGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVTdHJlYW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkRmlsZVN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlU3RyZWFtLCBtZXRhLCBlbmNyeXB0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgYXp1cmVNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHNmY2RpZ2VzdDogbWV0YVsnU0hBMjU2X0RJR0VTVCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgICAgICBhenVyZU1ldGFkYXRhWydlbmNyeXB0aW9uZGF0YSddID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIEVuY3J5cHRpb25Nb2RlOiAnRnVsbEJsb2InLFxuICAgICAgICAgICAgICAgIFdyYXBwZWRDb250ZW50S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgIEtleUlkOiAnc3ltbUtleTEnLFxuICAgICAgICAgICAgICAgICAgICBFbmNyeXB0ZWRLZXk6IGVuY3J5cHRpb25NZXRhZGF0YS5rZXksXG4gICAgICAgICAgICAgICAgICAgIEFsZ29yaXRobTogJ0FFU19DQkNfMjU2JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEVuY3J5cHRpb25BZ2VudDoge1xuICAgICAgICAgICAgICAgICAgICBQcm90b2NvbDogJzEuMCcsXG4gICAgICAgICAgICAgICAgICAgIEVuY3J5cHRpb25BbGdvcml0aG06ICdBRVNfQ0JDXzEyOCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDb250ZW50RW5jcnlwdGlvbklWOiBlbmNyeXB0aW9uTWV0YWRhdGEuaXYsXG4gICAgICAgICAgICAgICAgS2V5V3JhcHBpbmdNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBFbmNyeXB0aW9uTGlicmFyeTogJ0phdmEgNS4zLjAnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF6dXJlTWV0YWRhdGFbJ21hdGRlc2MnXSA9IGVuY3J5cHRpb25NZXRhZGF0YS5tYXREZXNjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuICAgICAgICBjb25zdCBhenVyZUxvY2F0aW9uID0gdGhpcy5leHRyYWN0Q29udGFpbmVyTmFtZUFuZFBhdGgoc3RhZ2VJbmZvWydsb2NhdGlvbiddKTtcbiAgICAgICAgY29uc3QgYmxvYk5hbWUgPSBhenVyZUxvY2F0aW9uLnBhdGggKyBtZXRhWydkc3RGaWxlTmFtZSddO1xuICAgICAgICBjb25zdCBjb250YWluZXJDbGllbnQgPSBjbGllbnQuZ2V0Q29udGFpbmVyQ2xpZW50KGF6dXJlTG9jYXRpb24uY29udGFpbmVyTmFtZSk7XG4gICAgICAgIGNvbnN0IGJsb2NrQmxvYkNsaWVudCA9IGNvbnRhaW5lckNsaWVudC5nZXRCbG9ja0Jsb2JDbGllbnQoYmxvYk5hbWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgYmxvY2tCbG9iQ2xpZW50LnVwbG9hZChmaWxlU3RyZWFtLCBmaWxlU3RyZWFtLmxlbmd0aCwge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBhenVyZU1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGJsb2JIVFRQSGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBibG9iQ29udGVudEVuY29kaW5nOiAnVVRGLTgnLFxuICAgICAgICAgICAgICAgICAgICBibG9iQ29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyWydzdGF0dXNDb2RlJ10gPT09IDQwMyAmJiBkZXRlY3RBenVyZVRva2VuRXhwaXJlRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUlk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IG1ldGFbJ3VwbG9hZFNpemUnXTtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCB0aGUgZmlsZSBibG9iIHRoZW4gd3JpdGUgdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSBmdWxsRHN0UGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy5uYXRpdmVEb3dubG9hZEZpbGUgPSBhc3luYyBmdW5jdGlvbiAobWV0YSwgZnVsbERzdFBhdGgpIHtcbiAgICAgICAgY29uc3Qgc3RhZ2VJbmZvID0gbWV0YVsnc3RhZ2VJbmZvJ107XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbyk7XG4gICAgICAgIGNvbnN0IGF6dXJlTG9jYXRpb24gPSB0aGlzLmV4dHJhY3RDb250YWluZXJOYW1lQW5kUGF0aChzdGFnZUluZm9bJ2xvY2F0aW9uJ10pO1xuICAgICAgICBjb25zdCBibG9iTmFtZSA9IGF6dXJlTG9jYXRpb24ucGF0aCArIG1ldGFbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckNsaWVudCA9IGNsaWVudC5nZXRDb250YWluZXJDbGllbnQoYXp1cmVMb2NhdGlvbi5jb250YWluZXJOYW1lKTtcbiAgICAgICAgY29uc3QgYmxvY2tCbG9iQ2xpZW50ID0gY29udGFpbmVyQ2xpZW50LmdldEJsb2NrQmxvYkNsaWVudChibG9iTmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZEJsb2NrQmxvYlJlc3BvbnNlID0gYXdhaXQgYmxvY2tCbG9iQ2xpZW50LmRvd25sb2FkKDApO1xuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSBkb3dubG9hZEJsb2NrQmxvYlJlc3BvbnNlLnJlYWRhYmxlU3RyZWFtQm9keTtcbiAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBTZW50IEdldCBSZXF1ZXN0IHRvICR7YmxvY2tCbG9iQ2xpZW50LnVybC5zcGxpdCgnPycpWzBdfSwgZGVzdGluYXRpb246ICR7ZnVsbERzdFBhdGh9LCBodHRwIHN0YXR1czogJHtkb3dubG9hZEJsb2NrQmxvYlJlc3BvbnNlLm9yaWdpbmFsUmVzcG9uc2UuX3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmdWxsRHN0UGF0aCk7XG4gICAgICAgICAgICAgICAgcmVhZGFibGVTdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhZGFibGVTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmVuZChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWFkYWJsZVN0cmVhbS5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyclsnc3RhdHVzQ29kZSddID09PSA0MDMgJiYgZGV0ZWN0QXp1cmVUb2tlbkV4cGlyZUVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIEF6dXJlIHRva2VuIGhhcyBleHBpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVyclxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGV0ZWN0QXp1cmVUb2tlbkV4cGlyZUVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyWydzdGF0dXNDb2RlJ10gIT09IDQwMykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycnN0ciA9IGVyci50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gKGVycnN0ci5pbmNsdWRlcygnU2lnbmF0dXJlIG5vdCB2YWxpZCBpbiB0aGUgc3BlY2lmaWVkIHRpbWUgZnJhbWUnKSB8fFxuICAgICAgICAgICAgZXJyc3RyLmluY2x1ZGVzKCdTZXJ2ZXIgZmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB0aGUgcmVxdWVzdC4nKSk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBBenVyZVV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1henVyZV91dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst AES_BLOCK_SIZE = 128;\nconst blockSize = parseInt(AES_BLOCK_SIZE / 8); // in bytes\nconst QUERY_STAGE_MASTER_KEY = 'queryStageMasterKey';\nconst BASE64 = 'base64';\nconst DEFAULT_AAD = Buffer.from('');\nconst AUTH_TAG_LENGTH_IN_BYTES = 16;\nconst AES_CBC = {\n    cipherName: function (keySizeInBytes) {\n        return `aes-${keySizeInBytes * 8}-cbc`;\n    },\n    ivSize: 16,\n};\nconst AES_ECB = {\n    cipherName: function (keySizeInBytes) {\n        return `aes-${keySizeInBytes * 8}-ecb`;\n    },\n};\nconst AES_GCM = {\n    cipherName: function (keySizeInBytes) {\n        return `aes-${keySizeInBytes * 8}-gcm`;\n    },\n    ivSize: 12,\n};\n// Material Descriptor\nfunction MaterialDescriptor(smkId, queryId, keySize) {\n    return {\n        smkId: smkId,\n        queryId: queryId,\n        keySize: keySize,\n    };\n}\n// Encryption Material\nfunction EncryptionMetadata(key, dataIv, matDesc, keyIv, dataAad, keyAad) {\n    return {\n        key: key,\n        iv: dataIv,\n        matDesc: matDesc,\n        keyIv: keyIv,\n        dataAad: dataAad,\n        keyAad: keyAad,\n    };\n}\nexports.EncryptionMetadata = EncryptionMetadata;\nfunction TempFileGenerator() {\n    this.fileSync = function (option = { dir: os.tmpdir(), prefix: '', postfix: '', extension: '' }) {\n        const randomName = crypto.randomUUID();\n        const fileName = `${option.prefix || ''}${randomName}${option.postfix || ''}${'.' + option.extension || 0}`;\n        if (!this.checkDirInTemp(option.dir)) {\n            option.dir = os.tmpdir();\n        }\n        const fullpath = path.join(option.dir, fileName);\n        fs.writeFileSync(fullpath, '');\n        const fileDescriptor = fs.openSync(fullpath);\n        return { name: fullpath, fd: fileDescriptor };\n    };\n    this.file = function (option = { dir: os.tmpdir(), prefix: '', postfix: '', extension: '' }, callback) {\n        try {\n            const { name, fd } = this.fileSync(option);\n            callback(null, name, fd);\n        }\n        catch (err) {\n            callback(err);\n        }\n    };\n    this.checkDirInTemp = function (directoryPath) {\n        if (!directoryPath || directoryPath.length === 0) {\n            return false;\n        }\n        if (directoryPath.includes(os.tmpdir())) {\n            if (fs.existsSync(directoryPath)) {\n                return true;\n            }\n            else {\n                Logger.getInstance().warn(`no such file or directory, open ${directoryPath}`);\n            }\n        }\n        else {\n            Logger.getInstance().warn(`dir option must be relative to ${os.tmpdir()}, found ${directoryPath}`);\n        }\n        return false;\n    };\n}\n/**\n * Creates an encryption utility object.\n *\n * @param {module} encrypt\n * @param {module} filestream\n * @param {module} temp\n *\n * @returns {Object}\n * @constructor\n */\nfunction EncryptUtil(encrypt, filestream, temp) {\n    const crypto = typeof encrypt !== 'undefined' ? encrypt : __webpack_require__(/*! crypto */ \"crypto\");\n    // TODO: SNOW-1814883: Replace 'fs' with 'fs/promises'\n    const fs = typeof filestream !== 'undefined' ? filestream : __webpack_require__(/*! fs */ \"fs\");\n    const tmp = typeof temp !== 'undefined' ? temp : new TempFileGenerator();\n    /**\n     * Generate a buffer with random bytes given a size.\n     *\n     * @param {Number} byteLength\n     *\n     * @returns {Buffer} of size byteLength\n     */\n    function getSecureRandom(byteLength) {\n        return crypto.randomBytes(byteLength);\n    }\n    /**\n     * Convert a material descriptor object's values to unicode.\n     *\n     * @param {Object} matDesc\n     *\n     * @returns {Object}\n     */\n    function matDescToUnicode(matDesc) {\n        matDesc['smkId'] = matDesc['smkId'].toString();\n        matDesc['keySize'] = matDesc['keySize'].toString();\n        const newMatDesc = JSON.stringify(matDesc);\n        return newMatDesc;\n    }\n    function createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv, keyIv = null, dataAad = null, keyAad = null) {\n        const matDesc = new MaterialDescriptor(encryptionMaterial.smkId, encryptionMaterial.queryId, keySize * 8);\n        return new EncryptionMetadata(encryptedKey.toString(BASE64), dataIv.toString(BASE64), matDescToUnicode(matDesc), keyIv ? keyIv.toString(BASE64) : null, dataAad ? dataAad.toString(BASE64) : null, keyAad ? keyAad.toString(BASE64) : null);\n    }\n    /**\n     * Encrypt content using AES-CBC algorithm.\n     */\n    this.encryptFileStream = async function (encryptionMaterial, content) {\n        return this.encryptDataCBC(encryptionMaterial, content);\n    };\n    this.encryptDataCBC = function (encryptionMaterial, data) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keySize = decodedKek.length;\n        const dataIv = getSecureRandom(AES_CBC.ivSize);\n        const fileKey = getSecureRandom(keySize);\n        const dataCipher = crypto.createCipheriv(AES_CBC.cipherName(keySize), fileKey, dataIv);\n        const encryptedData = performCrypto(dataCipher, data);\n        const keyCipher = crypto.createCipheriv(AES_ECB.cipherName(keySize), decodedKek, null);\n        const encryptedKey = performCrypto(keyCipher, fileKey);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv),\n            dataStream: encryptedData,\n        };\n    };\n    //TODO: SNOW-940981: Add proper usage when feature is ready\n    this.encryptDataGCM = function (encryptionMaterial, data) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keySize = decodedKek.length;\n        const dataIv = getSecureRandom(AES_GCM.ivSize);\n        const fileKey = getSecureRandom(keySize);\n        const encryptedData = this.encryptGCM(data, fileKey, dataIv, DEFAULT_AAD);\n        const keyIv = getSecureRandom(AES_GCM.ivSize);\n        const encryptedKey = this.encryptGCM(fileKey, decodedKek, keyIv, DEFAULT_AAD);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv, keyIv, DEFAULT_AAD, DEFAULT_AAD),\n            dataStream: encryptedData,\n        };\n    };\n    this.encryptGCM = function (data, key, iv, aad) {\n        const cipher = crypto.createCipheriv(AES_GCM.cipherName(key.length), key, iv, {\n            authTagLength: AUTH_TAG_LENGTH_IN_BYTES,\n        });\n        if (aad) {\n            cipher.setAAD(aad);\n        }\n        const encryptedData = performCrypto(cipher, data);\n        return Buffer.concat([encryptedData, cipher.getAuthTag()]);\n    };\n    this.decryptGCM = function (data, key, iv, aad) {\n        const decipher = crypto.createDecipheriv(AES_GCM.cipherName(key.length), key, iv, {\n            authTagLength: AUTH_TAG_LENGTH_IN_BYTES,\n        });\n        if (aad) {\n            decipher.setAAD(aad);\n        }\n        // last 16 bytes of data is the authentication tag\n        const authTag = data.slice(data.length - AUTH_TAG_LENGTH_IN_BYTES, data.length);\n        const cipherText = data.slice(0, data.length - AUTH_TAG_LENGTH_IN_BYTES);\n        decipher.setAuthTag(authTag);\n        return performCrypto(decipher, cipherText);\n    };\n    /**\n     * Encrypt file using AES algorithm.\n     */\n    this.encryptFile = async function (encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        return await this.encryptFileCBC(encryptionMaterial, inputFilePath, tmpDir, chunkSize);\n    };\n    this.encryptFileCBC = async function (encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keySize = decodedKek.length;\n        const dataIv = getSecureRandom(AES_CBC.ivSize);\n        const fileKey = getSecureRandom(keySize);\n        const dataCipher = crypto.createCipheriv(AES_CBC.cipherName(keySize), fileKey, dataIv);\n        const encryptedFilePath = await performFileStreamCrypto(dataCipher, tmpDir, inputFilePath, chunkSize);\n        const keyCipher = crypto.createCipheriv(AES_ECB.cipherName(keySize), decodedKek, null);\n        const encryptedKey = performCrypto(keyCipher, fileKey);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv),\n            dataFile: encryptedFilePath,\n        };\n    };\n    //TODO: SNOW-940981: Add proper usage when feature is ready\n    this.encryptFileGCM = async function (encryptionMaterial, inputFilePath, tmpDir = null) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const dataIv = getSecureRandom(AES_GCM.ivSize);\n        const fileKey = getSecureRandom(decodedKek.length);\n        const fileContent = await new Promise((resolve, reject) => {\n            fs.readFile(inputFilePath, (err, data) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n        const encryptedData = this.encryptGCM(fileContent, fileKey, dataIv, DEFAULT_AAD);\n        const encryptedFilePath = await writeContentToFile(tmpDir, path.basename(inputFilePath) + '#', encryptedData);\n        const keyIv = getSecureRandom(AES_GCM.ivSize);\n        const encryptedKey = this.encryptGCM(fileKey, decodedKek, keyIv, DEFAULT_AAD);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, fileKey.length, encryptedKey, dataIv, keyIv, DEFAULT_AAD, DEFAULT_AAD),\n            dataFile: encryptedFilePath,\n        };\n    };\n    /**\n     * Decrypt file using AES algorithm.\n     */\n    this.decryptFile = async function (metadata, encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        return await this.decryptFileCBC(metadata, encryptionMaterial, inputFilePath, tmpDir, chunkSize);\n    };\n    this.decryptFileCBC = async function (metadata, encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keyBytes = new Buffer.from(metadata.key, BASE64);\n        const ivBytes = new Buffer.from(metadata.iv, BASE64);\n        const keyDecipher = crypto.createDecipheriv(AES_ECB.cipherName(decodedKek.length), decodedKek, null);\n        const fileKey = performCrypto(keyDecipher, keyBytes);\n        const dataDecipher = crypto.createDecipheriv(AES_CBC.cipherName(fileKey.length), fileKey, ivBytes);\n        return await performFileStreamCrypto(dataDecipher, tmpDir, inputFilePath, chunkSize);\n    };\n    //TODO: SNOW-940981: Add proper usage when feature is ready\n    this.decryptFileGCM = async function (metadata, encryptionMaterial, inputFilePath, tmpDir = null) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keyBytes = new Buffer.from(metadata.key, BASE64);\n        const keyIvBytes = new Buffer.from(metadata.keyIv, BASE64);\n        const dataIvBytes = new Buffer.from(metadata.iv, BASE64);\n        const dataAadBytes = new Buffer.from(metadata.dataAad, BASE64);\n        const keyAadBytes = new Buffer.from(metadata.keyAad, BASE64);\n        const fileKey = this.decryptGCM(keyBytes, decodedKek, keyIvBytes, keyAadBytes);\n        const fileContent = await new Promise((resolve, reject) => {\n            fs.readFile(inputFilePath, (err, data) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n        const decryptedData = this.decryptGCM(fileContent, fileKey, dataIvBytes, dataAadBytes);\n        return await writeContentToFile(tmpDir, path.basename(inputFilePath) + '#', decryptedData);\n    };\n    function performCrypto(cipherOrDecipher, data) {\n        const encryptedOrDecrypted = cipherOrDecipher.update(data);\n        const final = cipherOrDecipher.final();\n        return Buffer.concat([encryptedOrDecrypted, final]);\n    }\n    async function performFileStreamCrypto(cipherOrDecipher, tmpDir, inputFilePath, chunkSize) {\n        const outputFile = await new Promise((resolve, reject) => {\n            tmp.file({ dir: tmpDir, prefix: path.basename(inputFilePath) + '#' }, (err, path, fd) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve({ path, fd });\n                }\n            });\n        });\n        await new Promise(function (resolve) {\n            const inputStream = fs.createReadStream(inputFilePath, { highWaterMark: chunkSize });\n            const outputStream = fs.createWriteStream(outputFile.path);\n            inputStream.on('data', function (chunk) {\n                const encrypted = cipherOrDecipher.update(chunk);\n                outputStream.write(encrypted);\n            });\n            inputStream.on('close', function () {\n                outputStream.write(cipherOrDecipher.final());\n                outputStream.close(resolve);\n            });\n        });\n        await new Promise((resolve, reject) => {\n            fs.close(outputFile.fd, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        return outputFile.path;\n    }\n    async function writeContentToFile(tmpDir, prefix, content) {\n        const outputFile = await new Promise((resolve, reject) => {\n            tmp.file({ dir: tmpDir, prefix: prefix }, (err, path, fd) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve({ path, fd });\n                }\n            });\n        });\n        await new Promise((resolve, reject) => {\n            fs.writeFile(outputFile.path, content, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        await new Promise((resolve, reject) => {\n            fs.close(outputFile.fd, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        return outputFile.path;\n    }\n}\nexports.EncryptUtil = EncryptUtil;\n//# sourceMappingURL=encrypt_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2VuY3J5cHRfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EseUNBQXlDLDBEQUEwRDtBQUNuRztBQUNBLDRCQUE0QixvQkFBb0IsRUFBRSxXQUFXLEVBQUUscUJBQXFCLEVBQUUsMEJBQTBCLENBQUUsQ0FBQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxQ0FBcUMsMERBQTBEO0FBQy9GO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGNBQWM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFlBQVksVUFBVSxjQUFjO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFPLENBQUMsc0JBQVE7QUFDOUU7QUFDQSxnRUFBZ0UsbUJBQU8sQ0FBQyxjQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUF5RDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLHFFQUFxRSwwQkFBMEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2VuY3J5cHRfdXRpbC5qcz8zMTQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBBRVNfQkxPQ0tfU0laRSA9IDEyODtcbmNvbnN0IGJsb2NrU2l6ZSA9IHBhcnNlSW50KEFFU19CTE9DS19TSVpFIC8gOCk7IC8vIGluIGJ5dGVzXG5jb25zdCBRVUVSWV9TVEFHRV9NQVNURVJfS0VZID0gJ3F1ZXJ5U3RhZ2VNYXN0ZXJLZXknO1xuY29uc3QgQkFTRTY0ID0gJ2Jhc2U2NCc7XG5jb25zdCBERUZBVUxUX0FBRCA9IEJ1ZmZlci5mcm9tKCcnKTtcbmNvbnN0IEFVVEhfVEFHX0xFTkdUSF9JTl9CWVRFUyA9IDE2O1xuY29uc3QgQUVTX0NCQyA9IHtcbiAgICBjaXBoZXJOYW1lOiBmdW5jdGlvbiAoa2V5U2l6ZUluQnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGBhZXMtJHtrZXlTaXplSW5CeXRlcyAqIDh9LWNiY2A7XG4gICAgfSxcbiAgICBpdlNpemU6IDE2LFxufTtcbmNvbnN0IEFFU19FQ0IgPSB7XG4gICAgY2lwaGVyTmFtZTogZnVuY3Rpb24gKGtleVNpemVJbkJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBgYWVzLSR7a2V5U2l6ZUluQnl0ZXMgKiA4fS1lY2JgO1xuICAgIH0sXG59O1xuY29uc3QgQUVTX0dDTSA9IHtcbiAgICBjaXBoZXJOYW1lOiBmdW5jdGlvbiAoa2V5U2l6ZUluQnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGBhZXMtJHtrZXlTaXplSW5CeXRlcyAqIDh9LWdjbWA7XG4gICAgfSxcbiAgICBpdlNpemU6IDEyLFxufTtcbi8vIE1hdGVyaWFsIERlc2NyaXB0b3JcbmZ1bmN0aW9uIE1hdGVyaWFsRGVzY3JpcHRvcihzbWtJZCwgcXVlcnlJZCwga2V5U2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNta0lkOiBzbWtJZCxcbiAgICAgICAgcXVlcnlJZDogcXVlcnlJZCxcbiAgICAgICAga2V5U2l6ZToga2V5U2l6ZSxcbiAgICB9O1xufVxuLy8gRW5jcnlwdGlvbiBNYXRlcmlhbFxuZnVuY3Rpb24gRW5jcnlwdGlvbk1ldGFkYXRhKGtleSwgZGF0YUl2LCBtYXREZXNjLCBrZXlJdiwgZGF0YUFhZCwga2V5QWFkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGl2OiBkYXRhSXYsXG4gICAgICAgIG1hdERlc2M6IG1hdERlc2MsXG4gICAgICAgIGtleUl2OiBrZXlJdixcbiAgICAgICAgZGF0YUFhZDogZGF0YUFhZCxcbiAgICAgICAga2V5QWFkOiBrZXlBYWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuRW5jcnlwdGlvbk1ldGFkYXRhID0gRW5jcnlwdGlvbk1ldGFkYXRhO1xuZnVuY3Rpb24gVGVtcEZpbGVHZW5lcmF0b3IoKSB7XG4gICAgdGhpcy5maWxlU3luYyA9IGZ1bmN0aW9uIChvcHRpb24gPSB7IGRpcjogb3MudG1wZGlyKCksIHByZWZpeDogJycsIHBvc3RmaXg6ICcnLCBleHRlbnNpb246ICcnIH0pIHtcbiAgICAgICAgY29uc3QgcmFuZG9tTmFtZSA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7b3B0aW9uLnByZWZpeCB8fCAnJ30ke3JhbmRvbU5hbWV9JHtvcHRpb24ucG9zdGZpeCB8fCAnJ30keycuJyArIG9wdGlvbi5leHRlbnNpb24gfHwgJyd9YDtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrRGlySW5UZW1wKG9wdGlvbi5kaXIpKSB7XG4gICAgICAgICAgICBvcHRpb24uZGlyID0gb3MudG1wZGlyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSBwYXRoLmpvaW4ob3B0aW9uLmRpciwgZmlsZU5hbWUpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZ1bGxwYXRoLCAnJyk7XG4gICAgICAgIGNvbnN0IGZpbGVEZXNjcmlwdG9yID0gZnMub3BlblN5bmMoZnVsbHBhdGgpO1xuICAgICAgICByZXR1cm4geyBuYW1lOiBmdWxscGF0aCwgZmQ6IGZpbGVEZXNjcmlwdG9yIH07XG4gICAgfTtcbiAgICB0aGlzLmZpbGUgPSBmdW5jdGlvbiAob3B0aW9uID0geyBkaXI6IG9zLnRtcGRpcigpLCBwcmVmaXg6ICcnLCBwb3N0Zml4OiAnJywgZXh0ZW5zaW9uOiAnJyB9LCBjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBmZCB9ID0gdGhpcy5maWxlU3luYyhvcHRpb24pO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbmFtZSwgZmQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2hlY2tEaXJJblRlbXAgPSBmdW5jdGlvbiAoZGlyZWN0b3J5UGF0aCkge1xuICAgICAgICBpZiAoIWRpcmVjdG9yeVBhdGggfHwgZGlyZWN0b3J5UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0b3J5UGF0aC5pbmNsdWRlcyhvcy50bXBkaXIoKSkpIHtcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGRpcmVjdG9yeVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5LCBvcGVuICR7ZGlyZWN0b3J5UGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYGRpciBvcHRpb24gbXVzdCBiZSByZWxhdGl2ZSB0byAke29zLnRtcGRpcigpfSwgZm91bmQgJHtkaXJlY3RvcnlQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGVuY3J5cHRpb24gdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHttb2R1bGV9IGVuY3J5cHRcbiAqIEBwYXJhbSB7bW9kdWxlfSBmaWxlc3RyZWFtXG4gKiBAcGFyYW0ge21vZHVsZX0gdGVtcFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRW5jcnlwdFV0aWwoZW5jcnlwdCwgZmlsZXN0cmVhbSwgdGVtcCkge1xuICAgIGNvbnN0IGNyeXB0byA9IHR5cGVvZiBlbmNyeXB0ICE9PSAndW5kZWZpbmVkJyA/IGVuY3J5cHQgOiByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICAvLyBUT0RPOiBTTk9XLTE4MTQ4ODM6IFJlcGxhY2UgJ2ZzJyB3aXRoICdmcy9wcm9taXNlcydcbiAgICBjb25zdCBmcyA9IHR5cGVvZiBmaWxlc3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IGZpbGVzdHJlYW0gOiByZXF1aXJlKCdmcycpO1xuICAgIGNvbnN0IHRtcCA9IHR5cGVvZiB0ZW1wICE9PSAndW5kZWZpbmVkJyA/IHRlbXAgOiBuZXcgVGVtcEZpbGVHZW5lcmF0b3IoKTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIGJ1ZmZlciB3aXRoIHJhbmRvbSBieXRlcyBnaXZlbiBhIHNpemUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZUxlbmd0aFxuICAgICAqXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gb2Ygc2l6ZSBieXRlTGVuZ3RoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2VjdXJlUmFuZG9tKGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIG1hdGVyaWFsIGRlc2NyaXB0b3Igb2JqZWN0J3MgdmFsdWVzIHRvIHVuaWNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWF0RGVzY1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXREZXNjVG9Vbmljb2RlKG1hdERlc2MpIHtcbiAgICAgICAgbWF0RGVzY1snc21rSWQnXSA9IG1hdERlc2NbJ3Nta0lkJ10udG9TdHJpbmcoKTtcbiAgICAgICAgbWF0RGVzY1sna2V5U2l6ZSddID0gbWF0RGVzY1sna2V5U2l6ZSddLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IG5ld01hdERlc2MgPSBKU09OLnN0cmluZ2lmeShtYXREZXNjKTtcbiAgICAgICAgcmV0dXJuIG5ld01hdERlc2M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVuY3J5cHRpb25NZXRhZGF0YShlbmNyeXB0aW9uTWF0ZXJpYWwsIGtleVNpemUsIGVuY3J5cHRlZEtleSwgZGF0YUl2LCBrZXlJdiA9IG51bGwsIGRhdGFBYWQgPSBudWxsLCBrZXlBYWQgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1hdERlc2MgPSBuZXcgTWF0ZXJpYWxEZXNjcmlwdG9yKGVuY3J5cHRpb25NYXRlcmlhbC5zbWtJZCwgZW5jcnlwdGlvbk1hdGVyaWFsLnF1ZXJ5SWQsIGtleVNpemUgKiA4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGVkS2V5LnRvU3RyaW5nKEJBU0U2NCksIGRhdGFJdi50b1N0cmluZyhCQVNFNjQpLCBtYXREZXNjVG9Vbmljb2RlKG1hdERlc2MpLCBrZXlJdiA/IGtleUl2LnRvU3RyaW5nKEJBU0U2NCkgOiBudWxsLCBkYXRhQWFkID8gZGF0YUFhZC50b1N0cmluZyhCQVNFNjQpIDogbnVsbCwga2V5QWFkID8ga2V5QWFkLnRvU3RyaW5nKEJBU0U2NCkgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCBjb250ZW50IHVzaW5nIEFFUy1DQkMgYWxnb3JpdGhtLlxuICAgICAqL1xuICAgIHRoaXMuZW5jcnlwdEZpbGVTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiAoZW5jcnlwdGlvbk1hdGVyaWFsLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHREYXRhQ0JDKGVuY3J5cHRpb25NYXRlcmlhbCwgY29udGVudCk7XG4gICAgfTtcbiAgICB0aGlzLmVuY3J5cHREYXRhQ0JDID0gZnVuY3Rpb24gKGVuY3J5cHRpb25NYXRlcmlhbCwgZGF0YSkge1xuICAgICAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBrZXlTaXplID0gZGVjb2RlZEtlay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRhdGFJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfQ0JDLml2U2l6ZSk7XG4gICAgICAgIGNvbnN0IGZpbGVLZXkgPSBnZXRTZWN1cmVSYW5kb20oa2V5U2l6ZSk7XG4gICAgICAgIGNvbnN0IGRhdGFDaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0NCQy5jaXBoZXJOYW1lKGtleVNpemUpLCBmaWxlS2V5LCBkYXRhSXYpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gcGVyZm9ybUNyeXB0byhkYXRhQ2lwaGVyLCBkYXRhKTtcbiAgICAgICAgY29uc3Qga2V5Q2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFFU19FQ0IuY2lwaGVyTmFtZShrZXlTaXplKSwgZGVjb2RlZEtlaywgbnVsbCk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZEtleSA9IHBlcmZvcm1DcnlwdG8oa2V5Q2lwaGVyLCBmaWxlS2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YTogY3JlYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGVuY3J5cHRpb25NYXRlcmlhbCwga2V5U2l6ZSwgZW5jcnlwdGVkS2V5LCBkYXRhSXYpLFxuICAgICAgICAgICAgZGF0YVN0cmVhbTogZW5jcnlwdGVkRGF0YSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vVE9ETzogU05PVy05NDA5ODE6IEFkZCBwcm9wZXIgdXNhZ2Ugd2hlbiBmZWF0dXJlIGlzIHJlYWR5XG4gICAgdGhpcy5lbmNyeXB0RGF0YUdDTSA9IGZ1bmN0aW9uIChlbmNyeXB0aW9uTWF0ZXJpYWwsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZEtlayA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25NYXRlcmlhbFtRVUVSWV9TVEFHRV9NQVNURVJfS0VZXSwgQkFTRTY0KTtcbiAgICAgICAgY29uc3Qga2V5U2l6ZSA9IGRlY29kZWRLZWsubGVuZ3RoO1xuICAgICAgICBjb25zdCBkYXRhSXYgPSBnZXRTZWN1cmVSYW5kb20oQUVTX0dDTS5pdlNpemUpO1xuICAgICAgICBjb25zdCBmaWxlS2V5ID0gZ2V0U2VjdXJlUmFuZG9tKGtleVNpemUpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gdGhpcy5lbmNyeXB0R0NNKGRhdGEsIGZpbGVLZXksIGRhdGFJdiwgREVGQVVMVF9BQUQpO1xuICAgICAgICBjb25zdCBrZXlJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfR0NNLml2U2l6ZSk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZEtleSA9IHRoaXMuZW5jcnlwdEdDTShmaWxlS2V5LCBkZWNvZGVkS2VrLCBrZXlJdiwgREVGQVVMVF9BQUQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhOiBjcmVhdGVFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbk1hdGVyaWFsLCBrZXlTaXplLCBlbmNyeXB0ZWRLZXksIGRhdGFJdiwga2V5SXYsIERFRkFVTFRfQUFELCBERUZBVUxUX0FBRCksXG4gICAgICAgICAgICBkYXRhU3RyZWFtOiBlbmNyeXB0ZWREYXRhLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5lbmNyeXB0R0NNID0gZnVuY3Rpb24gKGRhdGEsIGtleSwgaXYsIGFhZCkge1xuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0dDTS5jaXBoZXJOYW1lKGtleS5sZW5ndGgpLCBrZXksIGl2LCB7XG4gICAgICAgICAgICBhdXRoVGFnTGVuZ3RoOiBBVVRIX1RBR19MRU5HVEhfSU5fQllURVMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWFkKSB7XG4gICAgICAgICAgICBjaXBoZXIuc2V0QUFEKGFhZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHBlcmZvcm1DcnlwdG8oY2lwaGVyLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuY3J5cHRlZERhdGEsIGNpcGhlci5nZXRBdXRoVGFnKCldKTtcbiAgICB9O1xuICAgIHRoaXMuZGVjcnlwdEdDTSA9IGZ1bmN0aW9uIChkYXRhLCBrZXksIGl2LCBhYWQpIHtcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihBRVNfR0NNLmNpcGhlck5hbWUoa2V5Lmxlbmd0aCksIGtleSwgaXYsIHtcbiAgICAgICAgICAgIGF1dGhUYWdMZW5ndGg6IEFVVEhfVEFHX0xFTkdUSF9JTl9CWVRFUyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhYWQpIHtcbiAgICAgICAgICAgIGRlY2lwaGVyLnNldEFBRChhYWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxhc3QgMTYgYnl0ZXMgb2YgZGF0YSBpcyB0aGUgYXV0aGVudGljYXRpb24gdGFnXG4gICAgICAgIGNvbnN0IGF1dGhUYWcgPSBkYXRhLnNsaWNlKGRhdGEubGVuZ3RoIC0gQVVUSF9UQUdfTEVOR1RIX0lOX0JZVEVTLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNpcGhlclRleHQgPSBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gQVVUSF9UQUdfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyhhdXRoVGFnKTtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1DcnlwdG8oZGVjaXBoZXIsIGNpcGhlclRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCBmaWxlIHVzaW5nIEFFUyBhbGdvcml0aG0uXG4gICAgICovXG4gICAgdGhpcy5lbmNyeXB0RmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChlbmNyeXB0aW9uTWF0ZXJpYWwsIGlucHV0RmlsZVBhdGgsIHRtcERpciA9IG51bGwsIGNodW5rU2l6ZSA9IGJsb2NrU2l6ZSAqIDQgKiAxMDI0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuY3J5cHRGaWxlQ0JDKGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCwgdG1wRGlyLCBjaHVua1NpemUpO1xuICAgIH07XG4gICAgdGhpcy5lbmNyeXB0RmlsZUNCQyA9IGFzeW5jIGZ1bmN0aW9uIChlbmNyeXB0aW9uTWF0ZXJpYWwsIGlucHV0RmlsZVBhdGgsIHRtcERpciA9IG51bGwsIGNodW5rU2l6ZSA9IGJsb2NrU2l6ZSAqIDQgKiAxMDI0KSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRLZWsgPSBCdWZmZXIuZnJvbShlbmNyeXB0aW9uTWF0ZXJpYWxbUVVFUllfU1RBR0VfTUFTVEVSX0tFWV0sIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBkZWNvZGVkS2VrLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YUl2ID0gZ2V0U2VjdXJlUmFuZG9tKEFFU19DQkMuaXZTaXplKTtcbiAgICAgICAgY29uc3QgZmlsZUtleSA9IGdldFNlY3VyZVJhbmRvbShrZXlTaXplKTtcbiAgICAgICAgY29uc3QgZGF0YUNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihBRVNfQ0JDLmNpcGhlck5hbWUoa2V5U2l6ZSksIGZpbGVLZXksIGRhdGFJdik7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZEZpbGVQYXRoID0gYXdhaXQgcGVyZm9ybUZpbGVTdHJlYW1DcnlwdG8oZGF0YUNpcGhlciwgdG1wRGlyLCBpbnB1dEZpbGVQYXRoLCBjaHVua1NpemUpO1xuICAgICAgICBjb25zdCBrZXlDaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0VDQi5jaXBoZXJOYW1lKGtleVNpemUpLCBkZWNvZGVkS2VrLCBudWxsKTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkS2V5ID0gcGVyZm9ybUNyeXB0byhrZXlDaXBoZXIsIGZpbGVLZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhOiBjcmVhdGVFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbk1hdGVyaWFsLCBrZXlTaXplLCBlbmNyeXB0ZWRLZXksIGRhdGFJdiksXG4gICAgICAgICAgICBkYXRhRmlsZTogZW5jcnlwdGVkRmlsZVBhdGgsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvL1RPRE86IFNOT1ctOTQwOTgxOiBBZGQgcHJvcGVyIHVzYWdlIHdoZW4gZmVhdHVyZSBpcyByZWFkeVxuICAgIHRoaXMuZW5jcnlwdEZpbGVHQ00gPSBhc3luYyBmdW5jdGlvbiAoZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRLZWsgPSBCdWZmZXIuZnJvbShlbmNyeXB0aW9uTWF0ZXJpYWxbUVVFUllfU1RBR0VfTUFTVEVSX0tFWV0sIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGRhdGFJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfR0NNLml2U2l6ZSk7XG4gICAgICAgIGNvbnN0IGZpbGVLZXkgPSBnZXRTZWN1cmVSYW5kb20oZGVjb2RlZEtlay5sZW5ndGgpO1xuICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZzLnJlYWRGaWxlKGlucHV0RmlsZVBhdGgsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmVuY3J5cHRHQ00oZmlsZUNvbnRlbnQsIGZpbGVLZXksIGRhdGFJdiwgREVGQVVMVF9BQUQpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRGaWxlUGF0aCA9IGF3YWl0IHdyaXRlQ29udGVudFRvRmlsZSh0bXBEaXIsIHBhdGguYmFzZW5hbWUoaW5wdXRGaWxlUGF0aCkgKyAnIycsIGVuY3J5cHRlZERhdGEpO1xuICAgICAgICBjb25zdCBrZXlJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfR0NNLml2U2l6ZSk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZEtleSA9IHRoaXMuZW5jcnlwdEdDTShmaWxlS2V5LCBkZWNvZGVkS2VrLCBrZXlJdiwgREVGQVVMVF9BQUQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhOiBjcmVhdGVFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbk1hdGVyaWFsLCBmaWxlS2V5Lmxlbmd0aCwgZW5jcnlwdGVkS2V5LCBkYXRhSXYsIGtleUl2LCBERUZBVUxUX0FBRCwgREVGQVVMVF9BQUQpLFxuICAgICAgICAgICAgZGF0YUZpbGU6IGVuY3J5cHRlZEZpbGVQYXRoLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjcnlwdCBmaWxlIHVzaW5nIEFFUyBhbGdvcml0aG0uXG4gICAgICovXG4gICAgdGhpcy5kZWNyeXB0RmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhZGF0YSwgZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIgPSBudWxsLCBjaHVua1NpemUgPSBibG9ja1NpemUgKiA0ICogMTAyNCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWNyeXB0RmlsZUNCQyhtZXRhZGF0YSwgZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIsIGNodW5rU2l6ZSk7XG4gICAgfTtcbiAgICB0aGlzLmRlY3J5cHRGaWxlQ0JDID0gYXN5bmMgZnVuY3Rpb24gKG1ldGFkYXRhLCBlbmNyeXB0aW9uTWF0ZXJpYWwsIGlucHV0RmlsZVBhdGgsIHRtcERpciA9IG51bGwsIGNodW5rU2l6ZSA9IGJsb2NrU2l6ZSAqIDQgKiAxMDI0KSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRLZWsgPSBCdWZmZXIuZnJvbShlbmNyeXB0aW9uTWF0ZXJpYWxbUVVFUllfU1RBR0VfTUFTVEVSX0tFWV0sIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGtleUJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLmtleSwgQkFTRTY0KTtcbiAgICAgICAgY29uc3QgaXZCeXRlcyA9IG5ldyBCdWZmZXIuZnJvbShtZXRhZGF0YS5pdiwgQkFTRTY0KTtcbiAgICAgICAgY29uc3Qga2V5RGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihBRVNfRUNCLmNpcGhlck5hbWUoZGVjb2RlZEtlay5sZW5ndGgpLCBkZWNvZGVkS2VrLCBudWxsKTtcbiAgICAgICAgY29uc3QgZmlsZUtleSA9IHBlcmZvcm1DcnlwdG8oa2V5RGVjaXBoZXIsIGtleUJ5dGVzKTtcbiAgICAgICAgY29uc3QgZGF0YURlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoQUVTX0NCQy5jaXBoZXJOYW1lKGZpbGVLZXkubGVuZ3RoKSwgZmlsZUtleSwgaXZCeXRlcyk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtRmlsZVN0cmVhbUNyeXB0byhkYXRhRGVjaXBoZXIsIHRtcERpciwgaW5wdXRGaWxlUGF0aCwgY2h1bmtTaXplKTtcbiAgICB9O1xuICAgIC8vVE9ETzogU05PVy05NDA5ODE6IEFkZCBwcm9wZXIgdXNhZ2Ugd2hlbiBmZWF0dXJlIGlzIHJlYWR5XG4gICAgdGhpcy5kZWNyeXB0RmlsZUdDTSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhZGF0YSwgZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRLZWsgPSBCdWZmZXIuZnJvbShlbmNyeXB0aW9uTWF0ZXJpYWxbUVVFUllfU1RBR0VfTUFTVEVSX0tFWV0sIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGtleUJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLmtleSwgQkFTRTY0KTtcbiAgICAgICAgY29uc3Qga2V5SXZCeXRlcyA9IG5ldyBCdWZmZXIuZnJvbShtZXRhZGF0YS5rZXlJdiwgQkFTRTY0KTtcbiAgICAgICAgY29uc3QgZGF0YUl2Qnl0ZXMgPSBuZXcgQnVmZmVyLmZyb20obWV0YWRhdGEuaXYsIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGRhdGFBYWRCeXRlcyA9IG5ldyBCdWZmZXIuZnJvbShtZXRhZGF0YS5kYXRhQWFkLCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBrZXlBYWRCeXRlcyA9IG5ldyBCdWZmZXIuZnJvbShtZXRhZGF0YS5rZXlBYWQsIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGZpbGVLZXkgPSB0aGlzLmRlY3J5cHRHQ00oa2V5Qnl0ZXMsIGRlY29kZWRLZWssIGtleUl2Qnl0ZXMsIGtleUFhZEJ5dGVzKTtcbiAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmcy5yZWFkRmlsZShpbnB1dEZpbGVQYXRoLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gdGhpcy5kZWNyeXB0R0NNKGZpbGVDb250ZW50LCBmaWxlS2V5LCBkYXRhSXZCeXRlcywgZGF0YUFhZEJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHdyaXRlQ29udGVudFRvRmlsZSh0bXBEaXIsIHBhdGguYmFzZW5hbWUoaW5wdXRGaWxlUGF0aCkgKyAnIycsIGRlY3J5cHRlZERhdGEpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcGVyZm9ybUNyeXB0byhjaXBoZXJPckRlY2lwaGVyLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZE9yRGVjcnlwdGVkID0gY2lwaGVyT3JEZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICAgIGNvbnN0IGZpbmFsID0gY2lwaGVyT3JEZWNpcGhlci5maW5hbCgpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jcnlwdGVkT3JEZWNyeXB0ZWQsIGZpbmFsXSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1GaWxlU3RyZWFtQ3J5cHRvKGNpcGhlck9yRGVjaXBoZXIsIHRtcERpciwgaW5wdXRGaWxlUGF0aCwgY2h1bmtTaXplKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEZpbGUgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0bXAuZmlsZSh7IGRpcjogdG1wRGlyLCBwcmVmaXg6IHBhdGguYmFzZW5hbWUoaW5wdXRGaWxlUGF0aCkgKyAnIycgfSwgKGVyciwgcGF0aCwgZmQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHBhdGgsIGZkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0U3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShpbnB1dEZpbGVQYXRoLCB7IGhpZ2hXYXRlck1hcms6IGNodW5rU2l6ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dFN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG91dHB1dEZpbGUucGF0aCk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNpcGhlck9yRGVjaXBoZXIudXBkYXRlKGNodW5rKTtcbiAgICAgICAgICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoZW5jcnlwdGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbS53cml0ZShjaXBoZXJPckRlY2lwaGVyLmZpbmFsKCkpO1xuICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbS5jbG9zZShyZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnMuY2xvc2Uob3V0cHV0RmlsZS5mZCwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0RmlsZS5wYXRoO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRlbnRUb0ZpbGUodG1wRGlyLCBwcmVmaXgsIGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0RmlsZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRtcC5maWxlKHsgZGlyOiB0bXBEaXIsIHByZWZpeDogcHJlZml4IH0sIChlcnIsIHBhdGgsIGZkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBwYXRoLCBmZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZShvdXRwdXRGaWxlLnBhdGgsIGNvbnRlbnQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnMuY2xvc2Uob3V0cHV0RmlsZS5mZCwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0RmlsZS5wYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuRW5jcnlwdFV0aWwgPSBFbmNyeXB0VXRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable camelcase */\nconst Types = [\n    {\n        name: 'GZIP',\n        file_extension: '.gz',\n        mime_type: 'application',\n        mime_subtypes: ['gzip', 'x-gzip'],\n        is_supported: true,\n    },\n    {\n        name: 'DEFLATE',\n        file_extension: '.deflate',\n        mime_type: 'application',\n        mime_subtypes: ['zlib', 'deflate'],\n        is_supported: true,\n    },\n    {\n        name: 'RAW_DEFLATE',\n        file_extension: '.raw_deflate',\n        mime_type: 'application',\n        mime_subtypes: ['raw_deflate'],\n        is_supported: true,\n    },\n    {\n        name: 'BZIP2',\n        file_extension: '.bz2',\n        mime_type: 'application',\n        mime_subtypes: ['bzip2', 'x-bzip2', 'x-bz2', 'x-bzip', 'bz2'],\n        is_supported: true,\n    },\n    {\n        name: 'LZIP',\n        file_extension: '.lz',\n        mime_type: 'application',\n        mime_subtypes: ['lzip', 'x-lzip'],\n        is_supported: false,\n    },\n    {\n        name: 'LZMA',\n        file_extension: '.lzma',\n        mime_type: 'application',\n        mime_subtypes: ['lzma', 'x-lzma'],\n        is_supported: false,\n    },\n    {\n        name: 'LZO',\n        file_extension: '.lzo',\n        mime_type: 'application',\n        mime_subtypes: ['lzo', 'x-lzo'],\n        is_supported: false,\n    },\n    {\n        name: 'XZ',\n        file_extension: '.xz',\n        mime_type: 'application',\n        mime_subtypes: ['xz', 'x-xz'],\n        is_supported: false,\n    },\n    {\n        name: 'COMPRESS',\n        file_extension: '.Z',\n        mime_type: 'application',\n        mime_subtypes: ['compress', 'x-compress'],\n        is_supported: false,\n    },\n    {\n        name: 'PARQUET',\n        file_extension: '.parquet',\n        mime_type: 'snowflake',\n        mime_subtypes: ['parquet'],\n        is_supported: true,\n    },\n    {\n        name: 'ZSTD',\n        file_extension: '.zst',\n        mime_type: 'application',\n        mime_subtypes: ['zstd', 'x-zstd'],\n        is_supported: true,\n    },\n    {\n        name: 'BROTLI',\n        file_extension: '.br',\n        mime_type: 'application',\n        mime_subtypes: ['br', 'x-br'],\n        is_supported: true,\n    },\n    {\n        name: 'ORC',\n        file_extension: '.orc',\n        mime_type: 'snowflake',\n        mime_subtypes: ['orc'],\n        is_supported: true,\n    },\n];\n/* eslint-enable camelcase */\nconst subtypeToMeta = [];\nfor (const type of Types) {\n    for (const ms of type['mime_subtypes']) {\n        subtypeToMeta[ms] = type;\n    }\n}\n/**\n * Return the file compression type based on subtype.\n *\n * @param {String} subtype\n *\n * @returns {Object} the file compression object\n */\nexports.lookupByMimeSubType = function lookupByMimeSubType(subtype) {\n    return subtypeToMeta[subtype.toLowerCase()];\n};\n/**\n * Return the file compression type based on encoding.\n *\n * @param {String} encoding\n *\n * @returns {Object} the file compression object\n */\nexports.lookupByEncoding = function lookupByEncoding(encoding) {\n    encoding = encoding.substring(encoding.indexOf('/') + 1);\n    return subtypeToMeta[encoding];\n};\n//# sourceMappingURL=file_compression_type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2ZpbGVfY29tcHJlc3Npb25fdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2ZpbGVfY29tcHJlc3Npb25fdHlwZS5qcz9jMTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5jb25zdCBUeXBlcyA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdHWklQJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcuZ3onLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnZ3ppcCcsICd4LWd6aXAnXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnREVGTEFURScsXG4gICAgICAgIGZpbGVfZXh0ZW5zaW9uOiAnLmRlZmxhdGUnLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnemxpYicsICdkZWZsYXRlJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1JBV19ERUZMQVRFJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcucmF3X2RlZmxhdGUnLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsncmF3X2RlZmxhdGUnXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnQlpJUDInLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5iejInLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnYnppcDInLCAneC1iemlwMicsICd4LWJ6MicsICd4LWJ6aXAnLCAnYnoyJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0xaSVAnLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5seicsXG4gICAgICAgIG1pbWVfdHlwZTogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgbWltZV9zdWJ0eXBlczogWydsemlwJywgJ3gtbHppcCddLFxuICAgICAgICBpc19zdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTFpNQScsXG4gICAgICAgIGZpbGVfZXh0ZW5zaW9uOiAnLmx6bWEnLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnbHptYScsICd4LWx6bWEnXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0xaTycsXG4gICAgICAgIGZpbGVfZXh0ZW5zaW9uOiAnLmx6bycsXG4gICAgICAgIG1pbWVfdHlwZTogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgbWltZV9zdWJ0eXBlczogWydsem8nLCAneC1sem8nXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1haJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcueHonLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsneHonLCAneC14eiddLFxuICAgICAgICBpc19zdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnQ09NUFJFU1MnLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5aJyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ2NvbXByZXNzJywgJ3gtY29tcHJlc3MnXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1BBUlFVRVQnLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5wYXJxdWV0JyxcbiAgICAgICAgbWltZV90eXBlOiAnc25vd2ZsYWtlJyxcbiAgICAgICAgbWltZV9zdWJ0eXBlczogWydwYXJxdWV0J10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1pTVEQnLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy56c3QnLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnenN0ZCcsICd4LXpzdGQnXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnQlJPVExJJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcuYnInLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnYnInLCAneC1iciddLFxuICAgICAgICBpc19zdXBwb3J0ZWQ6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdPUkMnLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5vcmMnLFxuICAgICAgICBtaW1lX3R5cGU6ICdzbm93Zmxha2UnLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ29yYyddLFxuICAgICAgICBpc19zdXBwb3J0ZWQ6IHRydWUsXG4gICAgfSxcbl07XG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuY29uc3Qgc3VidHlwZVRvTWV0YSA9IFtdO1xuZm9yIChjb25zdCB0eXBlIG9mIFR5cGVzKSB7XG4gICAgZm9yIChjb25zdCBtcyBvZiB0eXBlWydtaW1lX3N1YnR5cGVzJ10pIHtcbiAgICAgICAgc3VidHlwZVRvTWV0YVttc10gPSB0eXBlO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJuIHRoZSBmaWxlIGNvbXByZXNzaW9uIHR5cGUgYmFzZWQgb24gc3VidHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3VidHlwZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBmaWxlIGNvbXByZXNzaW9uIG9iamVjdFxuICovXG5leHBvcnRzLmxvb2t1cEJ5TWltZVN1YlR5cGUgPSBmdW5jdGlvbiBsb29rdXBCeU1pbWVTdWJUeXBlKHN1YnR5cGUpIHtcbiAgICByZXR1cm4gc3VidHlwZVRvTWV0YVtzdWJ0eXBlLnRvTG93ZXJDYXNlKCldO1xufTtcbi8qKlxuICogUmV0dXJuIHRoZSBmaWxlIGNvbXByZXNzaW9uIHR5cGUgYmFzZWQgb24gZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nXG4gKlxuICogQHJldHVybnMge09iamVjdH0gdGhlIGZpbGUgY29tcHJlc3Npb24gb2JqZWN0XG4gKi9cbmV4cG9ydHMubG9va3VwQnlFbmNvZGluZyA9IGZ1bmN0aW9uIGxvb2t1cEJ5RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nLnN1YnN0cmluZyhlbmNvZGluZy5pbmRleE9mKCcvJykgKyAxKTtcbiAgICByZXR1cm4gc3VidHlwZVRvTWV0YVtlbmNvZGluZ107XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZV9jb21wcmVzc2lvbl90eXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst statement = __webpack_require__(/*! ../connection/statement */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\");\nconst fileCompressionType = __webpack_require__(/*! ./file_compression_type */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js\");\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst SnowflakeRemoteStorageUtil = (__webpack_require__(/*! ./remote_storage_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js\").RemoteStorageUtil);\nconst LocalUtil = (__webpack_require__(/*! ./local_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js\").LocalUtil);\nconst SnowflakeFileEncryptionMaterial = (__webpack_require__(/*! ./remote_storage_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js\").SnowflakeFileEncryptionMaterial);\nconst SnowflakeS3Util = __webpack_require__(/*! ./s3_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js\");\nconst { FileUtil, getMatchingFilePaths } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst SnowflakeFileUtil = new FileUtil();\nconst SnowflakeLocalUtil = new LocalUtil();\nconst S3_FS = 'S3';\nconst AZURE_FS = 'AZURE';\nconst GCS_FS = 'GCS';\nconst LOCAL_FS = 'LOCAL_FS';\nconst CMD_TYPE_UPLOAD = 'UPLOAD';\nconst CMD_TYPE_DOWNLOAD = 'DOWNLOAD';\nconst FILE_PROTOCOL = 'file://';\nconst INJECT_WAIT_IN_PUT = 0;\nconst RESULT_TEXT_COLUMN_DESC = function (name) {\n    return {\n        name: name,\n        type: 'text',\n        length: 16777216,\n        precision: null,\n        scale: null,\n        nullable: false,\n    };\n};\nconst RESULT_FIXED_COLUMN_DESC = function (name) {\n    return {\n        name: name,\n        type: 'fixed',\n        length: 5,\n        precision: 0,\n        scale: 0,\n        nullable: false,\n    };\n};\n/**\n * Creates a file transfer agent.\n *\n * @param {Object} context\n *\n * @returns {Object}\n * @constructor\n */\nfunction FileTransferAgent(context) {\n    const remoteStorageUtil = new SnowflakeRemoteStorageUtil(context.connectionConfig);\n    const response = context.fileMetadata;\n    const command = context.sqlText;\n    const cwd = context.cwd;\n    let commandType;\n    const encryptionMaterial = [];\n    let fileName;\n    const fileStream = context.fileStream ? context.fileStream : null;\n    let autoCompress;\n    let sourceCompression;\n    let parallel;\n    let stageInfo;\n    let stageLocationType;\n    let presignedUrls;\n    let overwrite;\n    let useAccelerateEndpoint = false;\n    let srcFiles;\n    const srcFilesToEncryptionMaterial = {};\n    let localLocation;\n    const results = [];\n    // Store info of files retrieved\n    const filesToPut = [];\n    // Store metadata of files retrieved\n    const fileMetadata = [];\n    const smallFileMetas = [];\n    const largeFileMetas = [];\n    /**\n     * Execute PUT or GET command.\n     *\n     * @returns {null}\n     */\n    this.execute = async function () {\n        if (fileStream) {\n            const data = response['data'];\n            commandType = data['command'];\n            autoCompress = data['autoCompress'];\n            sourceCompression = data['sourceCompression'];\n            parallel = data['parallel'];\n            stageInfo = data['stageInfo'];\n            stageLocationType = stageInfo['locationType'];\n            presignedUrls = data['presignedUrls'];\n            overwrite = data['overwrite'];\n            if (commandType !== CMD_TYPE_UPLOAD) {\n                throw new Error('Incorrect UploadFileStream command');\n            }\n            const currFileObj = {};\n            currFileObj['srcFileName'] = data.src_locations[0];\n            currFileObj['srcFilePath'] = '';\n            currFileObj['srcFileSize'] = fileStream.length;\n            filesToPut.push(currFileObj);\n            initEncryptionMaterial();\n            initFileMetadata();\n            await transferAccelerateConfig();\n            await updateFileMetasWithPresignedUrl();\n            if (fileMetadata.length !== 1) {\n                throw new Error('UploadFileStream only allow 1 file');\n            }\n            //upload\n            const storageClient = getStorageClient(stageLocationType);\n            const client = storageClient.createClient(stageInfo, false);\n            const meta = fileMetadata[0];\n            meta['parallel'] = parallel;\n            meta['client'] = client;\n            meta['fileStream'] = fileStream;\n            //for digest\n            const hash = crypto.createHash('sha256').update(fileStream).digest('base64');\n            meta['SHA256_DIGEST'] = hash;\n            meta['uploadSize'] = fileStream.length;\n            meta['dstCompressionType'] = fileCompressionType.lookupByEncoding(sourceCompression);\n            meta['requireCompress'] = false;\n            meta['dstFileName'] = meta['srcFileName'];\n            await storageClient.uploadOneFileStream(meta);\n        }\n        else {\n            parseCommand();\n            initFileMetadata();\n            if (commandType === CMD_TYPE_UPLOAD) {\n                if (filesToPut.length === 0) {\n                    throw new Error('No file found for: ' + fileName);\n                }\n                processFileCompressionType();\n            }\n            if (commandType === CMD_TYPE_DOWNLOAD) {\n                if (!fs.existsSync(localLocation)) {\n                    fs.mkdirSync(localLocation);\n                }\n            }\n            if (stageLocationType === LOCAL_FS) {\n                process.umask(0);\n                if (!fs.existsSync(stageInfo['location'])) {\n                    fs.mkdirSync(stageInfo['location'], { mode: 0o777, recursive: true });\n                }\n            }\n            await transferAccelerateConfig();\n            await updateFileMetasWithPresignedUrl();\n            for (const meta of fileMetadata) {\n                if (meta['srcFileSize'] > SnowflakeS3Util.DATA_SIZE_THRESHOLD) {\n                    // Add to large file metas\n                    meta['parallel'] = parallel;\n                    largeFileMetas.push(meta);\n                }\n                else {\n                    // Add to small file metas and set parallel to 1\n                    meta['parallel'] = 1;\n                    smallFileMetas.push(meta);\n                }\n            }\n            if (commandType === CMD_TYPE_UPLOAD) {\n                await upload(largeFileMetas, smallFileMetas);\n            }\n            if (commandType === CMD_TYPE_DOWNLOAD) {\n                await download(largeFileMetas, smallFileMetas);\n            }\n        }\n    };\n    /**\n     * Generate the rowset and rowset types using the file metadatas.\n     *\n     * @returns {Object}\n     */\n    this.result = function () {\n        const rowset = [];\n        if (commandType === CMD_TYPE_UPLOAD) {\n            let srcFileSize;\n            let dstFileSize;\n            let srcCompressionType;\n            let dstCompressionType;\n            let errorDetails;\n            if (results) {\n                for (const meta of results) {\n                    if (meta['resultStatus'] === 'ERROR') {\n                        errorDetails = meta['errorDetails'];\n                        if (!errorDetails) {\n                            errorDetails = `Unknown error during PUT of file: ${meta['srcFilePath']}`;\n                        }\n                        throw new Error(errorDetails);\n                    }\n                    if (meta['srcCompressionType']) {\n                        srcCompressionType = meta['srcCompressionType']['name'];\n                    }\n                    else {\n                        srcCompressionType = null;\n                    }\n                    if (meta['dstCompressionType']) {\n                        dstCompressionType = meta['dstCompressionType']['name'];\n                    }\n                    else {\n                        dstCompressionType = null;\n                    }\n                    errorDetails = meta['errorDetails'];\n                    srcFileSize = meta['srcFileSize'].toString();\n                    dstFileSize = meta['dstFileSize'].toString();\n                    rowset.push([\n                        meta['srcFileName'],\n                        meta['dstFileName'],\n                        srcFileSize,\n                        dstFileSize,\n                        srcCompressionType,\n                        dstCompressionType,\n                        meta['resultStatus'],\n                        errorDetails,\n                    ]);\n                }\n            }\n            return {\n                rowset: rowset,\n                rowtype: [\n                    RESULT_TEXT_COLUMN_DESC('source'),\n                    RESULT_TEXT_COLUMN_DESC('target'),\n                    RESULT_FIXED_COLUMN_DESC('sourceSize'),\n                    RESULT_FIXED_COLUMN_DESC('targetSize'),\n                    RESULT_TEXT_COLUMN_DESC('sourceCompression'),\n                    RESULT_TEXT_COLUMN_DESC('targetCompression'),\n                    RESULT_TEXT_COLUMN_DESC('status'),\n                    RESULT_TEXT_COLUMN_DESC('message'),\n                ],\n            };\n        }\n        else if (commandType === CMD_TYPE_DOWNLOAD) {\n            let dstFileSize;\n            let errorDetails;\n            if (results) {\n                for (const meta of results) {\n                    errorDetails = meta['errorDetails'];\n                    dstFileSize = meta['dstFileSize'];\n                    rowset.push([meta['dstFileName'], dstFileSize, meta['resultStatus'], errorDetails]);\n                }\n            }\n            return {\n                rowset: rowset,\n                rowtype: [\n                    RESULT_TEXT_COLUMN_DESC('file'),\n                    RESULT_FIXED_COLUMN_DESC('size'),\n                    RESULT_TEXT_COLUMN_DESC('status'),\n                    RESULT_TEXT_COLUMN_DESC('message'),\n                ],\n            };\n        }\n    };\n    /**\n     * Upload files in the metadata list.\n     *\n     * @returns {null}\n     */\n    async function upload(largeFileMetas, smallFileMetas) {\n        const storageClient = getStorageClient(stageLocationType);\n        const client = storageClient.createClient(stageInfo, false);\n        for (const meta of smallFileMetas) {\n            meta['client'] = client;\n        }\n        for (const meta of largeFileMetas) {\n            meta['client'] = client;\n        }\n        if (smallFileMetas.length > 0) {\n            //await uploadFilesinParallel(smallFileMetas);\n            await uploadFilesinSequential(smallFileMetas);\n        }\n        if (largeFileMetas.length > 0) {\n            await uploadFilesinSequential(largeFileMetas);\n        }\n    }\n    /**\n     * Upload a file sequentially.\n     *\n     * @param {Object} fileMeta\n     *\n     * @returns {null}\n     */\n    async function uploadFilesinSequential(fileMeta) {\n        let index = 0;\n        const fileMetaLen = fileMeta.length;\n        while (index < fileMetaLen) {\n            const result = await uploadOneFile(fileMeta[index]);\n            if (result['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                const client = renewExpiredClient();\n                for (let index2 = index; index2 < fileMetaLen; index2++) {\n                    fileMeta[index2]['client'] = client;\n                }\n                continue;\n            }\n            else if (result['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                await updateFileMetasWithPresignedUrl();\n                continue;\n            }\n            results.push(result);\n            if (result['resultStatus'] === resultStatus.ERROR) {\n                break;\n            }\n            index += 1;\n            if (INJECT_WAIT_IN_PUT > 0) {\n                await new Promise((resolve) => setTimeout(resolve, INJECT_WAIT_IN_PUT));\n            }\n        }\n    }\n    /**\n     * Generate a temporary directory for the file then upload.\n     *\n     * @param {Object} meta\n     *\n     * @returns {Object}\n     */\n    async function uploadOneFile(meta) {\n        meta['realSrcFilePath'] = meta['srcFilePath'];\n        const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'tmp'));\n        meta['tmpDir'] = tmpDir;\n        try {\n            if (meta['requireCompress']) {\n                const result = await SnowflakeFileUtil.compressFileWithGZIP(meta['srcFilePath'], meta['tmpDir']);\n                meta['realSrcFilePath'] = result.name;\n            }\n            const result = await SnowflakeFileUtil.getDigestAndSizeForFile(meta['realSrcFilePath']);\n            const sha256Digest = result.digest;\n            const uploadSize = result.size;\n            meta['SHA256_DIGEST'] = sha256Digest;\n            meta['uploadSize'] = uploadSize;\n            const storageClient = getStorageClient(meta['stageLocationType']);\n            await storageClient.uploadOneFileWithRetry(meta);\n        }\n        catch (err) {\n            meta['dstFileSize'] = 0;\n            if (meta['resultStatus']) {\n                meta['resultStatus'] = resultStatus.ERROR;\n            }\n            meta['errorDetails'] = err.toString();\n            meta['errorDetails'] += ` file=${meta['srcFileName']}, real file=${meta['realSrcFilePath']}`;\n        }\n        finally {\n            // Remove all files inside tmp folder\n            const matchingFileNames = getMatchingFilePaths(meta['tmpDir'], meta['srcFileName'] + '*');\n            for (const matchingFileName of matchingFileNames) {\n                await new Promise((resolve, reject) => {\n                    fs.unlink(matchingFileName, (err) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        resolve();\n                    });\n                });\n            }\n            // Delete tmp folder\n            fs.rmdir(meta['tmpDir'], (err) => {\n                if (err) {\n                    throw err;\n                }\n            });\n        }\n        return meta;\n    }\n    /**\n     * Download files in the metadata list.\n     *\n     * @returns {null}\n     */\n    async function download(largeFileMetas, smallFileMetas) {\n        const storageClient = getStorageClient(stageLocationType);\n        const client = storageClient.createClient(stageInfo, false);\n        for (const meta of smallFileMetas) {\n            meta['client'] = client;\n        }\n        for (const meta of largeFileMetas) {\n            meta['client'] = client;\n        }\n        if (smallFileMetas.length > 0) {\n            //await downloadFilesinParallel(smallFileMetas);\n            await downloadFilesinSequential(smallFileMetas);\n        }\n        if (largeFileMetas.length > 0) {\n            await downloadFilesinSequential(largeFileMetas);\n        }\n    }\n    /**\n     * Download a file sequentially.\n     *\n     * @param {Object} fileMeta\n     *\n     * @returns {null}\n     */\n    async function downloadFilesinSequential(fileMeta) {\n        let index = 0;\n        const fileMetaLen = fileMeta.length;\n        while (index < fileMetaLen) {\n            const result = await downloadOneFile(fileMeta[index]);\n            if (result['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                const client = renewExpiredClient();\n                for (let index2 = index; index2 < fileMetaLen; index2++) {\n                    fileMeta[index2]['client'] = client;\n                }\n                continue;\n            }\n            else if (result['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                await updateFileMetasWithPresignedUrl();\n                continue;\n            }\n            results.push(result);\n            index += 1;\n            if (INJECT_WAIT_IN_PUT > 0) {\n                await new Promise((resolve) => setTimeout(resolve, INJECT_WAIT_IN_PUT));\n            }\n        }\n    }\n    /**\n     * Download a file and place into the target directory.\n     *\n     * @param {Object} meta\n     *\n     * @returns {Object}\n     */\n    async function downloadOneFile(meta) {\n        meta['tmpDir'] = await new Promise((resolve, reject) => {\n            fs.mkdtemp(path.join(os.tmpdir(), 'tmp'), (err, dir) => {\n                if (err) {\n                    reject(err);\n                }\n                resolve(dir);\n            });\n        });\n        try {\n            const storageClient = getStorageClient(meta['stageLocationType']);\n            await storageClient.downloadOneFile(meta);\n        }\n        catch (err) {\n            meta['dstFileSize'] = -1;\n            if (meta['resultStatus']) {\n                meta['resultStatus'] = resultStatus.ERROR;\n            }\n            meta['errorDetails'] = err.toString();\n            meta['errorDetails'] += ` file=${meta['dstFileName']}`;\n        }\n        return meta;\n    }\n    /**\n     * Determine whether to acceleration configuration for S3 clients.\n     *\n     * @returns {null}\n     */\n    async function transferAccelerateConfig() {\n        if (stageLocationType === S3_FS) {\n            const client = remoteStorageUtil.createClient(stageInfo, false);\n            const s3location = SnowflakeS3Util.extractBucketNameAndPath(stageInfo['location']);\n            await client\n                .getBucketAccelerateConfiguration({ Bucket: s3location.bucketName })\n                .then(function (data) {\n                useAccelerateEndpoint = data['Status'] === 'Enabled';\n            })\n                .catch(function (err) {\n                if (err['code'] === 'AccessDenied') {\n                    return;\n                }\n            });\n        }\n    }\n    /**\n     * Update presigned URLs of file metadata when using GCS client.\n     *\n     * @returns {null}\n     */\n    async function updateFileMetasWithPresignedUrl() {\n        const storageClient = getStorageClient(stageLocationType);\n        // presigned url only applies to remote storage\n        if (storageClient === remoteStorageUtil) {\n            // presigned url only applies to GCS\n            if (stageLocationType === GCS_FS) {\n                if (commandType === CMD_TYPE_UPLOAD) {\n                    const filePathToReplace = getFileNameFromPutCommand(command);\n                    for (const meta of fileMetadata) {\n                        const fileNameToReplaceWith = meta['dstFileName'];\n                        let commandWithSingleFile = command;\n                        commandWithSingleFile = commandWithSingleFile.replace(filePathToReplace, fileNameToReplaceWith);\n                        const options = { sqlText: commandWithSingleFile };\n                        const newContext = statement.createContext(options, context.services, context.connectionConfig);\n                        const ret = await statement.sendRequest(newContext);\n                        meta['stageInfo'] = ret['data']['data']['stageInfo'];\n                        meta['presignedUrl'] = meta['stageInfo']['presignedUrl'];\n                    }\n                }\n                else if (commandType === CMD_TYPE_DOWNLOAD) {\n                    for (let index = 0; index < fileMetadata.length; index++) {\n                        fileMetadata[index]['presignedUrl'] = presignedUrls[index];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns the local file path.\n     *\n     * @param {String} command\n     *\n     * @returns {String}\n     */\n    function getFileNameFromPutCommand(command) {\n        // Extract file path from PUT command:\n        // E.g. \"PUT file://C:<path-to-file> @DB.SCHEMA.%TABLE;\"\n        const startIndex = command.indexOf(FILE_PROTOCOL) + FILE_PROTOCOL.length;\n        const spaceIndex = command.substring(startIndex).indexOf(' ');\n        const quoteIndex = command.substring(startIndex).indexOf(\"'\");\n        let endIndex = spaceIndex;\n        if (quoteIndex !== -1 && quoteIndex < spaceIndex) {\n            endIndex = quoteIndex;\n        }\n        const filePath = command.substring(startIndex, startIndex + endIndex);\n        return filePath;\n    }\n    /**\n     * Get the storage client based on stage location type.\n     *\n     * @param {String} stageLocationType\n     *\n     * @returns {Object}\n     */\n    function getStorageClient(stageLocationType) {\n        if (stageLocationType === LOCAL_FS) {\n            return SnowflakeLocalUtil;\n        }\n        else if (stageLocationType === S3_FS ||\n            stageLocationType === AZURE_FS ||\n            stageLocationType === GCS_FS) {\n            return remoteStorageUtil;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Parse the command and get list of files to upload/download.\n     *\n     * @returns {null}\n     */\n    function parseCommand() {\n        const data = response['data'];\n        commandType = data['command'];\n        if (commandType === CMD_TYPE_UPLOAD) {\n            const src = data['src_locations'][0];\n            // Get root directory of file path\n            let root = path.dirname(src);\n            // If cwd exists and root is relative . then replace with context's cwd\n            // Used for VS Code extension where extension cwd differs from user workspace dir\n            if (cwd && !path.isAbsolute(src)) {\n                const absolutePath = path.resolve(cwd, src);\n                root = path.dirname(absolutePath);\n            }\n            let dir;\n            // Check root directory exists\n            if (fs.existsSync(root)) {\n                // Check the root path is a directory\n                dir = fs.statSync(root);\n                if (dir.isDirectory()) {\n                    // Get file name to upload\n                    fileName = path.basename(src);\n                    // Full path name of the file\n                    const fileNameFullPath = path.join(root, fileName);\n                    // If file name has a wildcard\n                    if (fileName.includes('*')) {\n                        // Get all file names that matches the wildcard\n                        const matchingFileNames = getMatchingFilePaths(root, fileName);\n                        for (const matchingFileName of matchingFileNames) {\n                            initEncryptionMaterial();\n                            const fileInfo = fs.statSync(matchingFileName);\n                            const currFileObj = {};\n                            currFileObj['srcFileName'] = path.basename(matchingFileName);\n                            currFileObj['srcFilePath'] = matchingFileName;\n                            currFileObj['srcFileSize'] = fileInfo.size;\n                            filesToPut.push(currFileObj);\n                        }\n                    }\n                    else {\n                        // No wildcard, get single file\n                        if (fs.existsSync(root)) {\n                            initEncryptionMaterial();\n                            const fileInfo = fs.statSync(fileNameFullPath);\n                            const currFileObj = {};\n                            currFileObj['srcFileName'] = fileName;\n                            currFileObj['srcFilePath'] = fileNameFullPath;\n                            currFileObj['srcFileSize'] = fileInfo.size;\n                            filesToPut.push(currFileObj);\n                        }\n                    }\n                }\n            }\n            else {\n                throw new Error(dir + ' is not a directory');\n            }\n            autoCompress = data['autoCompress'];\n            sourceCompression = data['sourceCompression'];\n        }\n        else if (commandType === CMD_TYPE_DOWNLOAD) {\n            initEncryptionMaterial();\n            srcFiles = data['src_locations'];\n            if (srcFiles.length === encryptionMaterial.length) {\n                for (const idx in srcFiles) {\n                    srcFilesToEncryptionMaterial[srcFiles[idx]] = encryptionMaterial[idx];\n                }\n            }\n            else if (encryptionMaterial.length !== 0) {\n                // some encryption material exists. Zero means no encryption\n                throw new Error(\"The number of downloading files doesn't match\");\n            }\n            localLocation = expandTilde(data['localLocation']);\n            // If cwd exists and root is relative . then replace with context's cwd\n            // Used for VS Code extension where extension cwd differs from user workspace dir\n            if (cwd && !path.isAbsolute(localLocation)) {\n                const absolutePath = path.resolve(cwd, localLocation);\n                localLocation = absolutePath;\n            }\n            const dir = fs.statSync(localLocation);\n            if (!dir.isDirectory()) {\n                throw new Error('The local path is not a directory: ' + localLocation);\n            }\n        }\n        parallel = data['parallel'];\n        stageInfo = data['stageInfo'];\n        stageLocationType = stageInfo['locationType'];\n        presignedUrls = data['presignedUrls'];\n        overwrite = data['overwrite'];\n    }\n    /**\n     * Generate encryption material for each metadata.\n     *\n     * @returns {null}\n     */\n    function initEncryptionMaterial() {\n        if (response['data'] && response['data']['encryptionMaterial']) {\n            const rootNode = response['data']['encryptionMaterial'];\n            if (commandType === CMD_TYPE_UPLOAD) {\n                encryptionMaterial.push(new SnowflakeFileEncryptionMaterial(rootNode['queryStageMasterKey'], rootNode['queryId'], rootNode['smkId']));\n            }\n            else if (commandType === CMD_TYPE_DOWNLOAD) {\n                for (const elem in rootNode) {\n                    encryptionMaterial.push(new SnowflakeFileEncryptionMaterial(rootNode[elem]['queryStageMasterKey'], rootNode[elem]['queryId'], rootNode[elem]['smkId']));\n                }\n            }\n        }\n    }\n    /**\n     * Generate metadata for files to upload/download.\n     *\n     * @returns {null}\n     */\n    function initFileMetadata() {\n        if (commandType === CMD_TYPE_UPLOAD) {\n            for (const file of filesToPut) {\n                const currFileObj = {};\n                currFileObj['srcFilePath'] = file['srcFilePath'];\n                currFileObj['srcFileName'] = file['srcFileName'];\n                currFileObj['srcFileSize'] = file['srcFileSize'];\n                currFileObj['stageLocationType'] = stageLocationType;\n                currFileObj['stageInfo'] = stageInfo;\n                currFileObj['overwrite'] = overwrite;\n                fileMetadata.push(currFileObj);\n            }\n        }\n        else if (commandType === CMD_TYPE_DOWNLOAD) {\n            for (const fileName of srcFiles) {\n                const currFileObj = {};\n                currFileObj['srcFileName'] = fileName;\n                currFileObj['dstFileName'] = fileName;\n                currFileObj['stageLocationType'] = stageLocationType;\n                currFileObj['stageInfo'] = stageInfo;\n                currFileObj['useAccelerateEndpoint'] = useAccelerateEndpoint;\n                currFileObj['localLocation'] = localLocation;\n                currFileObj['encryptionMaterial'] = srcFilesToEncryptionMaterial[fileName];\n                fileMetadata.push(currFileObj);\n            }\n        }\n        if (encryptionMaterial.length > 0) {\n            let i = 0;\n            for (const file of fileMetadata) {\n                file['encryptionMaterial'] = encryptionMaterial[i];\n                i++;\n            }\n        }\n    }\n    /**\n     * Get the compression type of the file.\n     *\n     * @returns {null}\n     */\n    function processFileCompressionType() {\n        let userSpecifiedSourceCompression;\n        let autoDetect;\n        if (sourceCompression === 'auto_detect') {\n            autoDetect = true;\n        }\n        else if (sourceCompression === typeof 'undefined') {\n            autoDetect = false;\n        }\n        else {\n            userSpecifiedSourceCompression = fileCompressionType.lookupByMimeSubType(sourceCompression);\n            if (userSpecifiedSourceCompression === typeof 'undefined' ||\n                !userSpecifiedSourceCompression['is_supported']) {\n                throw new Error(sourceCompression + ' is not a supported compression type');\n            }\n            autoDetect = false;\n        }\n        for (const meta of fileMetadata) {\n            const fileName = meta['srcFileName'];\n            const filePath = meta['srcFilePath'];\n            let currentFileCompressionType;\n            let encoding;\n            if (autoDetect) {\n                encoding = mime.lookup(fileName);\n                if (!encoding) {\n                    const test = Buffer.alloc(4);\n                    const fd = fs.openSync(filePath, 'r+');\n                    fs.readSync(fd, test, 0, 4, 0);\n                    fs.closeSync(fd);\n                    if (fileName.substring(fileName.lastIndexOf('.')) === '.br') {\n                        encoding = 'br';\n                    }\n                    else if (fileName.substring(fileName.lastIndexOf('.')) === '.deflate') {\n                        encoding = 'deflate';\n                    }\n                    else if (fileName.substring(fileName.lastIndexOf('.')) === '.raw_deflate') {\n                        encoding = 'raw_deflate';\n                    }\n                    else if (Buffer.from(test.toString()).slice(0, 3) === Buffer.from('ORC')) {\n                        encoding = 'orc';\n                    }\n                    else if (Buffer.from(test.toString()) === Buffer.from('PAR1')) {\n                        encoding = 'parquet';\n                    }\n                    else if (test.toString('hex') === '28fd2ffd' ||\n                        fileName.substring(fileName.lastIndexOf('.')) === '.zst') {\n                        encoding = 'zstd';\n                    }\n                }\n                if (encoding) {\n                    currentFileCompressionType = fileCompressionType.lookupByEncoding(encoding);\n                }\n                // else {} No file encoding detected\n                if (currentFileCompressionType && !currentFileCompressionType['is_supported']) {\n                    throw new Error(encoding + ' is not a a supported compression type');\n                }\n            }\n            else {\n                currentFileCompressionType = userSpecifiedSourceCompression;\n            }\n            if (currentFileCompressionType) {\n                if (currentFileCompressionType['is_supported']) {\n                    meta['dstCompressionType'] = currentFileCompressionType;\n                    meta['requireCompress'] = false;\n                    meta['dstFileName'] = meta['srcFileName'];\n                }\n                else {\n                    throw new Error(encoding + ' is not a a supported compression type');\n                }\n            }\n            else {\n                meta['requireCompress'] = autoCompress;\n                meta['srcCompressionType'] = null;\n                // If requireCompress is true, destination file extension is changed to zip\n                if (autoCompress) {\n                    // Compress with gzip\n                    meta['dstCompressionType'] = fileCompressionType.lookupByMimeSubType('GZIP');\n                    meta['dstFileName'] = meta['srcFileName'] + meta['dstCompressionType']['file_extension'];\n                }\n                else {\n                    meta['dstFileName'] = meta['srcFileName'];\n                    meta['dstCompressionType'] = null;\n                }\n            }\n        }\n    }\n}\n//TODO SNOW-992387: Create a function to renew expired client\nfunction renewExpiredClient() { }\nmodule.exports = FileTransferAgent;\n//# sourceMappingURL=file_transfer_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2ZpbGVfdHJhbnNmZXJfYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLDREQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMseUhBQXlCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjO0FBQzFDLG1DQUFtQyw4SkFBa0Q7QUFDckYsa0JBQWtCLG9JQUFpQztBQUNuRCx3Q0FBd0MsNEtBQWdFO0FBQ3hHLHdCQUF3QixtQkFBTyxDQUFDLDZGQUFXO0FBQzNDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyw4RUFBYztBQUNqRSxxQkFBcUIsa0hBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw4QkFBOEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysb0JBQW9CO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CLGNBQWMsd0JBQXdCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9maWxlX3RyYW5zZmVyX2FnZW50LmpzP2FkYWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgc3RhdGVtZW50ID0gcmVxdWlyZSgnLi4vY29ubmVjdGlvbi9zdGF0ZW1lbnQnKTtcbmNvbnN0IGZpbGVDb21wcmVzc2lvblR5cGUgPSByZXF1aXJlKCcuL2ZpbGVfY29tcHJlc3Npb25fdHlwZScpO1xuY29uc3QgZXhwYW5kVGlsZGUgPSByZXF1aXJlKCdleHBhbmQtdGlsZGUnKTtcbmNvbnN0IFNub3dmbGFrZVJlbW90ZVN0b3JhZ2VVdGlsID0gcmVxdWlyZSgnLi9yZW1vdGVfc3RvcmFnZV91dGlsJykuUmVtb3RlU3RvcmFnZVV0aWw7XG5jb25zdCBMb2NhbFV0aWwgPSByZXF1aXJlKCcuL2xvY2FsX3V0aWwnKS5Mb2NhbFV0aWw7XG5jb25zdCBTbm93Zmxha2VGaWxlRW5jcnlwdGlvbk1hdGVyaWFsID0gcmVxdWlyZSgnLi9yZW1vdGVfc3RvcmFnZV91dGlsJykuU25vd2ZsYWtlRmlsZUVuY3J5cHRpb25NYXRlcmlhbDtcbmNvbnN0IFNub3dmbGFrZVMzVXRpbCA9IHJlcXVpcmUoJy4vczNfdXRpbCcpO1xuY29uc3QgeyBGaWxlVXRpbCwgZ2V0TWF0Y2hpbmdGaWxlUGF0aHMgfSA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpO1xuY29uc3QgcmVzdWx0U3RhdHVzID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykucmVzdWx0U3RhdHVzO1xuY29uc3QgU25vd2ZsYWtlRmlsZVV0aWwgPSBuZXcgRmlsZVV0aWwoKTtcbmNvbnN0IFNub3dmbGFrZUxvY2FsVXRpbCA9IG5ldyBMb2NhbFV0aWwoKTtcbmNvbnN0IFMzX0ZTID0gJ1MzJztcbmNvbnN0IEFaVVJFX0ZTID0gJ0FaVVJFJztcbmNvbnN0IEdDU19GUyA9ICdHQ1MnO1xuY29uc3QgTE9DQUxfRlMgPSAnTE9DQUxfRlMnO1xuY29uc3QgQ01EX1RZUEVfVVBMT0FEID0gJ1VQTE9BRCc7XG5jb25zdCBDTURfVFlQRV9ET1dOTE9BRCA9ICdET1dOTE9BRCc7XG5jb25zdCBGSUxFX1BST1RPQ09MID0gJ2ZpbGU6Ly8nO1xuY29uc3QgSU5KRUNUX1dBSVRfSU5fUFVUID0gMDtcbmNvbnN0IFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIGxlbmd0aDogMTY3NzcyMTYsXG4gICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICB9O1xufTtcbmNvbnN0IFJFU1VMVF9GSVhFRF9DT0xVTU5fREVTQyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2ZpeGVkJyxcbiAgICAgICAgbGVuZ3RoOiA1LFxuICAgICAgICBwcmVjaXNpb246IDAsXG4gICAgICAgIHNjYWxlOiAwLFxuICAgICAgICBudWxsYWJsZTogZmFsc2UsXG4gICAgfTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBmaWxlIHRyYW5zZmVyIGFnZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlVHJhbnNmZXJBZ2VudChjb250ZXh0KSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmFnZVV0aWwgPSBuZXcgU25vd2ZsYWtlUmVtb3RlU3RvcmFnZVV0aWwoY29udGV4dC5jb25uZWN0aW9uQ29uZmlnKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGNvbnRleHQuZmlsZU1ldGFkYXRhO1xuICAgIGNvbnN0IGNvbW1hbmQgPSBjb250ZXh0LnNxbFRleHQ7XG4gICAgY29uc3QgY3dkID0gY29udGV4dC5jd2Q7XG4gICAgbGV0IGNvbW1hbmRUeXBlO1xuICAgIGNvbnN0IGVuY3J5cHRpb25NYXRlcmlhbCA9IFtdO1xuICAgIGxldCBmaWxlTmFtZTtcbiAgICBjb25zdCBmaWxlU3RyZWFtID0gY29udGV4dC5maWxlU3RyZWFtID8gY29udGV4dC5maWxlU3RyZWFtIDogbnVsbDtcbiAgICBsZXQgYXV0b0NvbXByZXNzO1xuICAgIGxldCBzb3VyY2VDb21wcmVzc2lvbjtcbiAgICBsZXQgcGFyYWxsZWw7XG4gICAgbGV0IHN0YWdlSW5mbztcbiAgICBsZXQgc3RhZ2VMb2NhdGlvblR5cGU7XG4gICAgbGV0IHByZXNpZ25lZFVybHM7XG4gICAgbGV0IG92ZXJ3cml0ZTtcbiAgICBsZXQgdXNlQWNjZWxlcmF0ZUVuZHBvaW50ID0gZmFsc2U7XG4gICAgbGV0IHNyY0ZpbGVzO1xuICAgIGNvbnN0IHNyY0ZpbGVzVG9FbmNyeXB0aW9uTWF0ZXJpYWwgPSB7fTtcbiAgICBsZXQgbG9jYWxMb2NhdGlvbjtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgLy8gU3RvcmUgaW5mbyBvZiBmaWxlcyByZXRyaWV2ZWRcbiAgICBjb25zdCBmaWxlc1RvUHV0ID0gW107XG4gICAgLy8gU3RvcmUgbWV0YWRhdGEgb2YgZmlsZXMgcmV0cmlldmVkXG4gICAgY29uc3QgZmlsZU1ldGFkYXRhID0gW107XG4gICAgY29uc3Qgc21hbGxGaWxlTWV0YXMgPSBbXTtcbiAgICBjb25zdCBsYXJnZUZpbGVNZXRhcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgUFVUIG9yIEdFVCBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy5leGVjdXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZmlsZVN0cmVhbSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgICAgICBjb21tYW5kVHlwZSA9IGRhdGFbJ2NvbW1hbmQnXTtcbiAgICAgICAgICAgIGF1dG9Db21wcmVzcyA9IGRhdGFbJ2F1dG9Db21wcmVzcyddO1xuICAgICAgICAgICAgc291cmNlQ29tcHJlc3Npb24gPSBkYXRhWydzb3VyY2VDb21wcmVzc2lvbiddO1xuICAgICAgICAgICAgcGFyYWxsZWwgPSBkYXRhWydwYXJhbGxlbCddO1xuICAgICAgICAgICAgc3RhZ2VJbmZvID0gZGF0YVsnc3RhZ2VJbmZvJ107XG4gICAgICAgICAgICBzdGFnZUxvY2F0aW9uVHlwZSA9IHN0YWdlSW5mb1snbG9jYXRpb25UeXBlJ107XG4gICAgICAgICAgICBwcmVzaWduZWRVcmxzID0gZGF0YVsncHJlc2lnbmVkVXJscyddO1xuICAgICAgICAgICAgb3ZlcndyaXRlID0gZGF0YVsnb3ZlcndyaXRlJ107XG4gICAgICAgICAgICBpZiAoY29tbWFuZFR5cGUgIT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IFVwbG9hZEZpbGVTdHJlYW0gY29tbWFuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VyckZpbGVPYmogPSB7fTtcbiAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlTmFtZSddID0gZGF0YS5zcmNfbG9jYXRpb25zWzBdO1xuICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVQYXRoJ10gPSAnJztcbiAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlU2l6ZSddID0gZmlsZVN0cmVhbS5sZW5ndGg7XG4gICAgICAgICAgICBmaWxlc1RvUHV0LnB1c2goY3VyckZpbGVPYmopO1xuICAgICAgICAgICAgaW5pdEVuY3J5cHRpb25NYXRlcmlhbCgpO1xuICAgICAgICAgICAgaW5pdEZpbGVNZXRhZGF0YSgpO1xuICAgICAgICAgICAgYXdhaXQgdHJhbnNmZXJBY2NlbGVyYXRlQ29uZmlnKCk7XG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVGaWxlTWV0YXNXaXRoUHJlc2lnbmVkVXJsKCk7XG4gICAgICAgICAgICBpZiAoZmlsZU1ldGFkYXRhLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXBsb2FkRmlsZVN0cmVhbSBvbmx5IGFsbG93IDEgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy91cGxvYWRcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VDbGllbnQgPSBnZXRTdG9yYWdlQ2xpZW50KHN0YWdlTG9jYXRpb25UeXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHN0b3JhZ2VDbGllbnQuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbywgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IGZpbGVNZXRhZGF0YVswXTtcbiAgICAgICAgICAgIG1ldGFbJ3BhcmFsbGVsJ10gPSBwYXJhbGxlbDtcbiAgICAgICAgICAgIG1ldGFbJ2NsaWVudCddID0gY2xpZW50O1xuICAgICAgICAgICAgbWV0YVsnZmlsZVN0cmVhbSddID0gZmlsZVN0cmVhbTtcbiAgICAgICAgICAgIC8vZm9yIGRpZ2VzdFxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoZmlsZVN0cmVhbSkuZGlnZXN0KCdiYXNlNjQnKTtcbiAgICAgICAgICAgIG1ldGFbJ1NIQTI1Nl9ESUdFU1QnXSA9IGhhc2g7XG4gICAgICAgICAgICBtZXRhWyd1cGxvYWRTaXplJ10gPSBmaWxlU3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldGFbJ2RzdENvbXByZXNzaW9uVHlwZSddID0gZmlsZUNvbXByZXNzaW9uVHlwZS5sb29rdXBCeUVuY29kaW5nKHNvdXJjZUNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgIG1ldGFbJ3JlcXVpcmVDb21wcmVzcyddID0gZmFsc2U7XG4gICAgICAgICAgICBtZXRhWydkc3RGaWxlTmFtZSddID0gbWV0YVsnc3JjRmlsZU5hbWUnXTtcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2VDbGllbnQudXBsb2FkT25lRmlsZVN0cmVhbShtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlQ29tbWFuZCgpO1xuICAgICAgICAgICAgaW5pdEZpbGVNZXRhZGF0YSgpO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZXNUb1B1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmaWxlIGZvdW5kIGZvcjogJyArIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZpbGVDb21wcmVzc2lvblR5cGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfRE9XTkxPQUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobG9jYWxMb2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKGxvY2FsTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFnZUxvY2F0aW9uVHlwZSA9PT0gTE9DQUxfRlMpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLnVtYXNrKDApO1xuICAgICAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhzdGFnZUluZm9bJ2xvY2F0aW9uJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhzdGFnZUluZm9bJ2xvY2F0aW9uJ10sIHsgbW9kZTogMG83NzcsIHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0cmFuc2ZlckFjY2VsZXJhdGVDb25maWcoKTtcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUZpbGVNZXRhc1dpdGhQcmVzaWduZWRVcmwoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBmaWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YVsnc3JjRmlsZVNpemUnXSA+IFNub3dmbGFrZVMzVXRpbC5EQVRBX1NJWkVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsYXJnZSBmaWxlIG1ldGFzXG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ3BhcmFsbGVsJ10gPSBwYXJhbGxlbDtcbiAgICAgICAgICAgICAgICAgICAgbGFyZ2VGaWxlTWV0YXMucHVzaChtZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBzbWFsbCBmaWxlIG1ldGFzIGFuZCBzZXQgcGFyYWxsZWwgdG8gMVxuICAgICAgICAgICAgICAgICAgICBtZXRhWydwYXJhbGxlbCddID0gMTtcbiAgICAgICAgICAgICAgICAgICAgc21hbGxGaWxlTWV0YXMucHVzaChtZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZChsYXJnZUZpbGVNZXRhcywgc21hbGxGaWxlTWV0YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRvd25sb2FkKGxhcmdlRmlsZU1ldGFzLCBzbWFsbEZpbGVNZXRhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSByb3dzZXQgYW5kIHJvd3NldCB0eXBlcyB1c2luZyB0aGUgZmlsZSBtZXRhZGF0YXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByb3dzZXQgPSBbXTtcbiAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgIGxldCBzcmNGaWxlU2l6ZTtcbiAgICAgICAgICAgIGxldCBkc3RGaWxlU2l6ZTtcbiAgICAgICAgICAgIGxldCBzcmNDb21wcmVzc2lvblR5cGU7XG4gICAgICAgICAgICBsZXQgZHN0Q29tcHJlc3Npb25UeXBlO1xuICAgICAgICAgICAgbGV0IGVycm9yRGV0YWlscztcbiAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSAnRVJST1InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckRldGFpbHMgPSBtZXRhWydlcnJvckRldGFpbHMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3JEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzID0gYFVua25vd24gZXJyb3IgZHVyaW5nIFBVVCBvZiBmaWxlOiAke21ldGFbJ3NyY0ZpbGVQYXRoJ119YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhWydzcmNDb21wcmVzc2lvblR5cGUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjQ29tcHJlc3Npb25UeXBlID0gbWV0YVsnc3JjQ29tcHJlc3Npb25UeXBlJ11bJ25hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0NvbXByZXNzaW9uVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFbJ2RzdENvbXByZXNzaW9uVHlwZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkc3RDb21wcmVzc2lvblR5cGUgPSBtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXVsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHN0Q29tcHJlc3Npb25UeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvckRldGFpbHMgPSBtZXRhWydlcnJvckRldGFpbHMnXTtcbiAgICAgICAgICAgICAgICAgICAgc3JjRmlsZVNpemUgPSBtZXRhWydzcmNGaWxlU2l6ZSddLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGRzdEZpbGVTaXplID0gbWV0YVsnZHN0RmlsZVNpemUnXS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICByb3dzZXQucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhWydzcmNGaWxlTmFtZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsnZHN0RmlsZU5hbWUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0ZpbGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0RmlsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNDb21wcmVzc2lvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3RDb21wcmVzc2lvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzZXQ6IHJvd3NldCxcbiAgICAgICAgICAgICAgICByb3d0eXBlOiBbXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdzb3VyY2UnKSxcbiAgICAgICAgICAgICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ3RhcmdldCcpLFxuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfRklYRURfQ09MVU1OX0RFU0MoJ3NvdXJjZVNpemUnKSxcbiAgICAgICAgICAgICAgICAgICAgUkVTVUxUX0ZJWEVEX0NPTFVNTl9ERVNDKCd0YXJnZXRTaXplJyksXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdzb3VyY2VDb21wcmVzc2lvbicpLFxuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygndGFyZ2V0Q29tcHJlc3Npb24nKSxcbiAgICAgICAgICAgICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ3N0YXR1cycpLFxuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnbWVzc2FnZScpLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICAgICAgbGV0IGRzdEZpbGVTaXplO1xuICAgICAgICAgICAgbGV0IGVycm9yRGV0YWlscztcbiAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzID0gbWV0YVsnZXJyb3JEZXRhaWxzJ107XG4gICAgICAgICAgICAgICAgICAgIGRzdEZpbGVTaXplID0gbWV0YVsnZHN0RmlsZVNpemUnXTtcbiAgICAgICAgICAgICAgICAgICAgcm93c2V0LnB1c2goW21ldGFbJ2RzdEZpbGVOYW1lJ10sIGRzdEZpbGVTaXplLCBtZXRhWydyZXN1bHRTdGF0dXMnXSwgZXJyb3JEZXRhaWxzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzZXQ6IHJvd3NldCxcbiAgICAgICAgICAgICAgICByb3d0eXBlOiBbXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdmaWxlJyksXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9GSVhFRF9DT0xVTU5fREVTQygnc2l6ZScpLFxuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnc3RhdHVzJyksXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdtZXNzYWdlJyksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwbG9hZCBmaWxlcyBpbiB0aGUgbWV0YWRhdGEgbGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZChsYXJnZUZpbGVNZXRhcywgc21hbGxGaWxlTWV0YXMpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNsaWVudCA9IGdldFN0b3JhZ2VDbGllbnQoc3RhZ2VMb2NhdGlvblR5cGUpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBzdG9yYWdlQ2xpZW50LmNyZWF0ZUNsaWVudChzdGFnZUluZm8sIGZhbHNlKTtcbiAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIHNtYWxsRmlsZU1ldGFzKSB7XG4gICAgICAgICAgICBtZXRhWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbGFyZ2VGaWxlTWV0YXMpIHtcbiAgICAgICAgICAgIG1ldGFbJ2NsaWVudCddID0gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbWFsbEZpbGVNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvL2F3YWl0IHVwbG9hZEZpbGVzaW5QYXJhbGxlbChzbWFsbEZpbGVNZXRhcyk7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRGaWxlc2luU2VxdWVudGlhbChzbWFsbEZpbGVNZXRhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhcmdlRmlsZU1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHVwbG9hZEZpbGVzaW5TZXF1ZW50aWFsKGxhcmdlRmlsZU1ldGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHNlcXVlbnRpYWxseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlTWV0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZXNpblNlcXVlbnRpYWwoZmlsZU1ldGEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgZmlsZU1ldGFMZW4gPSBmaWxlTWV0YS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGZpbGVNZXRhTGVuKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGxvYWRPbmVGaWxlKGZpbGVNZXRhW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0WydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gcmVuZXdFeHBpcmVkQ2xpZW50KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXgyID0gaW5kZXg7IGluZGV4MiA8IGZpbGVNZXRhTGVuOyBpbmRleDIrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWxlTWV0YVtpbmRleDJdWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHRbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuUkVORVdfUFJFU0lHTkVEX1VSTCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUZpbGVNZXRhc1dpdGhQcmVzaWduZWRVcmwoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5FUlJPUikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmIChJTkpFQ1RfV0FJVF9JTl9QVVQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgSU5KRUNUX1dBSVRfSU5fUFVUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0ZW1wb3JhcnkgZGlyZWN0b3J5IGZvciB0aGUgZmlsZSB0aGVuIHVwbG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZE9uZUZpbGUobWV0YSkge1xuICAgICAgICBtZXRhWydyZWFsU3JjRmlsZVBhdGgnXSA9IG1ldGFbJ3NyY0ZpbGVQYXRoJ107XG4gICAgICAgIGNvbnN0IHRtcERpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3RtcCcpKTtcbiAgICAgICAgbWV0YVsndG1wRGlyJ10gPSB0bXBEaXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobWV0YVsncmVxdWlyZUNvbXByZXNzJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTbm93Zmxha2VGaWxlVXRpbC5jb21wcmVzc0ZpbGVXaXRoR1pJUChtZXRhWydzcmNGaWxlUGF0aCddLCBtZXRhWyd0bXBEaXInXSk7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVhbFNyY0ZpbGVQYXRoJ10gPSByZXN1bHQubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFNub3dmbGFrZUZpbGVVdGlsLmdldERpZ2VzdEFuZFNpemVGb3JGaWxlKG1ldGFbJ3JlYWxTcmNGaWxlUGF0aCddKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYTI1NkRpZ2VzdCA9IHJlc3VsdC5kaWdlc3Q7XG4gICAgICAgICAgICBjb25zdCB1cGxvYWRTaXplID0gcmVzdWx0LnNpemU7XG4gICAgICAgICAgICBtZXRhWydTSEEyNTZfRElHRVNUJ10gPSBzaGEyNTZEaWdlc3Q7XG4gICAgICAgICAgICBtZXRhWyd1cGxvYWRTaXplJ10gPSB1cGxvYWRTaXplO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUNsaWVudCA9IGdldFN0b3JhZ2VDbGllbnQobWV0YVsnc3RhZ2VMb2NhdGlvblR5cGUnXSk7XG4gICAgICAgICAgICBhd2FpdCBzdG9yYWdlQ2xpZW50LnVwbG9hZE9uZUZpbGVXaXRoUmV0cnkobWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IDA7XG4gICAgICAgICAgICBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFbJ2Vycm9yRGV0YWlscyddID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBtZXRhWydlcnJvckRldGFpbHMnXSArPSBgIGZpbGU9JHttZXRhWydzcmNGaWxlTmFtZSddfSwgcmVhbCBmaWxlPSR7bWV0YVsncmVhbFNyY0ZpbGVQYXRoJ119YDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZmlsZXMgaW5zaWRlIHRtcCBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRmlsZU5hbWVzID0gZ2V0TWF0Y2hpbmdGaWxlUGF0aHMobWV0YVsndG1wRGlyJ10sIG1ldGFbJ3NyY0ZpbGVOYW1lJ10gKyAnKicpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaGluZ0ZpbGVOYW1lIG9mIG1hdGNoaW5nRmlsZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmsobWF0Y2hpbmdGaWxlTmFtZSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSB0bXAgZm9sZGVyXG4gICAgICAgICAgICBmcy5ybWRpcihtZXRhWyd0bXBEaXInXSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBmaWxlcyBpbiB0aGUgbWV0YWRhdGEgbGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKGxhcmdlRmlsZU1ldGFzLCBzbWFsbEZpbGVNZXRhcykge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2xpZW50ID0gZ2V0U3RvcmFnZUNsaWVudChzdGFnZUxvY2F0aW9uVHlwZSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHN0b3JhZ2VDbGllbnQuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbywgZmFsc2UpO1xuICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2Ygc21hbGxGaWxlTWV0YXMpIHtcbiAgICAgICAgICAgIG1ldGFbJ2NsaWVudCddID0gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBsYXJnZUZpbGVNZXRhcykge1xuICAgICAgICAgICAgbWV0YVsnY2xpZW50J10gPSBjbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtYWxsRmlsZU1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vYXdhaXQgZG93bmxvYWRGaWxlc2luUGFyYWxsZWwoc21hbGxGaWxlTWV0YXMpO1xuICAgICAgICAgICAgYXdhaXQgZG93bmxvYWRGaWxlc2luU2VxdWVudGlhbChzbWFsbEZpbGVNZXRhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhcmdlRmlsZU1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IGRvd25sb2FkRmlsZXNpblNlcXVlbnRpYWwobGFyZ2VGaWxlTWV0YXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGEgZmlsZSBzZXF1ZW50aWFsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZU1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZXNpblNlcXVlbnRpYWwoZmlsZU1ldGEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgZmlsZU1ldGFMZW4gPSBmaWxlTWV0YS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGZpbGVNZXRhTGVuKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb3dubG9hZE9uZUZpbGUoZmlsZU1ldGFbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSByZW5ld0V4cGlyZWRDbGllbnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleDIgPSBpbmRleDsgaW5kZXgyIDwgZmlsZU1ldGFMZW47IGluZGV4MisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVNZXRhW2luZGV4Ml1bJ2NsaWVudCddID0gY2xpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdFsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlRmlsZU1ldGFzV2l0aFByZXNpZ25lZFVybCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKElOSkVDVF9XQUlUX0lOX1BVVCA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBJTkpFQ1RfV0FJVF9JTl9QVVQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhIGZpbGUgYW5kIHBsYWNlIGludG8gdGhlIHRhcmdldCBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBkb3dubG9hZE9uZUZpbGUobWV0YSkge1xuICAgICAgICBtZXRhWyd0bXBEaXInXSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAndG1wJyksIChlcnIsIGRpcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGlyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VDbGllbnQgPSBnZXRTdG9yYWdlQ2xpZW50KG1ldGFbJ3N0YWdlTG9jYXRpb25UeXBlJ10pO1xuICAgICAgICAgICAgYXdhaXQgc3RvcmFnZUNsaWVudC5kb3dubG9hZE9uZUZpbGUobWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IC0xO1xuICAgICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhWydlcnJvckRldGFpbHMnXSA9IGVyci50b1N0cmluZygpO1xuICAgICAgICAgICAgbWV0YVsnZXJyb3JEZXRhaWxzJ10gKz0gYCBmaWxlPSR7bWV0YVsnZHN0RmlsZU5hbWUnXX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0byBhY2NlbGVyYXRpb24gY29uZmlndXJhdGlvbiBmb3IgUzMgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHRyYW5zZmVyQWNjZWxlcmF0ZUNvbmZpZygpIHtcbiAgICAgICAgaWYgKHN0YWdlTG9jYXRpb25UeXBlID09PSBTM19GUykge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gcmVtb3RlU3RvcmFnZVV0aWwuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbywgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgczNsb2NhdGlvbiA9IFNub3dmbGFrZVMzVXRpbC5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGgoc3RhZ2VJbmZvWydsb2NhdGlvbiddKTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudFxuICAgICAgICAgICAgICAgIC5nZXRCdWNrZXRBY2NlbGVyYXRlQ29uZmlndXJhdGlvbih7IEJ1Y2tldDogczNsb2NhdGlvbi5idWNrZXROYW1lIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB1c2VBY2NlbGVyYXRlRW5kcG9pbnQgPSBkYXRhWydTdGF0dXMnXSA9PT0gJ0VuYWJsZWQnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJbJ2NvZGUnXSA9PT0gJ0FjY2Vzc0RlbmllZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwcmVzaWduZWQgVVJMcyBvZiBmaWxlIG1ldGFkYXRhIHdoZW4gdXNpbmcgR0NTIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUZpbGVNZXRhc1dpdGhQcmVzaWduZWRVcmwoKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDbGllbnQgPSBnZXRTdG9yYWdlQ2xpZW50KHN0YWdlTG9jYXRpb25UeXBlKTtcbiAgICAgICAgLy8gcHJlc2lnbmVkIHVybCBvbmx5IGFwcGxpZXMgdG8gcmVtb3RlIHN0b3JhZ2VcbiAgICAgICAgaWYgKHN0b3JhZ2VDbGllbnQgPT09IHJlbW90ZVN0b3JhZ2VVdGlsKSB7XG4gICAgICAgICAgICAvLyBwcmVzaWduZWQgdXJsIG9ubHkgYXBwbGllcyB0byBHQ1NcbiAgICAgICAgICAgIGlmIChzdGFnZUxvY2F0aW9uVHlwZSA9PT0gR0NTX0ZTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGhUb1JlcGxhY2UgPSBnZXRGaWxlTmFtZUZyb21QdXRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2YgZmlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZVRvUmVwbGFjZVdpdGggPSBtZXRhWydkc3RGaWxlTmFtZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmRXaXRoU2luZ2xlRmlsZSA9IGNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kV2l0aFNpbmdsZUZpbGUgPSBjb21tYW5kV2l0aFNpbmdsZUZpbGUucmVwbGFjZShmaWxlUGF0aFRvUmVwbGFjZSwgZmlsZU5hbWVUb1JlcGxhY2VXaXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHNxbFRleHQ6IGNvbW1hbmRXaXRoU2luZ2xlRmlsZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IHN0YXRlbWVudC5jcmVhdGVDb250ZXh0KG9wdGlvbnMsIGNvbnRleHQuc2VydmljZXMsIGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBzdGF0ZW1lbnQuc2VuZFJlcXVlc3QobmV3Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhWydzdGFnZUluZm8nXSA9IHJldFsnZGF0YSddWydkYXRhJ11bJ3N0YWdlSW5mbyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsncHJlc2lnbmVkVXJsJ10gPSBtZXRhWydzdGFnZUluZm8nXVsncHJlc2lnbmVkVXJsJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBmaWxlTWV0YWRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTWV0YWRhdGFbaW5kZXhdWydwcmVzaWduZWRVcmwnXSA9IHByZXNpZ25lZFVybHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvY2FsIGZpbGUgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZpbGVOYW1lRnJvbVB1dENvbW1hbmQoY29tbWFuZCkge1xuICAgICAgICAvLyBFeHRyYWN0IGZpbGUgcGF0aCBmcm9tIFBVVCBjb21tYW5kOlxuICAgICAgICAvLyBFLmcuIFwiUFVUIGZpbGU6Ly9DOjxwYXRoLXRvLWZpbGU+IEBEQi5TQ0hFTUEuJVRBQkxFO1wiXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBjb21tYW5kLmluZGV4T2YoRklMRV9QUk9UT0NPTCkgKyBGSUxFX1BST1RPQ09MLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3BhY2VJbmRleCA9IGNvbW1hbmQuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpLmluZGV4T2YoJyAnKTtcbiAgICAgICAgY29uc3QgcXVvdGVJbmRleCA9IGNvbW1hbmQuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpLmluZGV4T2YoXCInXCIpO1xuICAgICAgICBsZXQgZW5kSW5kZXggPSBzcGFjZUluZGV4O1xuICAgICAgICBpZiAocXVvdGVJbmRleCAhPT0gLTEgJiYgcXVvdGVJbmRleCA8IHNwYWNlSW5kZXgpIHtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gcXVvdGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGNvbW1hbmQuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIHN0YXJ0SW5kZXggKyBlbmRJbmRleCk7XG4gICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdG9yYWdlIGNsaWVudCBiYXNlZCBvbiBzdGFnZSBsb2NhdGlvbiB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YWdlTG9jYXRpb25UeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0b3JhZ2VDbGllbnQoc3RhZ2VMb2NhdGlvblR5cGUpIHtcbiAgICAgICAgaWYgKHN0YWdlTG9jYXRpb25UeXBlID09PSBMT0NBTF9GUykge1xuICAgICAgICAgICAgcmV0dXJuIFNub3dmbGFrZUxvY2FsVXRpbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFnZUxvY2F0aW9uVHlwZSA9PT0gUzNfRlMgfHxcbiAgICAgICAgICAgIHN0YWdlTG9jYXRpb25UeXBlID09PSBBWlVSRV9GUyB8fFxuICAgICAgICAgICAgc3RhZ2VMb2NhdGlvblR5cGUgPT09IEdDU19GUykge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JhZ2VVdGlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGNvbW1hbmQgYW5kIGdldCBsaXN0IG9mIGZpbGVzIHRvIHVwbG9hZC9kb3dubG9hZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlQ29tbWFuZCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGNvbW1hbmRUeXBlID0gZGF0YVsnY29tbWFuZCddO1xuICAgICAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gZGF0YVsnc3JjX2xvY2F0aW9ucyddWzBdO1xuICAgICAgICAgICAgLy8gR2V0IHJvb3QgZGlyZWN0b3J5IG9mIGZpbGUgcGF0aFxuICAgICAgICAgICAgbGV0IHJvb3QgPSBwYXRoLmRpcm5hbWUoc3JjKTtcbiAgICAgICAgICAgIC8vIElmIGN3ZCBleGlzdHMgYW5kIHJvb3QgaXMgcmVsYXRpdmUgLiB0aGVuIHJlcGxhY2Ugd2l0aCBjb250ZXh0J3MgY3dkXG4gICAgICAgICAgICAvLyBVc2VkIGZvciBWUyBDb2RlIGV4dGVuc2lvbiB3aGVyZSBleHRlbnNpb24gY3dkIGRpZmZlcnMgZnJvbSB1c2VyIHdvcmtzcGFjZSBkaXJcbiAgICAgICAgICAgIGlmIChjd2QgJiYgIXBhdGguaXNBYnNvbHV0ZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKGN3ZCwgc3JjKTtcbiAgICAgICAgICAgICAgICByb290ID0gcGF0aC5kaXJuYW1lKGFic29sdXRlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlyO1xuICAgICAgICAgICAgLy8gQ2hlY2sgcm9vdCBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhyb290KSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByb290IHBhdGggaXMgYSBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgICBkaXIgPSBmcy5zdGF0U3luYyhyb290KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGZpbGUgbmFtZSB0byB1cGxvYWRcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHNyYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZ1bGwgcGF0aCBuYW1lIG9mIHRoZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lRnVsbFBhdGggPSBwYXRoLmpvaW4ocm9vdCwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBmaWxlIG5hbWUgaGFzIGEgd2lsZGNhcmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKCcqJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgZmlsZSBuYW1lcyB0aGF0IG1hdGNoZXMgdGhlIHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0ZpbGVOYW1lcyA9IGdldE1hdGNoaW5nRmlsZVBhdGhzKHJvb3QsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2hpbmdGaWxlTmFtZSBvZiBtYXRjaGluZ0ZpbGVOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRFbmNyeXB0aW9uTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlSW5mbyA9IGZzLnN0YXRTeW5jKG1hdGNoaW5nRmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJGaWxlT2JqID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVOYW1lJ10gPSBwYXRoLmJhc2VuYW1lKG1hdGNoaW5nRmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlUGF0aCddID0gbWF0Y2hpbmdGaWxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVNpemUnXSA9IGZpbGVJbmZvLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNUb1B1dC5wdXNoKGN1cnJGaWxlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHdpbGRjYXJkLCBnZXQgc2luZ2xlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEVuY3J5cHRpb25NYXRlcmlhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVJbmZvID0gZnMuc3RhdFN5bmMoZmlsZU5hbWVGdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyckZpbGVPYmogPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlUGF0aCddID0gZmlsZU5hbWVGdWxsUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVNpemUnXSA9IGZpbGVJbmZvLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNUb1B1dC5wdXNoKGN1cnJGaWxlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkaXIgKyAnIGlzIG5vdCBhIGRpcmVjdG9yeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b0NvbXByZXNzID0gZGF0YVsnYXV0b0NvbXByZXNzJ107XG4gICAgICAgICAgICBzb3VyY2VDb21wcmVzc2lvbiA9IGRhdGFbJ3NvdXJjZUNvbXByZXNzaW9uJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICAgICAgICBpbml0RW5jcnlwdGlvbk1hdGVyaWFsKCk7XG4gICAgICAgICAgICBzcmNGaWxlcyA9IGRhdGFbJ3NyY19sb2NhdGlvbnMnXTtcbiAgICAgICAgICAgIGlmIChzcmNGaWxlcy5sZW5ndGggPT09IGVuY3J5cHRpb25NYXRlcmlhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlkeCBpbiBzcmNGaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBzcmNGaWxlc1RvRW5jcnlwdGlvbk1hdGVyaWFsW3NyY0ZpbGVzW2lkeF1dID0gZW5jcnlwdGlvbk1hdGVyaWFsW2lkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5jcnlwdGlvbk1hdGVyaWFsLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgZW5jcnlwdGlvbiBtYXRlcmlhbCBleGlzdHMuIFplcm8gbWVhbnMgbm8gZW5jcnlwdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBudW1iZXIgb2YgZG93bmxvYWRpbmcgZmlsZXMgZG9lc24ndCBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsTG9jYXRpb24gPSBleHBhbmRUaWxkZShkYXRhWydsb2NhbExvY2F0aW9uJ10pO1xuICAgICAgICAgICAgLy8gSWYgY3dkIGV4aXN0cyBhbmQgcm9vdCBpcyByZWxhdGl2ZSAuIHRoZW4gcmVwbGFjZSB3aXRoIGNvbnRleHQncyBjd2RcbiAgICAgICAgICAgIC8vIFVzZWQgZm9yIFZTIENvZGUgZXh0ZW5zaW9uIHdoZXJlIGV4dGVuc2lvbiBjd2QgZGlmZmVycyBmcm9tIHVzZXIgd29ya3NwYWNlIGRpclxuICAgICAgICAgICAgaWYgKGN3ZCAmJiAhcGF0aC5pc0Fic29sdXRlKGxvY2FsTG9jYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKGN3ZCwgbG9jYWxMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgbG9jYWxMb2NhdGlvbiA9IGFic29sdXRlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpciA9IGZzLnN0YXRTeW5jKGxvY2FsTG9jYXRpb24pO1xuICAgICAgICAgICAgaWYgKCFkaXIuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxvY2FsIHBhdGggaXMgbm90IGEgZGlyZWN0b3J5OiAnICsgbG9jYWxMb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyYWxsZWwgPSBkYXRhWydwYXJhbGxlbCddO1xuICAgICAgICBzdGFnZUluZm8gPSBkYXRhWydzdGFnZUluZm8nXTtcbiAgICAgICAgc3RhZ2VMb2NhdGlvblR5cGUgPSBzdGFnZUluZm9bJ2xvY2F0aW9uVHlwZSddO1xuICAgICAgICBwcmVzaWduZWRVcmxzID0gZGF0YVsncHJlc2lnbmVkVXJscyddO1xuICAgICAgICBvdmVyd3JpdGUgPSBkYXRhWydvdmVyd3JpdGUnXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZW5jcnlwdGlvbiBtYXRlcmlhbCBmb3IgZWFjaCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRFbmNyeXB0aW9uTWF0ZXJpYWwoKSB7XG4gICAgICAgIGlmIChyZXNwb25zZVsnZGF0YSddICYmIHJlc3BvbnNlWydkYXRhJ11bJ2VuY3J5cHRpb25NYXRlcmlhbCddKSB7XG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHJlc3BvbnNlWydkYXRhJ11bJ2VuY3J5cHRpb25NYXRlcmlhbCddO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgICAgICBlbmNyeXB0aW9uTWF0ZXJpYWwucHVzaChuZXcgU25vd2ZsYWtlRmlsZUVuY3J5cHRpb25NYXRlcmlhbChyb290Tm9kZVsncXVlcnlTdGFnZU1hc3RlcktleSddLCByb290Tm9kZVsncXVlcnlJZCddLCByb290Tm9kZVsnc21rSWQnXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtIGluIHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRpb25NYXRlcmlhbC5wdXNoKG5ldyBTbm93Zmxha2VGaWxlRW5jcnlwdGlvbk1hdGVyaWFsKHJvb3ROb2RlW2VsZW1dWydxdWVyeVN0YWdlTWFzdGVyS2V5J10sIHJvb3ROb2RlW2VsZW1dWydxdWVyeUlkJ10sIHJvb3ROb2RlW2VsZW1dWydzbWtJZCddKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG1ldGFkYXRhIGZvciBmaWxlcyB0byB1cGxvYWQvZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RmlsZU1ldGFkYXRhKCkge1xuICAgICAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzVG9QdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyRmlsZU9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlUGF0aCddID0gZmlsZVsnc3JjRmlsZVBhdGgnXTtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZU5hbWUnXSA9IGZpbGVbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVTaXplJ10gPSBmaWxlWydzcmNGaWxlU2l6ZSddO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzdGFnZUxvY2F0aW9uVHlwZSddID0gc3RhZ2VMb2NhdGlvblR5cGU7XG4gICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3N0YWdlSW5mbyddID0gc3RhZ2VJbmZvO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydvdmVyd3JpdGUnXSA9IG92ZXJ3cml0ZTtcbiAgICAgICAgICAgICAgICBmaWxlTWV0YWRhdGEucHVzaChjdXJyRmlsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIHNyY0ZpbGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckZpbGVPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydkc3RGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3N0YWdlTG9jYXRpb25UeXBlJ10gPSBzdGFnZUxvY2F0aW9uVHlwZTtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3RhZ2VJbmZvJ10gPSBzdGFnZUluZm87XG4gICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3VzZUFjY2VsZXJhdGVFbmRwb2ludCddID0gdXNlQWNjZWxlcmF0ZUVuZHBvaW50O1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydsb2NhbExvY2F0aW9uJ10gPSBsb2NhbExvY2F0aW9uO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSA9IHNyY0ZpbGVzVG9FbmNyeXB0aW9uTWF0ZXJpYWxbZmlsZU5hbWVdO1xuICAgICAgICAgICAgICAgIGZpbGVNZXRhZGF0YS5wdXNoKGN1cnJGaWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jcnlwdGlvbk1hdGVyaWFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBmaWxlWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSA9IGVuY3J5cHRpb25NYXRlcmlhbFtpXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb21wcmVzc2lvbiB0eXBlIG9mIHRoZSBmaWxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDb21wcmVzc2lvblR5cGUoKSB7XG4gICAgICAgIGxldCB1c2VyU3BlY2lmaWVkU291cmNlQ29tcHJlc3Npb247XG4gICAgICAgIGxldCBhdXRvRGV0ZWN0O1xuICAgICAgICBpZiAoc291cmNlQ29tcHJlc3Npb24gPT09ICdhdXRvX2RldGVjdCcpIHtcbiAgICAgICAgICAgIGF1dG9EZXRlY3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZUNvbXByZXNzaW9uID09PSB0eXBlb2YgJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGF1dG9EZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZXJTcGVjaWZpZWRTb3VyY2VDb21wcmVzc2lvbiA9IGZpbGVDb21wcmVzc2lvblR5cGUubG9va3VwQnlNaW1lU3ViVHlwZShzb3VyY2VDb21wcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAodXNlclNwZWNpZmllZFNvdXJjZUNvbXByZXNzaW9uID09PSB0eXBlb2YgJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICAhdXNlclNwZWNpZmllZFNvdXJjZUNvbXByZXNzaW9uWydpc19zdXBwb3J0ZWQnXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzb3VyY2VDb21wcmVzc2lvbiArICcgaXMgbm90IGEgc3VwcG9ydGVkIGNvbXByZXNzaW9uIHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9EZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2YgZmlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IG1ldGFbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IG1ldGFbJ3NyY0ZpbGVQYXRoJ107XG4gICAgICAgICAgICBsZXQgY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGU7XG4gICAgICAgICAgICBsZXQgZW5jb2Rpbmc7XG4gICAgICAgICAgICBpZiAoYXV0b0RldGVjdCkge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gbWltZS5sb29rdXAoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdCA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyhmaWxlUGF0aCwgJ3IrJyk7XG4gICAgICAgICAgICAgICAgICAgIGZzLnJlYWRTeW5jKGZkLCB0ZXN0LCAwLCA0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lLnN1YnN0cmluZyhmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpKSA9PT0gJy5icicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ2JyJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSkgPT09ICcuZGVmbGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ2RlZmxhdGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbGVOYW1lLnN1YnN0cmluZyhmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpKSA9PT0gJy5yYXdfZGVmbGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ3Jhd19kZWZsYXRlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChCdWZmZXIuZnJvbSh0ZXN0LnRvU3RyaW5nKCkpLnNsaWNlKDAsIDMpID09PSBCdWZmZXIuZnJvbSgnT1JDJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ29yYyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQnVmZmVyLmZyb20odGVzdC50b1N0cmluZygpKSA9PT0gQnVmZmVyLmZyb20oJ1BBUjEnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSAncGFycXVldCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGVzdC50b1N0cmluZygnaGV4JykgPT09ICcyOGZkMmZmZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lLnN1YnN0cmluZyhmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpKSA9PT0gJy56c3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICd6c3RkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGUgPSBmaWxlQ29tcHJlc3Npb25UeXBlLmxvb2t1cEJ5RW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbHNlIHt9IE5vIGZpbGUgZW5jb2RpbmcgZGV0ZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGUgJiYgIWN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlWydpc19zdXBwb3J0ZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW5jb2RpbmcgKyAnIGlzIG5vdCBhIGEgc3VwcG9ydGVkIGNvbXByZXNzaW9uIHR5cGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZUNvbXByZXNzaW9uVHlwZSA9IHVzZXJTcGVjaWZpZWRTb3VyY2VDb21wcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RmlsZUNvbXByZXNzaW9uVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmlsZUNvbXByZXNzaW9uVHlwZVsnaXNfc3VwcG9ydGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ10gPSBjdXJyZW50RmlsZUNvbXByZXNzaW9uVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVxdWlyZUNvbXByZXNzJ10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsnZHN0RmlsZU5hbWUnXSA9IG1ldGFbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW5jb2RpbmcgKyAnIGlzIG5vdCBhIGEgc3VwcG9ydGVkIGNvbXByZXNzaW9uIHR5cGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXF1aXJlQ29tcHJlc3MnXSA9IGF1dG9Db21wcmVzcztcbiAgICAgICAgICAgICAgICBtZXRhWydzcmNDb21wcmVzc2lvblR5cGUnXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gSWYgcmVxdWlyZUNvbXByZXNzIGlzIHRydWUsIGRlc3RpbmF0aW9uIGZpbGUgZXh0ZW5zaW9uIGlzIGNoYW5nZWQgdG8gemlwXG4gICAgICAgICAgICAgICAgaWYgKGF1dG9Db21wcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wcmVzcyB3aXRoIGd6aXBcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ10gPSBmaWxlQ29tcHJlc3Npb25UeXBlLmxvb2t1cEJ5TWltZVN1YlR5cGUoJ0daSVAnKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsnZHN0RmlsZU5hbWUnXSA9IG1ldGFbJ3NyY0ZpbGVOYW1lJ10gKyBtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXVsnZmlsZV9leHRlbnNpb24nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVOYW1lJ10gPSBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy9UT0RPIFNOT1ctOTkyMzg3OiBDcmVhdGUgYSBmdW5jdGlvbiB0byByZW5ldyBleHBpcmVkIGNsaWVudFxuZnVuY3Rpb24gcmVuZXdFeHBpcmVkQ2xpZW50KCkgeyB9XG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVUcmFuc2ZlckFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZV90cmFuc2Zlcl9hZ2VudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").FileHeader);\nconst getProxyAgent = (__webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\").getProxyAgent);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst { lstrip } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst GCS_METADATA_PREFIX = 'x-goog-meta-';\nconst SFC_DIGEST = 'sfc-digest';\nconst MATDESC_KEY = 'matdesc';\nconst ENCRYPTIONDATAPROP = 'encryptiondata';\nconst GCS_METADATA_SFC_DIGEST = GCS_METADATA_PREFIX + SFC_DIGEST;\nconst GCS_METADATA_MATDESC_KEY = GCS_METADATA_PREFIX + MATDESC_KEY;\nconst GCS_METADATA_ENCRYPTIONDATAPROP = GCS_METADATA_PREFIX + ENCRYPTIONDATAPROP;\nconst GCS_FILE_HEADER_DIGEST = 'gcs-file-header-digest';\nconst GCS_FILE_HEADER_CONTENT_LENGTH = 'gcs-file-header-content-length';\nconst GCS_FILE_HEADER_ENCRYPTION_METADATA = 'gcs-file-header-encryption-metadata';\nconst HTTP_HEADER_CONTENT_ENCODING = 'Content-Encoding';\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst { Storage } = __webpack_require__(/*! @google-cloud/storage */ \"(rsc)/./node_modules/@google-cloud/storage/build/cjs/src/index.js\");\nconst EXPIRED_TOKEN = 'ExpiredToken';\nconst ERRORNO_WSAECONNABORTED = 10053; // network connection was aborted\n/**\n * @typedef {object} GCSLocation\n * @property {string} bucketName\n * @property {string} path\n */\nfunction GCSLocation(bucketName, path) {\n    return {\n        bucketName: bucketName,\n        path: path,\n    };\n}\n/**\n * Creates an GCS utility object.\n * @param {module} connectionConfig\n * @param {module} httpClient\n * @param {module} fileStream\n *\n * @returns {Object}\n * @constructor\n */\nfunction GCSUtil(connectionConfig, httpClient) {\n    let axios = httpClient;\n    let isProxyEnabled = false;\n    /**\n     * Retrieve the GCS token from the stage info metadata.\n     *\n     * @param {Object} stageInfo\n     *\n     * @returns {String}\n     */\n    this.createClient = function (stageInfo) {\n        const stageCredentials = stageInfo['creds'];\n        const gcsToken = stageCredentials['GCS_ACCESS_TOKEN'];\n        //TODO: SNOW-1789759 the value is hardcoded now, but it should be server driven\n        const endPoint = this.getGCSCustomEndPoint(stageInfo);\n        let client;\n        if (gcsToken) {\n            const interceptors = [];\n            interceptors.push({\n                request: (requestConfig) => {\n                    requestConfig.headers = requestConfig.headers || {};\n                    Object.assign(requestConfig.headers, { Authorization: `Bearer ${gcsToken}` });\n                    return requestConfig;\n                },\n            });\n            const storage = Util.exists(endPoint)\n                ? new Storage({ interceptors_: interceptors, apiEndpoint: endPoint })\n                : new Storage({ interceptors_: interceptors });\n            client = { gcsToken: gcsToken, gcsClient: storage };\n        }\n        else {\n            client = null;\n        }\n        this.setupHttpClient(endPoint);\n        return client;\n    };\n    /**\n     * Extract the bucket name and path from the metadata's stage location.\n     *\n     * @param {String} stageLocation\n     *\n     * @returns {GCSLocation}\n     */\n    this.extractBucketNameAndPath = function (stageLocation) {\n        let containerName = stageLocation;\n        let path = '';\n        // split stage location as bucket name and path\n        if (stageLocation.includes('/')) {\n            containerName = stageLocation.substring(0, stageLocation.indexOf('/'));\n            path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n            if (path && !path.endsWith('/')) {\n                path += '/';\n            }\n        }\n        return GCSLocation(containerName, path);\n    };\n    /**\n     * Create file header based on file being uploaded or not.\n     *\n     * @param {Object} meta\n     * @param {String} filename\n     *\n     * @returns {Object}\n     */\n    this.getFileHeader = async function (meta, filename) {\n        if (meta['resultStatus'] === resultStatus.UPLOADED ||\n            meta['resultStatus'] === resultStatus.DOWNLOADED) {\n            return FileHeader(meta[GCS_FILE_HEADER_DIGEST], meta[GCS_FILE_HEADER_CONTENT_LENGTH], meta[GCS_FILE_HEADER_ENCRYPTION_METADATA]);\n        }\n        else {\n            if (meta['presignedUrl']) {\n                await axios.get(meta['presignedUrl']).catch((err) => {\n                    if ([401, 403, 404].includes(err.response.status)) {\n                        meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                    }\n                });\n            }\n            else {\n                const url = this.generateFileURL(meta.stageInfo, lstrip(filename, '/'));\n                const accessToken = meta['client'].gcsToken;\n                const gcsHeaders = { Authorization: `Bearer ${accessToken}` };\n                let encryptionMetadata;\n                let digest;\n                let contentLength;\n                let encryptionDataProp;\n                let matDescKey;\n                try {\n                    if (this.shouldUseJsonApi(meta)) {\n                        const gcsLocation = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n                        const metadata = await meta['client'].gcsClient\n                            .bucket(gcsLocation.bucketName)\n                            .file(gcsLocation.path + filename)\n                            .getMetadata();\n                        digest = metadata[0].metadata[SFC_DIGEST];\n                        contentLength = metadata[0].size;\n                        encryptionDataProp = metadata[0].metadata[ENCRYPTIONDATAPROP];\n                        matDescKey = metadata[0].metadata[MATDESC_KEY];\n                    }\n                    else {\n                        const response = await axios.head(url, { headers: gcsHeaders });\n                        digest = response.headers[GCS_METADATA_SFC_DIGEST];\n                        contentLength = response.headers['content-length'];\n                        encryptionDataProp = response.headers[GCS_METADATA_ENCRYPTIONDATAPROP];\n                        matDescKey = response.headers[GCS_METADATA_MATDESC_KEY];\n                    }\n                    if (encryptionDataProp) {\n                        const encryptionData = JSON.parse(encryptionDataProp);\n                        if (encryptionData) {\n                            encryptionMetadata = EncryptionMetadata(encryptionData['WrappedContentKey']['EncryptedKey'], encryptionData['ContentEncryptionIV'], matDescKey ? matDescKey : null);\n                        }\n                    }\n                    meta['resultStatus'] = resultStatus.UPLOADED;\n                    return FileHeader(digest, contentLength, encryptionMetadata);\n                }\n                catch (err) {\n                    const errCode = !isNaN(err['code']) && !isNaN(parseInt(err['code']))\n                        ? err['code']\n                        : err.response.status;\n                    if ([403, 408, 429, 500, 503].includes(errCode)) {\n                        meta['lastError'] = err;\n                        meta['resultStatus'] = resultStatus.NEED_RETRY;\n                        return;\n                    }\n                    if (errCode === 404) {\n                        meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                    }\n                    else if (errCode === 401) {\n                        meta['lastError'] = err;\n                        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                    }\n                    else {\n                        meta['lastError'] = err;\n                        meta['resultStatus'] = resultStatus.ERROR;\n                        throw err;\n                    }\n                }\n            }\n        }\n        return FileHeader(null, null, null);\n    };\n    /**\n     * Create the file metadata then upload the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     * @param {Number} maxConcurrency\n     *\n     * @returns {null}\n     */\n    this.uploadFile = async function (dataFile, meta, encryptionMetadata, maxConcurrency) {\n        const fileStream = fs.readFileSync(dataFile);\n        await this.uploadFileStream(fileStream, meta, encryptionMetadata, maxConcurrency);\n    };\n    /**\n     * Create the file metadata then upload the file stream.\n     *\n     * @param {String} fileStream\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     *\n     * @returns {null}\n     */\n    this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n        let uploadUrl = meta['presignedUrl'];\n        let accessToken = null;\n        if (!uploadUrl) {\n            const tempFilename = meta['dstFileName'].substring(meta['dstFileName'].indexOf('/') + 1, meta['dstFileName'].length);\n            uploadUrl = this.generateFileURL(meta.stageInfo, tempFilename);\n            accessToken = meta['client'].gcsToken;\n        }\n        let contentEncoding = '';\n        if (meta['dstCompressionType']) {\n            contentEncoding = meta['dstCompressionType']['name'];\n            contentEncoding = contentEncoding.toLowerCase();\n        }\n        // We set the contentEncoding to blank for the following file types\n        if (['gzip', 'bzip2', 'brotli', 'deflate', 'raw_deflate', 'zstd'].includes(contentEncoding)) {\n            contentEncoding = '';\n        }\n        const gcsHeaders = {\n            [HTTP_HEADER_CONTENT_ENCODING]: contentEncoding,\n            [GCS_METADATA_SFC_DIGEST]: meta['SHA256_DIGEST'],\n        };\n        if (accessToken) {\n            gcsHeaders['Authorization'] = `Bearer ${accessToken}`;\n        }\n        if (encryptionMetadata) {\n            gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP] = JSON.stringify({\n                EncryptionMode: 'FullBlob',\n                WrappedContentKey: {\n                    KeyId: 'symmKey1',\n                    EncryptedKey: encryptionMetadata.key,\n                    Algorithm: 'AES_CBC_256',\n                },\n                EncryptionAgent: {\n                    Protocol: '1.0',\n                    EncryptionAlgorithm: 'AES_CBC_256',\n                },\n                ContentEncryptionIV: encryptionMetadata.iv,\n                KeyWrappingMetadata: {\n                    EncryptionLibrary: 'Java 5.3.0',\n                },\n            });\n            gcsHeaders[GCS_METADATA_MATDESC_KEY] = encryptionMetadata.matDesc;\n        }\n        try {\n            if (this.shouldUseJsonApi(meta)) {\n                const gcsLocation = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n                await meta['client'].gcsClient\n                    .bucket(gcsLocation.bucketName)\n                    .file(gcsLocation.path + meta['dstFileName'])\n                    .save(fileStream, {\n                    resumable: false,\n                    metadata: {\n                        metadata: {\n                            [ENCRYPTIONDATAPROP]: gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP],\n                            [MATDESC_KEY]: gcsHeaders[GCS_METADATA_MATDESC_KEY],\n                            [SFC_DIGEST]: gcsHeaders[GCS_METADATA_SFC_DIGEST],\n                        },\n                    },\n                });\n            }\n            else {\n                // Set maxBodyLength to allow large file uploading\n                await axios.put(uploadUrl, fileStream, { maxBodyLength: Infinity, headers: gcsHeaders });\n            }\n        }\n        catch (err) {\n            if ([403, 408, 429, 500, 503].includes(err['code'])) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.NEED_RETRY;\n            }\n            else if (!accessToken &&\n                err['code'] === 400 &&\n                (!meta['lastError'] || meta['lastError']['code'] !== 400)) {\n                // Only attempt to renew urls if this isn't the second time this happens\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_PRESIGNED_URL;\n            }\n            else if (accessToken && err['code'] === 401) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            return;\n        }\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n        meta[GCS_FILE_HEADER_DIGEST] = gcsHeaders[GCS_METADATA_SFC_DIGEST];\n        meta[GCS_FILE_HEADER_CONTENT_LENGTH] = meta['uploadSize'];\n        meta[GCS_FILE_HEADER_ENCRYPTION_METADATA] = gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP];\n    };\n    /**\n     * Download the file.\n     *\n     * @param {Object} meta\n     * @param fullDstPath\n     *\n     * @returns {null}\n     */\n    this.nativeDownloadFile = async function (meta, fullDstPath) {\n        let downloadUrl = meta['presignedUrl'];\n        let accessToken = null;\n        let gcsHeaders = {};\n        if (!downloadUrl) {\n            downloadUrl = this.generateFileURL(meta.stageInfo, lstrip(meta['srcFileName'], '/'));\n            accessToken = meta['client'].gcsToken;\n            gcsHeaders = { Authorization: `Bearer ${accessToken}` };\n        }\n        let encryptionDataprop;\n        let matDescKey;\n        let sfcDigest;\n        let size;\n        try {\n            if (this.shouldUseJsonApi(meta)) {\n                const { bucketName, path } = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n                Logger().debug(`Use GCP client to download the file.`);\n                Logger().debug(`Send Get Request to the Bucket: ${bucketName}, GET request: ${path}`);\n                await meta['client'].gcsClient\n                    .bucket(bucketName)\n                    .file(path + meta['srcFileName'])\n                    .download({\n                    destination: fullDstPath,\n                });\n                const metadata = await meta['client'].gcsClient\n                    .bucket(bucketName)\n                    .file(path + meta['srcFileName'])\n                    .getMetadata();\n                encryptionDataprop = metadata[0].metadata[ENCRYPTIONDATAPROP];\n                matDescKey = metadata[0].metadata[MATDESC_KEY];\n                sfcDigest = metadata[0].metadata[SFC_DIGEST];\n                size = metadata[0].size;\n            }\n            else {\n                Logger().debug(`Downloading file from GCS using Axios`);\n                let response;\n                await axios\n                    .get(downloadUrl, {\n                    headers: gcsHeaders,\n                    responseType: 'stream',\n                })\n                    .then(async (res) => {\n                    response = res;\n                    await new Promise((resolve, reject) => {\n                        const writer = fs.createWriteStream(fullDstPath);\n                        response.data.pipe(writer);\n                        writer.on('error', (err) => {\n                            writer.close();\n                            reject(err);\n                        });\n                        writer.on('close', () => {\n                            resolve();\n                        });\n                    });\n                });\n                Logger().debug(`Sent Get Request to ${downloadUrl}, destination: ${fullDstPath}, http status: ${response.status}`);\n                encryptionDataprop = response.headers[GCS_METADATA_ENCRYPTIONDATAPROP];\n                matDescKey = response.headers[GCS_METADATA_MATDESC_KEY];\n                sfcDigest = response.headers[GCS_METADATA_SFC_DIGEST];\n                size = response.headers['content-length'];\n            }\n        }\n        catch (err) {\n            if (err['code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            else {\n                meta['lastError'] = err;\n                if (err['code'] === ERRORNO_WSAECONNABORTED) {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n                }\n                else {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY;\n                }\n            }\n            return;\n        }\n        let encryptionData;\n        if (encryptionDataprop) {\n            encryptionData = JSON.parse(encryptionDataprop);\n        }\n        let encryptionMetadata;\n        if (encryptionData) {\n            encryptionMetadata = EncryptionMetadata(encryptionData['WrappedContentKey']['EncryptedKey'], encryptionData['ContentEncryptionIV'], matDescKey);\n        }\n        const fileInfo = fs.statSync(fullDstPath);\n        meta['srcFileSize'] = fileInfo.size;\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n        meta[GCS_FILE_HEADER_DIGEST] = sfcDigest;\n        meta[GCS_FILE_HEADER_CONTENT_LENGTH] = size;\n        meta[GCS_FILE_HEADER_ENCRYPTION_METADATA] = encryptionMetadata;\n    };\n    /**\n     * Generate file URL based on bucket.\n     *\n     * @param {Object} stageInfo\n     * @param {String} filename\n     *\n     * @returns {String}\n     */\n    this.generateFileURL = function (stageInfo, filename) {\n        const gcsLocation = this.extractBucketNameAndPath(stageInfo.location);\n        const fullFilePath = `${gcsLocation.path}${filename}`;\n        const endPoint = this.getGCSCustomEndPoint(stageInfo);\n        let link;\n        if (stageInfo['useVirtualUrl']) {\n            link = `${endPoint}/${fullFilePath}`;\n        }\n        else {\n            link = `${endPoint != null ? endPoint : 'https://storage.googleapis.com'}/${gcsLocation.bucketName}/${fullFilePath}`;\n        }\n        return link.startsWith('https://') ? link : `https://${link}`;\n    };\n    this.getGCSCustomEndPoint = function (stageInfo) {\n        //TODO: SNOW-1789759 hardcoded region will be replaced in the future\n        const isRegionalUrlEnabled = stageInfo.region.toLowerCase() === 'me-central2' || stageInfo.useRegionalUrl;\n        let endPoint = null;\n        if (stageInfo['endPoint']) {\n            endPoint = stageInfo['endPoint'];\n        }\n        else if (stageInfo['useVirtualUrl']) {\n            const bucket = this.extractBucketNameAndPath(stageInfo.location).bucketName;\n            endPoint = `https://${bucket}.storage.googleapis.com`;\n        }\n        else if (isRegionalUrlEnabled) {\n            endPoint = `storage.${stageInfo.region.toLowerCase()}.rep.googleapis.com`;\n        }\n        return endPoint;\n    };\n    this.setupHttpClient = function (endPoint) {\n        if (typeof httpClient === 'undefined') {\n            const proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'GCS Util');\n            //When http_proxy is enabled, the driver should use Axios for HTTPS requests to avoid relying on HTTP_PROXY in GCS.\n            if (proxy || Util.getEnvVar('http_proxy')) {\n                isProxyEnabled = true;\n                const proxyAgent = getProxyAgent({\n                    proxyOptions: proxy,\n                    connectionConfig,\n                    parsedUrl: new URL(connectionConfig.accessUrl),\n                    destination: endPoint || 'storage.googleapis.com',\n                });\n                axios = (__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\").create)({\n                    proxy: false,\n                    httpAgent: proxyAgent,\n                    httpsAgent: proxyAgent,\n                });\n            }\n            else {\n                axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n            }\n        }\n    };\n    this.shouldUseJsonApi = function (meta) {\n        const accessToken = meta['client'].gcsToken;\n        const useVirtualUrl = meta['stageInfo']['useVirtualUrl'];\n        return (!!accessToken &&\n            process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL !== 'true' &&\n            !isProxyEnabled &&\n            !useVirtualUrl);\n    };\n}\nmodule.exports = GCSUtil;\n//# sourceMappingURL=gcs_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2djc191dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsMkJBQTJCLGlKQUE0QztBQUN2RSxtQkFBbUIsZ0hBQWtDO0FBQ3JELHNCQUFzQixtSEFBcUM7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDekMsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsb0VBQVM7QUFDcEMsZUFBZSwwR0FBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrSEFBb0M7QUFDekQsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDbkQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx5QkFBeUIsU0FBUyxHQUFHO0FBQ2hHO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxvREFBb0Q7QUFDcEYsZ0NBQWdDLDZCQUE2QjtBQUM3RCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlCQUF5QixZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxxQkFBcUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw4Q0FBOEM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCLFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0Esa0VBQWtFLFdBQVcsaUJBQWlCLEtBQUs7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixzREFBc0QsWUFBWSxpQkFBaUIsWUFBWSxpQkFBaUIsZ0JBQWdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQixFQUFFLFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVMsR0FBRyxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQStELEdBQUcsdUJBQXVCLEdBQUcsYUFBYTtBQUMvSDtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix3QkFBd0IsMkZBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsNkRBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9nY3NfdXRpbC5qcz83YmRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgRW5jcnlwdGlvbk1ldGFkYXRhID0gcmVxdWlyZSgnLi9lbmNyeXB0X3V0aWwnKS5FbmNyeXB0aW9uTWV0YWRhdGE7XG5jb25zdCBGaWxlSGVhZGVyID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykuRmlsZUhlYWRlcjtcbmNvbnN0IGdldFByb3h5QWdlbnQgPSByZXF1aXJlKCcuLi9odHRwL25vZGUnKS5nZXRQcm94eUFnZW50O1xuY29uc3QgUHJveHlVdGlsID0gcmVxdWlyZSgnLi4vcHJveHlfdXRpbCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IHsgbHN0cmlwIH0gPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKS5kZWZhdWx0O1xuY29uc3QgR0NTX01FVEFEQVRBX1BSRUZJWCA9ICd4LWdvb2ctbWV0YS0nO1xuY29uc3QgU0ZDX0RJR0VTVCA9ICdzZmMtZGlnZXN0JztcbmNvbnN0IE1BVERFU0NfS0VZID0gJ21hdGRlc2MnO1xuY29uc3QgRU5DUllQVElPTkRBVEFQUk9QID0gJ2VuY3J5cHRpb25kYXRhJztcbmNvbnN0IEdDU19NRVRBREFUQV9TRkNfRElHRVNUID0gR0NTX01FVEFEQVRBX1BSRUZJWCArIFNGQ19ESUdFU1Q7XG5jb25zdCBHQ1NfTUVUQURBVEFfTUFUREVTQ19LRVkgPSBHQ1NfTUVUQURBVEFfUFJFRklYICsgTUFUREVTQ19LRVk7XG5jb25zdCBHQ1NfTUVUQURBVEFfRU5DUllQVElPTkRBVEFQUk9QID0gR0NTX01FVEFEQVRBX1BSRUZJWCArIEVOQ1JZUFRJT05EQVRBUFJPUDtcbmNvbnN0IEdDU19GSUxFX0hFQURFUl9ESUdFU1QgPSAnZ2NzLWZpbGUtaGVhZGVyLWRpZ2VzdCc7XG5jb25zdCBHQ1NfRklMRV9IRUFERVJfQ09OVEVOVF9MRU5HVEggPSAnZ2NzLWZpbGUtaGVhZGVyLWNvbnRlbnQtbGVuZ3RoJztcbmNvbnN0IEdDU19GSUxFX0hFQURFUl9FTkNSWVBUSU9OX01FVEFEQVRBID0gJ2djcy1maWxlLWhlYWRlci1lbmNyeXB0aW9uLW1ldGFkYXRhJztcbmNvbnN0IEhUVFBfSEVBREVSX0NPTlRFTlRfRU5DT0RJTkcgPSAnQ29udGVudC1FbmNvZGluZyc7XG5jb25zdCByZXN1bHRTdGF0dXMgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5yZXN1bHRTdGF0dXM7XG5jb25zdCB7IFN0b3JhZ2UgfSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvc3RvcmFnZScpO1xuY29uc3QgRVhQSVJFRF9UT0tFTiA9ICdFeHBpcmVkVG9rZW4nO1xuY29uc3QgRVJST1JOT19XU0FFQ09OTkFCT1JURUQgPSAxMDA1MzsgLy8gbmV0d29yayBjb25uZWN0aW9uIHdhcyBhYm9ydGVkXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEdDU0xvY2F0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYnVja2V0TmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gR0NTTG9jYXRpb24oYnVja2V0TmFtZSwgcGF0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ1Y2tldE5hbWU6IGJ1Y2tldE5hbWUsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBHQ1MgdXRpbGl0eSBvYmplY3QuXG4gKiBAcGFyYW0ge21vZHVsZX0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHttb2R1bGV9IGh0dHBDbGllbnRcbiAqIEBwYXJhbSB7bW9kdWxlfSBmaWxlU3RyZWFtXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBHQ1NVdGlsKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpIHtcbiAgICBsZXQgYXhpb3MgPSBodHRwQ2xpZW50O1xuICAgIGxldCBpc1Byb3h5RW5hYmxlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBHQ1MgdG9rZW4gZnJvbSB0aGUgc3RhZ2UgaW5mbyBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFnZUluZm9cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAoc3RhZ2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlQ3JlZGVudGlhbHMgPSBzdGFnZUluZm9bJ2NyZWRzJ107XG4gICAgICAgIGNvbnN0IGdjc1Rva2VuID0gc3RhZ2VDcmVkZW50aWFsc1snR0NTX0FDQ0VTU19UT0tFTiddO1xuICAgICAgICAvL1RPRE86IFNOT1ctMTc4OTc1OSB0aGUgdmFsdWUgaXMgaGFyZGNvZGVkIG5vdywgYnV0IGl0IHNob3VsZCBiZSBzZXJ2ZXIgZHJpdmVuXG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gdGhpcy5nZXRHQ1NDdXN0b21FbmRQb2ludChzdGFnZUluZm8pO1xuICAgICAgICBsZXQgY2xpZW50O1xuICAgICAgICBpZiAoZ2NzVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IFtdO1xuICAgICAgICAgICAgaW50ZXJjZXB0b3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IChyZXF1ZXN0Q29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RDb25maWcuaGVhZGVycyA9IHJlcXVlc3RDb25maWcuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXF1ZXN0Q29uZmlnLmhlYWRlcnMsIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2djc1Rva2VufWAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0Q29uZmlnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2UgPSBVdGlsLmV4aXN0cyhlbmRQb2ludClcbiAgICAgICAgICAgICAgICA/IG5ldyBTdG9yYWdlKHsgaW50ZXJjZXB0b3JzXzogaW50ZXJjZXB0b3JzLCBhcGlFbmRwb2ludDogZW5kUG9pbnQgfSlcbiAgICAgICAgICAgICAgICA6IG5ldyBTdG9yYWdlKHsgaW50ZXJjZXB0b3JzXzogaW50ZXJjZXB0b3JzIH0pO1xuICAgICAgICAgICAgY2xpZW50ID0geyBnY3NUb2tlbjogZ2NzVG9rZW4sIGdjc0NsaWVudDogc3RvcmFnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldHVwSHR0cENsaWVudChlbmRQb2ludCk7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBidWNrZXQgbmFtZSBhbmQgcGF0aCBmcm9tIHRoZSBtZXRhZGF0YSdzIHN0YWdlIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YWdlTG9jYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtHQ1NMb2NhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aCA9IGZ1bmN0aW9uIChzdGFnZUxvY2F0aW9uKSB7XG4gICAgICAgIGxldCBjb250YWluZXJOYW1lID0gc3RhZ2VMb2NhdGlvbjtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgLy8gc3BsaXQgc3RhZ2UgbG9jYXRpb24gYXMgYnVja2V0IG5hbWUgYW5kIHBhdGhcbiAgICAgICAgaWYgKHN0YWdlTG9jYXRpb24uaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICAgICAgY29udGFpbmVyTmFtZSA9IHN0YWdlTG9jYXRpb24uc3Vic3RyaW5nKDAsIHN0YWdlTG9jYXRpb24uaW5kZXhPZignLycpKTtcbiAgICAgICAgICAgIHBhdGggPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZyhzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSArIDEsIHN0YWdlTG9jYXRpb24ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChwYXRoICYmICFwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR0NTTG9jYXRpb24oY29udGFpbmVyTmFtZSwgcGF0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZmlsZSBoZWFkZXIgYmFzZWQgb24gZmlsZSBiZWluZyB1cGxvYWRlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldEZpbGVIZWFkZXIgPSBhc3luYyBmdW5jdGlvbiAobWV0YSwgZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQgfHxcbiAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuRE9XTkxPQURFRCkge1xuICAgICAgICAgICAgcmV0dXJuIEZpbGVIZWFkZXIobWV0YVtHQ1NfRklMRV9IRUFERVJfRElHRVNUXSwgbWV0YVtHQ1NfRklMRV9IRUFERVJfQ09OVEVOVF9MRU5HVEhdLCBtZXRhW0dDU19GSUxFX0hFQURFUl9FTkNSWVBUSU9OX01FVEFEQVRBXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWV0YVsncHJlc2lnbmVkVXJsJ10pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBheGlvcy5nZXQobWV0YVsncHJlc2lnbmVkVXJsJ10pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFs0MDEsIDQwMywgNDA0XS5pbmNsdWRlcyhlcnIucmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTk9UX0ZPVU5EX0ZJTEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2VuZXJhdGVGaWxlVVJMKG1ldGEuc3RhZ2VJbmZvLCBsc3RyaXAoZmlsZW5hbWUsICcvJykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gbWV0YVsnY2xpZW50J10uZ2NzVG9rZW47XG4gICAgICAgICAgICAgICAgY29uc3QgZ2NzSGVhZGVycyA9IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAgfTtcbiAgICAgICAgICAgICAgICBsZXQgZW5jcnlwdGlvbk1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGxldCBkaWdlc3Q7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGVuY3J5cHRpb25EYXRhUHJvcDtcbiAgICAgICAgICAgICAgICBsZXQgbWF0RGVzY0tleTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRVc2VKc29uQXBpKG1ldGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnY3NMb2NhdGlvbiA9IHRoaXMuZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YVsnY2xpZW50J10uZ2NzQ2xpZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmJ1Y2tldChnY3NMb2NhdGlvbi5idWNrZXROYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWxlKGdjc0xvY2F0aW9uLnBhdGggKyBmaWxlbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2VzdCA9IG1ldGFkYXRhWzBdLm1ldGFkYXRhW1NGQ19ESUdFU1RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IG1ldGFkYXRhWzBdLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0aW9uRGF0YVByb3AgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtFTkNSWVBUSU9OREFUQVBST1BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0RGVzY0tleSA9IG1ldGFkYXRhWzBdLm1ldGFkYXRhW01BVERFU0NfS0VZXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuaGVhZCh1cmwsIHsgaGVhZGVyczogZ2NzSGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2VzdCA9IHJlc3BvbnNlLmhlYWRlcnNbR0NTX01FVEFEQVRBX1NGQ19ESUdFU1RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0aW9uRGF0YVByb3AgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9FTkNSWVBUSU9OREFUQVBST1BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0RGVzY0tleSA9IHJlc3BvbnNlLmhlYWRlcnNbR0NTX01FVEFEQVRBX01BVERFU0NfS0VZXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5jcnlwdGlvbkRhdGFQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNyeXB0aW9uRGF0YSA9IEpTT04ucGFyc2UoZW5jcnlwdGlvbkRhdGFQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmNyeXB0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YSA9IEVuY3J5cHRpb25NZXRhZGF0YShlbmNyeXB0aW9uRGF0YVsnV3JhcHBlZENvbnRlbnRLZXknXVsnRW5jcnlwdGVkS2V5J10sIGVuY3J5cHRpb25EYXRhWydDb250ZW50RW5jcnlwdGlvbklWJ10sIG1hdERlc2NLZXkgPyBtYXREZXNjS2V5IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWxlSGVhZGVyKGRpZ2VzdCwgY29udGVudExlbmd0aCwgZW5jcnlwdGlvbk1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJDb2RlID0gIWlzTmFOKGVyclsnY29kZSddKSAmJiAhaXNOYU4ocGFyc2VJbnQoZXJyWydjb2RlJ10pKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJbJ2NvZGUnXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnIucmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoWzQwMywgNDA4LCA0MjksIDUwMCwgNTAzXS5pbmNsdWRlcyhlcnJDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyckNvZGUgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZpbGVIZWFkZXIobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGZpbGUgbWV0YWRhdGEgdGhlbiB1cGxvYWQgdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4Q29uY3VycmVuY3lcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhRmlsZSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhLCBtYXhDb25jdXJyZW5jeSkge1xuICAgICAgICBjb25zdCBmaWxlU3RyZWFtID0gZnMucmVhZEZpbGVTeW5jKGRhdGFGaWxlKTtcbiAgICAgICAgYXdhaXQgdGhpcy51cGxvYWRGaWxlU3RyZWFtKGZpbGVTdHJlYW0sIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSwgbWF4Q29uY3VycmVuY3kpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBmaWxlIG1ldGFkYXRhIHRoZW4gdXBsb2FkIHRoZSBmaWxlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlU3RyZWFtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5jcnlwdGlvbk1ldGFkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZEZpbGVTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiAoZmlsZVN0cmVhbSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgIGxldCB1cGxvYWRVcmwgPSBtZXRhWydwcmVzaWduZWRVcmwnXTtcbiAgICAgICAgbGV0IGFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgaWYgKCF1cGxvYWRVcmwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBGaWxlbmFtZSA9IG1ldGFbJ2RzdEZpbGVOYW1lJ10uc3Vic3RyaW5nKG1ldGFbJ2RzdEZpbGVOYW1lJ10uaW5kZXhPZignLycpICsgMSwgbWV0YVsnZHN0RmlsZU5hbWUnXS5sZW5ndGgpO1xuICAgICAgICAgICAgdXBsb2FkVXJsID0gdGhpcy5nZW5lcmF0ZUZpbGVVUkwobWV0YS5zdGFnZUluZm8sIHRlbXBGaWxlbmFtZSk7XG4gICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IG1ldGFbJ2NsaWVudCddLmdjc1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50RW5jb2RpbmcgPSAnJztcbiAgICAgICAgaWYgKG1ldGFbJ2RzdENvbXByZXNzaW9uVHlwZSddKSB7XG4gICAgICAgICAgICBjb250ZW50RW5jb2RpbmcgPSBtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXVsnbmFtZSddO1xuICAgICAgICAgICAgY29udGVudEVuY29kaW5nID0gY29udGVudEVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugc2V0IHRoZSBjb250ZW50RW5jb2RpbmcgdG8gYmxhbmsgZm9yIHRoZSBmb2xsb3dpbmcgZmlsZSB0eXBlc1xuICAgICAgICBpZiAoWydnemlwJywgJ2J6aXAyJywgJ2Jyb3RsaScsICdkZWZsYXRlJywgJ3Jhd19kZWZsYXRlJywgJ3pzdGQnXS5pbmNsdWRlcyhjb250ZW50RW5jb2RpbmcpKSB7XG4gICAgICAgICAgICBjb250ZW50RW5jb2RpbmcgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnY3NIZWFkZXJzID0ge1xuICAgICAgICAgICAgW0hUVFBfSEVBREVSX0NPTlRFTlRfRU5DT0RJTkddOiBjb250ZW50RW5jb2RpbmcsXG4gICAgICAgICAgICBbR0NTX01FVEFEQVRBX1NGQ19ESUdFU1RdOiBtZXRhWydTSEEyNTZfRElHRVNUJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgZ2NzSGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke2FjY2Vzc1Rva2VufWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgZ2NzSGVhZGVyc1tHQ1NfTUVUQURBVEFfRU5DUllQVElPTkRBVEFQUk9QXSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBFbmNyeXB0aW9uTW9kZTogJ0Z1bGxCbG9iJyxcbiAgICAgICAgICAgICAgICBXcmFwcGVkQ29udGVudEtleToge1xuICAgICAgICAgICAgICAgICAgICBLZXlJZDogJ3N5bW1LZXkxJyxcbiAgICAgICAgICAgICAgICAgICAgRW5jcnlwdGVkS2V5OiBlbmNyeXB0aW9uTWV0YWRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgICBBbGdvcml0aG06ICdBRVNfQ0JDXzI1NicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBFbmNyeXB0aW9uQWdlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgUHJvdG9jb2w6ICcxLjAnLFxuICAgICAgICAgICAgICAgICAgICBFbmNyeXB0aW9uQWxnb3JpdGhtOiAnQUVTX0NCQ18yNTYnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQ29udGVudEVuY3J5cHRpb25JVjogZW5jcnlwdGlvbk1ldGFkYXRhLml2LFxuICAgICAgICAgICAgICAgIEtleVdyYXBwaW5nTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgRW5jcnlwdGlvbkxpYnJhcnk6ICdKYXZhIDUuMy4wJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnY3NIZWFkZXJzW0dDU19NRVRBREFUQV9NQVRERVNDX0tFWV0gPSBlbmNyeXB0aW9uTWV0YWRhdGEubWF0RGVzYztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlSnNvbkFwaShtZXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdjc0xvY2F0aW9uID0gdGhpcy5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGgobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pO1xuICAgICAgICAgICAgICAgIGF3YWl0IG1ldGFbJ2NsaWVudCddLmdjc0NsaWVudFxuICAgICAgICAgICAgICAgICAgICAuYnVja2V0KGdjc0xvY2F0aW9uLmJ1Y2tldE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5maWxlKGdjc0xvY2F0aW9uLnBhdGggKyBtZXRhWydkc3RGaWxlTmFtZSddKVxuICAgICAgICAgICAgICAgICAgICAuc2F2ZShmaWxlU3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtFTkNSWVBUSU9OREFUQVBST1BdOiBnY3NIZWFkZXJzW0dDU19NRVRBREFUQV9FTkNSWVBUSU9OREFUQVBST1BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNQVRERVNDX0tFWV06IGdjc0hlYWRlcnNbR0NTX01FVEFEQVRBX01BVERFU0NfS0VZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbU0ZDX0RJR0VTVF06IGdjc0hlYWRlcnNbR0NTX01FVEFEQVRBX1NGQ19ESUdFU1RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNldCBtYXhCb2R5TGVuZ3RoIHRvIGFsbG93IGxhcmdlIGZpbGUgdXBsb2FkaW5nXG4gICAgICAgICAgICAgICAgYXdhaXQgYXhpb3MucHV0KHVwbG9hZFVybCwgZmlsZVN0cmVhbSwgeyBtYXhCb2R5TGVuZ3RoOiBJbmZpbml0eSwgaGVhZGVyczogZ2NzSGVhZGVycyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoWzQwMywgNDA4LCA0MjksIDUwMCwgNTAzXS5pbmNsdWRlcyhlcnJbJ2NvZGUnXSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWFjY2Vzc1Rva2VuICYmXG4gICAgICAgICAgICAgICAgZXJyWydjb2RlJ10gPT09IDQwMCAmJlxuICAgICAgICAgICAgICAgICghbWV0YVsnbGFzdEVycm9yJ10gfHwgbWV0YVsnbGFzdEVycm9yJ11bJ2NvZGUnXSAhPT0gNDAwKSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXR0ZW1wdCB0byByZW5ldyB1cmxzIGlmIHRoaXMgaXNuJ3QgdGhlIHNlY29uZCB0aW1lIHRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1BSRVNJR05FRF9VUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2Nlc3NUb2tlbiAmJiBlcnJbJ2NvZGUnXSA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IG1ldGFbJ3VwbG9hZFNpemUnXTtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gICAgICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0RJR0VTVF0gPSBnY3NIZWFkZXJzW0dDU19NRVRBREFUQV9TRkNfRElHRVNUXTtcbiAgICAgICAgbWV0YVtHQ1NfRklMRV9IRUFERVJfQ09OVEVOVF9MRU5HVEhdID0gbWV0YVsndXBsb2FkU2l6ZSddO1xuICAgICAgICBtZXRhW0dDU19GSUxFX0hFQURFUl9FTkNSWVBUSU9OX01FVEFEQVRBXSA9IGdjc0hlYWRlcnNbR0NTX01FVEFEQVRBX0VOQ1JZUFRJT05EQVRBUFJPUF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCB0aGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIGZ1bGxEc3RQYXRoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5hdGl2ZURvd25sb2FkRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhLCBmdWxsRHN0UGF0aCkge1xuICAgICAgICBsZXQgZG93bmxvYWRVcmwgPSBtZXRhWydwcmVzaWduZWRVcmwnXTtcbiAgICAgICAgbGV0IGFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgbGV0IGdjc0hlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKCFkb3dubG9hZFVybCkge1xuICAgICAgICAgICAgZG93bmxvYWRVcmwgPSB0aGlzLmdlbmVyYXRlRmlsZVVSTChtZXRhLnN0YWdlSW5mbywgbHN0cmlwKG1ldGFbJ3NyY0ZpbGVOYW1lJ10sICcvJykpO1xuICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBtZXRhWydjbGllbnQnXS5nY3NUb2tlbjtcbiAgICAgICAgICAgIGdjc0hlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuY3J5cHRpb25EYXRhcHJvcDtcbiAgICAgICAgbGV0IG1hdERlc2NLZXk7XG4gICAgICAgIGxldCBzZmNEaWdlc3Q7XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlSnNvbkFwaShtZXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYnVja2V0TmFtZSwgcGF0aCB9ID0gdGhpcy5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGgobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pO1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBVc2UgR0NQIGNsaWVudCB0byBkb3dubG9hZCB0aGUgZmlsZS5gKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgU2VuZCBHZXQgUmVxdWVzdCB0byB0aGUgQnVja2V0OiAke2J1Y2tldE5hbWV9LCBHRVQgcmVxdWVzdDogJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIGF3YWl0IG1ldGFbJ2NsaWVudCddLmdjc0NsaWVudFxuICAgICAgICAgICAgICAgICAgICAuYnVja2V0KGJ1Y2tldE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5maWxlKHBhdGggKyBtZXRhWydzcmNGaWxlTmFtZSddKVxuICAgICAgICAgICAgICAgICAgICAuZG93bmxvYWQoe1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogZnVsbERzdFBhdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhWydjbGllbnQnXS5nY3NDbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLmJ1Y2tldChidWNrZXROYW1lKVxuICAgICAgICAgICAgICAgICAgICAuZmlsZShwYXRoICsgbWV0YVsnc3JjRmlsZU5hbWUnXSlcbiAgICAgICAgICAgICAgICAgICAgLmdldE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgZW5jcnlwdGlvbkRhdGFwcm9wID0gbWV0YWRhdGFbMF0ubWV0YWRhdGFbRU5DUllQVElPTkRBVEFQUk9QXTtcbiAgICAgICAgICAgICAgICBtYXREZXNjS2V5ID0gbWV0YWRhdGFbMF0ubWV0YWRhdGFbTUFUREVTQ19LRVldO1xuICAgICAgICAgICAgICAgIHNmY0RpZ2VzdCA9IG1ldGFkYXRhWzBdLm1ldGFkYXRhW1NGQ19ESUdFU1RdO1xuICAgICAgICAgICAgICAgIHNpemUgPSBtZXRhZGF0YVswXS5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYERvd25sb2FkaW5nIGZpbGUgZnJvbSBHQ1MgdXNpbmcgQXhpb3NgKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgYXdhaXQgYXhpb3NcbiAgICAgICAgICAgICAgICAgICAgLmdldChkb3dubG9hZFVybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBnY3NIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICdzdHJlYW0nLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZ1bGxEc3RQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEucGlwZSh3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVyLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVyLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFNlbnQgR2V0IFJlcXVlc3QgdG8gJHtkb3dubG9hZFVybH0sIGRlc3RpbmF0aW9uOiAke2Z1bGxEc3RQYXRofSwgaHR0cCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIGVuY3J5cHRpb25EYXRhcHJvcCA9IHJlc3BvbnNlLmhlYWRlcnNbR0NTX01FVEFEQVRBX0VOQ1JZUFRJT05EQVRBUFJPUF07XG4gICAgICAgICAgICAgICAgbWF0RGVzY0tleSA9IHJlc3BvbnNlLmhlYWRlcnNbR0NTX01FVEFEQVRBX01BVERFU0NfS0VZXTtcbiAgICAgICAgICAgICAgICBzZmNEaWdlc3QgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9TRkNfRElHRVNUXTtcbiAgICAgICAgICAgICAgICBzaXplID0gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyWydjb2RlJ10gPT09IEVYUElSRURfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgIGlmIChlcnJbJ2NvZGUnXSA9PT0gRVJST1JOT19XU0FFQ09OTkFCT1JURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuY3J5cHRpb25EYXRhO1xuICAgICAgICBpZiAoZW5jcnlwdGlvbkRhdGFwcm9wKSB7XG4gICAgICAgICAgICBlbmNyeXB0aW9uRGF0YSA9IEpTT04ucGFyc2UoZW5jcnlwdGlvbkRhdGFwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5jcnlwdGlvbk1ldGFkYXRhO1xuICAgICAgICBpZiAoZW5jcnlwdGlvbkRhdGEpIHtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YSA9IEVuY3J5cHRpb25NZXRhZGF0YShlbmNyeXB0aW9uRGF0YVsnV3JhcHBlZENvbnRlbnRLZXknXVsnRW5jcnlwdGVkS2V5J10sIGVuY3J5cHRpb25EYXRhWydDb250ZW50RW5jcnlwdGlvbklWJ10sIG1hdERlc2NLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gZnMuc3RhdFN5bmMoZnVsbERzdFBhdGgpO1xuICAgICAgICBtZXRhWydzcmNGaWxlU2l6ZSddID0gZmlsZUluZm8uc2l6ZTtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRE9XTkxPQURFRDtcbiAgICAgICAgbWV0YVtHQ1NfRklMRV9IRUFERVJfRElHRVNUXSA9IHNmY0RpZ2VzdDtcbiAgICAgICAgbWV0YVtHQ1NfRklMRV9IRUFERVJfQ09OVEVOVF9MRU5HVEhdID0gc2l6ZTtcbiAgICAgICAgbWV0YVtHQ1NfRklMRV9IRUFERVJfRU5DUllQVElPTl9NRVRBREFUQV0gPSBlbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBmaWxlIFVSTCBiYXNlZCBvbiBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhZ2VJbmZvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2VuZXJhdGVGaWxlVVJMID0gZnVuY3Rpb24gKHN0YWdlSW5mbywgZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgZ2NzTG9jYXRpb24gPSB0aGlzLmV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChzdGFnZUluZm8ubG9jYXRpb24pO1xuICAgICAgICBjb25zdCBmdWxsRmlsZVBhdGggPSBgJHtnY3NMb2NhdGlvbi5wYXRofSR7ZmlsZW5hbWV9YDtcbiAgICAgICAgY29uc3QgZW5kUG9pbnQgPSB0aGlzLmdldEdDU0N1c3RvbUVuZFBvaW50KHN0YWdlSW5mbyk7XG4gICAgICAgIGxldCBsaW5rO1xuICAgICAgICBpZiAoc3RhZ2VJbmZvWyd1c2VWaXJ0dWFsVXJsJ10pIHtcbiAgICAgICAgICAgIGxpbmsgPSBgJHtlbmRQb2ludH0vJHtmdWxsRmlsZVBhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmsgPSBgJHtlbmRQb2ludCAhPSBudWxsID8gZW5kUG9pbnQgOiAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tJ30vJHtnY3NMb2NhdGlvbi5idWNrZXROYW1lfS8ke2Z1bGxGaWxlUGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5rLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgPyBsaW5rIDogYGh0dHBzOi8vJHtsaW5rfWA7XG4gICAgfTtcbiAgICB0aGlzLmdldEdDU0N1c3RvbUVuZFBvaW50ID0gZnVuY3Rpb24gKHN0YWdlSW5mbykge1xuICAgICAgICAvL1RPRE86IFNOT1ctMTc4OTc1OSBoYXJkY29kZWQgcmVnaW9uIHdpbGwgYmUgcmVwbGFjZWQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBjb25zdCBpc1JlZ2lvbmFsVXJsRW5hYmxlZCA9IHN0YWdlSW5mby5yZWdpb24udG9Mb3dlckNhc2UoKSA9PT0gJ21lLWNlbnRyYWwyJyB8fCBzdGFnZUluZm8udXNlUmVnaW9uYWxVcmw7XG4gICAgICAgIGxldCBlbmRQb2ludCA9IG51bGw7XG4gICAgICAgIGlmIChzdGFnZUluZm9bJ2VuZFBvaW50J10pIHtcbiAgICAgICAgICAgIGVuZFBvaW50ID0gc3RhZ2VJbmZvWydlbmRQb2ludCddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YWdlSW5mb1sndXNlVmlydHVhbFVybCddKSB7XG4gICAgICAgICAgICBjb25zdCBidWNrZXQgPSB0aGlzLmV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChzdGFnZUluZm8ubG9jYXRpb24pLmJ1Y2tldE5hbWU7XG4gICAgICAgICAgICBlbmRQb2ludCA9IGBodHRwczovLyR7YnVja2V0fS5zdG9yYWdlLmdvb2dsZWFwaXMuY29tYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ2lvbmFsVXJsRW5hYmxlZCkge1xuICAgICAgICAgICAgZW5kUG9pbnQgPSBgc3RvcmFnZS4ke3N0YWdlSW5mby5yZWdpb24udG9Mb3dlckNhc2UoKX0ucmVwLmdvb2dsZWFwaXMuY29tYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kUG9pbnQ7XG4gICAgfTtcbiAgICB0aGlzLnNldHVwSHR0cENsaWVudCA9IGZ1bmN0aW9uIChlbmRQb2ludCkge1xuICAgICAgICBpZiAodHlwZW9mIGh0dHBDbGllbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBwcm94eSA9IFByb3h5VXRpbC5nZXRQcm94eShjb25uZWN0aW9uQ29uZmlnLmdldFByb3h5KCksICdHQ1MgVXRpbCcpO1xuICAgICAgICAgICAgLy9XaGVuIGh0dHBfcHJveHkgaXMgZW5hYmxlZCwgdGhlIGRyaXZlciBzaG91bGQgdXNlIEF4aW9zIGZvciBIVFRQUyByZXF1ZXN0cyB0byBhdm9pZCByZWx5aW5nIG9uIEhUVFBfUFJPWFkgaW4gR0NTLlxuICAgICAgICAgICAgaWYgKHByb3h5IHx8IFV0aWwuZ2V0RW52VmFyKCdodHRwX3Byb3h5JykpIHtcbiAgICAgICAgICAgICAgICBpc1Byb3h5RW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHlBZ2VudCA9IGdldFByb3h5QWdlbnQoe1xuICAgICAgICAgICAgICAgICAgICBwcm94eU9wdGlvbnM6IHByb3h5LFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRVcmw6IG5ldyBVUkwoY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwpLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogZW5kUG9pbnQgfHwgJ3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBwcm94eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBBZ2VudDogcHJveHlBZ2VudCxcbiAgICAgICAgICAgICAgICAgICAgaHR0cHNBZ2VudDogcHJveHlBZ2VudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zaG91bGRVc2VKc29uQXBpID0gZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBtZXRhWydjbGllbnQnXS5nY3NUb2tlbjtcbiAgICAgICAgY29uc3QgdXNlVmlydHVhbFVybCA9IG1ldGFbJ3N0YWdlSW5mbyddWyd1c2VWaXJ0dWFsVXJsJ107XG4gICAgICAgIHJldHVybiAoISFhY2Nlc3NUb2tlbiAmJlxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuU05PV0ZMQUtFX0ZPUkNFX0dDUF9VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMICE9PSAndHJ1ZScgJiZcbiAgICAgICAgICAgICFpc1Byb3h5RW5hYmxlZCAmJlxuICAgICAgICAgICAgIXVzZVZpcnR1YWxVcmwpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IEdDU1V0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nY3NfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\n/**\n * Creates a local utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction LocalUtil() {\n    this.createClient = function () {\n        return null;\n    };\n    /**\n     * Write file to upload.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFileWithRetry = async function (meta) {\n        await new Promise(function (resolve) {\n            // Create stream object for reader and writer\n            const reader = fs.createReadStream(meta['realSrcFilePath']);\n            // Create directory if doesn't exist\n            if (!fs.existsSync(meta['stageInfo']['location'])) {\n                fs.mkdirSync(meta['stageInfo']['location'], { recursive: true });\n            }\n            let output = path.join(meta['stageInfo']['location'], meta['dstFileName']);\n            // expand '~' and '~user' expressions\n            if (process.platform !== 'win32') {\n                output = expandTilde(output);\n            }\n            const writer = fs.createWriteStream(output);\n            // Write file\n            const result = reader.pipe(writer);\n            result.on('finish', function () {\n                resolve();\n            });\n        });\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n    };\n    /**\n     * Write file to download.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.downloadOneFile = async function (meta) {\n        let output;\n        await new Promise(function (resolve) {\n            const srcFilePath = expandTilde(meta['stageInfo']['location']);\n            // Create stream object for reader and writer\n            const realSrcFilePath = path.join(srcFilePath, meta['srcFileName']);\n            const reader = fs.createReadStream(realSrcFilePath);\n            // Create directory if doesn't exist\n            if (!fs.existsSync(meta['localLocation'])) {\n                fs.mkdirSync(meta['localLocation'], { recursive: true });\n            }\n            output = path.join(meta['localLocation'], meta['dstFileName']);\n            const writer = fs.createWriteStream(output);\n            // Write file\n            const result = reader.pipe(writer);\n            result.on('finish', function () {\n                resolve();\n            });\n        });\n        const fileStat = fs.statSync(output);\n        meta['dstFileSize'] = fileStat.size;\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n    };\n}\nexports.LocalUtil = LocalUtil;\n//# sourceMappingURL=local_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2xvY2FsX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsZ0VBQWM7QUFDMUMscUJBQXFCLGtIQUFvQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2xvY2FsX3V0aWwuanM/YTFiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBleHBhbmRUaWxkZSA9IHJlcXVpcmUoJ2V4cGFuZC10aWxkZScpO1xuY29uc3QgcmVzdWx0U3RhdHVzID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykucmVzdWx0U3RhdHVzO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9jYWwgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb2NhbFV0aWwoKSB7XG4gICAgdGhpcy5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGUgZmlsZSB0byB1cGxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGxvYWRPbmVGaWxlV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gb2JqZWN0IGZvciByZWFkZXIgYW5kIHdyaXRlclxuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gZnMuY3JlYXRlUmVhZFN0cmVhbShtZXRhWydyZWFsU3JjRmlsZVBhdGgnXSk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgZGlyZWN0b3J5IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhtZXRhWydzdGFnZUluZm8nXVsnbG9jYXRpb24nXSkpIHtcbiAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10sIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG91dHB1dCA9IHBhdGguam9pbihtZXRhWydzdGFnZUluZm8nXVsnbG9jYXRpb24nXSwgbWV0YVsnZHN0RmlsZU5hbWUnXSk7XG4gICAgICAgICAgICAvLyBleHBhbmQgJ34nIGFuZCAnfnVzZXInIGV4cHJlc3Npb25zXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGV4cGFuZFRpbGRlKG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvdXRwdXQpO1xuICAgICAgICAgICAgLy8gV3JpdGUgZmlsZVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGVyLnBpcGUod3JpdGVyKTtcbiAgICAgICAgICAgIHJlc3VsdC5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IG1ldGFbJ3VwbG9hZFNpemUnXTtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBmaWxlIHRvIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZG93bmxvYWRPbmVGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyY0ZpbGVQYXRoID0gZXhwYW5kVGlsZGUobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbSBvYmplY3QgZm9yIHJlYWRlciBhbmQgd3JpdGVyXG4gICAgICAgICAgICBjb25zdCByZWFsU3JjRmlsZVBhdGggPSBwYXRoLmpvaW4oc3JjRmlsZVBhdGgsIG1ldGFbJ3NyY0ZpbGVOYW1lJ10pO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gZnMuY3JlYXRlUmVhZFN0cmVhbShyZWFsU3JjRmlsZVBhdGgpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGRpcmVjdG9yeSBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobWV0YVsnbG9jYWxMb2NhdGlvbiddKSkge1xuICAgICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhtZXRhWydsb2NhbExvY2F0aW9uJ10sIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0ID0gcGF0aC5qb2luKG1ldGFbJ2xvY2FsTG9jYXRpb24nXSwgbWV0YVsnZHN0RmlsZU5hbWUnXSk7XG4gICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvdXRwdXQpO1xuICAgICAgICAgICAgLy8gV3JpdGUgZmlsZVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGVyLnBpcGUod3JpdGVyKTtcbiAgICAgICAgICAgIHJlc3VsdC5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSBmcy5zdGF0U3luYyhvdXRwdXQpO1xuICAgICAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gZmlsZVN0YXQuc2l6ZTtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRE9XTkxPQURFRDtcbiAgICB9O1xufVxuZXhwb3J0cy5Mb2NhbFV0aWwgPSBMb2NhbFV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbF91dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst SnowflakeS3Util = (__webpack_require__(/*! ./s3_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js\").S3Util);\nconst SnowflakeAzureUtil = __webpack_require__(/*! ./azure_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js\");\nconst SnowflakeGCSUtil = __webpack_require__(/*! ./gcs_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\nconst SnowflakeEncryptionUtil = new ((__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptUtil))();\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst DEFAULT_CONCURRENCY = 1;\nconst DEFAULT_MAX_RETRY = 5;\n// File Encryption Material\nfunction SnowflakeFileEncryptionMaterial(key, qid, smkid) {\n    const smkidString = '' + smkid;\n    return {\n        queryStageMasterKey: key, // query stage master key\n        queryId: qid, // query id\n        smkId: smkidString, // SMK id\n    };\n}\nexports.SnowflakeFileEncryptionMaterial = SnowflakeFileEncryptionMaterial;\n/**\n * Creates a remote storage utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction RemoteStorageUtil(connectionConfig) {\n    let client = null;\n    /**\n     * Get storage type based on location type.\n     *\n     * @param {String} type\n     *\n     * @returns {Object}\n     */\n    this.getForStorageType = function (type) {\n        if (client) {\n            return client;\n        }\n        if (type === 'S3') {\n            client = new SnowflakeS3Util(connectionConfig);\n        }\n        else if (type === 'AZURE') {\n            client = new SnowflakeAzureUtil(connectionConfig);\n        }\n        else if (type === 'GCS') {\n            client = new SnowflakeGCSUtil(connectionConfig);\n        }\n        return client;\n    };\n    /**\n     * Create the client based on the location type.\n     */\n    this.createClient = function (stageInfo, useAccelerateEndpoint = false) {\n        const utilClass = this.getForStorageType(stageInfo['locationType']);\n        return utilClass.createClient(stageInfo, useAccelerateEndpoint);\n    };\n    /**\n     * Encrypt then upload one file stream.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFileStream = async function (meta) {\n        let encryptionMetadata;\n        let dataFileStream = meta['fileStream'];\n        if (meta['encryptionMaterial']) {\n            const result = await SnowflakeEncryptionUtil.encryptFileStream(meta['encryptionMaterial'], meta['fileStream']);\n            encryptionMetadata = result.encryptionMetadata;\n            dataFileStream = result.dataStream;\n        }\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let maxConcurrency = meta['parallel'];\n        let lastErr;\n        const maxRetry = DEFAULT_MAX_RETRY;\n        for (let retry = 0; retry < maxRetry; retry++) {\n            if (!meta['overwrite']) {\n                const fileHeader = await utilClass.getFileHeader(meta, meta['dstFileName']);\n                if (fileHeader && meta['resultStatus'] === resultStatus.UPLOADED) {\n                    // File already exists\n                    meta['dstFileSize'] = 0;\n                    meta['resultStatus'] = resultStatus.SKIPPED;\n                    return;\n                }\n            }\n            if (meta['overwrite'] || meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n                await utilClass.uploadFileStream(dataFileStream, meta, encryptionMetadata, maxConcurrency);\n            }\n            if (meta['resultStatus'] === resultStatus.UPLOADED) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying with max concurrency\n                maxConcurrency = meta['parallel'] - parseInt((retry * meta['parallel']) / maxRetry);\n                maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n                meta['lastMaxConcurrency'] = maxConcurrency;\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n        }\n        if (lastErr) {\n            throw new Error(lastErr);\n        }\n        else {\n            const msg = 'Unknown Error in uploading a file: ' + meta['srcFileName'];\n            throw new Error(msg);\n        }\n    };\n    /**\n     * Encrypt then upload one file.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFile = async function (meta) {\n        let encryptionMetadata;\n        let dataFile;\n        if (meta['encryptionMaterial']) {\n            const result = await SnowflakeEncryptionUtil.encryptFile(meta['encryptionMaterial'], meta['realSrcFilePath'], meta['tmpDir']);\n            encryptionMetadata = result.encryptionMetadata;\n            dataFile = result.dataFile;\n        }\n        else {\n            dataFile = meta['realSrcFilePath'];\n        }\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let maxConcurrency = meta['parallel'];\n        let lastErr;\n        const maxRetry = DEFAULT_MAX_RETRY;\n        for (let retry = 0; retry < maxRetry; retry++) {\n            if (!meta['overwrite']) {\n                const fileHeader = await utilClass.getFileHeader(meta, meta['dstFileName']);\n                if (fileHeader && meta['resultStatus'] === resultStatus.UPLOADED) {\n                    // File already exists\n                    meta['dstFileSize'] = 0;\n                    meta['resultStatus'] = resultStatus.SKIPPED;\n                    return;\n                }\n            }\n            if (meta['overwrite'] || meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n                await utilClass.uploadFile(dataFile, meta, encryptionMetadata, maxConcurrency);\n            }\n            if (meta['resultStatus'] === resultStatus.UPLOADED) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying with max concurrency\n                maxConcurrency = meta['parallel'] - parseInt((retry * meta['parallel']) / maxRetry);\n                maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n                meta['lastMaxConcurrency'] = maxConcurrency;\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n        }\n        if (lastErr) {\n            throw new Error(lastErr);\n        }\n        else {\n            const msg = 'Unknown Error in uploading a file: ' + dataFile;\n            throw new Error(msg);\n        }\n    };\n    /**\n     * Attempt upload of a file and retry if fails.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFileWithRetry = async function (meta) {\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let breakFlag = false;\n        for (let x = 0; x < 10; x++) {\n            await this.uploadOneFile(meta);\n            if (meta['resultStatus'] === resultStatus.UPLOADED) {\n                for (let y = 0; y < 10; y++) {\n                    await utilClass.getFileHeader(meta, meta['dstFileName']);\n                    if (meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n                        // Wait 1 second\n                        await new Promise((resolve) => setTimeout(resolve, 1000));\n                        continue;\n                    }\n                    break;\n                }\n            }\n            breakFlag = true;\n            break;\n        }\n        if (!breakFlag) {\n            // Could not upload a file even after retry\n            meta['resultStatus'] = resultStatus.ERROR;\n        }\n    };\n    /**\n     * Download a file.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.downloadOneFile = async function (meta) {\n        // Downloads a file from S3\n        let fullDstPath = meta['localLocation'];\n        await new Promise((resolve, reject) => {\n            fs.realpath(fullDstPath, (err, basePath) => {\n                if (err) {\n                    reject(err);\n                }\n                fullDstPath = path.join(basePath, path.basename(meta['dstFileName']));\n                resolve();\n            });\n        });\n        // TODO: validate fullDstPath is under the writable directory\n        const baseDir = path.dirname(fullDstPath);\n        await new Promise((resolve) => {\n            fs.exists(baseDir, (exists) => {\n                if (!exists) {\n                    fs.mkdir(baseDir, () => {\n                        resolve();\n                    });\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let fileHeader = await utilClass.getFileHeader(meta, meta['srcFileName']);\n        if (fileHeader) {\n            meta['srcFileSize'] = fileHeader.contentLength;\n        }\n        let maxConcurrency = meta['parallel'];\n        let lastErr;\n        const maxRetry = DEFAULT_MAX_RETRY;\n        Logger().debug(`Started downloading result. File: ${meta.dstFileName}, location: ${meta.stageInfo.location}`);\n        const timer = new ExecutionTimer().start();\n        for (let retry = 0; retry < maxRetry; retry++) {\n            // Download the file\n            await utilClass.nativeDownloadFile(meta, fullDstPath, maxConcurrency);\n            if (meta['resultStatus'] === resultStatus.DOWNLOADED) {\n                timer.stop();\n                Logger().debug(`Successfully downloaded result. File: ${meta.dstFileName}, download time: ${timer.getDuration()} ms, chunkSize: ${meta.srcFileSize} bytes.`);\n                if (meta['encryptionMaterial']) {\n                    /**\n                     * For storage utils that do not have the privilege of\n                     * getting the metadata early, both object and metadata\n                     * are downloaded at once.In which case, the file meta will\n                     * be updated with all the metadata that we need and\n                     * then we can call getFileHeader to get just that and also\n                     * preserve the idea of getting metadata in the first place.\n                     * One example of this is the utils that use presigned url\n                     * for upload / download and not the storage client library.\n                     **/\n                    if (meta['presignedUrl']) {\n                        fileHeader = await utilClass.getFileHeader(meta, meta['srcFilePath']);\n                    }\n                    Logger().debug(`Start decrypting the downloaded file for ${meta.dstFileName} at path: ${fullDstPath}.`);\n                    timer.start();\n                    const tmpDstName = await SnowflakeEncryptionUtil.decryptFile(fileHeader.encryptionMetadata, meta['encryptionMaterial'], fullDstPath, meta['tmpDir']);\n                    timer.stop();\n                    Logger().debug(`Successfully decrypted the downloaded file for ${meta.dstFileName} in ${timer.getDuration()} ms.`);\n                    // Copy decrypted tmp file to target destination path\n                    await new Promise((resolve, reject) => {\n                        fs.copyFile(tmpDstName, fullDstPath, async (err) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            resolve();\n                        });\n                    });\n                    // Delete tmp file\n                    await new Promise((resolve, reject) => {\n                        fs.unlink(tmpDstName, (err) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            resolve();\n                        });\n                    });\n                    // Delete tmp folder\n                    await new Promise((resolve, reject) => {\n                        fs.rmdir(meta['tmpDir'], (err) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            resolve();\n                        });\n                    });\n                }\n                await new Promise((resolve) => {\n                    fs.stat(fullDstPath, (err, stat) => {\n                        meta['dstFileSize'] = stat.size;\n                        Logger().debug(`File size verification: Downloaded file at \"${meta.fullDstPath}\" is ${stat.size} bytes.`);\n                        resolve();\n                    });\n                });\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                Logger().debug(`Need to renew token for downloading file: ${meta.dstFileName}`);\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                Logger().debug(`Need to renew presigned URL for downloading. file: ${meta.dstFileName}, presignedUrl: ${meta.presignedUrl}`);\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n                Logger().debug(`Need to retry with lower concurrency for downloading file: ${meta.dstFileName}`);\n                lastErr = meta['lastError'];\n                // Failed to download file, retrying with max concurrency\n                maxConcurrency = meta['parallel'] - parseInt((retry * meta['parallel']) / maxRetry);\n                maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n                meta['lastMaxConcurrency'] = maxConcurrency;\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n                Logger().debug(`Need to retry for downloading file: ${meta.dstFileName}`);\n                lastErr = meta['lastError'];\n                // Failed to download file, retrying\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n        }\n        if (lastErr) {\n            Logger().error(`Failed to downloading file: ${meta.dstFileName} with error: ${lastErr}`);\n            throw new Error(lastErr);\n        }\n        else {\n            const msg = 'Unknown Error in downloading a file: ' + meta['srcFileName'];\n            throw new Error(msg);\n        }\n    };\n}\nexports.RemoteStorageUtil = RemoteStorageUtil;\n//# sourceMappingURL=remote_storage_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L3JlbW90ZV9zdG9yYWdlX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isd0JBQXdCLDJIQUEyQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyxtR0FBYztBQUNqRCx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBWTtBQUM3Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDMUQscUNBQXFDLDBJQUFxQztBQUMxRSxxQkFBcUIsa0hBQW9DO0FBQ3pELGVBQWUsMEdBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQixjQUFjLHdCQUF3QjtBQUNuSDtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCLG1CQUFtQixxQkFBcUIsaUJBQWlCLGtCQUFrQjtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGtCQUFrQixXQUFXLFlBQVk7QUFDeEg7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGtCQUFrQixLQUFLLHFCQUFxQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixpQkFBaUIsT0FBTyxXQUFXO0FBQ3pIO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsaUJBQWlCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixpQkFBaUIsa0JBQWtCLGtCQUFrQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsaUJBQWlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0IsY0FBYyxRQUFRO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvcmVtb3RlX3N0b3JhZ2VfdXRpbC5qcz9lNDU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IFNub3dmbGFrZVMzVXRpbCA9IHJlcXVpcmUoJy4vczNfdXRpbCcpLlMzVXRpbDtcbmNvbnN0IFNub3dmbGFrZUF6dXJlVXRpbCA9IHJlcXVpcmUoJy4vYXp1cmVfdXRpbCcpO1xuY29uc3QgU25vd2ZsYWtlR0NTVXRpbCA9IHJlcXVpcmUoJy4vZ2NzX3V0aWwnKTtcbmNvbnN0IEV4ZWN1dGlvblRpbWVyID0gcmVxdWlyZSgnLi4vbG9nZ2VyL2V4ZWN1dGlvbl90aW1lcicpO1xuY29uc3QgU25vd2ZsYWtlRW5jcnlwdGlvblV0aWwgPSBuZXcgKHJlcXVpcmUoJy4vZW5jcnlwdF91dGlsJykuRW5jcnlwdFV0aWwpKCk7XG5jb25zdCByZXN1bHRTdGF0dXMgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5yZXN1bHRTdGF0dXM7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKS5kZWZhdWx0O1xuY29uc3QgREVGQVVMVF9DT05DVVJSRU5DWSA9IDE7XG5jb25zdCBERUZBVUxUX01BWF9SRVRSWSA9IDU7XG4vLyBGaWxlIEVuY3J5cHRpb24gTWF0ZXJpYWxcbmZ1bmN0aW9uIFNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWwoa2V5LCBxaWQsIHNta2lkKSB7XG4gICAgY29uc3Qgc21raWRTdHJpbmcgPSAnJyArIHNta2lkO1xuICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5U3RhZ2VNYXN0ZXJLZXk6IGtleSwgLy8gcXVlcnkgc3RhZ2UgbWFzdGVyIGtleVxuICAgICAgICBxdWVyeUlkOiBxaWQsIC8vIHF1ZXJ5IGlkXG4gICAgICAgIHNta0lkOiBzbWtpZFN0cmluZywgLy8gU01LIGlkXG4gICAgfTtcbn1cbmV4cG9ydHMuU25vd2ZsYWtlRmlsZUVuY3J5cHRpb25NYXRlcmlhbCA9IFNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWw7XG4vKipcbiAqIENyZWF0ZXMgYSByZW1vdGUgc3RvcmFnZSB1dGlsaXR5IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlbW90ZVN0b3JhZ2VVdGlsKGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICBsZXQgY2xpZW50ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBHZXQgc3RvcmFnZSB0eXBlIGJhc2VkIG9uIGxvY2F0aW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldEZvclN0b3JhZ2VUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ1MzJykge1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IFNub3dmbGFrZVMzVXRpbChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnQVpVUkUnKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgU25vd2ZsYWtlQXp1cmVVdGlsKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdHQ1MnKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgU25vd2ZsYWtlR0NTVXRpbChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBjbGllbnQgYmFzZWQgb24gdGhlIGxvY2F0aW9uIHR5cGUuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAoc3RhZ2VJbmZvLCB1c2VBY2NlbGVyYXRlRW5kcG9pbnQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB1dGlsQ2xhc3MgPSB0aGlzLmdldEZvclN0b3JhZ2VUeXBlKHN0YWdlSW5mb1snbG9jYXRpb25UeXBlJ10pO1xuICAgICAgICByZXR1cm4gdXRpbENsYXNzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8sIHVzZUFjY2VsZXJhdGVFbmRwb2ludCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IHRoZW4gdXBsb2FkIG9uZSBmaWxlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZE9uZUZpbGVTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiAobWV0YSkge1xuICAgICAgICBsZXQgZW5jcnlwdGlvbk1ldGFkYXRhO1xuICAgICAgICBsZXQgZGF0YUZpbGVTdHJlYW0gPSBtZXRhWydmaWxlU3RyZWFtJ107XG4gICAgICAgIGlmIChtZXRhWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU25vd2ZsYWtlRW5jcnlwdGlvblV0aWwuZW5jcnlwdEZpbGVTdHJlYW0obWV0YVsnZW5jcnlwdGlvbk1hdGVyaWFsJ10sIG1ldGFbJ2ZpbGVTdHJlYW0nXSk7XG4gICAgICAgICAgICBlbmNyeXB0aW9uTWV0YWRhdGEgPSByZXN1bHQuZW5jcnlwdGlvbk1ldGFkYXRhO1xuICAgICAgICAgICAgZGF0YUZpbGVTdHJlYW0gPSByZXN1bHQuZGF0YVN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1dGlsQ2xhc3MgPSB0aGlzLmdldEZvclN0b3JhZ2VUeXBlKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvblR5cGUnXSk7XG4gICAgICAgIGxldCBtYXhDb25jdXJyZW5jeSA9IG1ldGFbJ3BhcmFsbGVsJ107XG4gICAgICAgIGxldCBsYXN0RXJyO1xuICAgICAgICBjb25zdCBtYXhSZXRyeSA9IERFRkFVTFRfTUFYX1JFVFJZO1xuICAgICAgICBmb3IgKGxldCByZXRyeSA9IDA7IHJldHJ5IDwgbWF4UmV0cnk7IHJldHJ5KyspIHtcbiAgICAgICAgICAgIGlmICghbWV0YVsnb3ZlcndyaXRlJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlSGVhZGVyID0gYXdhaXQgdXRpbENsYXNzLmdldEZpbGVIZWFkZXIobWV0YSwgbWV0YVsnZHN0RmlsZU5hbWUnXSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVIZWFkZXIgJiYgbWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5VUExPQURFRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSAwO1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5TS0lQUEVEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFbJ292ZXJ3cml0ZSddIHx8IG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTk9UX0ZPVU5EX0ZJTEUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB1dGlsQ2xhc3MudXBsb2FkRmlsZVN0cmVhbShkYXRhRmlsZVN0cmVhbSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5VUExPQURFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1BSRVNJR05FRF9VUkwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUlkpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gbWV0YVsnbGFzdEVycm9yJ107XG4gICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIHVwbG9hZCBmaWxlLCByZXRyeWluZ1xuICAgICAgICAgICAgICAgIGlmICghbWV0YVsnbm9TbGVlcGluZ1RpbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1kpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gbWV0YVsnbGFzdEVycm9yJ107XG4gICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIHVwbG9hZCBmaWxlLCByZXRyeWluZyB3aXRoIG1heCBjb25jdXJyZW5jeVxuICAgICAgICAgICAgICAgIG1heENvbmN1cnJlbmN5ID0gbWV0YVsncGFyYWxsZWwnXSAtIHBhcnNlSW50KChyZXRyeSAqIG1ldGFbJ3BhcmFsbGVsJ10pIC8gbWF4UmV0cnkpO1xuICAgICAgICAgICAgICAgIG1heENvbmN1cnJlbmN5ID0gTWF0aC5tYXgoREVGQVVMVF9DT05DVVJSRU5DWSwgbWF4Q29uY3VycmVuY3kpO1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RNYXhDb25jdXJyZW5jeSddID0gbWF4Q29uY3VycmVuY3k7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRhWydub1NsZWVwaW5nVGltZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsZWVwaW5nVGltZSA9IE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5KSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBzbGVlcGluZ1RpbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RFcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsYXN0RXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdVbmtub3duIEVycm9yIGluIHVwbG9hZGluZyBhIGZpbGU6ICcgKyBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgdGhlbiB1cGxvYWQgb25lIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGxvYWRPbmVGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICAgICAgbGV0IGRhdGFGaWxlO1xuICAgICAgICBpZiAobWV0YVsnZW5jcnlwdGlvbk1hdGVyaWFsJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFNub3dmbGFrZUVuY3J5cHRpb25VdGlsLmVuY3J5cHRGaWxlKG1ldGFbJ2VuY3J5cHRpb25NYXRlcmlhbCddLCBtZXRhWydyZWFsU3JjRmlsZVBhdGgnXSwgbWV0YVsndG1wRGlyJ10pO1xuICAgICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhID0gcmVzdWx0LmVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICAgICAgICAgIGRhdGFGaWxlID0gcmVzdWx0LmRhdGFGaWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YUZpbGUgPSBtZXRhWydyZWFsU3JjRmlsZVBhdGgnXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1dGlsQ2xhc3MgPSB0aGlzLmdldEZvclN0b3JhZ2VUeXBlKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvblR5cGUnXSk7XG4gICAgICAgIGxldCBtYXhDb25jdXJyZW5jeSA9IG1ldGFbJ3BhcmFsbGVsJ107XG4gICAgICAgIGxldCBsYXN0RXJyO1xuICAgICAgICBjb25zdCBtYXhSZXRyeSA9IERFRkFVTFRfTUFYX1JFVFJZO1xuICAgICAgICBmb3IgKGxldCByZXRyeSA9IDA7IHJldHJ5IDwgbWF4UmV0cnk7IHJldHJ5KyspIHtcbiAgICAgICAgICAgIGlmICghbWV0YVsnb3ZlcndyaXRlJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlSGVhZGVyID0gYXdhaXQgdXRpbENsYXNzLmdldEZpbGVIZWFkZXIobWV0YSwgbWV0YVsnZHN0RmlsZU5hbWUnXSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVIZWFkZXIgJiYgbWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5VUExPQURFRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSAwO1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5TS0lQUEVEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFbJ292ZXJ3cml0ZSddIHx8IG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTk9UX0ZPVU5EX0ZJTEUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB1dGlsQ2xhc3MudXBsb2FkRmlsZShkYXRhRmlsZSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5VUExPQURFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1BSRVNJR05FRF9VUkwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUlkpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gbWV0YVsnbGFzdEVycm9yJ107XG4gICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIHVwbG9hZCBmaWxlLCByZXRyeWluZ1xuICAgICAgICAgICAgICAgIGlmICghbWV0YVsnbm9TbGVlcGluZ1RpbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1kpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gbWV0YVsnbGFzdEVycm9yJ107XG4gICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIHVwbG9hZCBmaWxlLCByZXRyeWluZyB3aXRoIG1heCBjb25jdXJyZW5jeVxuICAgICAgICAgICAgICAgIG1heENvbmN1cnJlbmN5ID0gbWV0YVsncGFyYWxsZWwnXSAtIHBhcnNlSW50KChyZXRyeSAqIG1ldGFbJ3BhcmFsbGVsJ10pIC8gbWF4UmV0cnkpO1xuICAgICAgICAgICAgICAgIG1heENvbmN1cnJlbmN5ID0gTWF0aC5tYXgoREVGQVVMVF9DT05DVVJSRU5DWSwgbWF4Q29uY3VycmVuY3kpO1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RNYXhDb25jdXJyZW5jeSddID0gbWF4Q29uY3VycmVuY3k7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRhWydub1NsZWVwaW5nVGltZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsZWVwaW5nVGltZSA9IE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5KSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBzbGVlcGluZ1RpbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RFcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsYXN0RXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdVbmtub3duIEVycm9yIGluIHVwbG9hZGluZyBhIGZpbGU6ICcgKyBkYXRhRmlsZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHVwbG9hZCBvZiBhIGZpbGUgYW5kIHJldHJ5IGlmIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkT25lRmlsZVdpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgIGNvbnN0IHV0aWxDbGFzcyA9IHRoaXMuZ2V0Rm9yU3RvcmFnZVR5cGUobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uVHlwZSddKTtcbiAgICAgICAgbGV0IGJyZWFrRmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXBsb2FkT25lRmlsZShtZXRhKTtcbiAgICAgICAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlVQTE9BREVEKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCAxMDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHV0aWxDbGFzcy5nZXRGaWxlSGVhZGVyKG1ldGEsIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5OT1RfRk9VTkRfRklMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCAxIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnJlYWtGbGFnKSB7XG4gICAgICAgICAgICAvLyBDb3VsZCBub3QgdXBsb2FkIGEgZmlsZSBldmVuIGFmdGVyIHJldHJ5XG4gICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5FUlJPUjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgYSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZG93bmxvYWRPbmVGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgLy8gRG93bmxvYWRzIGEgZmlsZSBmcm9tIFMzXG4gICAgICAgIGxldCBmdWxsRHN0UGF0aCA9IG1ldGFbJ2xvY2FsTG9jYXRpb24nXTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnMucmVhbHBhdGgoZnVsbERzdFBhdGgsIChlcnIsIGJhc2VQYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVsbERzdFBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsIHBhdGguYmFzZW5hbWUobWV0YVsnZHN0RmlsZU5hbWUnXSkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgZnVsbERzdFBhdGggaXMgdW5kZXIgdGhlIHdyaXRhYmxlIGRpcmVjdG9yeVxuICAgICAgICBjb25zdCBiYXNlRGlyID0gcGF0aC5kaXJuYW1lKGZ1bGxEc3RQYXRoKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGZzLmV4aXN0cyhiYXNlRGlyLCAoZXhpc3RzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMubWtkaXIoYmFzZURpciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHV0aWxDbGFzcyA9IHRoaXMuZ2V0Rm9yU3RvcmFnZVR5cGUobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uVHlwZSddKTtcbiAgICAgICAgbGV0IGZpbGVIZWFkZXIgPSBhd2FpdCB1dGlsQ2xhc3MuZ2V0RmlsZUhlYWRlcihtZXRhLCBtZXRhWydzcmNGaWxlTmFtZSddKTtcbiAgICAgICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgICAgICAgIG1ldGFbJ3NyY0ZpbGVTaXplJ10gPSBmaWxlSGVhZGVyLmNvbnRlbnRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1heENvbmN1cnJlbmN5ID0gbWV0YVsncGFyYWxsZWwnXTtcbiAgICAgICAgbGV0IGxhc3RFcnI7XG4gICAgICAgIGNvbnN0IG1heFJldHJ5ID0gREVGQVVMVF9NQVhfUkVUUlk7XG4gICAgICAgIExvZ2dlcigpLmRlYnVnKGBTdGFydGVkIGRvd25sb2FkaW5nIHJlc3VsdC4gRmlsZTogJHttZXRhLmRzdEZpbGVOYW1lfSwgbG9jYXRpb246ICR7bWV0YS5zdGFnZUluZm8ubG9jYXRpb259YCk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gbmV3IEV4ZWN1dGlvblRpbWVyKCkuc3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgcmV0cnkgPSAwOyByZXRyeSA8IG1heFJldHJ5OyByZXRyeSsrKSB7XG4gICAgICAgICAgICAvLyBEb3dubG9hZCB0aGUgZmlsZVxuICAgICAgICAgICAgYXdhaXQgdXRpbENsYXNzLm5hdGl2ZURvd25sb2FkRmlsZShtZXRhLCBmdWxsRHN0UGF0aCwgbWF4Q29uY3VycmVuY3kpO1xuICAgICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuRE9XTkxPQURFRCkge1xuICAgICAgICAgICAgICAgIHRpbWVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGRvd25sb2FkZWQgcmVzdWx0LiBGaWxlOiAke21ldGEuZHN0RmlsZU5hbWV9LCBkb3dubG9hZCB0aW1lOiAke3RpbWVyLmdldER1cmF0aW9uKCl9IG1zLCBjaHVua1NpemU6ICR7bWV0YS5zcmNGaWxlU2l6ZX0gYnl0ZXMuYCk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFbJ2VuY3J5cHRpb25NYXRlcmlhbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGb3Igc3RvcmFnZSB1dGlscyB0aGF0IGRvIG5vdCBoYXZlIHRoZSBwcml2aWxlZ2Ugb2ZcbiAgICAgICAgICAgICAgICAgICAgICogZ2V0dGluZyB0aGUgbWV0YWRhdGEgZWFybHksIGJvdGggb2JqZWN0IGFuZCBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBhcmUgZG93bmxvYWRlZCBhdCBvbmNlLkluIHdoaWNoIGNhc2UsIHRoZSBmaWxlIG1ldGEgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgKiBiZSB1cGRhdGVkIHdpdGggYWxsIHRoZSBtZXRhZGF0YSB0aGF0IHdlIG5lZWQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZW4gd2UgY2FuIGNhbGwgZ2V0RmlsZUhlYWRlciB0byBnZXQganVzdCB0aGF0IGFuZCBhbHNvXG4gICAgICAgICAgICAgICAgICAgICAqIHByZXNlcnZlIHRoZSBpZGVhIG9mIGdldHRpbmcgbWV0YWRhdGEgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICAgKiBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzIHRoZSB1dGlscyB0aGF0IHVzZSBwcmVzaWduZWQgdXJsXG4gICAgICAgICAgICAgICAgICAgICAqIGZvciB1cGxvYWQgLyBkb3dubG9hZCBhbmQgbm90IHRoZSBzdG9yYWdlIGNsaWVudCBsaWJyYXJ5LlxuICAgICAgICAgICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhWydwcmVzaWduZWRVcmwnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUhlYWRlciA9IGF3YWl0IHV0aWxDbGFzcy5nZXRGaWxlSGVhZGVyKG1ldGEsIG1ldGFbJ3NyY0ZpbGVQYXRoJ10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBTdGFydCBkZWNyeXB0aW5nIHRoZSBkb3dubG9hZGVkIGZpbGUgZm9yICR7bWV0YS5kc3RGaWxlTmFtZX0gYXQgcGF0aDogJHtmdWxsRHN0UGF0aH0uYCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcERzdE5hbWUgPSBhd2FpdCBTbm93Zmxha2VFbmNyeXB0aW9uVXRpbC5kZWNyeXB0RmlsZShmaWxlSGVhZGVyLmVuY3J5cHRpb25NZXRhZGF0YSwgbWV0YVsnZW5jcnlwdGlvbk1hdGVyaWFsJ10sIGZ1bGxEc3RQYXRoLCBtZXRhWyd0bXBEaXInXSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFN1Y2Nlc3NmdWxseSBkZWNyeXB0ZWQgdGhlIGRvd25sb2FkZWQgZmlsZSBmb3IgJHttZXRhLmRzdEZpbGVOYW1lfSBpbiAke3RpbWVyLmdldER1cmF0aW9uKCl9IG1zLmApO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGRlY3J5cHRlZCB0bXAgZmlsZSB0byB0YXJnZXQgZGVzdGluYXRpb24gcGF0aFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcy5jb3B5RmlsZSh0bXBEc3ROYW1lLCBmdWxsRHN0UGF0aCwgYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRtcCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzLnVubGluayh0bXBEc3ROYW1lLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdG1wIGZvbGRlclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcy5ybWRpcihtZXRhWyd0bXBEaXInXSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZnMuc3RhdChmdWxsRHN0UGF0aCwgKGVyciwgc3RhdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IHN0YXQuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBGaWxlIHNpemUgdmVyaWZpY2F0aW9uOiBEb3dubG9hZGVkIGZpbGUgYXQgXCIke21ldGEuZnVsbERzdFBhdGh9XCIgaXMgJHtzdGF0LnNpemV9IGJ5dGVzLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYE5lZWQgdG8gcmVuZXcgdG9rZW4gZm9yIGRvd25sb2FkaW5nIGZpbGU6ICR7bWV0YS5kc3RGaWxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1BSRVNJR05FRF9VUkwpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgTmVlZCB0byByZW5ldyBwcmVzaWduZWQgVVJMIGZvciBkb3dubG9hZGluZy4gZmlsZTogJHttZXRhLmRzdEZpbGVOYW1lfSwgcHJlc2lnbmVkVXJsOiAke21ldGEucHJlc2lnbmVkVXJsfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYE5lZWQgdG8gcmV0cnkgd2l0aCBsb3dlciBjb25jdXJyZW5jeSBmb3IgZG93bmxvYWRpbmcgZmlsZTogJHttZXRhLmRzdEZpbGVOYW1lfWApO1xuICAgICAgICAgICAgICAgIGxhc3RFcnIgPSBtZXRhWydsYXN0RXJyb3InXTtcbiAgICAgICAgICAgICAgICAvLyBGYWlsZWQgdG8gZG93bmxvYWQgZmlsZSwgcmV0cnlpbmcgd2l0aCBtYXggY29uY3VycmVuY3lcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeSA9IG1ldGFbJ3BhcmFsbGVsJ10gLSBwYXJzZUludCgocmV0cnkgKiBtZXRhWydwYXJhbGxlbCddKSAvIG1heFJldHJ5KTtcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeSA9IE1hdGgubWF4KERFRkFVTFRfQ09OQ1VSUkVOQ1ksIG1heENvbmN1cnJlbmN5KTtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0TWF4Q29uY3VycmVuY3knXSA9IG1heENvbmN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIGlmICghbWV0YVsnbm9TbGVlcGluZ1RpbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYE5lZWQgdG8gcmV0cnkgZm9yIGRvd25sb2FkaW5nIGZpbGU6ICR7bWV0YS5kc3RGaWxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gbWV0YVsnbGFzdEVycm9yJ107XG4gICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIGRvd25sb2FkIGZpbGUsIHJldHJ5aW5nXG4gICAgICAgICAgICAgICAgaWYgKCFtZXRhWydub1NsZWVwaW5nVGltZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsZWVwaW5nVGltZSA9IE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5KSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBzbGVlcGluZ1RpbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RFcnIpIHtcbiAgICAgICAgICAgIExvZ2dlcigpLmVycm9yKGBGYWlsZWQgdG8gZG93bmxvYWRpbmcgZmlsZTogJHttZXRhLmRzdEZpbGVOYW1lfSB3aXRoIGVycm9yOiAke2xhc3RFcnJ9YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobGFzdEVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5rbm93biBFcnJvciBpbiBkb3dubG9hZGluZyBhIGZpbGU6ICcgKyBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5SZW1vdGVTdG9yYWdlVXRpbCA9IFJlbW90ZVN0b3JhZ2VVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlX3N0b3JhZ2VfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { NodeHttpHandler } = __webpack_require__(/*! @smithy/node-http-handler */ \"(rsc)/./node_modules/@smithy/node-http-handler/dist-es/index.js\");\nconst EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").FileHeader);\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst getProxyAgent = (__webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\").getProxyAgent);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst AMZ_IV = 'x-amz-iv';\nconst AMZ_KEY = 'x-amz-key';\nconst AMZ_MATDESC = 'x-amz-matdesc';\nconst SFC_DIGEST = 'sfc-digest';\nconst EXPIRED_TOKEN = 'ExpiredToken';\nconst NO_SUCH_KEY = 'NoSuchKey';\nconst SNOWFLAKE_S3_DESTINATION = 's3.amazonaws.com';\nconst ERRORNO_WSAECONNABORTED = 10053; // network connection was aborted\nconst DATA_SIZE_THRESHOLD = 67108864; // magic number, given from  error message.\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst HTTP_HEADER_VALUE_OCTET_STREAM = 'application/octet-stream';\n// S3 Location: S3 bucket name + path\nfunction S3Location(bucketName, s3path) {\n    return {\n        bucketName: bucketName, // S3 bucket name\n        s3path: s3path, // S3 path name\n    };\n}\n/**\n * Creates an S3 utility object.\n *\n * @param connectionConfig\n *\n * @param s3 - used for tests, mock can be supplied\n * @param filestream - used for tests, mock can be supplied\n * @returns {Object}\n * @constructor\n */\nfunction S3Util(connectionConfig, s3, filestream) {\n    const AWS = typeof s3 !== 'undefined' ? s3 : __webpack_require__(/*! @aws-sdk/client-s3 */ \"@aws-sdk/client-s3\");\n    const fs = typeof filestream !== 'undefined' ? filestream : __webpack_require__(/*! fs */ \"fs\");\n    /**\n     * Create an AWS S3 client using an AWS token.\n     */\n    this.createClient = function (stageInfo, useAccelerateEndpoint) {\n        const stageCredentials = stageInfo['creds'];\n        const securityToken = stageCredentials['AWS_TOKEN'];\n        const isRegionalUrlEnabled = stageInfo.useRegionalUrl || stageInfo.useS3RegionalUrl;\n        // if GS sends us an endpoint, it's likely for FIPS. Use it.\n        let endPoint = null;\n        if (stageInfo['endPoint']) {\n            endPoint = `https://${stageInfo['endPoint']}`;\n        }\n        else {\n            if (stageInfo.region && isRegionalUrlEnabled) {\n                const domainSuffixForRegionalUrl = stageInfo.region.toLowerCase().startsWith('cn-')\n                    ? 'amazonaws.com.cn'\n                    : 'amazonaws.com';\n                endPoint = `https://s3.${stageInfo.region}.${domainSuffixForRegionalUrl}`;\n            }\n        }\n        const config = {\n            apiVersion: '2006-03-01',\n            region: stageInfo['region'],\n            credentials: {\n                accessKeyId: stageCredentials['AWS_KEY_ID'],\n                secretAccessKey: stageCredentials['AWS_SECRET_KEY'],\n                sessionToken: securityToken,\n            },\n            endpoint: endPoint,\n            useAccelerateEndpoint: useAccelerateEndpoint,\n        };\n        const proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'S3 Util');\n        if (proxy) {\n            const proxyAgent = getProxyAgent({\n                proxyOptions: proxy,\n                connectionConfig,\n                parsedUrl: new URL(connectionConfig.accessUrl),\n                destination: endPoint || SNOWFLAKE_S3_DESTINATION,\n            });\n            config.requestHandler = new NodeHttpHandler({\n                httpAgent: proxyAgent,\n                httpsAgent: proxyAgent,\n            });\n        }\n        return new AWS.S3(config);\n    };\n    /**\n     * Get file header based on file being uploaded or not.\n     *\n     * @param {Object} meta\n     * @param {String} filename\n     *\n     * @returns {Object}\n     */\n    this.getFileHeader = async function (meta, filename) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const s3location = extractBucketNameAndPath(stageInfo['location']);\n        const params = {\n            Bucket: s3location.bucketName,\n            Key: s3location.s3path + filename,\n        };\n        let akey;\n        try {\n            await client.getObject(params).then(function (data) {\n                akey = data;\n            });\n        }\n        catch (err) {\n            if (err['Code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else if (err['Code'] === NO_SUCH_KEY) {\n                meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                return FileHeader(null, null, null);\n            }\n            else if (err['Code'] === '400') {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else {\n                meta['resultStatus'] = resultStatus.ERROR;\n                return null;\n            }\n        }\n        meta['resultStatus'] = resultStatus.UPLOADED;\n        let encryptionMetadata;\n        if (akey && akey.Metadata[AMZ_KEY]) {\n            encryptionMetadata = EncryptionMetadata(akey.Metadata[AMZ_KEY], akey.Metadata[AMZ_IV], akey.Metadata[AMZ_MATDESC]);\n        }\n        return FileHeader(akey.Metadata[SFC_DIGEST], akey.ContentLength, encryptionMetadata);\n    };\n    /**\n     * Create the file metadata then upload the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     */\n    this.uploadFile = async function (dataFile, meta, encryptionMetadata) {\n        const fileStream = fs.readFileSync(dataFile);\n        await this.uploadFileStream(fileStream, meta, encryptionMetadata);\n    };\n    /**\n     * Create the file metadata then upload the file stream.\n     *\n     * @param {String} fileStream\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     */\n    this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n        const s3Metadata = {\n            HTTP_HEADER_CONTENT_TYPE: HTTP_HEADER_VALUE_OCTET_STREAM,\n            SFC_DIGEST: meta['SHA256_DIGEST'],\n        };\n        if (encryptionMetadata) {\n            s3Metadata[AMZ_IV] = encryptionMetadata.iv;\n            s3Metadata[AMZ_KEY] = encryptionMetadata.key;\n            s3Metadata[AMZ_MATDESC] = encryptionMetadata.matDesc;\n        }\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const s3location = extractBucketNameAndPath(meta['stageInfo']['location']);\n        const params = {\n            Bucket: s3location.bucketName,\n            Body: fileStream,\n            Key: s3location.s3path + meta['dstFileName'],\n            Metadata: s3Metadata,\n        };\n        // call S3 to upload file to specified bucket\n        try {\n            await client.putObject(params);\n        }\n        catch (err) {\n            if (err['Code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            else {\n                meta['lastError'] = err;\n                if (err['Code'] === ERRORNO_WSAECONNABORTED.toString()) {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n                }\n                else {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY;\n                }\n            }\n            return;\n        }\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n    };\n    /**\n     * Download the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     */\n    this.nativeDownloadFile = async function (meta, fullDstPath) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const s3location = extractBucketNameAndPath(meta['stageInfo']['location']);\n        const params = {\n            Bucket: s3location.bucketName,\n            Key: s3location.s3path + meta['dstFileName'],\n        };\n        // call S3 to download file to specified bucket\n        try {\n            Logger().debug(`Send Get Request to the Bucket: ${params.Bucket}, GET request: ${params.Key}`);\n            await client\n                .getObject(params)\n                .then((data) => {\n                Logger().debug(`Http Status for the GET request: ${params.Key} : ${data.$metadata.httpStatusCode}`);\n                return data.Body.transformToByteArray();\n            })\n                .then((data) => {\n                return new Promise((resolve, reject) => {\n                    fs.writeFile(fullDstPath, data, 'binary', (err) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        resolve();\n                    });\n                });\n            });\n        }\n        catch (err) {\n            if (err['Code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            else {\n                meta['lastError'] = err;\n                if (err['Code'] === ERRORNO_WSAECONNABORTED.toString()) {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n                }\n                else {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY;\n                }\n            }\n            return;\n        }\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n    };\n}\n/**\n * Extract the bucket name and path from the metadata's stage location.\n *\n * @param {String} stageLocation\n *\n * @returns {Object}\n */\nfunction extractBucketNameAndPath(stageLocation) {\n    // expand '~' and '~user' expressions\n    if (process.platform !== 'win32') {\n        stageLocation = expandTilde(stageLocation);\n    }\n    let bucketName = stageLocation;\n    let s3path;\n    // split stage location as bucket name and path\n    if (stageLocation.includes('/')) {\n        bucketName = stageLocation.substring(0, stageLocation.indexOf('/'));\n        s3path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n        if (s3path && !s3path.endsWith('/')) {\n            s3path += '/';\n        }\n    }\n    return S3Location(bucketName, s3path);\n}\nmodule.exports = {\n    S3Util,\n    SNOWFLAKE_S3_DESTINATION,\n    DATA_SIZE_THRESHOLD,\n    extractBucketNameAndPath,\n};\n//# sourceMappingURL=s3_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L3MzX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsa0dBQTJCO0FBQy9ELDJCQUEyQixpSkFBNEM7QUFDdkUsbUJBQW1CLGdIQUFrQztBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQyxzQkFBc0IsbUhBQXFDO0FBQzNELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFlO0FBQ3pDLGVBQWUsMEdBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHNDQUFzQztBQUN0QyxxQkFBcUIsa0hBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsbUJBQU8sQ0FBQyw4Q0FBb0I7QUFDN0UsZ0VBQWdFLG1CQUFPLENBQUMsY0FBSTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQixHQUFHLDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWMsaUJBQWlCLFdBQVc7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFlBQVksSUFBSSw4QkFBOEI7QUFDakg7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9zM191dGlsLmpzP2ZlODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IE5vZGVIdHRwSGFuZGxlciB9ID0gcmVxdWlyZSgnQHNtaXRoeS9ub2RlLWh0dHAtaGFuZGxlcicpO1xuY29uc3QgRW5jcnlwdGlvbk1ldGFkYXRhID0gcmVxdWlyZSgnLi9lbmNyeXB0X3V0aWwnKS5FbmNyeXB0aW9uTWV0YWRhdGE7XG5jb25zdCBGaWxlSGVhZGVyID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykuRmlsZUhlYWRlcjtcbmNvbnN0IGV4cGFuZFRpbGRlID0gcmVxdWlyZSgnZXhwYW5kLXRpbGRlJyk7XG5jb25zdCBnZXRQcm94eUFnZW50ID0gcmVxdWlyZSgnLi4vaHR0cC9ub2RlJykuZ2V0UHJveHlBZ2VudDtcbmNvbnN0IFByb3h5VXRpbCA9IHJlcXVpcmUoJy4uL3Byb3h5X3V0aWwnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpLmRlZmF1bHQ7XG5jb25zdCBBTVpfSVYgPSAneC1hbXotaXYnO1xuY29uc3QgQU1aX0tFWSA9ICd4LWFtei1rZXknO1xuY29uc3QgQU1aX01BVERFU0MgPSAneC1hbXotbWF0ZGVzYyc7XG5jb25zdCBTRkNfRElHRVNUID0gJ3NmYy1kaWdlc3QnO1xuY29uc3QgRVhQSVJFRF9UT0tFTiA9ICdFeHBpcmVkVG9rZW4nO1xuY29uc3QgTk9fU1VDSF9LRVkgPSAnTm9TdWNoS2V5JztcbmNvbnN0IFNOT1dGTEFLRV9TM19ERVNUSU5BVElPTiA9ICdzMy5hbWF6b25hd3MuY29tJztcbmNvbnN0IEVSUk9STk9fV1NBRUNPTk5BQk9SVEVEID0gMTAwNTM7IC8vIG5ldHdvcmsgY29ubmVjdGlvbiB3YXMgYWJvcnRlZFxuY29uc3QgREFUQV9TSVpFX1RIUkVTSE9MRCA9IDY3MTA4ODY0OyAvLyBtYWdpYyBudW1iZXIsIGdpdmVuIGZyb20gIGVycm9yIG1lc3NhZ2UuXG5jb25zdCByZXN1bHRTdGF0dXMgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5yZXN1bHRTdGF0dXM7XG5jb25zdCBIVFRQX0hFQURFUl9WQUxVRV9PQ1RFVF9TVFJFQU0gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbi8vIFMzIExvY2F0aW9uOiBTMyBidWNrZXQgbmFtZSArIHBhdGhcbmZ1bmN0aW9uIFMzTG9jYXRpb24oYnVja2V0TmFtZSwgczNwYXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVja2V0TmFtZTogYnVja2V0TmFtZSwgLy8gUzMgYnVja2V0IG5hbWVcbiAgICAgICAgczNwYXRoOiBzM3BhdGgsIC8vIFMzIHBhdGggbmFtZVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gUzMgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcGFyYW0gczMgLSB1c2VkIGZvciB0ZXN0cywgbW9jayBjYW4gYmUgc3VwcGxpZWRcbiAqIEBwYXJhbSBmaWxlc3RyZWFtIC0gdXNlZCBmb3IgdGVzdHMsIG1vY2sgY2FuIGJlIHN1cHBsaWVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFMzVXRpbChjb25uZWN0aW9uQ29uZmlnLCBzMywgZmlsZXN0cmVhbSkge1xuICAgIGNvbnN0IEFXUyA9IHR5cGVvZiBzMyAhPT0gJ3VuZGVmaW5lZCcgPyBzMyA6IHJlcXVpcmUoJ0Bhd3Mtc2RrL2NsaWVudC1zMycpO1xuICAgIGNvbnN0IGZzID0gdHlwZW9mIGZpbGVzdHJlYW0gIT09ICd1bmRlZmluZWQnID8gZmlsZXN0cmVhbSA6IHJlcXVpcmUoJ2ZzJyk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEFXUyBTMyBjbGllbnQgdXNpbmcgYW4gQVdTIHRva2VuLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gKHN0YWdlSW5mbywgdXNlQWNjZWxlcmF0ZUVuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHN0YWdlQ3JlZGVudGlhbHMgPSBzdGFnZUluZm9bJ2NyZWRzJ107XG4gICAgICAgIGNvbnN0IHNlY3VyaXR5VG9rZW4gPSBzdGFnZUNyZWRlbnRpYWxzWydBV1NfVE9LRU4nXTtcbiAgICAgICAgY29uc3QgaXNSZWdpb25hbFVybEVuYWJsZWQgPSBzdGFnZUluZm8udXNlUmVnaW9uYWxVcmwgfHwgc3RhZ2VJbmZvLnVzZVMzUmVnaW9uYWxVcmw7XG4gICAgICAgIC8vIGlmIEdTIHNlbmRzIHVzIGFuIGVuZHBvaW50LCBpdCdzIGxpa2VseSBmb3IgRklQUy4gVXNlIGl0LlxuICAgICAgICBsZXQgZW5kUG9pbnQgPSBudWxsO1xuICAgICAgICBpZiAoc3RhZ2VJbmZvWydlbmRQb2ludCddKSB7XG4gICAgICAgICAgICBlbmRQb2ludCA9IGBodHRwczovLyR7c3RhZ2VJbmZvWydlbmRQb2ludCddfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhZ2VJbmZvLnJlZ2lvbiAmJiBpc1JlZ2lvbmFsVXJsRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpblN1ZmZpeEZvclJlZ2lvbmFsVXJsID0gc3RhZ2VJbmZvLnJlZ2lvbi50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2NuLScpXG4gICAgICAgICAgICAgICAgICAgID8gJ2FtYXpvbmF3cy5jb20uY24nXG4gICAgICAgICAgICAgICAgICAgIDogJ2FtYXpvbmF3cy5jb20nO1xuICAgICAgICAgICAgICAgIGVuZFBvaW50ID0gYGh0dHBzOi8vczMuJHtzdGFnZUluZm8ucmVnaW9ufS4ke2RvbWFpblN1ZmZpeEZvclJlZ2lvbmFsVXJsfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgYXBpVmVyc2lvbjogJzIwMDYtMDMtMDEnLFxuICAgICAgICAgICAgcmVnaW9uOiBzdGFnZUluZm9bJ3JlZ2lvbiddLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NLZXlJZDogc3RhZ2VDcmVkZW50aWFsc1snQVdTX0tFWV9JRCddLFxuICAgICAgICAgICAgICAgIHNlY3JldEFjY2Vzc0tleTogc3RhZ2VDcmVkZW50aWFsc1snQVdTX1NFQ1JFVF9LRVknXSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uVG9rZW46IHNlY3VyaXR5VG9rZW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZFBvaW50LFxuICAgICAgICAgICAgdXNlQWNjZWxlcmF0ZUVuZHBvaW50OiB1c2VBY2NlbGVyYXRlRW5kcG9pbnQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb3h5ID0gUHJveHlVdGlsLmdldFByb3h5KGNvbm5lY3Rpb25Db25maWcuZ2V0UHJveHkoKSwgJ1MzIFV0aWwnKTtcbiAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgICBjb25zdCBwcm94eUFnZW50ID0gZ2V0UHJveHlBZ2VudCh7XG4gICAgICAgICAgICAgICAgcHJveHlPcHRpb25zOiBwcm94eSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlZFVybDogbmV3IFVSTChjb25uZWN0aW9uQ29uZmlnLmFjY2Vzc1VybCksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IGVuZFBvaW50IHx8IFNOT1dGTEFLRV9TM19ERVNUSU5BVElPTixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnLnJlcXVlc3RIYW5kbGVyID0gbmV3IE5vZGVIdHRwSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgaHR0cEFnZW50OiBwcm94eUFnZW50LFxuICAgICAgICAgICAgICAgIGh0dHBzQWdlbnQ6IHByb3h5QWdlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFXUy5TMyhjb25maWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgaGVhZGVyIGJhc2VkIG9uIGZpbGUgYmVpbmcgdXBsb2FkZWQgb3Igbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRGaWxlSGVhZGVyID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEsIGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuICAgICAgICBjb25zdCBzM2xvY2F0aW9uID0gZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKHN0YWdlSW5mb1snbG9jYXRpb24nXSk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIEJ1Y2tldDogczNsb2NhdGlvbi5idWNrZXROYW1lLFxuICAgICAgICAgICAgS2V5OiBzM2xvY2F0aW9uLnMzcGF0aCArIGZpbGVuYW1lLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgYWtleTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5nZXRPYmplY3QocGFyYW1zKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgYWtleSA9IGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyWydDb2RlJ10gPT09IEVYUElSRURfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVyclsnQ29kZSddID09PSBOT19TVUNIX0tFWSkge1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFO1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWxlSGVhZGVyKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyWydDb2RlJ10gPT09ICc0MDAnKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5VUExPQURFRDtcbiAgICAgICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICAgICAgaWYgKGFrZXkgJiYgYWtleS5NZXRhZGF0YVtBTVpfS0VZXSkge1xuICAgICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhID0gRW5jcnlwdGlvbk1ldGFkYXRhKGFrZXkuTWV0YWRhdGFbQU1aX0tFWV0sIGFrZXkuTWV0YWRhdGFbQU1aX0lWXSwgYWtleS5NZXRhZGF0YVtBTVpfTUFUREVTQ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaWxlSGVhZGVyKGFrZXkuTWV0YWRhdGFbU0ZDX0RJR0VTVF0sIGFrZXkuQ29udGVudExlbmd0aCwgZW5jcnlwdGlvbk1ldGFkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhRmlsZSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUZpbGUpO1xuICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEZpbGVTdHJlYW0oZmlsZVN0cmVhbSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVN0cmVhbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkRmlsZVN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlU3RyZWFtLCBtZXRhLCBlbmNyeXB0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgczNNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIEhUVFBfSEVBREVSX0NPTlRFTlRfVFlQRTogSFRUUF9IRUFERVJfVkFMVUVfT0NURVRfU1RSRUFNLFxuICAgICAgICAgICAgU0ZDX0RJR0VTVDogbWV0YVsnU0hBMjU2X0RJR0VTVCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgICAgICBzM01ldGFkYXRhW0FNWl9JVl0gPSBlbmNyeXB0aW9uTWV0YWRhdGEuaXY7XG4gICAgICAgICAgICBzM01ldGFkYXRhW0FNWl9LRVldID0gZW5jcnlwdGlvbk1ldGFkYXRhLmtleTtcbiAgICAgICAgICAgIHMzTWV0YWRhdGFbQU1aX01BVERFU0NdID0gZW5jcnlwdGlvbk1ldGFkYXRhLm1hdERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhZ2VJbmZvID0gbWV0YVsnc3RhZ2VJbmZvJ107XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbyk7XG4gICAgICAgIGNvbnN0IHMzbG9jYXRpb24gPSBleHRyYWN0QnVja2V0TmFtZUFuZFBhdGgobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBCdWNrZXQ6IHMzbG9jYXRpb24uYnVja2V0TmFtZSxcbiAgICAgICAgICAgIEJvZHk6IGZpbGVTdHJlYW0sXG4gICAgICAgICAgICBLZXk6IHMzbG9jYXRpb24uczNwYXRoICsgbWV0YVsnZHN0RmlsZU5hbWUnXSxcbiAgICAgICAgICAgIE1ldGFkYXRhOiBzM01ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBjYWxsIFMzIHRvIHVwbG9hZCBmaWxlIHRvIHNwZWNpZmllZCBidWNrZXRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5wdXRPYmplY3QocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyWydDb2RlJ10gPT09IEVYUElSRURfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgIGlmIChlcnJbJ0NvZGUnXSA9PT0gRVJST1JOT19XU0FFQ09OTkFCT1JURUQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gbWV0YVsndXBsb2FkU2l6ZSddO1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5VUExPQURFRDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvd25sb2FkIHRoZSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5jcnlwdGlvbk1ldGFkYXRhXG4gICAgICovXG4gICAgdGhpcy5uYXRpdmVEb3dubG9hZEZpbGUgPSBhc3luYyBmdW5jdGlvbiAobWV0YSwgZnVsbERzdFBhdGgpIHtcbiAgICAgICAgY29uc3Qgc3RhZ2VJbmZvID0gbWV0YVsnc3RhZ2VJbmZvJ107XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbyk7XG4gICAgICAgIGNvbnN0IHMzbG9jYXRpb24gPSBleHRyYWN0QnVja2V0TmFtZUFuZFBhdGgobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBCdWNrZXQ6IHMzbG9jYXRpb24uYnVja2V0TmFtZSxcbiAgICAgICAgICAgIEtleTogczNsb2NhdGlvbi5zM3BhdGggKyBtZXRhWydkc3RGaWxlTmFtZSddLFxuICAgICAgICB9O1xuICAgICAgICAvLyBjYWxsIFMzIHRvIGRvd25sb2FkIGZpbGUgdG8gc3BlY2lmaWVkIGJ1Y2tldFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFNlbmQgR2V0IFJlcXVlc3QgdG8gdGhlIEJ1Y2tldDogJHtwYXJhbXMuQnVja2V0fSwgR0VUIHJlcXVlc3Q6ICR7cGFyYW1zLktleX1gKTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudFxuICAgICAgICAgICAgICAgIC5nZXRPYmplY3QocGFyYW1zKVxuICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYEh0dHAgU3RhdHVzIGZvciB0aGUgR0VUIHJlcXVlc3Q6ICR7cGFyYW1zLktleX0gOiAke2RhdGEuJG1ldGFkYXRhLmh0dHBTdGF0dXNDb2RlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLkJvZHkudHJhbnNmb3JtVG9CeXRlQXJyYXkoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGUoZnVsbERzdFBhdGgsIGRhdGEsICdiaW5hcnknLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyclsnQ29kZSddID09PSBFWFBJUkVEX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyWydDb2RlJ10gPT09IEVSUk9STk9fV1NBRUNPTk5BQk9SVEVELnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRE9XTkxPQURFRDtcbiAgICB9O1xufVxuLyoqXG4gKiBFeHRyYWN0IHRoZSBidWNrZXQgbmFtZSBhbmQgcGF0aCBmcm9tIHRoZSBtZXRhZGF0YSdzIHN0YWdlIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdGFnZUxvY2F0aW9uXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKHN0YWdlTG9jYXRpb24pIHtcbiAgICAvLyBleHBhbmQgJ34nIGFuZCAnfnVzZXInIGV4cHJlc3Npb25zXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgc3RhZ2VMb2NhdGlvbiA9IGV4cGFuZFRpbGRlKHN0YWdlTG9jYXRpb24pO1xuICAgIH1cbiAgICBsZXQgYnVja2V0TmFtZSA9IHN0YWdlTG9jYXRpb247XG4gICAgbGV0IHMzcGF0aDtcbiAgICAvLyBzcGxpdCBzdGFnZSBsb2NhdGlvbiBhcyBidWNrZXQgbmFtZSBhbmQgcGF0aFxuICAgIGlmIChzdGFnZUxvY2F0aW9uLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgYnVja2V0TmFtZSA9IHN0YWdlTG9jYXRpb24uc3Vic3RyaW5nKDAsIHN0YWdlTG9jYXRpb24uaW5kZXhPZignLycpKTtcbiAgICAgICAgczNwYXRoID0gc3RhZ2VMb2NhdGlvbi5zdWJzdHJpbmcoc3RhZ2VMb2NhdGlvbi5pbmRleE9mKCcvJykgKyAxLCBzdGFnZUxvY2F0aW9uLmxlbmd0aCk7XG4gICAgICAgIGlmIChzM3BhdGggJiYgIXMzcGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBzM3BhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTM0xvY2F0aW9uKGJ1Y2tldE5hbWUsIHMzcGF0aCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBTM1V0aWwsXG4gICAgU05PV0ZMQUtFX1MzX0RFU1RJTkFUSU9OLFxuICAgIERBVEFfU0laRV9USFJFU0hPTEQsXG4gICAgZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXMzX3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst fsPromises = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/dist/commonjs/index.js\");\nconst { isWindows } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = (__webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst resultStatus = {\n    ERROR: 'ERROR',\n    UPLOADED: 'UPLOADED',\n    DOWNLOADED: 'DOWNLOADED',\n    COLLISION: 'COLLISION',\n    SKIPPED: 'SKIPPED',\n    RENEW_TOKEN: 'RENEW_TOKEN',\n    RENEW_PRESIGNED_URL: 'RENEW_PRESIGNED_URL',\n    NOT_FOUND_FILE: 'NOT_FOUND_FILE',\n    NEED_RETRY: 'NEED_RETRY',\n    NEED_RETRY_WITH_LOWER_CONCURRENCY: 'NEED_RETRY_WITH_LOWER_CONCURRENCY',\n};\nexports.resultStatus = resultStatus;\nconst ownerReadAndWriteFilePermission = 0o600;\nconst othersCanReadFilePermission = 0o044;\nconst othersCanWriteFilePermission = 0o022;\nconst executableFilePermission = 0o111;\nconst skipWarningForReadPermissionsEnv = 'SF_SKIP_WARNING_FOR_READ_PERMISSIONS_ON_CONFIG_FILE';\n// File Header\nfunction FileHeader(digest, contentLength, encryptionMetadata) {\n    return {\n        digest: digest,\n        contentLength: contentLength,\n        encryptionMetadata: encryptionMetadata,\n    };\n}\nexports.FileHeader = FileHeader;\n/**\n * Creates a file utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction FileUtil() {\n    /**\n     * Compress file with GZIP.\n     *\n     * @param {String} fileName\n     * @param {String} tmpDir\n     *\n     * @returns {Object}\n     */\n    this.compressFileWithGZIP = async function (fileName, tmpDir) {\n        // Set file name and path for compressed file\n        const baseName = path.basename(fileName);\n        const gzipFileName = path.join(tmpDir, baseName + '_c.gz');\n        await new Promise(function (resolve) {\n            // Create gzip object\n            const gzip = zlib.createGzip();\n            // Create stream object for reader and writer\n            const reader = fs.createReadStream(fileName);\n            const writer = fs.createWriteStream(gzipFileName);\n            // Write and compress file\n            const result = reader.pipe(gzip).pipe(writer);\n            result.on('finish', function () {\n                resolve();\n            });\n        });\n        await this.normalizeGzipHeader(gzipFileName);\n        const fileInfo = fs.statSync(gzipFileName);\n        return {\n            name: gzipFileName,\n            size: fileInfo.size,\n        };\n    };\n    /**\n     * Normalize the header by removing the timestamp.\n     * Note: GZIP in python includes the file name when compressing but\n     * nodejs does not so there is no need to remove it here.\n     *\n     * @param {String} gzipFileName\n     *\n     * @returns {null}\n     */\n    this.normalizeGzipHeader = async function (gzipFileName) {\n        const fd = fs.openSync(gzipFileName, 'rs+');\n        // Reset the timestamp in gzip header\n        // Write at position 4\n        const timestampBuffer = Buffer.alloc(4);\n        timestampBuffer.writeUInt32LE(0, 0);\n        fs.writeSync(fd, timestampBuffer, 0, 4, 4);\n        fs.closeSync(fd);\n    };\n    /**\n     * Get file digest and size.\n     *\n     * @param {String} fileName\n     *\n     * @returns {Object}\n     */\n    this.getDigestAndSizeForFile = async function (fileName) {\n        const chunkSize = 16 * 4 * 1024;\n        const fileInfo = fs.statSync(fileName);\n        const bufferSize = fileInfo.size;\n        let buffer = [];\n        await new Promise(function (resolve) {\n            // Create reader stream and set maximum chunk size\n            const infile = fs.createReadStream(fileName, { highWaterMark: chunkSize });\n            infile.on('data', function (chunk) {\n                buffer.push(chunk);\n            });\n            infile.on('close', function () {\n                buffer = Buffer.concat(buffer);\n                resolve();\n            });\n        });\n        const hash = crypto.createHash('sha256').update(buffer).digest('base64');\n        return {\n            digest: hash,\n            size: bufferSize,\n        };\n    };\n}\nexports.FileUtil = FileUtil;\nexports.getMatchingFilePaths = function (dir, fileName) {\n    const pathWithWildcard = path.join(dir, fileName);\n    const pathWithWildcardDependsOnPlatform = isWindows()\n        ? pathWithWildcard.replace(/\\\\/g, '/')\n        : pathWithWildcard;\n    return glob.sync(pathWithWildcardDependsOnPlatform);\n};\n/**\n * Checks if the provided file or directory is writable only by the user and os that file owner is the same as os user. FsPromises can be provided.\n * @param filePath\n * @param fsPromises\n * @param useSync\n * @returns {Promise<void>|void} Returns a Promise<void> or void on Windows (no validation needed), otherwise returns the result of the validation\n\n */\nexports.validateNoExtraPermissionsForOthers = function (filePath, fsPromises = null, useSync = false) {\n    const fsp = fsPromises ? fsPromises : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n    if (isWindows()) {\n        return;\n    }\n    const validatePermissions = (stats) => {\n        const permission = stats.mode & 0o777;\n        if (!shouldSkipWarningForReadPermissions() &&\n            (permission & othersCanReadFilePermission) !== 0) {\n            Logger()\n                .warn(`file ${filePath} is readable by someone other than the owner. Your Permission: ${permission.toString(8)}. If you want \"+\n\t\t\t\"to disable this warning, either remove read permissions from group and others or set the environment \"+\n\t\t\t\"variable ${skipWarningForReadPermissionsEnv} to true`);\n        }\n        if ((permission & executableFilePermission) !== 0) {\n            throw new Error(`file ${filePath} is executable  this poses a security risk because the file could be misused as a script or executed unintentionally. File Permission: ${permission.toString(8)}`);\n        }\n        if ((permission & othersCanWriteFilePermission) !== 0) {\n            throw new Error(`file ${filePath} is writable by group or others  this poses a security risk because it allows unauthorized users to modify sensitive settings. File Permission: ${permission.toString(8)}`);\n        }\n        //The owner should have read and write permission.\n        if ((permission & ownerReadAndWriteFilePermission) === ownerReadAndWriteFilePermission) {\n            Logger().debug(`Validated that the owner has read and write permission for file: ${filePath}, Permission: ${permission.toString(8)}`);\n        }\n        else {\n            throw new Error(`Invalid file permissions (${permission.toString(8)} for file ${filePath}). Make sure the owner has read and write permissions, and other users do not have access to it. Please fix the ownership and permissions of the file or remove the file and re-run the driver.`);\n        }\n        const userInfo = os.userInfo();\n        if (stats.uid === userInfo.uid) {\n            Logger().debug('Validated file owner');\n        }\n        else {\n            throw new Error(`Invalid file owner for file ${filePath}). Make sure the user running the software is the owner of the file, or remove the file and re-run the driver.`);\n        }\n    };\n    const handleError = (err) => {\n        // When file doesn't exist - return\n        if (err.code === 'ENOENT') {\n            return;\n        }\n        throw err;\n    };\n    if (useSync) {\n        try {\n            const stats = fs.statSync(filePath);\n            return validatePermissions(stats);\n        }\n        catch (err) {\n            handleError(err);\n        }\n    }\n    else {\n        return fsp.stat(filePath).then(validatePermissions).catch(handleError);\n    }\n};\nexports.validateNoExtraPermissionsForOthersSync = function (filePath) {\n    return exports.validateNoExtraPermissionsForOthers(filePath, fs, true);\n};\n/**\n * Checks if the provided file is writable only by the user and os that file owner is the same as os user. FsPromises can be provided.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<FileHandle>}\n */\nexports.getSecureHandle = async function (filePath, flags, fsPromises) {\n    const fsp = fsPromises ? fsPromises : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n    try {\n        const fileHandle = await fsp.open(filePath, flags, 0o600);\n        if (os.platform() === 'win32') {\n            return fileHandle;\n        }\n        const stats = await fileHandle.stat();\n        const mode = stats.mode;\n        const permission = mode & 0o777;\n        //This should be 600 permission, which means the file permission has not been changed by others.\n        if (permission === 0o600) {\n            Logger().debug(`Validated that the user has only read and write permission for file: ${filePath}, Permission: ${permission}`);\n        }\n        else {\n            throw new Error(`Invalid file permissions (${permission.toString(8)} for file ${filePath}). Make sure you have read and write permissions and other users do not have access to it. Please remove the file and re-run the driver.`);\n        }\n        const userInfo = os.userInfo();\n        if (stats.uid === userInfo.uid) {\n            Logger().debug('Validated file owner');\n        }\n        else {\n            throw new Error(`Invalid file owner for file ${filePath}). Make sure the system user is the owner of the file otherwise please remove the file and re-run the driver.`);\n        }\n        return fileHandle;\n    }\n    catch (err) {\n        //When file doesn't exist - return\n        if (err.code === 'ENOENT') {\n            return null;\n        }\n        else {\n            throw err;\n        }\n    }\n};\nexports.closeHandle = async function (fileHandle) {\n    if (fileHandle !== undefined && fileHandle !== null) {\n        await fileHandle.close();\n    }\n};\n/**\n * Checks if the provided file or directory permissions are correct.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileModeCorrect = async function (filePath, expectedMode, fsPromises) {\n    if (os.platform() === 'win32') {\n        return true;\n    }\n    return await fsPromises.stat(filePath).then((stats) => {\n        // we have to limit the number of LSB bits to 9 with the mask, as the stats.mode starts with the file type,\n        // e.g. the directory with permissions 755 will have stats.mask of 40755.\n        const mask = (1 << 9) - 1;\n        return (stats.mode & mask) === expectedMode;\n    });\n};\n/**\n * Checks if the provided file or directory is writable only by the user.\n * @param configFilePath\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileNotWritableByGroupOrOthers = async function (configFilePath, fsPromises) {\n    if (os.platform() === 'win32') {\n        return true;\n    }\n    const stats = await fsPromises.stat(configFilePath);\n    return (stats.mode & (1 << 4)) === 0 && (stats.mode & (1 << 1)) === 0;\n};\n/**\n * Generate checksum for given text. The algorithm and encoding can be provided.\n * @param text\n * @param algorithm\n * @param encoding\n * @returns {Promise<String>} resolves always to true for Windows\n */\nexports.generateChecksum = function (text, algorithm, encoding) {\n    return crypto\n        .createHash(algorithm || 'sha256')\n        .update(text, 'utf8')\n        .digest(encoding || 'hex')\n        .substring(0, 32);\n};\nexports.IsFileExisted = async function (filePath) {\n    try {\n        await fsPromises.access(filePath, fs.constants.F_OK);\n        return true;\n    }\n    catch (err) {\n        return false;\n    }\n};\nfunction shouldSkipWarningForReadPermissions() {\n    return process.env[skipWarningForReadPermissionsEnv] !== undefined;\n}\n//# sourceMappingURL=file_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsbUJBQW1CLG1CQUFPLENBQUMsMENBQWtCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLDhEQUFNO0FBQzNCLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsbUVBQVE7QUFDdEMsZUFBZSx5R0FBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMEJBQTBCO0FBQ3JGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9COztBQUVqQztBQUNBLDJDQUEyQztBQUMzQywwQ0FBMEMsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVUsZ0VBQWdFLHVCQUF1QjtBQUMvSDtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSx5SUFBeUksdUJBQXVCO0FBQzlNO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSxrSkFBa0osdUJBQXVCO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixTQUFTLGdCQUFnQix1QkFBdUI7QUFDL0k7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0IsV0FBVyxTQUFTO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBDQUEwQyxtQkFBTyxDQUFDLGdDQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLFNBQVMsZ0JBQWdCLFdBQVc7QUFDdkk7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0IsV0FBVyxTQUFTO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3V0aWwuanM/MzZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgZnNQcm9taXNlcyA9IHJlcXVpcmUoJ25vZGU6ZnMvcHJvbWlzZXMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcbmNvbnN0IHsgaXNXaW5kb3dzIH0gPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJykuZGVmYXVsdDtcbmNvbnN0IHJlc3VsdFN0YXR1cyA9IHtcbiAgICBFUlJPUjogJ0VSUk9SJyxcbiAgICBVUExPQURFRDogJ1VQTE9BREVEJyxcbiAgICBET1dOTE9BREVEOiAnRE9XTkxPQURFRCcsXG4gICAgQ09MTElTSU9OOiAnQ09MTElTSU9OJyxcbiAgICBTS0lQUEVEOiAnU0tJUFBFRCcsXG4gICAgUkVORVdfVE9LRU46ICdSRU5FV19UT0tFTicsXG4gICAgUkVORVdfUFJFU0lHTkVEX1VSTDogJ1JFTkVXX1BSRVNJR05FRF9VUkwnLFxuICAgIE5PVF9GT1VORF9GSUxFOiAnTk9UX0ZPVU5EX0ZJTEUnLFxuICAgIE5FRURfUkVUUlk6ICdORUVEX1JFVFJZJyxcbiAgICBORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1k6ICdORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1knLFxufTtcbmV4cG9ydHMucmVzdWx0U3RhdHVzID0gcmVzdWx0U3RhdHVzO1xuY29uc3Qgb3duZXJSZWFkQW5kV3JpdGVGaWxlUGVybWlzc2lvbiA9IDBvNjAwO1xuY29uc3Qgb3RoZXJzQ2FuUmVhZEZpbGVQZXJtaXNzaW9uID0gMG8wNDQ7XG5jb25zdCBvdGhlcnNDYW5Xcml0ZUZpbGVQZXJtaXNzaW9uID0gMG8wMjI7XG5jb25zdCBleGVjdXRhYmxlRmlsZVBlcm1pc3Npb24gPSAwbzExMTtcbmNvbnN0IHNraXBXYXJuaW5nRm9yUmVhZFBlcm1pc3Npb25zRW52ID0gJ1NGX1NLSVBfV0FSTklOR19GT1JfUkVBRF9QRVJNSVNTSU9OU19PTl9DT05GSUdfRklMRSc7XG4vLyBGaWxlIEhlYWRlclxuZnVuY3Rpb24gRmlsZUhlYWRlcihkaWdlc3QsIGNvbnRlbnRMZW5ndGgsIGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpZ2VzdDogZGlnZXN0LFxuICAgICAgICBjb250ZW50TGVuZ3RoOiBjb250ZW50TGVuZ3RoLFxuICAgICAgICBlbmNyeXB0aW9uTWV0YWRhdGE6IGVuY3J5cHRpb25NZXRhZGF0YSxcbiAgICB9O1xufVxuZXhwb3J0cy5GaWxlSGVhZGVyID0gRmlsZUhlYWRlcjtcbi8qKlxuICogQ3JlYXRlcyBhIGZpbGUgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlVXRpbCgpIHtcbiAgICAvKipcbiAgICAgKiBDb21wcmVzcyBmaWxlIHdpdGggR1pJUC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0bXBEaXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5jb21wcmVzc0ZpbGVXaXRoR1pJUCA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlTmFtZSwgdG1wRGlyKSB7XG4gICAgICAgIC8vIFNldCBmaWxlIG5hbWUgYW5kIHBhdGggZm9yIGNvbXByZXNzZWQgZmlsZVxuICAgICAgICBjb25zdCBiYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUpO1xuICAgICAgICBjb25zdCBnemlwRmlsZU5hbWUgPSBwYXRoLmpvaW4odG1wRGlyLCBiYXNlTmFtZSArICdfYy5neicpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGd6aXAgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBnemlwID0gemxpYi5jcmVhdGVHemlwKCk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIG9iamVjdCBmb3IgcmVhZGVyIGFuZCB3cml0ZXJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZU5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZ3ppcEZpbGVOYW1lKTtcbiAgICAgICAgICAgIC8vIFdyaXRlIGFuZCBjb21wcmVzcyBmaWxlXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkZXIucGlwZShnemlwKS5waXBlKHdyaXRlcik7XG4gICAgICAgICAgICByZXN1bHQub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMubm9ybWFsaXplR3ppcEhlYWRlcihnemlwRmlsZU5hbWUpO1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IGZzLnN0YXRTeW5jKGd6aXBGaWxlTmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBnemlwRmlsZU5hbWUsXG4gICAgICAgICAgICBzaXplOiBmaWxlSW5mby5zaXplLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHRoZSBoZWFkZXIgYnkgcmVtb3ZpbmcgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBOb3RlOiBHWklQIGluIHB5dGhvbiBpbmNsdWRlcyB0aGUgZmlsZSBuYW1lIHdoZW4gY29tcHJlc3NpbmcgYnV0XG4gICAgICogbm9kZWpzIGRvZXMgbm90IHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVtb3ZlIGl0IGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3ppcEZpbGVOYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5vcm1hbGl6ZUd6aXBIZWFkZXIgPSBhc3luYyBmdW5jdGlvbiAoZ3ppcEZpbGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGZkID0gZnMub3BlblN5bmMoZ3ppcEZpbGVOYW1lLCAncnMrJyk7XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lc3RhbXAgaW4gZ3ppcCBoZWFkZXJcbiAgICAgICAgLy8gV3JpdGUgYXQgcG9zaXRpb24gNFxuICAgICAgICBjb25zdCB0aW1lc3RhbXBCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIHRpbWVzdGFtcEJ1ZmZlci53cml0ZVVJbnQzMkxFKDAsIDApO1xuICAgICAgICBmcy53cml0ZVN5bmMoZmQsIHRpbWVzdGFtcEJ1ZmZlciwgMCwgNCwgNCk7XG4gICAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBkaWdlc3QgYW5kIHNpemUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZU5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXREaWdlc3RBbmRTaXplRm9yRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSAxNiAqIDQgKiAxMDI0O1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IGZzLnN0YXRTeW5jKGZpbGVOYW1lKTtcbiAgICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGZpbGVJbmZvLnNpemU7XG4gICAgICAgIGxldCBidWZmZXIgPSBbXTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSByZWFkZXIgc3RyZWFtIGFuZCBzZXQgbWF4aW11bSBjaHVuayBzaXplXG4gICAgICAgICAgICBjb25zdCBpbmZpbGUgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVOYW1lLCB7IGhpZ2hXYXRlck1hcms6IGNodW5rU2l6ZSB9KTtcbiAgICAgICAgICAgIGluZmlsZS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5maWxlLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWdlc3Q6IGhhc2gsXG4gICAgICAgICAgICBzaXplOiBidWZmZXJTaXplLFxuICAgICAgICB9O1xuICAgIH07XG59XG5leHBvcnRzLkZpbGVVdGlsID0gRmlsZVV0aWw7XG5leHBvcnRzLmdldE1hdGNoaW5nRmlsZVBhdGhzID0gZnVuY3Rpb24gKGRpciwgZmlsZU5hbWUpIHtcbiAgICBjb25zdCBwYXRoV2l0aFdpbGRjYXJkID0gcGF0aC5qb2luKGRpciwgZmlsZU5hbWUpO1xuICAgIGNvbnN0IHBhdGhXaXRoV2lsZGNhcmREZXBlbmRzT25QbGF0Zm9ybSA9IGlzV2luZG93cygpXG4gICAgICAgID8gcGF0aFdpdGhXaWxkY2FyZC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICAgICAgOiBwYXRoV2l0aFdpbGRjYXJkO1xuICAgIHJldHVybiBnbG9iLnN5bmMocGF0aFdpdGhXaWxkY2FyZERlcGVuZHNPblBsYXRmb3JtKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgZmlsZSBvciBkaXJlY3RvcnkgaXMgd3JpdGFibGUgb25seSBieSB0aGUgdXNlciBhbmQgb3MgdGhhdCBmaWxlIG93bmVyIGlzIHRoZSBzYW1lIGFzIG9zIHVzZXIuIEZzUHJvbWlzZXMgY2FuIGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIGZpbGVQYXRoXG4gKiBAcGFyYW0gZnNQcm9taXNlc1xuICogQHBhcmFtIHVzZVN5bmNcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fHZvaWR9IFJldHVybnMgYSBQcm9taXNlPHZvaWQ+IG9yIHZvaWQgb24gV2luZG93cyAobm8gdmFsaWRhdGlvbiBuZWVkZWQpLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSB2YWxpZGF0aW9uXG5cbiAqL1xuZXhwb3J0cy52YWxpZGF0ZU5vRXh0cmFQZXJtaXNzaW9uc0Zvck90aGVycyA9IGZ1bmN0aW9uIChmaWxlUGF0aCwgZnNQcm9taXNlcyA9IG51bGwsIHVzZVN5bmMgPSBmYWxzZSkge1xuICAgIGNvbnN0IGZzcCA9IGZzUHJvbWlzZXMgPyBmc1Byb21pc2VzIDogcmVxdWlyZSgnZnMvcHJvbWlzZXMnKTtcbiAgICBpZiAoaXNXaW5kb3dzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZVBlcm1pc3Npb25zID0gKHN0YXRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSBzdGF0cy5tb2RlICYgMG83Nzc7XG4gICAgICAgIGlmICghc2hvdWxkU2tpcFdhcm5pbmdGb3JSZWFkUGVybWlzc2lvbnMoKSAmJlxuICAgICAgICAgICAgKHBlcm1pc3Npb24gJiBvdGhlcnNDYW5SZWFkRmlsZVBlcm1pc3Npb24pICE9PSAwKSB7XG4gICAgICAgICAgICBMb2dnZXIoKVxuICAgICAgICAgICAgICAgIC53YXJuKGBmaWxlICR7ZmlsZVBhdGh9IGlzIHJlYWRhYmxlIGJ5IHNvbWVvbmUgb3RoZXIgdGhhbiB0aGUgb3duZXIuIFlvdXIgUGVybWlzc2lvbjogJHtwZXJtaXNzaW9uLnRvU3RyaW5nKDgpfS4gSWYgeW91IHdhbnQgXCIrXG5cdFx0XHRcInRvIGRpc2FibGUgdGhpcyB3YXJuaW5nLCBlaXRoZXIgcmVtb3ZlIHJlYWQgcGVybWlzc2lvbnMgZnJvbSBncm91cCBhbmQgb3RoZXJzIG9yIHNldCB0aGUgZW52aXJvbm1lbnQgXCIrXG5cdFx0XHRcInZhcmlhYmxlICR7c2tpcFdhcm5pbmdGb3JSZWFkUGVybWlzc2lvbnNFbnZ9IHRvIHRydWVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHBlcm1pc3Npb24gJiBleGVjdXRhYmxlRmlsZVBlcm1pc3Npb24pICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGUgJHtmaWxlUGF0aH0gaXMgZXhlY3V0YWJsZSDigJQgdGhpcyBwb3NlcyBhIHNlY3VyaXR5IHJpc2sgYmVjYXVzZSB0aGUgZmlsZSBjb3VsZCBiZSBtaXN1c2VkIGFzIGEgc2NyaXB0IG9yIGV4ZWN1dGVkIHVuaW50ZW50aW9uYWxseS4gRmlsZSBQZXJtaXNzaW9uOiAke3Blcm1pc3Npb24udG9TdHJpbmcoOCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwZXJtaXNzaW9uICYgb3RoZXJzQ2FuV3JpdGVGaWxlUGVybWlzc2lvbikgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmlsZSAke2ZpbGVQYXRofSBpcyB3cml0YWJsZSBieSBncm91cCBvciBvdGhlcnMg4oCUIHRoaXMgcG9zZXMgYSBzZWN1cml0eSByaXNrIGJlY2F1c2UgaXQgYWxsb3dzIHVuYXV0aG9yaXplZCB1c2VycyB0byBtb2RpZnkgc2Vuc2l0aXZlIHNldHRpbmdzLiBGaWxlIFBlcm1pc3Npb246ICR7cGVybWlzc2lvbi50b1N0cmluZyg4KX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvL1RoZSBvd25lciBzaG91bGQgaGF2ZSByZWFkIGFuZCB3cml0ZSBwZXJtaXNzaW9uLlxuICAgICAgICBpZiAoKHBlcm1pc3Npb24gJiBvd25lclJlYWRBbmRXcml0ZUZpbGVQZXJtaXNzaW9uKSA9PT0gb3duZXJSZWFkQW5kV3JpdGVGaWxlUGVybWlzc2lvbikge1xuICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFZhbGlkYXRlZCB0aGF0IHRoZSBvd25lciBoYXMgcmVhZCBhbmQgd3JpdGUgcGVybWlzc2lvbiBmb3IgZmlsZTogJHtmaWxlUGF0aH0sIFBlcm1pc3Npb246ICR7cGVybWlzc2lvbi50b1N0cmluZyg4KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWxlIHBlcm1pc3Npb25zICgke3Blcm1pc3Npb24udG9TdHJpbmcoOCl9IGZvciBmaWxlICR7ZmlsZVBhdGh9KS4gTWFrZSBzdXJlIHRoZSBvd25lciBoYXMgcmVhZCBhbmQgd3JpdGUgcGVybWlzc2lvbnMsIGFuZCBvdGhlciB1c2VycyBkbyBub3QgaGF2ZSBhY2Nlc3MgdG8gaXQuIFBsZWFzZSBmaXggdGhlIG93bmVyc2hpcCBhbmQgcGVybWlzc2lvbnMgb2YgdGhlIGZpbGUgb3IgcmVtb3ZlIHRoZSBmaWxlIGFuZCByZS1ydW4gdGhlIGRyaXZlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySW5mbyA9IG9zLnVzZXJJbmZvKCk7XG4gICAgICAgIGlmIChzdGF0cy51aWQgPT09IHVzZXJJbmZvLnVpZCkge1xuICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoJ1ZhbGlkYXRlZCBmaWxlIG93bmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsZSBvd25lciBmb3IgZmlsZSAke2ZpbGVQYXRofSkuIE1ha2Ugc3VyZSB0aGUgdXNlciBydW5uaW5nIHRoZSBzb2Z0d2FyZSBpcyB0aGUgb3duZXIgb2YgdGhlIGZpbGUsIG9yIHJlbW92ZSB0aGUgZmlsZSBhbmQgcmUtcnVuIHRoZSBkcml2ZXIuYCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAvLyBXaGVuIGZpbGUgZG9lc24ndCBleGlzdCAtIHJldHVyblxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgaWYgKHVzZVN5bmMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlUGVybWlzc2lvbnMoc3RhdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmc3Auc3RhdChmaWxlUGF0aCkudGhlbih2YWxpZGF0ZVBlcm1pc3Npb25zKS5jYXRjaChoYW5kbGVFcnJvcik7XG4gICAgfVxufTtcbmV4cG9ydHMudmFsaWRhdGVOb0V4dHJhUGVybWlzc2lvbnNGb3JPdGhlcnNTeW5jID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudmFsaWRhdGVOb0V4dHJhUGVybWlzc2lvbnNGb3JPdGhlcnMoZmlsZVBhdGgsIGZzLCB0cnVlKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgZmlsZSBpcyB3cml0YWJsZSBvbmx5IGJ5IHRoZSB1c2VyIGFuZCBvcyB0aGF0IGZpbGUgb3duZXIgaXMgdGhlIHNhbWUgYXMgb3MgdXNlci4gRnNQcm9taXNlcyBjYW4gYmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0gZmlsZVBhdGhcbiAqIEBwYXJhbSBleHBlY3RlZE1vZGVcbiAqIEBwYXJhbSBmc1Byb21pc2VzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlSGFuZGxlPn1cbiAqL1xuZXhwb3J0cy5nZXRTZWN1cmVIYW5kbGUgPSBhc3luYyBmdW5jdGlvbiAoZmlsZVBhdGgsIGZsYWdzLCBmc1Byb21pc2VzKSB7XG4gICAgY29uc3QgZnNwID0gZnNQcm9taXNlcyA/IGZzUHJvbWlzZXMgOiByZXF1aXJlKCdmcy9wcm9taXNlcycpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGVIYW5kbGUgPSBhd2FpdCBmc3Aub3BlbihmaWxlUGF0aCwgZmxhZ3MsIDBvNjAwKTtcbiAgICAgICAgaWYgKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlSGFuZGxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZmlsZUhhbmRsZS5zdGF0KCk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBzdGF0cy5tb2RlO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gbW9kZSAmIDBvNzc3O1xuICAgICAgICAvL1RoaXMgc2hvdWxkIGJlIDYwMCBwZXJtaXNzaW9uLCB3aGljaCBtZWFucyB0aGUgZmlsZSBwZXJtaXNzaW9uIGhhcyBub3QgYmVlbiBjaGFuZ2VkIGJ5IG90aGVycy5cbiAgICAgICAgaWYgKHBlcm1pc3Npb24gPT09IDBvNjAwKSB7XG4gICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgVmFsaWRhdGVkIHRoYXQgdGhlIHVzZXIgaGFzIG9ubHkgcmVhZCBhbmQgd3JpdGUgcGVybWlzc2lvbiBmb3IgZmlsZTogJHtmaWxlUGF0aH0sIFBlcm1pc3Npb246ICR7cGVybWlzc2lvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWxlIHBlcm1pc3Npb25zICgke3Blcm1pc3Npb24udG9TdHJpbmcoOCl9IGZvciBmaWxlICR7ZmlsZVBhdGh9KS4gTWFrZSBzdXJlIHlvdSBoYXZlIHJlYWQgYW5kIHdyaXRlIHBlcm1pc3Npb25zIGFuZCBvdGhlciB1c2VycyBkbyBub3QgaGF2ZSBhY2Nlc3MgdG8gaXQuIFBsZWFzZSByZW1vdmUgdGhlIGZpbGUgYW5kIHJlLXJ1biB0aGUgZHJpdmVyLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJbmZvID0gb3MudXNlckluZm8oKTtcbiAgICAgICAgaWYgKHN0YXRzLnVpZCA9PT0gdXNlckluZm8udWlkKSB7XG4gICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZygnVmFsaWRhdGVkIGZpbGUgb3duZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWxlIG93bmVyIGZvciBmaWxlICR7ZmlsZVBhdGh9KS4gTWFrZSBzdXJlIHRoZSBzeXN0ZW0gdXNlciBpcyB0aGUgb3duZXIgb2YgdGhlIGZpbGUgb3RoZXJ3aXNlIHBsZWFzZSByZW1vdmUgdGhlIGZpbGUgYW5kIHJlLXJ1biB0aGUgZHJpdmVyLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlSGFuZGxlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vV2hlbiBmaWxlIGRvZXNuJ3QgZXhpc3QgLSByZXR1cm5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5jbG9zZUhhbmRsZSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlSGFuZGxlKSB7XG4gICAgaWYgKGZpbGVIYW5kbGUgIT09IHVuZGVmaW5lZCAmJiBmaWxlSGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IGZpbGVIYW5kbGUuY2xvc2UoKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGZpbGUgb3IgZGlyZWN0b3J5IHBlcm1pc3Npb25zIGFyZSBjb3JyZWN0LlxuICogQHBhcmFtIGZpbGVQYXRoXG4gKiBAcGFyYW0gZXhwZWN0ZWRNb2RlXG4gKiBAcGFyYW0gZnNQcm9taXNlc1xuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHJlc29sdmVzIGFsd2F5cyB0byB0cnVlIGZvciBXaW5kb3dzXG4gKi9cbmV4cG9ydHMuaXNGaWxlTW9kZUNvcnJlY3QgPSBhc3luYyBmdW5jdGlvbiAoZmlsZVBhdGgsIGV4cGVjdGVkTW9kZSwgZnNQcm9taXNlcykge1xuICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgZnNQcm9taXNlcy5zdGF0KGZpbGVQYXRoKS50aGVuKChzdGF0cykgPT4ge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgTFNCIGJpdHMgdG8gOSB3aXRoIHRoZSBtYXNrLCBhcyB0aGUgc3RhdHMubW9kZSBzdGFydHMgd2l0aCB0aGUgZmlsZSB0eXBlLFxuICAgICAgICAvLyBlLmcuIHRoZSBkaXJlY3Rvcnkgd2l0aCBwZXJtaXNzaW9ucyA3NTUgd2lsbCBoYXZlIHN0YXRzLm1hc2sgb2YgNDA3NTUuXG4gICAgICAgIGNvbnN0IG1hc2sgPSAoMSA8PCA5KSAtIDE7XG4gICAgICAgIHJldHVybiAoc3RhdHMubW9kZSAmIG1hc2spID09PSBleHBlY3RlZE1vZGU7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGZpbGUgb3IgZGlyZWN0b3J5IGlzIHdyaXRhYmxlIG9ubHkgYnkgdGhlIHVzZXIuXG4gKiBAcGFyYW0gY29uZmlnRmlsZVBhdGhcbiAqIEBwYXJhbSBmc1Byb21pc2VzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gcmVzb2x2ZXMgYWx3YXlzIHRvIHRydWUgZm9yIFdpbmRvd3NcbiAqL1xuZXhwb3J0cy5pc0ZpbGVOb3RXcml0YWJsZUJ5R3JvdXBPck90aGVycyA9IGFzeW5jIGZ1bmN0aW9uIChjb25maWdGaWxlUGF0aCwgZnNQcm9taXNlcykge1xuICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzUHJvbWlzZXMuc3RhdChjb25maWdGaWxlUGF0aCk7XG4gICAgcmV0dXJuIChzdGF0cy5tb2RlICYgKDEgPDwgNCkpID09PSAwICYmIChzdGF0cy5tb2RlICYgKDEgPDwgMSkpID09PSAwO1xufTtcbi8qKlxuICogR2VuZXJhdGUgY2hlY2tzdW0gZm9yIGdpdmVuIHRleHQuIFRoZSBhbGdvcml0aG0gYW5kIGVuY29kaW5nIGNhbiBiZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB0ZXh0XG4gKiBAcGFyYW0gYWxnb3JpdGhtXG4gKiBAcGFyYW0gZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtQcm9taXNlPFN0cmluZz59IHJlc29sdmVzIGFsd2F5cyB0byB0cnVlIGZvciBXaW5kb3dzXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVDaGVja3N1bSA9IGZ1bmN0aW9uICh0ZXh0LCBhbGdvcml0aG0sIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGNyeXB0b1xuICAgICAgICAuY3JlYXRlSGFzaChhbGdvcml0aG0gfHwgJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUodGV4dCwgJ3V0ZjgnKVxuICAgICAgICAuZGlnZXN0KGVuY29kaW5nIHx8ICdoZXgnKVxuICAgICAgICAuc3Vic3RyaW5nKDAsIDMyKTtcbn07XG5leHBvcnRzLklzRmlsZUV4aXN0ZWQgPSBhc3luYyBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBmc1Byb21pc2VzLmFjY2VzcyhmaWxlUGF0aCwgZnMuY29uc3RhbnRzLkZfT0spO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNraXBXYXJuaW5nRm9yUmVhZFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudltza2lwV2FybmluZ0ZvclJlYWRQZXJtaXNzaW9uc0Vudl0gIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGVfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js":
/*!**************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/global_config.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { XMLParser, XMLValidator } = __webpack_require__(/*! fast-xml-parser */ \"(rsc)/./node_modules/fast-xml-parser/src/fxp.js\");\nlet disableOCSPChecks = false;\n/**\n * Updates the value of the 'disableOCSPChecks' parameter.\n *\n * @param {boolean} value\n */\nexports.setDisableOCSPChecks = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isBoolean(value));\n    disableOCSPChecks = value;\n};\n/**\n * Returns the value of the 'disableOCSPChecks' parameter.\n *\n * @returns {boolean}\n */\nexports.isOCSPChecksDisabled = function () {\n    return disableOCSPChecks;\n};\nlet ocspFailOpen = true;\nexports.ocspFailOpen = ocspFailOpen;\n/**\n * Updates the value of the 'ocspFailOpen' parameter.\n *\n * @param {boolean} value\n */\nexports.setOcspFailOpen = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isBoolean(value));\n    ocspFailOpen = value;\n};\n/**\n * Returns the value of the 'ocspFailOpen' parameter.\n *\n * @param {boolean} value\n */\nexports.getOcspFailOpen = function () {\n    return ocspFailOpen;\n};\nconst ocspModes = {\n    FAIL_CLOSED: 'FAIL_CLOSED',\n    FAIL_OPEN: 'FAIL_OPEN',\n    INSECURE: 'INSECURE',\n};\nexports.ocspModes = ocspModes;\n/**\n * Returns the OCSP mode\n *\n * @returns {string}\n */\nexports.getOcspMode = function () {\n    if (disableOCSPChecks) {\n        return ocspModes.INSECURE;\n    }\n    else if (!ocspFailOpen) {\n        return ocspModes.FAIL_CLOSED;\n    }\n    return ocspModes.FAIL_OPEN;\n};\n/**\n * Returns the upper limit for number of entries we can have in the OCSP response cache.\n *\n * @returns {number}\n */\nexports.getOcspResponseCacheSizeLimit = function () {\n    return 1000;\n};\n/**\n * Returns the maximum time in seconds that entries can live in the OCSP\n * response cache.\n *\n * @returns {number}\n */\nexports.getOcspResponseCacheMaxAge = function () {\n    // 24 hours, in seconds\n    // It was in millionseconds before but the timestamp we save in\n    // cache file was in seconds. Compare that with max age in millionseconds\n    // would makes the cache never expire.\n    // change max age here because customer would have local cache file exist\n    // already and we need to keep that valid with new version of the driver.\n    // use small value for test only\n    let maxage = Number(process.env.SF_OCSP_TEST_CACHE_MAXAGE) || 86400;\n    if (maxage > 86400 || maxage <= 0) {\n        maxage = 86400;\n    }\n    return maxage;\n};\n/**\n * Creates a cache directory.\n *\n * @returns {string}\n */\nexports.mkdirCacheDir = function () {\n    let cacheRootDir = process.env.SF_OCSP_RESPONSE_CACHE_DIR;\n    if (!Util.exists(cacheRootDir)) {\n        cacheRootDir = os.homedir();\n    }\n    if (!Util.exists(cacheRootDir)) {\n        cacheRootDir = os.tmpdir(); // fallback to TMP if user home doesn't exist.\n    }\n    let cacheDir;\n    const platform = os.platform();\n    if (platform === 'darwin') {\n        cacheDir = path.join(cacheRootDir, 'Library', 'Caches', 'Snowflake');\n    }\n    else if (platform === 'win32') {\n        cacheDir = path.join(cacheRootDir, 'AppData', 'Local', 'Snowflake', 'Caches');\n    }\n    else {\n        // linux\n        cacheDir = path.join(cacheRootDir, '.cache', 'snowflake');\n    }\n    try {\n        fs.mkdirSync(cacheDir, { recursive: true });\n    }\n    catch (e) {\n        Logger.getInstance().debug('Failed to create a cache directory %s, err: %s', cacheDir, e);\n    }\n    return cacheDir;\n};\nconst rest = {\n    HTTPS_PORT: 443,\n    HTTPS_PROTOCOL: 'https',\n};\nexports.rest = rest;\n// The default JSON parser\nexports.jsonColumnVariantParser = (rawColumnValue) => new Function(`return (${rawColumnValue});`)();\n/**\n * Updates the value of the 'jsonColumnVariantParser' parameter.\n *\n * @param {function: (rawColumnValue: string) => any} value\n */\nexports.setJsonColumnVariantParser = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isFunction(value));\n    exports.jsonColumnVariantParser = value;\n};\n/**\n * As a default we set parameters values identical like in fast-xml-parser lib defaults\n * thus preserving backward compatibility if customer doesn't set custom configuration\n * and give possibility to set only part of parameters\n */\nconst defaultXmlParserConfiguration = {\n    ignoreAttributes: true,\n    alwaysCreateTextNode: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n};\n// The default XML parser\nexports.xmlColumnVariantParser = createXmlColumnVariantParser(defaultXmlParserConfiguration);\n/**\n * Updates the value of the 'xmlColumnVariantParser' parameter.\n * Return fucntion with custom XmlParser configuration or default if not set.\n *\n * @param {function: (rawColumnValue: string) => any} value\n */\nexports.setXmlColumnVariantParser = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isFunction(value));\n    exports.xmlColumnVariantParser = value;\n};\n/**\n * Create and update the 'xmlColumnVariantParser' parameter using custom parser configuration.\n *\n * @param {function: (rawColumnValue: string) => any} params\n */\nexports.createXmlColumnVariantParserWithParameters = function (params) {\n    exports.xmlColumnVariantParser = createXmlColumnVariantParser(params);\n};\n/**\n * Create function to parse XML using XMlParser with custom configuration.\n * Parametrs that you can override:\n *  ignoreAttributes: true,\n *  attributeNamePrefix: '@_',\n *  attributesGroupName: false,\n *  alwaysCreateTextNode: false\n *\n * @param {object} config\n */\nfunction createXmlColumnVariantParser(config) {\n    let parserConfiguration;\n    if (!Util.isObject(config)) {\n        parserConfiguration = defaultXmlParserConfiguration;\n    }\n    else {\n        parserConfiguration = {\n            ignoreAttributes: Util.exists(config.ignoreAttributes)\n                ? config.ignoreAttributes\n                : defaultXmlParserConfiguration.ignoreAttributes,\n            attributeNamePrefix: Util.exists(config.attributeNamePrefix)\n                ? config.attributeNamePrefix\n                : defaultXmlParserConfiguration.attributeNamePrefix,\n            //For attributesGroupName null value is acceptable and mean no grouping\n            attributesGroupName: config.attributesGroupName !== undefined\n                ? config.attributesGroupName\n                : defaultXmlParserConfiguration.attributesGroupName,\n            alwaysCreateTextNode: Util.exists(config.alwaysCreateTextNode)\n                ? config.alwaysCreateTextNode\n                : defaultXmlParserConfiguration.alwaysCreateTextNode,\n        };\n    }\n    return (rawColumnValue) => {\n        // check if raw string is in XML format\n        // ensure each tag is enclosed and all attributes and elements are valid\n        // XMLValidator.validate returns true if valid, returns an error if invalid\n        const validateResult = XMLValidator.validate(rawColumnValue);\n        if (validateResult === true) {\n            // use XML parser\n            return new XMLParser(parserConfiguration).parse(rawColumnValue);\n        }\n        else {\n            throw new Error(validateResult.err.msg);\n        }\n    };\n}\nlet keepAlive = true;\n/**\n * Updates the value of the 'keepAlive' parameter.\n *\n * @param {boolean} value\n */\nexports.setKeepAlive = function (value) {\n    Errors.assertInternal(Util.isBoolean(value));\n    keepAlive = value;\n};\n/**\n * Returns the overriden value of 'keepAlive' or default if not set. Default value is true\n *\n * @param {boolean} value\n */\nexports.getKeepAlive = function () {\n    return keepAlive;\n};\nlet credentialManager = null;\nexports.setCustomCredentialManager = function (customCredentialManager) {\n    Errors.checkArgumentValid(Util.checkValidCustomCredentialManager(customCredentialManager), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER);\n    credentialManager = customCredentialManager;\n    Logger.getInstance().info('Custom credential manager is set by a user.');\n};\nexports.getCredentialManager = function () {\n    return credentialManager;\n};\nlet envProxy = true;\nexports.setEnvProxy = function (value) {\n    Errors.assertInternal(Util.isBoolean(value));\n    envProxy = value;\n};\nexports.isEnvProxyActive = function () {\n    return envProxy;\n};\nlet customRedirectingClient;\nexports.setCustomRedirectingClient = function (value) {\n    customRedirectingClient = value;\n};\nexports.getCustomRedirectingClient = function () {\n    return customRedirectingClient;\n};\n//# sourceMappingURL=global_config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9nbG9iYWxfY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsdUVBQVU7QUFDakMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsK0JBQStCLCtDQUErQyxlQUFlLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLElBQUksOEJBQThCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQsSUFBSSw4QkFBOEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZ2xvYmFsX2NvbmZpZy5qcz8xYjMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbmNvbnN0IHsgWE1MUGFyc2VyLCBYTUxWYWxpZGF0b3IgfSA9IHJlcXVpcmUoJ2Zhc3QteG1sLXBhcnNlcicpO1xubGV0IGRpc2FibGVPQ1NQQ2hlY2tzID0gZmFsc2U7XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSAnZGlzYWJsZU9DU1BDaGVja3MnIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKi9cbmV4cG9ydHMuc2V0RGlzYWJsZU9DU1BDaGVja3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQm9vbGVhbih2YWx1ZSkpO1xuICAgIGRpc2FibGVPQ1NQQ2hlY2tzID0gdmFsdWU7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgJ2Rpc2FibGVPQ1NQQ2hlY2tzJyBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNPQ1NQQ2hlY2tzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc2FibGVPQ1NQQ2hlY2tzO1xufTtcbmxldCBvY3NwRmFpbE9wZW4gPSB0cnVlO1xuZXhwb3J0cy5vY3NwRmFpbE9wZW4gPSBvY3NwRmFpbE9wZW47XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSAnb2NzcEZhaWxPcGVuJyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICovXG5leHBvcnRzLnNldE9jc3BGYWlsT3BlbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNCb29sZWFuKHZhbHVlKSk7XG4gICAgb2NzcEZhaWxPcGVuID0gdmFsdWU7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgJ29jc3BGYWlsT3BlbicgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqL1xuZXhwb3J0cy5nZXRPY3NwRmFpbE9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9jc3BGYWlsT3Blbjtcbn07XG5jb25zdCBvY3NwTW9kZXMgPSB7XG4gICAgRkFJTF9DTE9TRUQ6ICdGQUlMX0NMT1NFRCcsXG4gICAgRkFJTF9PUEVOOiAnRkFJTF9PUEVOJyxcbiAgICBJTlNFQ1VSRTogJ0lOU0VDVVJFJyxcbn07XG5leHBvcnRzLm9jc3BNb2RlcyA9IG9jc3BNb2Rlcztcbi8qKlxuICogUmV0dXJucyB0aGUgT0NTUCBtb2RlXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5nZXRPY3NwTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGlzYWJsZU9DU1BDaGVja3MpIHtcbiAgICAgICAgcmV0dXJuIG9jc3BNb2Rlcy5JTlNFQ1VSRTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9jc3BGYWlsT3Blbikge1xuICAgICAgICByZXR1cm4gb2NzcE1vZGVzLkZBSUxfQ0xPU0VEO1xuICAgIH1cbiAgICByZXR1cm4gb2NzcE1vZGVzLkZBSUxfT1BFTjtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHVwcGVyIGxpbWl0IGZvciBudW1iZXIgb2YgZW50cmllcyB3ZSBjYW4gaGF2ZSBpbiB0aGUgT0NTUCByZXNwb25zZSBjYWNoZS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldE9jc3BSZXNwb25zZUNhY2hlU2l6ZUxpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAxMDAwO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSB0aW1lIGluIHNlY29uZHMgdGhhdCBlbnRyaWVzIGNhbiBsaXZlIGluIHRoZSBPQ1NQXG4gKiByZXNwb25zZSBjYWNoZS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldE9jc3BSZXNwb25zZUNhY2hlTWF4QWdlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIDI0IGhvdXJzLCBpbiBzZWNvbmRzXG4gICAgLy8gSXQgd2FzIGluIG1pbGxpb25zZWNvbmRzIGJlZm9yZSBidXQgdGhlIHRpbWVzdGFtcCB3ZSBzYXZlIGluXG4gICAgLy8gY2FjaGUgZmlsZSB3YXMgaW4gc2Vjb25kcy4gQ29tcGFyZSB0aGF0IHdpdGggbWF4IGFnZSBpbiBtaWxsaW9uc2Vjb25kc1xuICAgIC8vIHdvdWxkIG1ha2VzIHRoZSBjYWNoZSBuZXZlciBleHBpcmUuXG4gICAgLy8gY2hhbmdlIG1heCBhZ2UgaGVyZSBiZWNhdXNlIGN1c3RvbWVyIHdvdWxkIGhhdmUgbG9jYWwgY2FjaGUgZmlsZSBleGlzdFxuICAgIC8vIGFscmVhZHkgYW5kIHdlIG5lZWQgdG8ga2VlcCB0aGF0IHZhbGlkIHdpdGggbmV3IHZlcnNpb24gb2YgdGhlIGRyaXZlci5cbiAgICAvLyB1c2Ugc21hbGwgdmFsdWUgZm9yIHRlc3Qgb25seVxuICAgIGxldCBtYXhhZ2UgPSBOdW1iZXIocHJvY2Vzcy5lbnYuU0ZfT0NTUF9URVNUX0NBQ0hFX01BWEFHRSkgfHwgODY0MDA7XG4gICAgaWYgKG1heGFnZSA+IDg2NDAwIHx8IG1heGFnZSA8PSAwKSB7XG4gICAgICAgIG1heGFnZSA9IDg2NDAwO1xuICAgIH1cbiAgICByZXR1cm4gbWF4YWdlO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIGRpcmVjdG9yeS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLm1rZGlyQ2FjaGVEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGNhY2hlUm9vdERpciA9IHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfRElSO1xuICAgIGlmICghVXRpbC5leGlzdHMoY2FjaGVSb290RGlyKSkge1xuICAgICAgICBjYWNoZVJvb3REaXIgPSBvcy5ob21lZGlyKCk7XG4gICAgfVxuICAgIGlmICghVXRpbC5leGlzdHMoY2FjaGVSb290RGlyKSkge1xuICAgICAgICBjYWNoZVJvb3REaXIgPSBvcy50bXBkaXIoKTsgLy8gZmFsbGJhY2sgdG8gVE1QIGlmIHVzZXIgaG9tZSBkb2Vzbid0IGV4aXN0LlxuICAgIH1cbiAgICBsZXQgY2FjaGVEaXI7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgICAgY2FjaGVEaXIgPSBwYXRoLmpvaW4oY2FjaGVSb290RGlyLCAnTGlicmFyeScsICdDYWNoZXMnLCAnU25vd2ZsYWtlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIGNhY2hlRGlyID0gcGF0aC5qb2luKGNhY2hlUm9vdERpciwgJ0FwcERhdGEnLCAnTG9jYWwnLCAnU25vd2ZsYWtlJywgJ0NhY2hlcycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbGludXhcbiAgICAgICAgY2FjaGVEaXIgPSBwYXRoLmpvaW4oY2FjaGVSb290RGlyLCAnLmNhY2hlJywgJ3Nub3dmbGFrZScpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBmcy5ta2RpclN5bmMoY2FjaGVEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGRpcmVjdG9yeSAlcywgZXJyOiAlcycsIGNhY2hlRGlyLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlRGlyO1xufTtcbmNvbnN0IHJlc3QgPSB7XG4gICAgSFRUUFNfUE9SVDogNDQzLFxuICAgIEhUVFBTX1BST1RPQ09MOiAnaHR0cHMnLFxufTtcbmV4cG9ydHMucmVzdCA9IHJlc3Q7XG4vLyBUaGUgZGVmYXVsdCBKU09OIHBhcnNlclxuZXhwb3J0cy5qc29uQ29sdW1uVmFyaWFudFBhcnNlciA9IChyYXdDb2x1bW5WYWx1ZSkgPT4gbmV3IEZ1bmN0aW9uKGByZXR1cm4gKCR7cmF3Q29sdW1uVmFsdWV9KTtgKSgpO1xuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgJ2pzb25Db2x1bW5WYXJpYW50UGFyc2VyJyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbjogKHJhd0NvbHVtblZhbHVlOiBzdHJpbmcpID0+IGFueX0gdmFsdWVcbiAqL1xuZXhwb3J0cy5zZXRKc29uQ29sdW1uVmFyaWFudFBhcnNlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNGdW5jdGlvbih2YWx1ZSkpO1xuICAgIGV4cG9ydHMuanNvbkNvbHVtblZhcmlhbnRQYXJzZXIgPSB2YWx1ZTtcbn07XG4vKipcbiAqIEFzIGEgZGVmYXVsdCB3ZSBzZXQgcGFyYW1ldGVycyB2YWx1ZXMgaWRlbnRpY2FsIGxpa2UgaW4gZmFzdC14bWwtcGFyc2VyIGxpYiBkZWZhdWx0c1xuICogdGh1cyBwcmVzZXJ2aW5nIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaWYgY3VzdG9tZXIgZG9lc24ndCBzZXQgY3VzdG9tIGNvbmZpZ3VyYXRpb25cbiAqIGFuZCBnaXZlIHBvc3NpYmlsaXR5IHRvIHNldCBvbmx5IHBhcnQgb2YgcGFyYW1ldGVyc1xuICovXG5jb25zdCBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGFsd2F5c0NyZWF0ZVRleHROb2RlOiBmYWxzZSxcbiAgICBhdHRyaWJ1dGVOYW1lUHJlZml4OiAnQF8nLFxuICAgIGF0dHJpYnV0ZXNHcm91cE5hbWU6IGZhbHNlLFxufTtcbi8vIFRoZSBkZWZhdWx0IFhNTCBwYXJzZXJcbmV4cG9ydHMueG1sQ29sdW1uVmFyaWFudFBhcnNlciA9IGNyZWF0ZVhtbENvbHVtblZhcmlhbnRQYXJzZXIoZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb24pO1xuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgJ3htbENvbHVtblZhcmlhbnRQYXJzZXInIHBhcmFtZXRlci5cbiAqIFJldHVybiBmdWNudGlvbiB3aXRoIGN1c3RvbSBYbWxQYXJzZXIgY29uZmlndXJhdGlvbiBvciBkZWZhdWx0IGlmIG5vdCBzZXQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbjogKHJhd0NvbHVtblZhbHVlOiBzdHJpbmcpID0+IGFueX0gdmFsdWVcbiAqL1xuZXhwb3J0cy5zZXRYbWxDb2x1bW5WYXJpYW50UGFyc2VyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Z1bmN0aW9uKHZhbHVlKSk7XG4gICAgZXhwb3J0cy54bWxDb2x1bW5WYXJpYW50UGFyc2VyID0gdmFsdWU7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHVwZGF0ZSB0aGUgJ3htbENvbHVtblZhcmlhbnRQYXJzZXInIHBhcmFtZXRlciB1c2luZyBjdXN0b20gcGFyc2VyIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbjogKHJhd0NvbHVtblZhbHVlOiBzdHJpbmcpID0+IGFueX0gcGFyYW1zXG4gKi9cbmV4cG9ydHMuY3JlYXRlWG1sQ29sdW1uVmFyaWFudFBhcnNlcldpdGhQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGV4cG9ydHMueG1sQ29sdW1uVmFyaWFudFBhcnNlciA9IGNyZWF0ZVhtbENvbHVtblZhcmlhbnRQYXJzZXIocGFyYW1zKTtcbn07XG4vKipcbiAqIENyZWF0ZSBmdW5jdGlvbiB0byBwYXJzZSBYTUwgdXNpbmcgWE1sUGFyc2VyIHdpdGggY3VzdG9tIGNvbmZpZ3VyYXRpb24uXG4gKiBQYXJhbWV0cnMgdGhhdCB5b3UgY2FuIG92ZXJyaWRlOlxuICogIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWUsXG4gKiAgYXR0cmlidXRlTmFtZVByZWZpeDogJ0BfJyxcbiAqICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBmYWxzZSxcbiAqICBhbHdheXNDcmVhdGVUZXh0Tm9kZTogZmFsc2VcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVhtbENvbHVtblZhcmlhbnRQYXJzZXIoY29uZmlnKSB7XG4gICAgbGV0IHBhcnNlckNvbmZpZ3VyYXRpb247XG4gICAgaWYgKCFVdGlsLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgcGFyc2VyQ29uZmlndXJhdGlvbiA9IGRlZmF1bHRYbWxQYXJzZXJDb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyc2VyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgIGlnbm9yZUF0dHJpYnV0ZXM6IFV0aWwuZXhpc3RzKGNvbmZpZy5pZ25vcmVBdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgID8gY29uZmlnLmlnbm9yZUF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRYbWxQYXJzZXJDb25maWd1cmF0aW9uLmlnbm9yZUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lUHJlZml4OiBVdGlsLmV4aXN0cyhjb25maWcuYXR0cmlidXRlTmFtZVByZWZpeClcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5hdHRyaWJ1dGVOYW1lUHJlZml4XG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbi5hdHRyaWJ1dGVOYW1lUHJlZml4LFxuICAgICAgICAgICAgLy9Gb3IgYXR0cmlidXRlc0dyb3VwTmFtZSBudWxsIHZhbHVlIGlzIGFjY2VwdGFibGUgYW5kIG1lYW4gbm8gZ3JvdXBpbmdcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNHcm91cE5hbWU6IGNvbmZpZy5hdHRyaWJ1dGVzR3JvdXBOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5hdHRyaWJ1dGVzR3JvdXBOYW1lXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbi5hdHRyaWJ1dGVzR3JvdXBOYW1lLFxuICAgICAgICAgICAgYWx3YXlzQ3JlYXRlVGV4dE5vZGU6IFV0aWwuZXhpc3RzKGNvbmZpZy5hbHdheXNDcmVhdGVUZXh0Tm9kZSlcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5hbHdheXNDcmVhdGVUZXh0Tm9kZVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb24uYWx3YXlzQ3JlYXRlVGV4dE5vZGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAocmF3Q29sdW1uVmFsdWUpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgcmF3IHN0cmluZyBpcyBpbiBYTUwgZm9ybWF0XG4gICAgICAgIC8vIGVuc3VyZSBlYWNoIHRhZyBpcyBlbmNsb3NlZCBhbmQgYWxsIGF0dHJpYnV0ZXMgYW5kIGVsZW1lbnRzIGFyZSB2YWxpZFxuICAgICAgICAvLyBYTUxWYWxpZGF0b3IudmFsaWRhdGUgcmV0dXJucyB0cnVlIGlmIHZhbGlkLCByZXR1cm5zIGFuIGVycm9yIGlmIGludmFsaWRcbiAgICAgICAgY29uc3QgdmFsaWRhdGVSZXN1bHQgPSBYTUxWYWxpZGF0b3IudmFsaWRhdGUocmF3Q29sdW1uVmFsdWUpO1xuICAgICAgICBpZiAodmFsaWRhdGVSZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHVzZSBYTUwgcGFyc2VyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTFBhcnNlcihwYXJzZXJDb25maWd1cmF0aW9uKS5wYXJzZShyYXdDb2x1bW5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGVSZXN1bHQuZXJyLm1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxubGV0IGtlZXBBbGl2ZSA9IHRydWU7XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSAna2VlcEFsaXZlJyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICovXG5leHBvcnRzLnNldEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQm9vbGVhbih2YWx1ZSkpO1xuICAgIGtlZXBBbGl2ZSA9IHZhbHVlO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgb3ZlcnJpZGVuIHZhbHVlIG9mICdrZWVwQWxpdmUnIG9yIGRlZmF1bHQgaWYgbm90IHNldC4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICovXG5leHBvcnRzLmdldEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ga2VlcEFsaXZlO1xufTtcbmxldCBjcmVkZW50aWFsTWFuYWdlciA9IG51bGw7XG5leHBvcnRzLnNldEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyID0gZnVuY3Rpb24gKGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmNoZWNrVmFsaWRDdXN0b21DcmVkZW50aWFsTWFuYWdlcihjdXN0b21DcmVkZW50aWFsTWFuYWdlciksIEVycm9yQ29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9DVVNUT01fQ1JFREVOVElBTF9NQU5BR0VSKTtcbiAgICBjcmVkZW50aWFsTWFuYWdlciA9IGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0N1c3RvbSBjcmVkZW50aWFsIG1hbmFnZXIgaXMgc2V0IGJ5IGEgdXNlci4nKTtcbn07XG5leHBvcnRzLmdldENyZWRlbnRpYWxNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVkZW50aWFsTWFuYWdlcjtcbn07XG5sZXQgZW52UHJveHkgPSB0cnVlO1xuZXhwb3J0cy5zZXRFbnZQcm94eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQm9vbGVhbih2YWx1ZSkpO1xuICAgIGVudlByb3h5ID0gdmFsdWU7XG59O1xuZXhwb3J0cy5pc0VudlByb3h5QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbnZQcm94eTtcbn07XG5sZXQgY3VzdG9tUmVkaXJlY3RpbmdDbGllbnQ7XG5leHBvcnRzLnNldEN1c3RvbVJlZGlyZWN0aW5nQ2xpZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgY3VzdG9tUmVkaXJlY3RpbmdDbGllbnQgPSB2YWx1ZTtcbn07XG5leHBvcnRzLmdldEN1c3RvbVJlZGlyZWN0aW5nQ2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjdXN0b21SZWRpcmVjdGluZ0NsaWVudDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxfY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/global_config_typed.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.globalConfigCustomValues = exports.GLOBAL_CONFIG_DEFAULTS = void 0;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst disk_cache_1 = __webpack_require__(/*! ./disk_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js\");\nexports.GLOBAL_CONFIG_DEFAULTS = {\n    crlDownloadTimeout: 10000,\n    crlCacheValidityTime: 86400000,\n    get crlCacheDir() {\n        return process.env.SNOWFLAKE_CRL_ON_DISK_CACHE_DIR || path_1.default.join((0, disk_cache_1.getDefaultCacheDir)(), 'crls');\n    },\n};\nexports.globalConfigCustomValues = {};\nexports[\"default\"] = {\n    setValues: (options) => {\n        const filteredOptions = Object.fromEntries(Object.entries(options).filter(([key, value]) => key in exports.GLOBAL_CONFIG_DEFAULTS && value !== undefined));\n        (0, logger_1.default)().debug('Setting global config typed values: %j', filteredOptions);\n        Object.assign(exports.globalConfigCustomValues, filteredOptions);\n    },\n    getValue: (key) => {\n        return exports.globalConfigCustomValues[key] ?? exports.GLOBAL_CONFIG_DEFAULTS[key];\n    },\n};\n//# sourceMappingURL=global_config_typed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9nbG9iYWxfY29uZmlnX3R5cGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcsOEJBQThCO0FBQ2pFLCtCQUErQixtQkFBTyxDQUFDLGtCQUFNO0FBQzdDLGlDQUFpQyxtQkFBTyxDQUFDLHVFQUFVO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLCtFQUFjO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQyxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZ2xvYmFsX2NvbmZpZ190eXBlZC5qcz8wOWExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nbG9iYWxDb25maWdDdXN0b21WYWx1ZXMgPSBleHBvcnRzLkdMT0JBTF9DT05GSUdfREVGQVVMVFMgPSB2b2lkIDA7XG5jb25zdCBwYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGRpc2tfY2FjaGVfMSA9IHJlcXVpcmUoXCIuL2Rpc2tfY2FjaGVcIik7XG5leHBvcnRzLkdMT0JBTF9DT05GSUdfREVGQVVMVFMgPSB7XG4gICAgY3JsRG93bmxvYWRUaW1lb3V0OiAxMDAwMCxcbiAgICBjcmxDYWNoZVZhbGlkaXR5VGltZTogODY0MDAwMDAsXG4gICAgZ2V0IGNybENhY2hlRGlyKCkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuU05PV0ZMQUtFX0NSTF9PTl9ESVNLX0NBQ0hFX0RJUiB8fCBwYXRoXzEuZGVmYXVsdC5qb2luKCgwLCBkaXNrX2NhY2hlXzEuZ2V0RGVmYXVsdENhY2hlRGlyKSgpLCAnY3JscycpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5nbG9iYWxDb25maWdDdXN0b21WYWx1ZXMgPSB7fTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBzZXRWYWx1ZXM6IChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkT3B0aW9ucyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvcHRpb25zKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ga2V5IGluIGV4cG9ydHMuR0xPQkFMX0NPTkZJR19ERUZBVUxUUyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdTZXR0aW5nIGdsb2JhbCBjb25maWcgdHlwZWQgdmFsdWVzOiAlaicsIGZpbHRlcmVkT3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5nbG9iYWxDb25maWdDdXN0b21WYWx1ZXMsIGZpbHRlcmVkT3B0aW9ucyk7XG4gICAgfSxcbiAgICBnZXRWYWx1ZTogKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5nbG9iYWxDb25maWdDdXN0b21WYWx1ZXNba2V5XSA/PyBleHBvcnRzLkdMT0JBTF9DT05GSUdfREVGQVVMVFNba2V5XTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbF9jb25maWdfdHlwZWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/base.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\nconst axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nconst URL = (__webpack_require__(/*! node:url */ \"node:url\").URL);\nconst requestUtil = __webpack_require__(/*! ./request_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js\");\nconst DEFAULT_REQUEST_TIMEOUT = 360000;\n/**\n * Creates a new HTTP client.\n *\n * @param connectionConfig\n * @constructor\n */\nfunction HttpClient(connectionConfig) {\n    // save the connection config\n    Logger.getInstance().trace('Initializing base HttpClient with Connection Config[%s]', connectionConfig.describeIdentityAttributes());\n    this._connectionConfig = connectionConfig;\n}\n/**\n * Issues an HTTP request.\n *\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.request = function (options) {\n    Logger.getInstance().trace('Request%s - preparing for sending.', requestUtil.describeRequestFromOptions(options));\n    const requestObject = {};\n    const requestAbortController = new AbortController();\n    const requestHandlers = { signal: requestAbortController.signal };\n    const requestOptions = prepareRequestOptions.call(this, options, requestHandlers);\n    let sendRequest = async function sendRequest() {\n        Logger.getInstance().trace('Request%s - sending.', requestUtil.describeRequestFromOptions(requestOptions));\n        const timer = new ExecutionTimer().start();\n        requestObject.requestPromise = axios\n            .request(requestOptions)\n            .then((response) => {\n            const httpResponseTime = timer.getDuration();\n            Logger.getInstance().debug('Request%s - response received after %s milliseconds with status %s.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime, response.status);\n            parseResponseData(response);\n            sanitizeAxiosResponse(response);\n            if (Util.isFunction(options.callback)) {\n                Logger.getInstance().trace('Request%s - calling callback function.', requestUtil.describeRequestFromOptions(requestOptions));\n                return options.callback(null, normalizeResponse(response), response.data);\n            }\n            else {\n                Logger.getInstance().trace('Request%s - callback function was not provided.', requestUtil.describeRequestFromOptions(requestOptions));\n                return null;\n            }\n        })\n            .catch((err) => {\n            const httpResponseTime = timer.getDuration();\n            Logger.getInstance().debug('Request%s - failed after %s milliseconds.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime);\n            sanitizeAxiosError(err);\n            if (Util.isFunction(options.callback)) {\n                if (err.response) {\n                    // axios returns error for not 2xx responses - let's unwrap it\n                    Logger.getInstance().trace('Request%s - calling callback function for error from response. Received code: ', requestUtil.describeRequestFromOptions(requestOptions), err.response.status);\n                    options.callback(null, normalizeResponse(err.response), err.response.data);\n                }\n                else {\n                    Logger.getInstance().trace('Request%s - calling callback function for error without response.', requestUtil.describeRequestFromOptions(requestOptions));\n                    options.callback(err, normalizeResponse(null), null);\n                }\n                return null;\n            }\n            else {\n                Logger.getInstance().warn('Request%s - callback function was not provided. Error will be re-raised.', requestUtil.describeRequestFromOptions(requestOptions));\n                throw err;\n            }\n        });\n    };\n    sendRequest = sendRequest.bind(this);\n    Logger.getInstance().trace('Request%s - issued for the next tick.', requestUtil.describeRequestFromOptions(requestOptions));\n    process.nextTick(sendRequest);\n    // return an externalized request object that only contains\n    // methods we're comfortable exposing to the outside world\n    requestObject.abort = function () {\n        if (requestAbortController) {\n            Logger.getInstance().trace('Request%s - aborting.', requestUtil.describeRequestFromOptions(requestOptions));\n            requestAbortController.abort();\n            Logger.getInstance().debug('Request%s - aborted.', requestUtil.describeRequestFromOptions(requestOptions));\n        }\n    };\n    return requestObject;\n};\n/**\n * Issues an HTTP request.\n *\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.requestAsync = async function (options) {\n    Logger.getInstance().trace('Request%s - preparing for async sending.', requestUtil.describeRequestFromOptions(options));\n    const timer = new ExecutionTimer();\n    try {\n        const requestOptions = prepareRequestOptions.call(this, options);\n        timer.start();\n        const response = await axios.request(requestOptions);\n        const httpResponseTime = timer.getDuration();\n        Logger.getInstance().debug('Request%s - response received after %s milliseconds with status %s.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime, response.status);\n        parseResponseData(response);\n        sanitizeAxiosResponse(response);\n        return normalizeResponse(response);\n    }\n    catch (err) {\n        const httpResponseTime = timer.getDuration();\n        Logger.getInstance().debug('Request%s - failed after %s milliseconds. Error will be re-raised.', requestUtil.describeRequestFromOptions(options), httpResponseTime);\n        sanitizeAxiosError(err);\n        throw err;\n    }\n};\nfunction parseResponseData(response) {\n    Logger.getInstance().trace('Request%s - parsing response data.', requestUtil.describeRequestFromResponse(response));\n    parseIfJSONData(response);\n}\nfunction parseIfJSONData(response) {\n    if (Util.isString(response['data']) &&\n        response['headers']['content-type'] === 'application/json') {\n        // NOTE:\n        // A super hacky solution to patch /queries/v1/query-request response for PUT/GET operations\n        // Returned encryptionMaterial.smkId is an integer, that might be higher than Number.MAX_SAFE_INTEGER\n        // Treating it as integer will result in uploaded files being UNRECOVERABLE\n        //\n        // This should be replaced with new API field that is a string\n        if (response['data'].includes('smkId')) {\n            response['data'] = Util.convertSmkIdToString(response['data']);\n        }\n        response['json'] = response['data'];\n        response['data'] = JSON.parse(response['data']);\n    }\n}\n/**\n * Issues an HTTP POST request.\n *\n * @param {String} url\n * @param {String} body\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.post = async function (url, body, options) {\n    return this.requestAsync({\n        url: url,\n        method: 'POST',\n        data: body,\n        ...options,\n    });\n};\n/**\n * Issues an HTTP GET request.\n *\n * @param {String} url\n * @param {Object} params\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.get = async function (url, params) {\n    return this.requestAsync({\n        url: url,\n        method: 'GET',\n        ...params,\n    });\n};\n/**\n * Issues an HTTP HEAD request.\n *\n * @param {String} url\n * @param {Object} config\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.head = async function (url, config) {\n    return this.requestAsync({\n        url: url,\n        method: 'HEAD',\n        ...config,\n    });\n};\n/**\n * Issues an HTTP PUT request.\n *\n * @param {String} url\n * @param {Object} data\n * @param {Object} config\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.put = async function (url, data, config) {\n    return this.requestAsync({\n        url: url,\n        method: 'PUT',\n        data: data,\n        ...config,\n    });\n};\n/**\n * @abstract\n * Returns the module to use when making HTTP requests. Subclasses must override\n * and provide their own implementations.\n *\n * @returns {*}\n */\nHttpClient.prototype.getRequestModule = function () {\n    return null;\n};\n/**\n * Returns the agent and proxy options.\n *\n * @returns {*}\n */\nHttpClient.prototype.getAgent = function () {\n    return null;\n};\nmodule.exports = HttpClient;\nfunction sanitizeAxiosResponse(response) {\n    Logger.getInstance().trace('Request%s - sanitizing response data.', requestUtil.describeRequestFromResponse(response));\n    response.request = undefined;\n    if (response.config) {\n        response.config.data = undefined;\n        response.config.headers = undefined;\n    }\n}\nfunction sanitizeAxiosError(error) {\n    error.request = undefined;\n    error.config = undefined;\n    if (error.response) {\n        Logger.getInstance().trace('Request%s - sanitizing response error data.', requestUtil.describeRequestFromResponse(error.response));\n        sanitizeAxiosResponse(error.response);\n    }\n}\nfunction prepareRequestOptions(options, requestHandlers = {}) {\n    Logger.getInstance().trace('Request%s - constructing options.', requestUtil.describeRequestFromOptions(options));\n    const headers = normalizeHeaders(options.headers) || {};\n    const timeout = options.timeout || this._connectionConfig.getTimeout() || DEFAULT_REQUEST_TIMEOUT;\n    let data = options.data || options.json || options.body;\n    if (data) {\n        const bufferUncompressed = Buffer.from(JSON.stringify(data), 'utf8');\n        zlib.gzip(bufferUncompressed, null, function (err, bufferCompressed) {\n            // if the compression was successful\n            if (!err) {\n                data = bufferCompressed;\n                headers['Content-Encoding'] = 'gzip';\n                Logger.getInstance().debug('Request%s - original buffer length: %d bytes. Compressed buffer length: %d bytes.', requestUtil.describeRequestFromOptions(options), bufferUncompressed.buffer.byteLength, bufferCompressed.buffer.byteLength);\n            }\n            else {\n                // Logging 'err' variable value should not be done, since it may contain compressed customer's data.\n                // It can be added only for debugging purposes.\n                Logger.getInstance().warn('Request%s - could not compress request data.', requestUtil.describeRequestFromOptions(options));\n            }\n        });\n    }\n    const params = options.params;\n    let mock;\n    if (this._connectionConfig.agentClass) {\n        mock = {\n            agentClass: this._connectionConfig.agentClass,\n        };\n    }\n    const backoffStrategy = this.constructExponentialBackoffStrategy();\n    const requestOptions = {\n        method: options.method,\n        url: options.url,\n        headers: headers,\n        data: data,\n        params: params,\n        timeout: timeout,\n        requestOCSP: true,\n        retryDelay: backoffStrategy,\n        rejectUnauthorized: true,\n        // we manually parse jsons or other structures from the server so they need to be text\n        responseType: options.responseType || 'text',\n        proxy: false,\n        ...requestHandlers,\n    };\n    const url = new URL(options.url);\n    const isHttps = url.protocol === 'https:';\n    const agent = this.getAgent(url, this._connectionConfig.getProxy(), mock);\n    if (isHttps) {\n        requestOptions.httpsAgent = agent;\n    }\n    else {\n        requestOptions.httpAgent = agent;\n    }\n    Logger.getInstance().debug('Request%s - options - timeout: %s, retryDelay: %s, responseType: %s', requestUtil.describeRequestFromOptions(options), requestOptions.timeout, requestOptions.retryDelay, requestOptions.responseType);\n    return requestOptions;\n}\n/**\n * Normalizes a request headers object so that we get the same behavior\n * regardless of whether we're using request.js or browser-request.js.\n *\n * @param {Object} headers\n *\n * @returns {Object}\n */\nfunction normalizeHeaders(headers) {\n    Logger.getInstance().trace('Normalizing headers');\n    if (Util.isObject(headers)) {\n        const normalizedHeaders = {\n            'user-agent': Util.userAgent,\n        };\n        // shallow copy the headers object and convert some headers like 'Accept'\n        // and 'Content-Type' to lower case while copying; this is necessary\n        // because the browser-request module, which we use to make http requests in\n        // the browser, does not do case-insensitive checks when deciding whether to\n        // insert default values for the 'accept' and 'content-type' headers; in\n        // otherwise, if someone specifies an 'Accept': 'application/json' header,\n        // browser-request will inject its own 'accept': 'application/json' header\n        // and the browser XMLHttpRequest object will concatenate the two values and\n        // send 'Accept': 'application/json, application/json' with the request\n        let headerNameLowerCase;\n        for (const headerName in headers) {\n            if (Object.prototype.hasOwnProperty.call(headers, headerName)) {\n                headerNameLowerCase = headerName.toLowerCase();\n                if (headerNameLowerCase === 'accept' || headerNameLowerCase === 'content-type') {\n                    normalizedHeaders[headerNameLowerCase] = headers[headerName];\n                }\n                else {\n                    normalizedHeaders[headerName] = headers[headerName];\n                }\n            }\n        }\n        Logger.getInstance().trace('Headers were normalized');\n        return normalizedHeaders;\n    }\n    else {\n        Logger.getInstance().trace('Headers were not an object. Original value will be returned.');\n        return headers;\n    }\n}\n/**\n * Normalizes the response object so that we can extract response headers from\n * it in a uniform way regardless of whether we're using request.js or\n * browser-request.js.\n *\n * @param {Object} response\n *\n * @return {Object}\n */\nfunction normalizeResponse(response) {\n    // if the response doesn't already have a getResponseHeader() method, add one\n    if (response && !response.getResponseHeader) {\n        Logger.getInstance().trace('Request%s - normalizing.', requestUtil.describeRequestFromResponse(response));\n        response.getResponseHeader = function (header) {\n            return (response.headers && response.headers[Util.isString(header) ? header.toLowerCase() : header]);\n        };\n    }\n    if (response) {\n        response.body = response.data; // converting axios response body to old expected body attribute\n        response.statusCode = response.status; // converting axios status to old expected statusCode\n    }\n    return response;\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL2Jhc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDMUQsY0FBYyxtQkFBTyxDQUFDLDZEQUFPO0FBQzdCLFlBQVkscURBQXVCO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHdGQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL2Jhc2UuanM/OWM2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBFeGVjdXRpb25UaW1lciA9IHJlcXVpcmUoJy4uL2xvZ2dlci9leGVjdXRpb25fdGltZXInKTtcbmNvbnN0IGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbmNvbnN0IFVSTCA9IHJlcXVpcmUoJ25vZGU6dXJsJykuVVJMO1xuY29uc3QgcmVxdWVzdFV0aWwgPSByZXF1aXJlKCcuL3JlcXVlc3RfdXRpbCcpO1xuY29uc3QgREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQgPSAzNjAwMDA7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgSFRUUCBjbGllbnQuXG4gKlxuICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdHRwQ2xpZW50KGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvLyBzYXZlIHRoZSBjb25uZWN0aW9uIGNvbmZpZ1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdJbml0aWFsaXppbmcgYmFzZSBIdHRwQ2xpZW50IHdpdGggQ29ubmVjdGlvbiBDb25maWdbJXNdJywgY29ubmVjdGlvbkNvbmZpZy5kZXNjcmliZUlkZW50aXR5QXR0cmlidXRlcygpKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbn1cbi8qKlxuICogSXNzdWVzIGFuIEhUVFAgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gcHJlcGFyaW5nIGZvciBzZW5kaW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgICBjb25zdCByZXF1ZXN0T2JqZWN0ID0ge307XG4gICAgY29uc3QgcmVxdWVzdEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCByZXF1ZXN0SGFuZGxlcnMgPSB7IHNpZ25hbDogcmVxdWVzdEFib3J0Q29udHJvbGxlci5zaWduYWwgfTtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHByZXBhcmVSZXF1ZXN0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsIHJlcXVlc3RIYW5kbGVycyk7XG4gICAgbGV0IHNlbmRSZXF1ZXN0ID0gYXN5bmMgZnVuY3Rpb24gc2VuZFJlcXVlc3QoKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBzZW5kaW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gbmV3IEV4ZWN1dGlvblRpbWVyKCkuc3RhcnQoKTtcbiAgICAgICAgcmVxdWVzdE9iamVjdC5yZXF1ZXN0UHJvbWlzZSA9IGF4aW9zXG4gICAgICAgICAgICAucmVxdWVzdChyZXF1ZXN0T3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaHR0cFJlc3BvbnNlVGltZSA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gcmVzcG9uc2UgcmVjZWl2ZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzIHdpdGggc3RhdHVzICVzLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSwgaHR0cFJlc3BvbnNlVGltZSwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHNhbml0aXplQXhpb3NSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIGNhbGxpbmcgY2FsbGJhY2sgZnVuY3Rpb24uJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYWxsYmFjayhudWxsLCBub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSksIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIGNhbGxiYWNrIGZ1bmN0aW9uIHdhcyBub3QgcHJvdmlkZWQuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodHRwUmVzcG9uc2VUaW1lID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdSZXF1ZXN0JXMgLSBmYWlsZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSwgaHR0cFJlc3BvbnNlVGltZSk7XG4gICAgICAgICAgICBzYW5pdGl6ZUF4aW9zRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24ob3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF4aW9zIHJldHVybnMgZXJyb3IgZm9yIG5vdCAyeHggcmVzcG9uc2VzIC0gbGV0J3MgdW53cmFwIGl0XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBjYWxsaW5nIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlcnJvciBmcm9tIHJlc3BvbnNlLiBSZWNlaXZlZCBjb2RlOiAnLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucyksIGVyci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG51bGwsIG5vcm1hbGl6ZVJlc3BvbnNlKGVyci5yZXNwb25zZSksIGVyci5yZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBjYWxsaW5nIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlcnJvciB3aXRob3V0IHJlc3BvbnNlLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyLCBub3JtYWxpemVSZXNwb25zZShudWxsKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignUmVxdWVzdCVzIC0gY2FsbGJhY2sgZnVuY3Rpb24gd2FzIG5vdCBwcm92aWRlZC4gRXJyb3Igd2lsbCBiZSByZS1yYWlzZWQuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgc2VuZFJlcXVlc3QgPSBzZW5kUmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBpc3N1ZWQgZm9yIHRoZSBuZXh0IHRpY2suJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHNlbmRSZXF1ZXN0KTtcbiAgICAvLyByZXR1cm4gYW4gZXh0ZXJuYWxpemVkIHJlcXVlc3Qgb2JqZWN0IHRoYXQgb25seSBjb250YWluc1xuICAgIC8vIG1ldGhvZHMgd2UncmUgY29tZm9ydGFibGUgZXhwb3NpbmcgdG8gdGhlIG91dHNpZGUgd29ybGRcbiAgICByZXF1ZXN0T2JqZWN0LmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVxdWVzdEFib3J0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIGFib3J0aW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgICAgICByZXF1ZXN0QWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gYWJvcnRlZC4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVxdWVzdE9iamVjdDtcbn07XG4vKipcbiAqIElzc3VlcyBhbiBIVFRQIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUucmVxdWVzdEFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gcHJlcGFyaW5nIGZvciBhc3luYyBzZW5kaW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgICBjb25zdCB0aW1lciA9IG5ldyBFeGVjdXRpb25UaW1lcigpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gcHJlcGFyZVJlcXVlc3RPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRpbWVyLnN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZVRpbWUgPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gcmVzcG9uc2UgcmVjZWl2ZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzIHdpdGggc3RhdHVzICVzLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSwgaHR0cFJlc3BvbnNlVGltZSwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgcGFyc2VSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuICAgICAgICBzYW5pdGl6ZUF4aW9zUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZVRpbWUgPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gZmFpbGVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4gRXJyb3Igd2lsbCBiZSByZS1yYWlzZWQuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMob3B0aW9ucyksIGh0dHBSZXNwb25zZVRpbWUpO1xuICAgICAgICBzYW5pdGl6ZUF4aW9zRXJyb3IoZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBwYXJzaW5nIHJlc3BvbnNlIGRhdGEuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgcGFyc2VJZkpTT05EYXRhKHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSWZKU09ORGF0YShyZXNwb25zZSkge1xuICAgIGlmIChVdGlsLmlzU3RyaW5nKHJlc3BvbnNlWydkYXRhJ10pICYmXG4gICAgICAgIHJlc3BvbnNlWydoZWFkZXJzJ11bJ2NvbnRlbnQtdHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgLy8gTk9URTpcbiAgICAgICAgLy8gQSBzdXBlciBoYWNreSBzb2x1dGlvbiB0byBwYXRjaCAvcXVlcmllcy92MS9xdWVyeS1yZXF1ZXN0IHJlc3BvbnNlIGZvciBQVVQvR0VUIG9wZXJhdGlvbnNcbiAgICAgICAgLy8gUmV0dXJuZWQgZW5jcnlwdGlvbk1hdGVyaWFsLnNta0lkIGlzIGFuIGludGVnZXIsIHRoYXQgbWlnaHQgYmUgaGlnaGVyIHRoYW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgLy8gVHJlYXRpbmcgaXQgYXMgaW50ZWdlciB3aWxsIHJlc3VsdCBpbiB1cGxvYWRlZCBmaWxlcyBiZWluZyBVTlJFQ09WRVJBQkxFXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggbmV3IEFQSSBmaWVsZCB0aGF0IGlzIGEgc3RyaW5nXG4gICAgICAgIGlmIChyZXNwb25zZVsnZGF0YSddLmluY2x1ZGVzKCdzbWtJZCcpKSB7XG4gICAgICAgICAgICByZXNwb25zZVsnZGF0YSddID0gVXRpbC5jb252ZXJ0U21rSWRUb1N0cmluZyhyZXNwb25zZVsnZGF0YSddKTtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZVsnanNvbiddID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgcmVzcG9uc2VbJ2RhdGEnXSA9IEpTT04ucGFyc2UocmVzcG9uc2VbJ2RhdGEnXSk7XG4gICAgfVxufVxuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCBQT1NUIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge09iamVjdH0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVxdWVzdCB0aGF0IHdhcyBpc3N1ZWQuXG4gKi9cbkh0dHBDbGllbnQucHJvdG90eXBlLnBvc3QgPSBhc3luYyBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xufTtcbi8qKlxuICogSXNzdWVzIGFuIEhUVFAgR0VUIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5nZXQgPSBhc3luYyBmdW5jdGlvbiAodXJsLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgIH0pO1xufTtcbi8qKlxuICogSXNzdWVzIGFuIEhUVFAgSEVBRCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUuaGVhZCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyh7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgLi4uY29uZmlnLFxuICAgIH0pO1xufTtcbi8qKlxuICogSXNzdWVzIGFuIEhUVFAgUFVUIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUucHV0ID0gYXN5bmMgZnVuY3Rpb24gKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICB9KTtcbn07XG4vKipcbiAqIEBhYnN0cmFjdFxuICogUmV0dXJucyB0aGUgbW9kdWxlIHRvIHVzZSB3aGVuIG1ha2luZyBIVFRQIHJlcXVlc3RzLiBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGVcbiAqIGFuZCBwcm92aWRlIHRoZWlyIG93biBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbkh0dHBDbGllbnQucHJvdG90eXBlLmdldFJlcXVlc3RNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhZ2VudCBhbmQgcHJveHkgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0QWdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBIdHRwQ2xpZW50O1xuZnVuY3Rpb24gc2FuaXRpemVBeGlvc1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIHNhbml0aXppbmcgcmVzcG9uc2UgZGF0YS4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tUmVzcG9uc2UocmVzcG9uc2UpKTtcbiAgICByZXNwb25zZS5yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChyZXNwb25zZS5jb25maWcpIHtcbiAgICAgICAgcmVzcG9uc2UuY29uZmlnLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlc3BvbnNlLmNvbmZpZy5oZWFkZXJzID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbml0aXplQXhpb3NFcnJvcihlcnJvcikge1xuICAgIGVycm9yLnJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgZXJyb3IuY29uZmlnID0gdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gc2FuaXRpemluZyByZXNwb25zZSBlcnJvciBkYXRhLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShlcnJvci5yZXNwb25zZSkpO1xuICAgICAgICBzYW5pdGl6ZUF4aW9zUmVzcG9uc2UoZXJyb3IucmVzcG9uc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0T3B0aW9ucyhvcHRpb25zLCByZXF1ZXN0SGFuZGxlcnMgPSB7fSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBjb25zdHJ1Y3Rpbmcgb3B0aW9ucy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgY29uc3QgaGVhZGVycyA9IG5vcm1hbGl6ZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKSB8fCB7fTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IHRoaXMuX2Nvbm5lY3Rpb25Db25maWcuZ2V0VGltZW91dCgpIHx8IERFRkFVTFRfUkVRVUVTVF9USU1FT1VUO1xuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IG9wdGlvbnMuanNvbiB8fCBvcHRpb25zLmJvZHk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyVW5jb21wcmVzc2VkID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoZGF0YSksICd1dGY4Jyk7XG4gICAgICAgIHpsaWIuZ3ppcChidWZmZXJVbmNvbXByZXNzZWQsIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJ1ZmZlckNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wcmVzc2lvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYnVmZmVyQ29tcHJlc3NlZDtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LUVuY29kaW5nJ10gPSAnZ3ppcCc7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlcXVlc3QlcyAtIG9yaWdpbmFsIGJ1ZmZlciBsZW5ndGg6ICVkIGJ5dGVzLiBDb21wcmVzc2VkIGJ1ZmZlciBsZW5ndGg6ICVkIGJ5dGVzLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpLCBidWZmZXJVbmNvbXByZXNzZWQuYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlckNvbXByZXNzZWQuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9nZ2luZyAnZXJyJyB2YXJpYWJsZSB2YWx1ZSBzaG91bGQgbm90IGJlIGRvbmUsIHNpbmNlIGl0IG1heSBjb250YWluIGNvbXByZXNzZWQgY3VzdG9tZXIncyBkYXRhLlxuICAgICAgICAgICAgICAgIC8vIEl0IGNhbiBiZSBhZGRlZCBvbmx5IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignUmVxdWVzdCVzIC0gY291bGQgbm90IGNvbXByZXNzIHJlcXVlc3QgZGF0YS4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICBsZXQgbW9jaztcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbkNvbmZpZy5hZ2VudENsYXNzKSB7XG4gICAgICAgIG1vY2sgPSB7XG4gICAgICAgICAgICBhZ2VudENsYXNzOiB0aGlzLl9jb25uZWN0aW9uQ29uZmlnLmFnZW50Q2xhc3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGJhY2tvZmZTdHJhdGVneSA9IHRoaXMuY29uc3RydWN0RXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3koKTtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgIHJlcXVlc3RPQ1NQOiB0cnVlLFxuICAgICAgICByZXRyeURlbGF5OiBiYWNrb2ZmU3RyYXRlZ3ksXG4gICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogdHJ1ZSxcbiAgICAgICAgLy8gd2UgbWFudWFsbHkgcGFyc2UganNvbnMgb3Igb3RoZXIgc3RydWN0dXJlcyBmcm9tIHRoZSBzZXJ2ZXIgc28gdGhleSBuZWVkIHRvIGJlIHRleHRcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBvcHRpb25zLnJlc3BvbnNlVHlwZSB8fCAndGV4dCcsXG4gICAgICAgIHByb3h5OiBmYWxzZSxcbiAgICAgICAgLi4ucmVxdWVzdEhhbmRsZXJzLFxuICAgIH07XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChvcHRpb25zLnVybCk7XG4gICAgY29uc3QgaXNIdHRwcyA9IHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgY29uc3QgYWdlbnQgPSB0aGlzLmdldEFnZW50KHVybCwgdGhpcy5fY29ubmVjdGlvbkNvbmZpZy5nZXRQcm94eSgpLCBtb2NrKTtcbiAgICBpZiAoaXNIdHRwcykge1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5odHRwc0FnZW50ID0gYWdlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5odHRwQWdlbnQgPSBhZ2VudDtcbiAgICB9XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlcXVlc3QlcyAtIG9wdGlvbnMgLSB0aW1lb3V0OiAlcywgcmV0cnlEZWxheTogJXMsIHJlc3BvbnNlVHlwZTogJXMnLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSwgcmVxdWVzdE9wdGlvbnMudGltZW91dCwgcmVxdWVzdE9wdGlvbnMucmV0cnlEZWxheSwgcmVxdWVzdE9wdGlvbnMucmVzcG9uc2VUeXBlKTtcbiAgICByZXR1cm4gcmVxdWVzdE9wdGlvbnM7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgYSByZXF1ZXN0IGhlYWRlcnMgb2JqZWN0IHNvIHRoYXQgd2UgZ2V0IHRoZSBzYW1lIGJlaGF2aW9yXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgd2UncmUgdXNpbmcgcmVxdWVzdC5qcyBvciBicm93c2VyLXJlcXVlc3QuanMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnTm9ybWFsaXppbmcgaGVhZGVycycpO1xuICAgIGlmIChVdGlsLmlzT2JqZWN0KGhlYWRlcnMpKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ3VzZXItYWdlbnQnOiBVdGlsLnVzZXJBZ2VudCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2hhbGxvdyBjb3B5IHRoZSBoZWFkZXJzIG9iamVjdCBhbmQgY29udmVydCBzb21lIGhlYWRlcnMgbGlrZSAnQWNjZXB0J1xuICAgICAgICAvLyBhbmQgJ0NvbnRlbnQtVHlwZScgdG8gbG93ZXIgY2FzZSB3aGlsZSBjb3B5aW5nOyB0aGlzIGlzIG5lY2Vzc2FyeVxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBicm93c2VyLXJlcXVlc3QgbW9kdWxlLCB3aGljaCB3ZSB1c2UgdG8gbWFrZSBodHRwIHJlcXVlc3RzIGluXG4gICAgICAgIC8vIHRoZSBicm93c2VyLCBkb2VzIG5vdCBkbyBjYXNlLWluc2Vuc2l0aXZlIGNoZWNrcyB3aGVuIGRlY2lkaW5nIHdoZXRoZXIgdG9cbiAgICAgICAgLy8gaW5zZXJ0IGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgJ2FjY2VwdCcgYW5kICdjb250ZW50LXR5cGUnIGhlYWRlcnM7IGluXG4gICAgICAgIC8vIG90aGVyd2lzZSwgaWYgc29tZW9uZSBzcGVjaWZpZXMgYW4gJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyBoZWFkZXIsXG4gICAgICAgIC8vIGJyb3dzZXItcmVxdWVzdCB3aWxsIGluamVjdCBpdHMgb3duICdhY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicgaGVhZGVyXG4gICAgICAgIC8vIGFuZCB0aGUgYnJvd3NlciBYTUxIdHRwUmVxdWVzdCBvYmplY3Qgd2lsbCBjb25jYXRlbmF0ZSB0aGUgdHdvIHZhbHVlcyBhbmRcbiAgICAgICAgLy8gc2VuZCAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIGFwcGxpY2F0aW9uL2pzb24nIHdpdGggdGhlIHJlcXVlc3RcbiAgICAgICAgbGV0IGhlYWRlck5hbWVMb3dlckNhc2U7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyTmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIGhlYWRlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyTmFtZUxvd2VyQ2FzZSA9IGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyTmFtZUxvd2VyQ2FzZSA9PT0gJ2FjY2VwdCcgfHwgaGVhZGVyTmFtZUxvd2VyQ2FzZSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEhlYWRlcnNbaGVhZGVyTmFtZUxvd2VyQ2FzZV0gPSBoZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEhlYWRlcnNbaGVhZGVyTmFtZV0gPSBoZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnSGVhZGVycyB3ZXJlIG5vcm1hbGl6ZWQnKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRIZWFkZXJzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0hlYWRlcnMgd2VyZSBub3QgYW4gb2JqZWN0LiBPcmlnaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkLicpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHJlc3BvbnNlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBleHRyYWN0IHJlc3BvbnNlIGhlYWRlcnMgZnJvbVxuICogaXQgaW4gYSB1bmlmb3JtIHdheSByZWdhcmRsZXNzIG9mIHdoZXRoZXIgd2UncmUgdXNpbmcgcmVxdWVzdC5qcyBvclxuICogYnJvd3Nlci1yZXF1ZXN0LmpzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAvLyBpZiB0aGUgcmVzcG9uc2UgZG9lc24ndCBhbHJlYWR5IGhhdmUgYSBnZXRSZXNwb25zZUhlYWRlcigpIG1ldGhvZCwgYWRkIG9uZVxuICAgIGlmIChyZXNwb25zZSAmJiAhcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIG5vcm1hbGl6aW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShyZXNwb25zZSkpO1xuICAgICAgICByZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAocmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzW1V0aWwuaXNTdHJpbmcoaGVhZGVyKSA/IGhlYWRlci50b0xvd2VyQ2FzZSgpIDogaGVhZGVyXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS5ib2R5ID0gcmVzcG9uc2UuZGF0YTsgLy8gY29udmVydGluZyBheGlvcyByZXNwb25zZSBib2R5IHRvIG9sZCBleHBlY3RlZCBib2R5IGF0dHJpYnV0ZVxuICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzOyAvLyBjb252ZXJ0aW5nIGF4aW9zIHN0YXR1cyB0byBvbGQgZXhwZWN0ZWQgc3RhdHVzQ29kZVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/node.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBypassProxy = exports.httpsAgentCache = exports.NodeHttpClient = void 0;\nexports.getProxyAgent = getProxyAgent;\nconst node_untyped_1 = __webpack_require__(/*! ./node_untyped */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js\");\nvar node_untyped_2 = __webpack_require__(/*! ./node_untyped */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js\");\nObject.defineProperty(exports, \"NodeHttpClient\", ({ enumerable: true, get: function () { return node_untyped_2.NodeHttpClient; } }));\nObject.defineProperty(exports, \"httpsAgentCache\", ({ enumerable: true, get: function () { return node_untyped_2.httpsAgentCache; } }));\nObject.defineProperty(exports, \"isBypassProxy\", ({ enumerable: true, get: function () { return node_untyped_2.isBypassProxy; } }));\n/**\n * Work In Progress TypeScript migration for http/node_untyped.js\n */\nfunction getProxyAgent(config) {\n    const { proxyOptions, connectionConfig, parsedUrl, destination, mockAgent } = config;\n    return (0, node_untyped_1.getProxyAgent)(proxyOptions, parsedUrl, destination, mockAgent, connectionConfig);\n}\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCO0FBQ3hFLHFCQUFxQjtBQUNyQix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsd0ZBQWdCO0FBQzdDLGtEQUFpRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNsSSxtREFBa0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDcEksaURBQWdELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRUFBb0U7QUFDaEY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL25vZGUuanM/NWMzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNCeXBhc3NQcm94eSA9IGV4cG9ydHMuaHR0cHNBZ2VudENhY2hlID0gZXhwb3J0cy5Ob2RlSHR0cENsaWVudCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0UHJveHlBZ2VudCA9IGdldFByb3h5QWdlbnQ7XG5jb25zdCBub2RlX3VudHlwZWRfMSA9IHJlcXVpcmUoXCIuL25vZGVfdW50eXBlZFwiKTtcbnZhciBub2RlX3VudHlwZWRfMiA9IHJlcXVpcmUoXCIuL25vZGVfdW50eXBlZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vZGVIdHRwQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBub2RlX3VudHlwZWRfMi5Ob2RlSHR0cENsaWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImh0dHBzQWdlbnRDYWNoZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZV91bnR5cGVkXzIuaHR0cHNBZ2VudENhY2hlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCeXBhc3NQcm94eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZV91bnR5cGVkXzIuaXNCeXBhc3NQcm94eTsgfSB9KTtcbi8qKlxuICogV29yayBJbiBQcm9ncmVzcyBUeXBlU2NyaXB0IG1pZ3JhdGlvbiBmb3IgaHR0cC9ub2RlX3VudHlwZWQuanNcbiAqL1xuZnVuY3Rpb24gZ2V0UHJveHlBZ2VudChjb25maWcpIHtcbiAgICBjb25zdCB7IHByb3h5T3B0aW9ucywgY29ubmVjdGlvbkNvbmZpZywgcGFyc2VkVXJsLCBkZXN0aW5hdGlvbiwgbW9ja0FnZW50IH0gPSBjb25maWc7XG4gICAgcmV0dXJuICgwLCBub2RlX3VudHlwZWRfMS5nZXRQcm94eUFnZW50KShwcm94eU9wdGlvbnMsIHBhcnNlZFVybCwgZGVzdGluYXRpb24sIG1vY2tBZ2VudCwgY29ubmVjdGlvbkNvbmZpZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Base = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/base.js\");\nconst HttpsOcspAgent = __webpack_require__(/*! ../agent/https_ocsp_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js\");\nconst HttpsCrlAgent = (__webpack_require__(/*! ../agent/https_crl_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js\")[\"default\"]);\nconst HttpsProxyAgent = __webpack_require__(/*! ../agent/https_proxy_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js\");\nconst HttpAgent = (__webpack_require__(/*! http */ \"http\").Agent);\nconst GlobalConfig = __webpack_require__(/*! ../../lib/global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst RequestUtil = __webpack_require__(/*! ../http/request_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js\");\nconst { isCrlValidationEnabled } = __webpack_require__(/*! ../agent/crl_validator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\");\n/**\n * Returns the delay time calculated by exponential backoff with\n * decorrelated jitter. For more details, check out:\n * http://www.awsarchitectureblog.com/2015/03/backoff.html\n * @return  {Number} number of milliseconds to wait before retrying again the request.\n */\nNodeHttpClient.prototype.constructExponentialBackoffStrategy = function () {\n    Logger.getInstance().trace('Calculating exponential backoff strategy');\n    const previousSleepTime = this._connectionConfig.getRetrySfStartingSleepTime();\n    // maximum seconds\n    const cap = this._connectionConfig.getRetrySfMaxSleepTime();\n    // minimum seconds\n    const base = 1;\n    const nextSleepTime = Util.nextSleepTime(base, cap, previousSleepTime);\n    const nextSleepTimeInMilliseconds = nextSleepTime * 1000;\n    Logger.getInstance().trace('Calculated exponential backoff strategy sleep time: %d', nextSleepTimeInMilliseconds);\n    return nextSleepTimeInMilliseconds;\n};\n/**\n * Creates a client that can be used to make requests in Node.js.\n *\n * @param {ConnectionConfig} connectionConfig\n * @constructor\n */\nfunction NodeHttpClient(connectionConfig) {\n    Logger.getInstance().trace('Initializing NodeHttpClient with Connection Config[%s]', connectionConfig.describeIdentityAttributes());\n    Base.apply(this, [connectionConfig]);\n}\nUtil.inherits(NodeHttpClient, Base);\nconst httpsAgentCache = new Map();\nfunction getFromCacheOrCreate(AgentClass, options, agentId) {\n    Logger.getInstance().trace('Agent[id: %s] - trying to retrieve from cache or create.', agentId);\n    let agent = {};\n    function createAgent(AgentClass, agentOptions, agentId) {\n        Logger.getInstance().trace('Agent[id: %s] - creating a new agent instance.', agentId);\n        const agent = new AgentClass(agentOptions);\n        httpsAgentCache.set(agentId, agent);\n        Logger.getInstance().trace('Agent[id: %s] - new instance stored in cache.', agentId);\n        // detect and log PROXY envvar + agent proxy settings\n        const compareAndLogEnvAndAgentProxies = ProxyUtil.getCompareAndLogEnvAndAgentProxies(agentOptions);\n        Logger.getInstance().debug('Agent[id: %s] - proxy settings used in requests: %s', agentId, compareAndLogEnvAndAgentProxies.messages);\n        // if there's anything to warn on (e.g. both envvar + agent proxy used, and they are different)\n        // log warnings on them\n        if (compareAndLogEnvAndAgentProxies.warnings) {\n            Logger.getInstance().warn('Agent[id: %s] - %s', agentId, compareAndLogEnvAndAgentProxies.warnings);\n        }\n        return agent;\n    }\n    if (httpsAgentCache.has(agentId)) {\n        Logger.getInstance().trace('Agent[id: %s] - retrieving an agent instance from cache.', agentId);\n        agent = httpsAgentCache.get(agentId);\n    }\n    else {\n        agent = createAgent(AgentClass, options, agentId);\n    }\n    return agent;\n}\nfunction enrichAgentOptionsWithProxyConfig(agentOptions, proxy) {\n    agentOptions.host = proxy.host;\n    agentOptions.port = proxy.port;\n    agentOptions.protocol = proxy.protocol;\n    agentOptions.useForOCSP = proxy.useForOCSP;\n    agentOptions.noProxy = proxy.noProxy;\n    if (proxy.user && proxy.password) {\n        agentOptions.user = proxy.user;\n        agentOptions.password = proxy.password;\n    }\n}\nfunction isBypassProxy(proxy, destination, agentId) {\n    const matches = ProxyUtil.isByPassProxy(proxy, destination);\n    if (matches) {\n        Logger.getInstance().debug('Agent[id: %s] - bypassing proxy allowed for destination: %s', agentId, destination);\n        return true;\n    }\n    return false;\n}\n/**\n * @inheritDoc\n */\nNodeHttpClient.prototype.getAgent = function (parsedUrl, proxy, mock) {\n    Logger.getInstance().trace('Agent[url: %s] - getting an agent instance.', RequestUtil.describeURL(parsedUrl.href));\n    if (!proxy && GlobalConfig.isEnvProxyActive()) {\n        const isHttps = parsedUrl.protocol === 'https:';\n        proxy = ProxyUtil.getProxyFromEnv(isHttps);\n        if (proxy) {\n            Logger.getInstance().debug('Agent[url: %s] - proxy info loaded from the environment variable. Proxy host: %s', RequestUtil.describeURL(parsedUrl.href), proxy.host);\n        }\n    }\n    return getProxyAgent(proxy, parsedUrl, parsedUrl.href, mock, this._connectionConfig);\n};\nfunction getProxyAgent(proxyOptions, parsedUrl, destination, mock, connectionConfig) {\n    Logger.getInstance().trace('Agent[url: %s] - getting a proxy agent instance.', RequestUtil.describeURL(parsedUrl.href));\n    const agentOptions = {\n        protocol: parsedUrl.protocol,\n        hostname: parsedUrl.hostname,\n        keepAlive: GlobalConfig.getKeepAlive(),\n    };\n    if (mock) {\n        const mockAgent = mock.agentClass(agentOptions);\n        if (mockAgent.protocol === parsedUrl.protocol) {\n            Logger.getInstance().debug('Agent[url: %s] - the mock agent will be used.', RequestUtil.describeURL(parsedUrl.href));\n            return mockAgent;\n        }\n    }\n    const destHost = ProxyUtil.getHostFromURL(destination);\n    const agentId = createAgentId({\n        protocol: agentOptions.protocol,\n        hostname: agentOptions.hostname,\n        destination: destHost,\n        keepAlive: agentOptions.keepAlive,\n        connectionConfig,\n    });\n    Logger.getInstance().debug('Agent[id: %s] - the destination host is: %s.', agentId, destHost);\n    const bypassProxy = isBypassProxy(proxyOptions, destination, agentId);\n    let agent;\n    const isHttps = agentOptions.protocol === 'https:';\n    if (isHttps) {\n        agentOptions.crlValidatorConfig = connectionConfig.crlValidatorConfig;\n        if (proxyOptions && !bypassProxy) {\n            Logger.getInstance().trace('Agent[id: %s] - using HTTPS agent enriched with proxy options.', agentId);\n            enrichAgentOptionsWithProxyConfig(agentOptions, proxyOptions);\n            agent = getFromCacheOrCreate(HttpsProxyAgent, agentOptions, agentId);\n        }\n        else {\n            const AgentClass = isCrlValidationEnabled(connectionConfig.crlValidatorConfig)\n                ? HttpsCrlAgent\n                : HttpsOcspAgent;\n            Logger.getInstance().trace(`Agent[id: %s] - using ${AgentClass.name} agent without proxy.`, agentId);\n            agent = getFromCacheOrCreate(AgentClass, agentOptions, agentId);\n        }\n    }\n    else if (proxyOptions && !bypassProxy) {\n        Logger.getInstance().trace('Agent[id: %s] - using HTTP agent enriched with proxy options.', agentId);\n        enrichAgentOptionsWithProxyConfig(agentOptions, proxyOptions);\n        agent = getFromCacheOrCreate(HttpAgent, agentOptions, agentId);\n    }\n    else {\n        Logger.getInstance().trace('Agent[id: %s] - using HTTP agent without proxy.', agentId);\n        agent = getFromCacheOrCreate(HttpAgent, agentOptions, agentId);\n    }\n    return agent;\n}\nfunction createAgentId({ protocol, hostname, destination, keepAlive, connectionConfig }) {\n    return [\n        protocol,\n        hostname,\n        destination,\n        keepAlive ? 'keepAlive' : 'noKeepAlive',\n        `crl:${connectionConfig.crlValidatorConfig.checkMode}`,\n    ].join('-');\n}\nmodule.exports = { NodeHttpClient, getProxyAgent, isBypassProxy, httpsAgentCache };\n//# sourceMappingURL=node_untyped.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL25vZGVfdW50eXBlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxhQUFhLG1CQUFPLENBQUMsd0VBQVE7QUFDN0IsdUJBQXVCLG1CQUFPLENBQUMsd0dBQTJCO0FBQzFELHNCQUFzQix3SUFBMkM7QUFDakUsd0JBQXdCLG1CQUFPLENBQUMsMEdBQTRCO0FBQzVELGtCQUFrQiwrQ0FBcUI7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDbEQsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLGtHQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUE4RDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvaHR0cC9ub2RlX3VudHlwZWQuanM/ZDUzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBQcm94eVV0aWwgPSByZXF1aXJlKCcuLi9wcm94eV91dGlsJyk7XG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jb25zdCBIdHRwc09jc3BBZ2VudCA9IHJlcXVpcmUoJy4uL2FnZW50L2h0dHBzX29jc3BfYWdlbnQnKTtcbmNvbnN0IEh0dHBzQ3JsQWdlbnQgPSByZXF1aXJlKCcuLi9hZ2VudC9odHRwc19jcmxfYWdlbnQnKS5kZWZhdWx0O1xuY29uc3QgSHR0cHNQcm94eUFnZW50ID0gcmVxdWlyZSgnLi4vYWdlbnQvaHR0cHNfcHJveHlfYWdlbnQnKTtcbmNvbnN0IEh0dHBBZ2VudCA9IHJlcXVpcmUoJ2h0dHAnKS5BZ2VudDtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL2xpYi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IFJlcXVlc3RVdGlsID0gcmVxdWlyZSgnLi4vaHR0cC9yZXF1ZXN0X3V0aWwnKTtcbmNvbnN0IHsgaXNDcmxWYWxpZGF0aW9uRW5hYmxlZCB9ID0gcmVxdWlyZSgnLi4vYWdlbnQvY3JsX3ZhbGlkYXRvcicpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWxheSB0aW1lIGNhbGN1bGF0ZWQgYnkgZXhwb25lbnRpYWwgYmFja29mZiB3aXRoXG4gKiBkZWNvcnJlbGF0ZWQgaml0dGVyLiBGb3IgbW9yZSBkZXRhaWxzLCBjaGVjayBvdXQ6XG4gKiBodHRwOi8vd3d3LmF3c2FyY2hpdGVjdHVyZWJsb2cuY29tLzIwMTUvMDMvYmFja29mZi5odG1sXG4gKiBAcmV0dXJuICB7TnVtYmVyfSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nIGFnYWluIHRoZSByZXF1ZXN0LlxuICovXG5Ob2RlSHR0cENsaWVudC5wcm90b3R5cGUuY29uc3RydWN0RXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0NhbGN1bGF0aW5nIGV4cG9uZW50aWFsIGJhY2tvZmYgc3RyYXRlZ3knKTtcbiAgICBjb25zdCBwcmV2aW91c1NsZWVwVGltZSA9IHRoaXMuX2Nvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZlN0YXJ0aW5nU2xlZXBUaW1lKCk7XG4gICAgLy8gbWF4aW11bSBzZWNvbmRzXG4gICAgY29uc3QgY2FwID0gdGhpcy5fY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmTWF4U2xlZXBUaW1lKCk7XG4gICAgLy8gbWluaW11bSBzZWNvbmRzXG4gICAgY29uc3QgYmFzZSA9IDE7XG4gICAgY29uc3QgbmV4dFNsZWVwVGltZSA9IFV0aWwubmV4dFNsZWVwVGltZShiYXNlLCBjYXAsIHByZXZpb3VzU2xlZXBUaW1lKTtcbiAgICBjb25zdCBuZXh0U2xlZXBUaW1lSW5NaWxsaXNlY29uZHMgPSBuZXh0U2xlZXBUaW1lICogMTAwMDtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ2FsY3VsYXRlZCBleHBvbmVudGlhbCBiYWNrb2ZmIHN0cmF0ZWd5IHNsZWVwIHRpbWU6ICVkJywgbmV4dFNsZWVwVGltZUluTWlsbGlzZWNvbmRzKTtcbiAgICByZXR1cm4gbmV4dFNsZWVwVGltZUluTWlsbGlzZWNvbmRzO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGNsaWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgcmVxdWVzdHMgaW4gTm9kZS5qcy5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb25Db25maWd9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOb2RlSHR0cENsaWVudChjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0luaXRpYWxpemluZyBOb2RlSHR0cENsaWVudCB3aXRoIENvbm5lY3Rpb24gQ29uZmlnWyVzXScsIGNvbm5lY3Rpb25Db25maWcuZGVzY3JpYmVJZGVudGl0eUF0dHJpYnV0ZXMoKSk7XG4gICAgQmFzZS5hcHBseSh0aGlzLCBbY29ubmVjdGlvbkNvbmZpZ10pO1xufVxuVXRpbC5pbmhlcml0cyhOb2RlSHR0cENsaWVudCwgQmFzZSk7XG5jb25zdCBodHRwc0FnZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRGcm9tQ2FjaGVPckNyZWF0ZShBZ2VudENsYXNzLCBvcHRpb25zLCBhZ2VudElkKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W2lkOiAlc10gLSB0cnlpbmcgdG8gcmV0cmlldmUgZnJvbSBjYWNoZSBvciBjcmVhdGUuJywgYWdlbnRJZCk7XG4gICAgbGV0IGFnZW50ID0ge307XG4gICAgZnVuY3Rpb24gY3JlYXRlQWdlbnQoQWdlbnRDbGFzcywgYWdlbnRPcHRpb25zLCBhZ2VudElkKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gY3JlYXRpbmcgYSBuZXcgYWdlbnQgaW5zdGFuY2UuJywgYWdlbnRJZCk7XG4gICAgICAgIGNvbnN0IGFnZW50ID0gbmV3IEFnZW50Q2xhc3MoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgaHR0cHNBZ2VudENhY2hlLnNldChhZ2VudElkLCBhZ2VudCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gbmV3IGluc3RhbmNlIHN0b3JlZCBpbiBjYWNoZS4nLCBhZ2VudElkKTtcbiAgICAgICAgLy8gZGV0ZWN0IGFuZCBsb2cgUFJPWFkgZW52dmFyICsgYWdlbnQgcHJveHkgc2V0dGluZ3NcbiAgICAgICAgY29uc3QgY29tcGFyZUFuZExvZ0VudkFuZEFnZW50UHJveGllcyA9IFByb3h5VXRpbC5nZXRDb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzKGFnZW50T3B0aW9ucyk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBZ2VudFtpZDogJXNdIC0gcHJveHkgc2V0dGluZ3MgdXNlZCBpbiByZXF1ZXN0czogJXMnLCBhZ2VudElkLCBjb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzLm1lc3NhZ2VzKTtcbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbnl0aGluZyB0byB3YXJuIG9uIChlLmcuIGJvdGggZW52dmFyICsgYWdlbnQgcHJveHkgdXNlZCwgYW5kIHRoZXkgYXJlIGRpZmZlcmVudClcbiAgICAgICAgLy8gbG9nIHdhcm5pbmdzIG9uIHRoZW1cbiAgICAgICAgaWYgKGNvbXBhcmVBbmRMb2dFbnZBbmRBZ2VudFByb3hpZXMud2FybmluZ3MpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0FnZW50W2lkOiAlc10gLSAlcycsIGFnZW50SWQsIGNvbXBhcmVBbmRMb2dFbnZBbmRBZ2VudFByb3hpZXMud2FybmluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZ2VudDtcbiAgICB9XG4gICAgaWYgKGh0dHBzQWdlbnRDYWNoZS5oYXMoYWdlbnRJZCkpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W2lkOiAlc10gLSByZXRyaWV2aW5nIGFuIGFnZW50IGluc3RhbmNlIGZyb20gY2FjaGUuJywgYWdlbnRJZCk7XG4gICAgICAgIGFnZW50ID0gaHR0cHNBZ2VudENhY2hlLmdldChhZ2VudElkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFnZW50ID0gY3JlYXRlQWdlbnQoQWdlbnRDbGFzcywgb3B0aW9ucywgYWdlbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiBhZ2VudDtcbn1cbmZ1bmN0aW9uIGVucmljaEFnZW50T3B0aW9uc1dpdGhQcm94eUNvbmZpZyhhZ2VudE9wdGlvbnMsIHByb3h5KSB7XG4gICAgYWdlbnRPcHRpb25zLmhvc3QgPSBwcm94eS5ob3N0O1xuICAgIGFnZW50T3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydDtcbiAgICBhZ2VudE9wdGlvbnMucHJvdG9jb2wgPSBwcm94eS5wcm90b2NvbDtcbiAgICBhZ2VudE9wdGlvbnMudXNlRm9yT0NTUCA9IHByb3h5LnVzZUZvck9DU1A7XG4gICAgYWdlbnRPcHRpb25zLm5vUHJveHkgPSBwcm94eS5ub1Byb3h5O1xuICAgIGlmIChwcm94eS51c2VyICYmIHByb3h5LnBhc3N3b3JkKSB7XG4gICAgICAgIGFnZW50T3B0aW9ucy51c2VyID0gcHJveHkudXNlcjtcbiAgICAgICAgYWdlbnRPcHRpb25zLnBhc3N3b3JkID0gcHJveHkucGFzc3dvcmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNCeXBhc3NQcm94eShwcm94eSwgZGVzdGluYXRpb24sIGFnZW50SWQpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gUHJveHlVdGlsLmlzQnlQYXNzUHJveHkocHJveHksIGRlc3RpbmF0aW9uKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQWdlbnRbaWQ6ICVzXSAtIGJ5cGFzc2luZyBwcm94eSBhbGxvd2VkIGZvciBkZXN0aW5hdGlvbjogJXMnLCBhZ2VudElkLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cbk5vZGVIdHRwQ2xpZW50LnByb3RvdHlwZS5nZXRBZ2VudCA9IGZ1bmN0aW9uIChwYXJzZWRVcmwsIHByb3h5LCBtb2NrKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W3VybDogJXNdIC0gZ2V0dGluZyBhbiBhZ2VudCBpbnN0YW5jZS4nLCBSZXF1ZXN0VXRpbC5kZXNjcmliZVVSTChwYXJzZWRVcmwuaHJlZikpO1xuICAgIGlmICghcHJveHkgJiYgR2xvYmFsQ29uZmlnLmlzRW52UHJveHlBY3RpdmUoKSkge1xuICAgICAgICBjb25zdCBpc0h0dHBzID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgcHJveHkgPSBQcm94eVV0aWwuZ2V0UHJveHlGcm9tRW52KGlzSHR0cHMpO1xuICAgICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBZ2VudFt1cmw6ICVzXSAtIHByb3h5IGluZm8gbG9hZGVkIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLiBQcm94eSBob3N0OiAlcycsIFJlcXVlc3RVdGlsLmRlc2NyaWJlVVJMKHBhcnNlZFVybC5ocmVmKSwgcHJveHkuaG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdldFByb3h5QWdlbnQocHJveHksIHBhcnNlZFVybCwgcGFyc2VkVXJsLmhyZWYsIG1vY2ssIHRoaXMuX2Nvbm5lY3Rpb25Db25maWcpO1xufTtcbmZ1bmN0aW9uIGdldFByb3h5QWdlbnQocHJveHlPcHRpb25zLCBwYXJzZWRVcmwsIGRlc3RpbmF0aW9uLCBtb2NrLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W3VybDogJXNdIC0gZ2V0dGluZyBhIHByb3h5IGFnZW50IGluc3RhbmNlLicsIFJlcXVlc3RVdGlsLmRlc2NyaWJlVVJMKHBhcnNlZFVybC5ocmVmKSk7XG4gICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAgICBwcm90b2NvbDogcGFyc2VkVXJsLnByb3RvY29sLFxuICAgICAgICBob3N0bmFtZTogcGFyc2VkVXJsLmhvc3RuYW1lLFxuICAgICAgICBrZWVwQWxpdmU6IEdsb2JhbENvbmZpZy5nZXRLZWVwQWxpdmUoKSxcbiAgICB9O1xuICAgIGlmIChtb2NrKSB7XG4gICAgICAgIGNvbnN0IG1vY2tBZ2VudCA9IG1vY2suYWdlbnRDbGFzcyhhZ2VudE9wdGlvbnMpO1xuICAgICAgICBpZiAobW9ja0FnZW50LnByb3RvY29sID09PSBwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBZ2VudFt1cmw6ICVzXSAtIHRoZSBtb2NrIGFnZW50IHdpbGwgYmUgdXNlZC4nLCBSZXF1ZXN0VXRpbC5kZXNjcmliZVVSTChwYXJzZWRVcmwuaHJlZikpO1xuICAgICAgICAgICAgcmV0dXJuIG1vY2tBZ2VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZXN0SG9zdCA9IFByb3h5VXRpbC5nZXRIb3N0RnJvbVVSTChkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgYWdlbnRJZCA9IGNyZWF0ZUFnZW50SWQoe1xuICAgICAgICBwcm90b2NvbDogYWdlbnRPcHRpb25zLnByb3RvY29sLFxuICAgICAgICBob3N0bmFtZTogYWdlbnRPcHRpb25zLmhvc3RuYW1lLFxuICAgICAgICBkZXN0aW5hdGlvbjogZGVzdEhvc3QsXG4gICAgICAgIGtlZXBBbGl2ZTogYWdlbnRPcHRpb25zLmtlZXBBbGl2ZSxcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZyxcbiAgICB9KTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQWdlbnRbaWQ6ICVzXSAtIHRoZSBkZXN0aW5hdGlvbiBob3N0IGlzOiAlcy4nLCBhZ2VudElkLCBkZXN0SG9zdCk7XG4gICAgY29uc3QgYnlwYXNzUHJveHkgPSBpc0J5cGFzc1Byb3h5KHByb3h5T3B0aW9ucywgZGVzdGluYXRpb24sIGFnZW50SWQpO1xuICAgIGxldCBhZ2VudDtcbiAgICBjb25zdCBpc0h0dHBzID0gYWdlbnRPcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICBpZiAoaXNIdHRwcykge1xuICAgICAgICBhZ2VudE9wdGlvbnMuY3JsVmFsaWRhdG9yQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZy5jcmxWYWxpZGF0b3JDb25maWc7XG4gICAgICAgIGlmIChwcm94eU9wdGlvbnMgJiYgIWJ5cGFzc1Byb3h5KSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQWdlbnRbaWQ6ICVzXSAtIHVzaW5nIEhUVFBTIGFnZW50IGVucmljaGVkIHdpdGggcHJveHkgb3B0aW9ucy4nLCBhZ2VudElkKTtcbiAgICAgICAgICAgIGVucmljaEFnZW50T3B0aW9uc1dpdGhQcm94eUNvbmZpZyhhZ2VudE9wdGlvbnMsIHByb3h5T3B0aW9ucyk7XG4gICAgICAgICAgICBhZ2VudCA9IGdldEZyb21DYWNoZU9yQ3JlYXRlKEh0dHBzUHJveHlBZ2VudCwgYWdlbnRPcHRpb25zLCBhZ2VudElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IEFnZW50Q2xhc3MgPSBpc0NybFZhbGlkYXRpb25FbmFibGVkKGNvbm5lY3Rpb25Db25maWcuY3JsVmFsaWRhdG9yQ29uZmlnKVxuICAgICAgICAgICAgICAgID8gSHR0cHNDcmxBZ2VudFxuICAgICAgICAgICAgICAgIDogSHR0cHNPY3NwQWdlbnQ7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgQWdlbnRbaWQ6ICVzXSAtIHVzaW5nICR7QWdlbnRDbGFzcy5uYW1lfSBhZ2VudCB3aXRob3V0IHByb3h5LmAsIGFnZW50SWQpO1xuICAgICAgICAgICAgYWdlbnQgPSBnZXRGcm9tQ2FjaGVPckNyZWF0ZShBZ2VudENsYXNzLCBhZ2VudE9wdGlvbnMsIGFnZW50SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3h5T3B0aW9ucyAmJiAhYnlwYXNzUHJveHkpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W2lkOiAlc10gLSB1c2luZyBIVFRQIGFnZW50IGVucmljaGVkIHdpdGggcHJveHkgb3B0aW9ucy4nLCBhZ2VudElkKTtcbiAgICAgICAgZW5yaWNoQWdlbnRPcHRpb25zV2l0aFByb3h5Q29uZmlnKGFnZW50T3B0aW9ucywgcHJveHlPcHRpb25zKTtcbiAgICAgICAgYWdlbnQgPSBnZXRGcm9tQ2FjaGVPckNyZWF0ZShIdHRwQWdlbnQsIGFnZW50T3B0aW9ucywgYWdlbnRJZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQWdlbnRbaWQ6ICVzXSAtIHVzaW5nIEhUVFAgYWdlbnQgd2l0aG91dCBwcm94eS4nLCBhZ2VudElkKTtcbiAgICAgICAgYWdlbnQgPSBnZXRGcm9tQ2FjaGVPckNyZWF0ZShIdHRwQWdlbnQsIGFnZW50T3B0aW9ucywgYWdlbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiBhZ2VudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFnZW50SWQoeyBwcm90b2NvbCwgaG9zdG5hbWUsIGRlc3RpbmF0aW9uLCBrZWVwQWxpdmUsIGNvbm5lY3Rpb25Db25maWcgfSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIGtlZXBBbGl2ZSA/ICdrZWVwQWxpdmUnIDogJ25vS2VlcEFsaXZlJyxcbiAgICAgICAgYGNybDoke2Nvbm5lY3Rpb25Db25maWcuY3JsVmFsaWRhdG9yQ29uZmlnLmNoZWNrTW9kZX1gLFxuICAgIF0uam9pbignLScpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7IE5vZGVIdHRwQ2xpZW50LCBnZXRQcm94eUFnZW50LCBpc0J5cGFzc1Byb3h5LCBodHRwc0FnZW50Q2FjaGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGVfdW50eXBlZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/request_util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst LoggingUtil = __webpack_require__(/*! ../logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\");\nconst sfParams = __webpack_require__(/*! ../constants/sf_params */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js\");\n// Initial whitelist for attributes - they will be described with values\nconst DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES = [\n    'baseUrl',\n    'path',\n    'method',\n    sfParams.paramsNames.SF_REQUEST_ID,\n    sfParams.paramsNames.SF_REQUEST_GUID,\n    sfParams.paramsNames.SF_WAREHOUSE_NAME,\n    sfParams.paramsNames.SF_DB_NAME,\n    sfParams.paramsNames.SF_SCHEMA_NAME,\n];\n// Initial blacklist for attributes - described as present/not present only\nconst DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES = [sfParams.paramsNames.SF_TOKEN];\n// Helper function to resolve attributes arrays given defaults and overrides.\nfunction resolveAttributeList(defaultAttrs, overrideAttrs) {\n    return overrideAttrs || defaultAttrs;\n}\n/**\n * Describes a request based on its options.\n * Should work with not-yet-parsed options as well (before calling prepareRequestOptions method).\n *\n * @param {Object} requestOptions - Object representing the request data with top-level keys.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string representation of the request data.\n */\nfunction describeRequestFromOptions(requestOptions, { overrideAttributesDescribedWithValues, overrideAttributesDescribedWithoutValues } = {}) {\n    const describingAttributesWithValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES, overrideAttributesDescribedWithValues);\n    const describingAttributesWithoutValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES, overrideAttributesDescribedWithoutValues);\n    const { method, url, params } = requestOptions || {};\n    return describeRequestData({ method, url, params }, describingAttributesWithValues, describingAttributesWithoutValues);\n}\n/**\n * Creates a string that represents request data from a response.\n * Helps to identify the request that was the source of the response.\n *\n * @param {Object} response - Axios response object.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string representation of the request data.\n */\nfunction describeRequestFromResponse(response, { overrideAttributesDescribedWithValues, overrideAttributesDescribedWithoutValues } = {}) {\n    let method;\n    let url;\n    let params;\n    const responseConfig = response?.config;\n    const describingAttributesWithValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES, overrideAttributesDescribedWithValues);\n    const describingAttributesWithoutValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES, overrideAttributesDescribedWithoutValues);\n    if (responseConfig) {\n        method = responseConfig.method;\n        url = responseConfig.url;\n        params = responseConfig.params;\n    }\n    return describeRequestData({ method, url, params }, describingAttributesWithValues, describingAttributesWithoutValues);\n}\n/**\n * Constructs a string representation of request data.\n *\n * @param {Object} requestData - Object containing the method, url, and parameters.\n * @param {string} requestData.method - HTTP method.\n * @param {string} requestData.url - Request URL.\n * @param {Object} [requestData.params] - Additional query parameters.\n * @param {Array<string>} attributesWithValues - Attributes to describe with values.\n * @param {Array<string>} attributesWithoutValues - Attributes to describe without values.\n * @returns {string} A string describing the request data.\n */\nfunction describeRequestData({ method, url, params } = {}, attributesWithValues, attributesWithoutValues) {\n    const requestObject = {\n        // Ensure consistent casing for methods to match request-response pairs in logs.\n        method: method?.toUpperCase(),\n        ...constructURLData(url, params),\n    };\n    return LoggingUtil.describeAttributes(requestObject, attributesWithValues, attributesWithoutValues);\n}\n/**\n * Constructs an object representing URL data including the base URL, path, and query parameters.\n *\n * @param {string} url - The full URL.\n * @param {Object} [params] - Additional query parameters.\n * @returns {Object} Contains baseUrl, path, and merged query parameters.\n */\nfunction constructURLData(url, params = {}) {\n    if (!url) {\n        return { baseUrl: undefined, path: undefined, queryParams: {} };\n    }\n    const urlObj = new URL(url);\n    const queryParams = { ...params };\n    urlObj.searchParams.forEach((value, key) => {\n        queryParams[key] = value;\n    });\n    const baseUrl = `${urlObj.protocol}//${urlObj.hostname}${urlObj.port ? `:${urlObj.port}` : ''}`;\n    return {\n        baseUrl: baseUrl,\n        path: urlObj.pathname,\n        ...queryParams,\n    };\n}\n/**\n * @param {string} url - The URL to describe.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string describing the URL.\n */\nfunction describeURL(url, { overrideAttributesDescribedWithValues, overrideAttributesDescribedWithoutValues } = {}) {\n    const describingAttributesWithValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES, overrideAttributesDescribedWithValues);\n    const describingAttributesWithoutValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES, overrideAttributesDescribedWithoutValues);\n    const urlData = constructURLData(url);\n    return LoggingUtil.describeAttributes(urlData, describingAttributesWithValues, describingAttributesWithoutValues);\n}\nexports.DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES =\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES;\nexports.DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES =\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES;\nexports.describeRequestFromOptions = describeRequestFromOptions;\nexports.describeRequestFromResponse = describeRequestFromResponse;\nexports.describeURL = describeURL;\n//# sourceMappingURL=request_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL3JlcXVlc3RfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9CQUFvQixtQkFBTyxDQUFDLGtHQUF3QjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxrR0FBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHNEQUFzRCxrRkFBa0YsSUFBSTtBQUM1STtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGlEQUFpRCxrRkFBa0YsSUFBSTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLCtCQUErQixzQkFBc0IsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsZ0JBQWdCLElBQUksZ0JBQWdCLEVBQUUsa0JBQWtCLFlBQVksT0FBTztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQSw0QkFBNEIsa0ZBQWtGLElBQUk7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL3JlcXVlc3RfdXRpbC5qcz9iOGI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgTG9nZ2luZ1V0aWwgPSByZXF1aXJlKCcuLi9sb2dnZXIvbG9nZ2luZ191dGlsJyk7XG5jb25zdCBzZlBhcmFtcyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9zZl9wYXJhbXMnKTtcbi8vIEluaXRpYWwgd2hpdGVsaXN0IGZvciBhdHRyaWJ1dGVzIC0gdGhleSB3aWxsIGJlIGRlc2NyaWJlZCB3aXRoIHZhbHVlc1xuY29uc3QgREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIX1ZBTFVFUyA9IFtcbiAgICAnYmFzZVVybCcsXG4gICAgJ3BhdGgnLFxuICAgICdtZXRob2QnLFxuICAgIHNmUGFyYW1zLnBhcmFtc05hbWVzLlNGX1JFUVVFU1RfSUQsXG4gICAgc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfUkVRVUVTVF9HVUlELFxuICAgIHNmUGFyYW1zLnBhcmFtc05hbWVzLlNGX1dBUkVIT1VTRV9OQU1FLFxuICAgIHNmUGFyYW1zLnBhcmFtc05hbWVzLlNGX0RCX05BTUUsXG4gICAgc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfU0NIRU1BX05BTUUsXG5dO1xuLy8gSW5pdGlhbCBibGFja2xpc3QgZm9yIGF0dHJpYnV0ZXMgLSBkZXNjcmliZWQgYXMgcHJlc2VudC9ub3QgcHJlc2VudCBvbmx5XG5jb25zdCBERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhPVVRfVkFMVUVTID0gW3NmUGFyYW1zLnBhcmFtc05hbWVzLlNGX1RPS0VOXTtcbi8vIEhlbHBlciBmdW5jdGlvbiB0byByZXNvbHZlIGF0dHJpYnV0ZXMgYXJyYXlzIGdpdmVuIGRlZmF1bHRzIGFuZCBvdmVycmlkZXMuXG5mdW5jdGlvbiByZXNvbHZlQXR0cmlidXRlTGlzdChkZWZhdWx0QXR0cnMsIG92ZXJyaWRlQXR0cnMpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVBdHRycyB8fCBkZWZhdWx0QXR0cnM7XG59XG4vKipcbiAqIERlc2NyaWJlcyBhIHJlcXVlc3QgYmFzZWQgb24gaXRzIG9wdGlvbnMuXG4gKiBTaG91bGQgd29yayB3aXRoIG5vdC15ZXQtcGFyc2VkIG9wdGlvbnMgYXMgd2VsbCAoYmVmb3JlIGNhbGxpbmcgcHJlcGFyZVJlcXVlc3RPcHRpb25zIG1ldGhvZCkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zIC0gT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVxdWVzdCBkYXRhIHdpdGggdG9wLWxldmVsIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgZGVzY3JpYmluZyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbb3B0aW9ucy5vdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzXVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbb3B0aW9ucy5vdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRob3V0VmFsdWVzXVxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlcXVlc3QgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMsIHsgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlcywgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlcyB9ID0ge30pIHtcbiAgICBjb25zdCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhWYWx1ZXMgPSByZXNvbHZlQXR0cmlidXRlTGlzdChERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhfVkFMVUVTLCBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzKTtcbiAgICBjb25zdCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgPSByZXNvbHZlQXR0cmlidXRlTGlzdChERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhPVVRfVkFMVUVTLCBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRob3V0VmFsdWVzKTtcbiAgICBjb25zdCB7IG1ldGhvZCwgdXJsLCBwYXJhbXMgfSA9IHJlcXVlc3RPcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBkZXNjcmliZVJlcXVlc3REYXRhKHsgbWV0aG9kLCB1cmwsIHBhcmFtcyB9LCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhWYWx1ZXMsIGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHJlcXVlc3QgZGF0YSBmcm9tIGEgcmVzcG9uc2UuXG4gKiBIZWxwcyB0byBpZGVudGlmeSB0aGUgcmVxdWVzdCB0aGF0IHdhcyB0aGUgc291cmNlIG9mIHRoZSByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSBBeGlvcyByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgZGVzY3JpYmluZyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbb3B0aW9ucy5vdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzXVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbb3B0aW9ucy5vdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRob3V0VmFsdWVzXVxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlcXVlc3QgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlKHJlc3BvbnNlLCB7IG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXMsIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXMgfSA9IHt9KSB7XG4gICAgbGV0IG1ldGhvZDtcbiAgICBsZXQgdXJsO1xuICAgIGxldCBwYXJhbXM7XG4gICAgY29uc3QgcmVzcG9uc2VDb25maWcgPSByZXNwb25zZT8uY29uZmlnO1xuICAgIGNvbnN0IGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aFZhbHVlcyA9IHJlc29sdmVBdHRyaWJ1dGVMaXN0KERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVMsIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXMpO1xuICAgIGNvbnN0IGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyA9IHJlc29sdmVBdHRyaWJ1dGVMaXN0KERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSE9VVF9WQUxVRVMsIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXMpO1xuICAgIGlmIChyZXNwb25zZUNvbmZpZykge1xuICAgICAgICBtZXRob2QgPSByZXNwb25zZUNvbmZpZy5tZXRob2Q7XG4gICAgICAgIHVybCA9IHJlc3BvbnNlQ29uZmlnLnVybDtcbiAgICAgICAgcGFyYW1zID0gcmVzcG9uc2VDb25maWcucGFyYW1zO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpYmVSZXF1ZXN0RGF0YSh7IG1ldGhvZCwgdXJsLCBwYXJhbXMgfSwgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRoVmFsdWVzLCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMpO1xufVxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHJlcXVlc3QgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdERhdGEgLSBPYmplY3QgY29udGFpbmluZyB0aGUgbWV0aG9kLCB1cmwsIGFuZCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3REYXRhLm1ldGhvZCAtIEhUVFAgbWV0aG9kLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3REYXRhLnVybCAtIFJlcXVlc3QgVVJMLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0RGF0YS5wYXJhbXNdIC0gQWRkaXRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdHRyaWJ1dGVzV2l0aFZhbHVlcyAtIEF0dHJpYnV0ZXMgdG8gZGVzY3JpYmUgd2l0aCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzIC0gQXR0cmlidXRlcyB0byBkZXNjcmliZSB3aXRob3V0IHZhbHVlcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHJlcXVlc3QgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVSZXF1ZXN0RGF0YSh7IG1ldGhvZCwgdXJsLCBwYXJhbXMgfSA9IHt9LCBhdHRyaWJ1dGVzV2l0aFZhbHVlcywgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMpIHtcbiAgICBjb25zdCByZXF1ZXN0T2JqZWN0ID0ge1xuICAgICAgICAvLyBFbnN1cmUgY29uc2lzdGVudCBjYXNpbmcgZm9yIG1ldGhvZHMgdG8gbWF0Y2ggcmVxdWVzdC1yZXNwb25zZSBwYWlycyBpbiBsb2dzLlxuICAgICAgICBtZXRob2Q6IG1ldGhvZD8udG9VcHBlckNhc2UoKSxcbiAgICAgICAgLi4uY29uc3RydWN0VVJMRGF0YSh1cmwsIHBhcmFtcyksXG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2luZ1V0aWwuZGVzY3JpYmVBdHRyaWJ1dGVzKHJlcXVlc3RPYmplY3QsIGF0dHJpYnV0ZXNXaXRoVmFsdWVzLCBhdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyk7XG59XG4vKipcbiAqIENvbnN0cnVjdHMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBVUkwgZGF0YSBpbmNsdWRpbmcgdGhlIGJhc2UgVVJMLCBwYXRoLCBhbmQgcXVlcnkgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIGZ1bGwgVVJMLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gQWRkaXRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMge09iamVjdH0gQ29udGFpbnMgYmFzZVVybCwgcGF0aCwgYW5kIG1lcmdlZCBxdWVyeSBwYXJhbWV0ZXJzLlxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RVUkxEYXRhKHVybCwgcGFyYW1zID0ge30pIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4geyBiYXNlVXJsOiB1bmRlZmluZWQsIHBhdGg6IHVuZGVmaW5lZCwgcXVlcnlQYXJhbXM6IHt9IH07XG4gICAgfVxuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHsgLi4ucGFyYW1zIH07XG4gICAgdXJsT2JqLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBiYXNlVXJsID0gYCR7dXJsT2JqLnByb3RvY29sfS8vJHt1cmxPYmouaG9zdG5hbWV9JHt1cmxPYmoucG9ydCA/IGA6JHt1cmxPYmoucG9ydH1gIDogJyd9YDtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgICAgICBwYXRoOiB1cmxPYmoucGF0aG5hbWUsXG4gICAgICAgIC4uLnF1ZXJ5UGFyYW1zLFxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIGRlc2NyaWJlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGRlc2NyaWJpbmcgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlc11cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIFVSTC5cbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVVUkwodXJsLCB7IG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXMsIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXMgfSA9IHt9KSB7XG4gICAgY29uc3QgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRoVmFsdWVzID0gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIX1ZBTFVFUywgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlcyk7XG4gICAgY29uc3QgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRob3V0VmFsdWVzID0gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIT1VUX1ZBTFVFUywgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlcyk7XG4gICAgY29uc3QgdXJsRGF0YSA9IGNvbnN0cnVjdFVSTERhdGEodXJsKTtcbiAgICByZXR1cm4gTG9nZ2luZ1V0aWwuZGVzY3JpYmVBdHRyaWJ1dGVzKHVybERhdGEsIGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aFZhbHVlcywgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRob3V0VmFsdWVzKTtcbn1cbmV4cG9ydHMuREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIX1ZBTFVFUyA9XG4gICAgREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIX1ZBTFVFUztcbmV4cG9ydHMuREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIT1VUX1ZBTFVFUyA9XG4gICAgREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIT1VUX1ZBTFVFUztcbmV4cG9ydHMuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMgPSBkZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucztcbmV4cG9ydHMuZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlID0gZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlO1xuZXhwb3J0cy5kZXNjcmliZVVSTCA9IGRlc2NyaWJlVVJMO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdF91dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setInstance = setInstance;\nexports.getInstance = getInstance;\nconst browser_1 = __importDefault(__webpack_require__(/*! ./logger/browser */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/browser.js\"));\nlet instance;\n/**\n * Sets the logger instance. For internal use only.\n */\nfunction setInstance(newInstance) {\n    instance = newInstance;\n}\n/**\n * Returns the current logger instance.\n * @deprecated\n *\n * In TypeScript, use default import:\n * ```\n *  import Logger from './Logger';\n *  Logger().info(...)\n * ```\n *\n * In JavaScript, use:\n * ```\n *  const Logger = require('./Logger').default;\n *  Logger().info(...)\n * ```\n */\nfunction getInstance() {\n    // use the browser implementation of logger as the default implementation;\n    // we do this so that unit tests don't fail when the modules they're testing\n    // log messages\n    if (!instance) {\n        instance = new browser_1.default();\n    }\n    return instance;\n}\nexports[\"default\"] = () => getInstance();\n//# sourceMappingURL=logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGtDQUFrQyxtQkFBTyxDQUFDLHVGQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvbG9nZ2VyLmpzPzhiODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldEluc3RhbmNlID0gc2V0SW5zdGFuY2U7XG5leHBvcnRzLmdldEluc3RhbmNlID0gZ2V0SW5zdGFuY2U7XG5jb25zdCBicm93c2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbG9nZ2VyL2Jyb3dzZXJcIikpO1xubGV0IGluc3RhbmNlO1xuLyoqXG4gKiBTZXRzIHRoZSBsb2dnZXIgaW5zdGFuY2UuIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqL1xuZnVuY3Rpb24gc2V0SW5zdGFuY2UobmV3SW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZSA9IG5ld0luc3RhbmNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvZ2dlciBpbnN0YW5jZS5cbiAqIEBkZXByZWNhdGVkXG4gKlxuICogSW4gVHlwZVNjcmlwdCwgdXNlIGRlZmF1bHQgaW1wb3J0OlxuICogYGBgXG4gKiAgaW1wb3J0IExvZ2dlciBmcm9tICcuL0xvZ2dlcic7XG4gKiAgTG9nZ2VyKCkuaW5mbyguLi4pXG4gKiBgYGBcbiAqXG4gKiBJbiBKYXZhU2NyaXB0LCB1c2U6XG4gKiBgYGBcbiAqICBjb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL0xvZ2dlcicpLmRlZmF1bHQ7XG4gKiAgTG9nZ2VyKCkuaW5mbyguLi4pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG4gICAgLy8gdXNlIHRoZSBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGxvZ2dlciBhcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbjtcbiAgICAvLyB3ZSBkbyB0aGlzIHNvIHRoYXQgdW5pdCB0ZXN0cyBkb24ndCBmYWlsIHdoZW4gdGhlIG1vZHVsZXMgdGhleSdyZSB0ZXN0aW5nXG4gICAgLy8gbG9nIG1lc3NhZ2VzXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZSA9IG5ldyBicm93c2VyXzEuZGVmYXVsdCgpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5leHBvcnRzLmRlZmF1bHQgPSAoKSA9PiBnZXRJbnN0YW5jZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/browser.js":
/*!***************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/browser.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\n/**\n * Creates a new Logger instance for when we're running in the browser.\n *\n * @param {Object} [options]\n *\n * @constructor\n */\nfunction Logger(options) {\n    /**\n     * The array to which all log messages will be added.\n     *\n     * @type {String[]}\n     */\n    const buffer = [];\n    /**\n     * Logs a message at a given level.\n     *\n     * @param {String} levelTag the tag associated with the level at which to log\n     *   the message.\n     * @param {String} message the message to log.\n     * @param {Number} bufferMaxLength the maximum size to which the message\n     *   buffer can grow.\n     */\n    const logMessage = function (levelTag, message, bufferMaxLength) {\n        // add the log level tag (e.g. info, warn, etc.) to the front of the message\n        message = Util.format('%s: %s', levelTag, message);\n        // if the buffer is full, evict old messages\n        while (buffer.length >= bufferMaxLength) {\n            buffer.shift();\n        }\n        // add the new message to the buffer\n        buffer.push(message);\n    };\n    // create an inner implementation to which all our methods will be forwarded\n    const common = Core.createLogger(options, logMessage);\n    /**\n     * Configures this logger.\n     *\n     * @param {Object} options\n     */\n    this.configure = function (options) {\n        common.configure(options);\n    };\n    /**\n     * Returns the current log level.\n     *\n     * @returns {Number}\n     */\n    this.getLevel = function () {\n        return common.getLevelNumber();\n    };\n    /**\n     * Logs a given message at the error level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.error = function (message, ...params) {\n        common.error.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the warning level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.warn = function (message, ...params) {\n        common.warn.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the info level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.info = function (message, ...params) {\n        common.info.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the debug level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.debug = function (message, ...params) {\n        common.debug.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the trace level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.trace = function (message, ...params) {\n        common.trace.apply(common, [message, ...params]);\n    };\n    /**\n     * Returns the log buffer.\n     *\n     * @returns {String[]}\n     */\n    this.getLogBuffer = function () {\n        // return a copy of the buffer array; calling slice() shallow-copies the\n        // original array, but that's sufficient in this case because the array\n        // contains strings\n        return buffer.slice();\n    };\n}\nmodule.exports = Logger;\n//# sourceMappingURL=browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsMEVBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2xvZ2dlci9icm93c2VyLmpzPzA1MTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExvZ2dlciBpbnN0YW5jZSBmb3Igd2hlbiB3ZSdyZSBydW5uaW5nIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9nZ2VyKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgdG8gd2hpY2ggYWxsIGxvZyBtZXNzYWdlcyB3aWxsIGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IGEgZ2l2ZW4gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWxUYWcgdGhlIHRhZyBhc3NvY2lhdGVkIHdpdGggdGhlIGxldmVsIGF0IHdoaWNoIHRvIGxvZ1xuICAgICAqICAgdGhlIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBidWZmZXJNYXhMZW5ndGggdGhlIG1heGltdW0gc2l6ZSB0byB3aGljaCB0aGUgbWVzc2FnZVxuICAgICAqICAgYnVmZmVyIGNhbiBncm93LlxuICAgICAqL1xuICAgIGNvbnN0IGxvZ01lc3NhZ2UgPSBmdW5jdGlvbiAobGV2ZWxUYWcsIG1lc3NhZ2UsIGJ1ZmZlck1heExlbmd0aCkge1xuICAgICAgICAvLyBhZGQgdGhlIGxvZyBsZXZlbCB0YWcgKGUuZy4gaW5mbywgd2FybiwgZXRjLikgdG8gdGhlIGZyb250IG9mIHRoZSBtZXNzYWdlXG4gICAgICAgIG1lc3NhZ2UgPSBVdGlsLmZvcm1hdCgnJXM6ICVzJywgbGV2ZWxUYWcsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBpZiB0aGUgYnVmZmVyIGlzIGZ1bGwsIGV2aWN0IG9sZCBtZXNzYWdlc1xuICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCA+PSBidWZmZXJNYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IG1lc3NhZ2UgdG8gdGhlIGJ1ZmZlclxuICAgICAgICBidWZmZXIucHVzaChtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8vIGNyZWF0ZSBhbiBpbm5lciBpbXBsZW1lbnRhdGlvbiB0byB3aGljaCBhbGwgb3VyIG1ldGhvZHMgd2lsbCBiZSBmb3J3YXJkZWRcbiAgICBjb25zdCBjb21tb24gPSBDb3JlLmNyZWF0ZUxvZ2dlcihvcHRpb25zLCBsb2dNZXNzYWdlKTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoaXMgbG9nZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGNvbW1vbi5jb25maWd1cmUob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbi5nZXRMZXZlbE51bWJlcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGVycm9yIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29tbW9uLmVycm9yLmFwcGx5KGNvbW1vbiwgW21lc3NhZ2UsIC4uLnBhcmFtc10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHdhcm5pbmcgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICB0aGlzLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi53YXJuLmFwcGx5KGNvbW1vbiwgW21lc3NhZ2UsIC4uLnBhcmFtc10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGluZm8gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi5pbmZvLmFwcGx5KGNvbW1vbiwgW21lc3NhZ2UsIC4uLnBhcmFtc10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGRlYnVnIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy5kZWJ1ZyA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29tbW9uLmRlYnVnLmFwcGx5KGNvbW1vbiwgW21lc3NhZ2UsIC4uLnBhcmFtc10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHRyYWNlIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy50cmFjZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29tbW9uLnRyYWNlLmFwcGx5KGNvbW1vbiwgW21lc3NhZ2UsIC4uLnBhcmFtc10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9nIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLmdldExvZ0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgYnVmZmVyIGFycmF5OyBjYWxsaW5nIHNsaWNlKCkgc2hhbGxvdy1jb3BpZXMgdGhlXG4gICAgICAgIC8vIG9yaWdpbmFsIGFycmF5LCBidXQgdGhhdCdzIHN1ZmZpY2llbnQgaW4gdGhpcyBjYXNlIGJlY2F1c2UgdGhlIGFycmF5XG4gICAgICAgIC8vIGNvbnRhaW5zIHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IExvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/core.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst SecretDetector = new (__webpack_require__(/*! ../secret_detector.js */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/secret_detector.js\"))();\nconst LOG_LEVEL_OFF = {\n    tag: 'OFF',\n    level: -1,\n};\nconst LOG_LEVEL_ERROR = {\n    tag: 'ERROR',\n    level: 0,\n};\nconst LOG_LEVEL_WARN = {\n    tag: 'WARN',\n    level: 1,\n};\nconst LOG_LEVEL_INFO = {\n    tag: 'INFO',\n    level: 2,\n};\nconst LOG_LEVEL_DEBUG = {\n    tag: 'DEBUG',\n    level: 3,\n};\nconst LOG_LEVEL_TRACE = {\n    tag: 'TRACE',\n    level: 4,\n};\nconst LOG_LEVELS = [\n    LOG_LEVEL_OFF,\n    LOG_LEVEL_ERROR,\n    LOG_LEVEL_WARN,\n    LOG_LEVEL_INFO,\n    LOG_LEVEL_DEBUG,\n    LOG_LEVEL_TRACE,\n];\nconst LOG_LEVEL_TAGS = {\n    OFF: LOG_LEVEL_OFF.tag,\n    ERROR: LOG_LEVEL_ERROR.tag,\n    WARN: LOG_LEVEL_WARN.tag,\n    INFO: LOG_LEVEL_INFO.tag,\n    DEBUG: LOG_LEVEL_DEBUG.tag,\n    TRACE: LOG_LEVEL_TRACE.tag,\n};\nexports.LOG_LEVEL_TAGS = LOG_LEVEL_TAGS;\n// create two maps, one in which the key is the log level and the value is the\n// corresponding log level object, and another in which the key is the log tag\n// and the value is the corresponding log level\nconst MAP_LOG_LEVEL_TO_OBJECT = {};\nconst MAP_LOG_TAG_TO_LEVEL = {};\nfor (let index = 0, length = LOG_LEVELS.length; index < length; index++) {\n    const logLevelObject = LOG_LEVELS[index];\n    MAP_LOG_LEVEL_TO_OBJECT[logLevelObject.level] = logLevelObject;\n    MAP_LOG_TAG_TO_LEVEL[logLevelObject.tag] = logLevelObject.level;\n}\nconst DEFAULT_BUFFER_MAX_LENGTH = 500;\nconst DEFAULT_MESSAGE_MAX_LENGTH = 500;\nconst DEFAULT_LEVEL = LOG_LEVEL_INFO;\n/**\n * Creates a new Logger instance.\n *\n * @param options {Object}\n * @param logMessage {Function}\n * @param reconfigureOperation {Function} Action to perform to change log destination file\n *\n * @returns {Object}\n */\nexports.createLogger = function (options, logMessage, reconfigureOperation) {\n    // a log function must be specified\n    Errors.assertInternal(Util.isFunction(logMessage));\n    /**\n     * Whether to include the current timestamp in the log message.\n     */\n    let includeTimestamp;\n    /**\n     * The maximum size (in terms of number of messages) to which the log buffer\n     * can grow.\n     *\n     * @type {Number}\n     */\n    let bufferMaxLength;\n    /**\n     * The maximum message length. Longer messages will be truncated.\n     *\n     * @type {Number}\n     */\n    let messageMaxLength;\n    /**\n     * The current log level. Any message logged at a lower level won't be added\n     * to the log buffer.\n     *\n     * @type {Object}\n     */\n    let currlevelObject;\n    // create a new logger instance\n    const logger = {\n        /**\n         * Configures this logger.\n         *\n         * @param {Object} options\n         */\n        configure: function (options) {\n            let localIncludeTimestamp;\n            let localBufferMaxLength;\n            let localMessageMaxLength;\n            let localLevel;\n            let localFilePath;\n            let localAdditionalLogToConsole;\n            // if an options argument is specified\n            if (Util.exists(options)) {\n                // make sure it's an object\n                Errors.assertInternal(Util.isObject(options));\n                localIncludeTimestamp = options.includeTimestamp;\n                localBufferMaxLength = options.bufferMaxLength;\n                localMessageMaxLength = options.messageMaxLength;\n                localLevel = options.level;\n                localFilePath = options.filePath;\n                localAdditionalLogToConsole = options.additionalLogToConsole;\n            }\n            // if an includeTimestamp options is specified, convert it to a boolean\n            if (Util.exists(localIncludeTimestamp)) {\n                includeTimestamp = !!localIncludeTimestamp;\n            }\n            else if (!Util.exists(includeTimestamp)) {\n                // default to true\n                includeTimestamp = true;\n            }\n            // if a bufferMaxLength option is specified, make sure\n            // it's a positive integer before updating the logger option\n            if (Util.exists(localBufferMaxLength)) {\n                Errors.assertInternal(Util.number.isPositiveInteger(localBufferMaxLength));\n                bufferMaxLength = localBufferMaxLength;\n            }\n            else if (!Util.exists(bufferMaxLength)) {\n                // initialize logger option if configure() hasn't been called before\n                bufferMaxLength = DEFAULT_BUFFER_MAX_LENGTH;\n            }\n            // if a messageMaxLength option is specified, make sure\n            // it's a positive integer before updating the logger option\n            if (Util.exists(localMessageMaxLength)) {\n                Errors.assertInternal(Util.number.isPositiveInteger(localMessageMaxLength));\n                messageMaxLength = localMessageMaxLength;\n            }\n            else if (!Util.exists(messageMaxLength)) {\n                // initialize logger option if configure() hasn't been called before\n                messageMaxLength = DEFAULT_MESSAGE_MAX_LENGTH;\n            }\n            // if a level option is specified, make sure\n            // it's valid before updating the logger option\n            if (Util.exists(localLevel)) {\n                Errors.assertInternal(Object.prototype.hasOwnProperty.call(MAP_LOG_LEVEL_TO_OBJECT, localLevel));\n                currlevelObject = MAP_LOG_LEVEL_TO_OBJECT[localLevel];\n            }\n            else if (!Util.exists(currlevelObject)) {\n                // initialize logger option if configure() hasn't been called before\n                currlevelObject = DEFAULT_LEVEL;\n            }\n            if (Util.isFunction(reconfigureOperation)) {\n                reconfigureOperation(localFilePath, localAdditionalLogToConsole);\n            }\n        },\n        /**\n         * Logs a given message at the error level.\n         *\n         * @param {String} message\n         */\n        error: function (message) {\n            log(LOG_LEVEL_ERROR, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the warn level.\n         *\n         * @param {String} message\n         */\n        warn: function (message) {\n            log(LOG_LEVEL_WARN, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the info level.\n         *\n         * @param {String} message\n         */\n        info: function (message) {\n            log(LOG_LEVEL_INFO, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the debug level.\n         *\n         * @param {String} message\n         */\n        debug: function (message) {\n            log(LOG_LEVEL_DEBUG, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the trace level.\n         *\n         * @param {String} message\n         */\n        trace: function (message) {\n            log(LOG_LEVEL_TRACE, message, getMessageArgs(arguments));\n        },\n        /**\n         * Returns the log buffer.\n         *\n         * @returns {String[]}\n         */\n        getLogBuffer: function () {\n            return [];\n        },\n        /**\n         * Returns the level number associated with the current log level.\n         *\n         * @returns {Number}\n         */\n        getLevelNumber: function () {\n            return currlevelObject.level;\n        },\n        /**\n         * Returns the tag associated with the current log level.\n         *\n         * @returns {String}\n         */\n        getLevelTag: function () {\n            return currlevelObject.tag;\n        },\n        /**\n         * Returns a map in which the keys are the level tags and the values are the\n         * corresponding log levels.\n         *\n         * @returns {Object}\n         */\n        getLevelTagsMap: function () {\n            return MAP_LOG_TAG_TO_LEVEL;\n        },\n    };\n    // configure the logger\n    logger.configure(options);\n    /**\n     * Logs a message at a given level.\n     *\n     * @param {Object} targetLevelObject the level at which to log the message.\n     * @param {String} message the message template.\n     * @param {String[]} messageArgs any arguments to substitute into the message.\n     */\n    const log = function (targetLevelObject, message, messageArgs) {\n        // the message should not be logged if the target\n        // level is more verbose than the current level\n        if (targetLevelObject.level <= currlevelObject.level) {\n            // substitute the messageArgs into the message template\n            messageArgs.unshift(message);\n            message = Util.format.apply(Util, messageArgs);\n            // truncate the message if it's too long\n            if (message.length > messageMaxLength) {\n                message = message.slice(0, messageMaxLength);\n            }\n            // if needed, add the current time to the front of the message\n            if (includeTimestamp) {\n                message = Util.format('[%s]: %s', moment().format('h:mm:ss.SSS A'), message);\n            }\n            // mask secrets\n            message = SecretDetector.maskSecrets(message).maskedtxt;\n            // log the message\n            logMessage(targetLevelObject.tag, message, bufferMaxLength);\n        }\n    };\n    return logger;\n};\nexports.isValidLogTag = function (logTag) {\n    if (!Util.isString(logTag)) {\n        return false;\n    }\n    return Object.prototype.hasOwnProperty.call(MAP_LOG_TAG_TO_LEVEL, logTag.toUpperCase());\n};\nexports.logTagToLevel = function (logTag) {\n    Errors.assertInternal(Util.isString(logTag));\n    return MAP_LOG_TAG_TO_LEVEL[logTag.toUpperCase()];\n};\n/**\n * Helper method to extract the messageArgs from the arguments passed to\n * trace(), debug(), info(), warn() and error().\n *\n * @param {Object} args\n *\n * @returns {*}\n */\nfunction getMessageArgs(args) {\n    return Array.prototype.slice.call(args, 1);\n}\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvY29yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLDZGQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvbG9nZ2VyL2NvcmUuanM/YmYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgU2VjcmV0RGV0ZWN0b3IgPSBuZXcgKHJlcXVpcmUoJy4uL3NlY3JldF9kZXRlY3Rvci5qcycpKSgpO1xuY29uc3QgTE9HX0xFVkVMX09GRiA9IHtcbiAgICB0YWc6ICdPRkYnLFxuICAgIGxldmVsOiAtMSxcbn07XG5jb25zdCBMT0dfTEVWRUxfRVJST1IgPSB7XG4gICAgdGFnOiAnRVJST1InLFxuICAgIGxldmVsOiAwLFxufTtcbmNvbnN0IExPR19MRVZFTF9XQVJOID0ge1xuICAgIHRhZzogJ1dBUk4nLFxuICAgIGxldmVsOiAxLFxufTtcbmNvbnN0IExPR19MRVZFTF9JTkZPID0ge1xuICAgIHRhZzogJ0lORk8nLFxuICAgIGxldmVsOiAyLFxufTtcbmNvbnN0IExPR19MRVZFTF9ERUJVRyA9IHtcbiAgICB0YWc6ICdERUJVRycsXG4gICAgbGV2ZWw6IDMsXG59O1xuY29uc3QgTE9HX0xFVkVMX1RSQUNFID0ge1xuICAgIHRhZzogJ1RSQUNFJyxcbiAgICBsZXZlbDogNCxcbn07XG5jb25zdCBMT0dfTEVWRUxTID0gW1xuICAgIExPR19MRVZFTF9PRkYsXG4gICAgTE9HX0xFVkVMX0VSUk9SLFxuICAgIExPR19MRVZFTF9XQVJOLFxuICAgIExPR19MRVZFTF9JTkZPLFxuICAgIExPR19MRVZFTF9ERUJVRyxcbiAgICBMT0dfTEVWRUxfVFJBQ0UsXG5dO1xuY29uc3QgTE9HX0xFVkVMX1RBR1MgPSB7XG4gICAgT0ZGOiBMT0dfTEVWRUxfT0ZGLnRhZyxcbiAgICBFUlJPUjogTE9HX0xFVkVMX0VSUk9SLnRhZyxcbiAgICBXQVJOOiBMT0dfTEVWRUxfV0FSTi50YWcsXG4gICAgSU5GTzogTE9HX0xFVkVMX0lORk8udGFnLFxuICAgIERFQlVHOiBMT0dfTEVWRUxfREVCVUcudGFnLFxuICAgIFRSQUNFOiBMT0dfTEVWRUxfVFJBQ0UudGFnLFxufTtcbmV4cG9ydHMuTE9HX0xFVkVMX1RBR1MgPSBMT0dfTEVWRUxfVEFHUztcbi8vIGNyZWF0ZSB0d28gbWFwcywgb25lIGluIHdoaWNoIHRoZSBrZXkgaXMgdGhlIGxvZyBsZXZlbCBhbmQgdGhlIHZhbHVlIGlzIHRoZVxuLy8gY29ycmVzcG9uZGluZyBsb2cgbGV2ZWwgb2JqZWN0LCBhbmQgYW5vdGhlciBpbiB3aGljaCB0aGUga2V5IGlzIHRoZSBsb2cgdGFnXG4vLyBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjb3JyZXNwb25kaW5nIGxvZyBsZXZlbFxuY29uc3QgTUFQX0xPR19MRVZFTF9UT19PQkpFQ1QgPSB7fTtcbmNvbnN0IE1BUF9MT0dfVEFHX1RPX0xFVkVMID0ge307XG5mb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IExPR19MRVZFTFMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGxvZ0xldmVsT2JqZWN0ID0gTE9HX0xFVkVMU1tpbmRleF07XG4gICAgTUFQX0xPR19MRVZFTF9UT19PQkpFQ1RbbG9nTGV2ZWxPYmplY3QubGV2ZWxdID0gbG9nTGV2ZWxPYmplY3Q7XG4gICAgTUFQX0xPR19UQUdfVE9fTEVWRUxbbG9nTGV2ZWxPYmplY3QudGFnXSA9IGxvZ0xldmVsT2JqZWN0LmxldmVsO1xufVxuY29uc3QgREVGQVVMVF9CVUZGRVJfTUFYX0xFTkdUSCA9IDUwMDtcbmNvbnN0IERFRkFVTFRfTUVTU0FHRV9NQVhfTEVOR1RIID0gNTAwO1xuY29uc3QgREVGQVVMVF9MRVZFTCA9IExPR19MRVZFTF9JTkZPO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExvZ2dlciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogQHBhcmFtIGxvZ01lc3NhZ2Uge0Z1bmN0aW9ufVxuICogQHBhcmFtIHJlY29uZmlndXJlT3BlcmF0aW9uIHtGdW5jdGlvbn0gQWN0aW9uIHRvIHBlcmZvcm0gdG8gY2hhbmdlIGxvZyBkZXN0aW5hdGlvbiBmaWxlXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5jcmVhdGVMb2dnZXIgPSBmdW5jdGlvbiAob3B0aW9ucywgbG9nTWVzc2FnZSwgcmVjb25maWd1cmVPcGVyYXRpb24pIHtcbiAgICAvLyBhIGxvZyBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzRnVuY3Rpb24obG9nTWVzc2FnZSkpO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgY3VycmVudCB0aW1lc3RhbXAgaW4gdGhlIGxvZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIGxldCBpbmNsdWRlVGltZXN0YW1wO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHNpemUgKGluIHRlcm1zIG9mIG51bWJlciBvZiBtZXNzYWdlcykgdG8gd2hpY2ggdGhlIGxvZyBidWZmZXJcbiAgICAgKiBjYW4gZ3Jvdy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbGV0IGJ1ZmZlck1heExlbmd0aDtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBtZXNzYWdlIGxlbmd0aC4gTG9uZ2VyIG1lc3NhZ2VzIHdpbGwgYmUgdHJ1bmNhdGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBsZXQgbWVzc2FnZU1heExlbmd0aDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBsb2cgbGV2ZWwuIEFueSBtZXNzYWdlIGxvZ2dlZCBhdCBhIGxvd2VyIGxldmVsIHdvbid0IGJlIGFkZGVkXG4gICAgICogdG8gdGhlIGxvZyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxldCBjdXJybGV2ZWxPYmplY3Q7XG4gICAgLy8gY3JlYXRlIGEgbmV3IGxvZ2dlciBpbnN0YW5jZVxuICAgIGNvbnN0IGxvZ2dlciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhpcyBsb2dnZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxJbmNsdWRlVGltZXN0YW1wO1xuICAgICAgICAgICAgbGV0IGxvY2FsQnVmZmVyTWF4TGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGxvY2FsTWVzc2FnZU1heExlbmd0aDtcbiAgICAgICAgICAgIGxldCBsb2NhbExldmVsO1xuICAgICAgICAgICAgbGV0IGxvY2FsRmlsZVBhdGg7XG4gICAgICAgICAgICBsZXQgbG9jYWxBZGRpdGlvbmFsTG9nVG9Db25zb2xlO1xuICAgICAgICAgICAgLy8gaWYgYW4gb3B0aW9ucyBhcmd1bWVudCBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICBsb2NhbEluY2x1ZGVUaW1lc3RhbXAgPSBvcHRpb25zLmluY2x1ZGVUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgbG9jYWxCdWZmZXJNYXhMZW5ndGggPSBvcHRpb25zLmJ1ZmZlck1heExlbmd0aDtcbiAgICAgICAgICAgICAgICBsb2NhbE1lc3NhZ2VNYXhMZW5ndGggPSBvcHRpb25zLm1lc3NhZ2VNYXhMZW5ndGg7XG4gICAgICAgICAgICAgICAgbG9jYWxMZXZlbCA9IG9wdGlvbnMubGV2ZWw7XG4gICAgICAgICAgICAgICAgbG9jYWxGaWxlUGF0aCA9IG9wdGlvbnMuZmlsZVBhdGg7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGRpdGlvbmFsTG9nVG9Db25zb2xlID0gb3B0aW9ucy5hZGRpdGlvbmFsTG9nVG9Db25zb2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYW4gaW5jbHVkZVRpbWVzdGFtcCBvcHRpb25zIGlzIHNwZWNpZmllZCwgY29udmVydCBpdCB0byBhIGJvb2xlYW5cbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhsb2NhbEluY2x1ZGVUaW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZVRpbWVzdGFtcCA9ICEhbG9jYWxJbmNsdWRlVGltZXN0YW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIVV0aWwuZXhpc3RzKGluY2x1ZGVUaW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byB0cnVlXG4gICAgICAgICAgICAgICAgaW5jbHVkZVRpbWVzdGFtcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBhIGJ1ZmZlck1heExlbmd0aCBvcHRpb24gaXMgc3BlY2lmaWVkLCBtYWtlIHN1cmVcbiAgICAgICAgICAgIC8vIGl0J3MgYSBwb3NpdGl2ZSBpbnRlZ2VyIGJlZm9yZSB1cGRhdGluZyB0aGUgbG9nZ2VyIG9wdGlvblxuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKGxvY2FsQnVmZmVyTWF4TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLm51bWJlci5pc1Bvc2l0aXZlSW50ZWdlcihsb2NhbEJ1ZmZlck1heExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlck1heExlbmd0aCA9IGxvY2FsQnVmZmVyTWF4TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIVV0aWwuZXhpc3RzKGJ1ZmZlck1heExlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIGxvZ2dlciBvcHRpb24gaWYgY29uZmlndXJlKCkgaGFzbid0IGJlZW4gY2FsbGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIGJ1ZmZlck1heExlbmd0aCA9IERFRkFVTFRfQlVGRkVSX01BWF9MRU5HVEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBhIG1lc3NhZ2VNYXhMZW5ndGggb3B0aW9uIGlzIHNwZWNpZmllZCwgbWFrZSBzdXJlXG4gICAgICAgICAgICAvLyBpdCdzIGEgcG9zaXRpdmUgaW50ZWdlciBiZWZvcmUgdXBkYXRpbmcgdGhlIGxvZ2dlciBvcHRpb25cbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhsb2NhbE1lc3NhZ2VNYXhMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyKGxvY2FsTWVzc2FnZU1heExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VNYXhMZW5ndGggPSBsb2NhbE1lc3NhZ2VNYXhMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghVXRpbC5leGlzdHMobWVzc2FnZU1heExlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIGxvZ2dlciBvcHRpb24gaWYgY29uZmlndXJlKCkgaGFzbid0IGJlZW4gY2FsbGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VNYXhMZW5ndGggPSBERUZBVUxUX01FU1NBR0VfTUFYX0xFTkdUSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGEgbGV2ZWwgb3B0aW9uIGlzIHNwZWNpZmllZCwgbWFrZSBzdXJlXG4gICAgICAgICAgICAvLyBpdCdzIHZhbGlkIGJlZm9yZSB1cGRhdGluZyB0aGUgbG9nZ2VyIG9wdGlvblxuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKGxvY2FsTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNQVBfTE9HX0xFVkVMX1RPX09CSkVDVCwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgICAgIGN1cnJsZXZlbE9iamVjdCA9IE1BUF9MT0dfTEVWRUxfVE9fT0JKRUNUW2xvY2FsTGV2ZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIVV0aWwuZXhpc3RzKGN1cnJsZXZlbE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIGxvZ2dlciBvcHRpb24gaWYgY29uZmlndXJlKCkgaGFzbid0IGJlZW4gY2FsbGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIGN1cnJsZXZlbE9iamVjdCA9IERFRkFVTFRfTEVWRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHJlY29uZmlndXJlT3BlcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJlY29uZmlndXJlT3BlcmF0aW9uKGxvY2FsRmlsZVBhdGgsIGxvY2FsQWRkaXRpb25hbExvZ1RvQ29uc29sZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgZXJyb3IgbGV2ZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZyhMT0dfTEVWRUxfRVJST1IsIG1lc3NhZ2UsIGdldE1lc3NhZ2VBcmdzKGFyZ3VtZW50cykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHdhcm4gbGV2ZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICB3YXJuOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nKExPR19MRVZFTF9XQVJOLCBtZXNzYWdlLCBnZXRNZXNzYWdlQXJncyhhcmd1bWVudHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSBpbmZvIGxldmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5mbzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZyhMT0dfTEVWRUxfSU5GTywgbWVzc2FnZSwgZ2V0TWVzc2FnZUFyZ3MoYXJndW1lbnRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgZGVidWcgbGV2ZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZyhMT0dfTEVWRUxfREVCVUcsIG1lc3NhZ2UsIGdldE1lc3NhZ2VBcmdzKGFyZ3VtZW50cykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHRyYWNlIGxldmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhY2U6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2coTE9HX0xFVkVMX1RSQUNFLCBtZXNzYWdlLCBnZXRNZXNzYWdlQXJncyhhcmd1bWVudHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxvZyBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIGdldExvZ0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGV2ZWwgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMZXZlbE51bWJlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJsZXZlbE9iamVjdC5sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRhZyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbG9nIGxldmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGV2ZWxUYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJybGV2ZWxPYmplY3QudGFnO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG1hcCBpbiB3aGljaCB0aGUga2V5cyBhcmUgdGhlIGxldmVsIHRhZ3MgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIGxvZyBsZXZlbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMZXZlbFRhZ3NNYXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNQVBfTE9HX1RBR19UT19MRVZFTDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8vIGNvbmZpZ3VyZSB0aGUgbG9nZ2VyXG4gICAgbG9nZ2VyLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldExldmVsT2JqZWN0IHRoZSBsZXZlbCBhdCB3aGljaCB0byBsb2cgdGhlIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbWVzc2FnZUFyZ3MgYW55IGFyZ3VtZW50cyB0byBzdWJzdGl0dXRlIGludG8gdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3QgbG9nID0gZnVuY3Rpb24gKHRhcmdldExldmVsT2JqZWN0LCBtZXNzYWdlLCBtZXNzYWdlQXJncykge1xuICAgICAgICAvLyB0aGUgbWVzc2FnZSBzaG91bGQgbm90IGJlIGxvZ2dlZCBpZiB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIGxldmVsIGlzIG1vcmUgdmVyYm9zZSB0aGFuIHRoZSBjdXJyZW50IGxldmVsXG4gICAgICAgIGlmICh0YXJnZXRMZXZlbE9iamVjdC5sZXZlbCA8PSBjdXJybGV2ZWxPYmplY3QubGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIHN1YnN0aXR1dGUgdGhlIG1lc3NhZ2VBcmdzIGludG8gdGhlIG1lc3NhZ2UgdGVtcGxhdGVcbiAgICAgICAgICAgIG1lc3NhZ2VBcmdzLnVuc2hpZnQobWVzc2FnZSk7XG4gICAgICAgICAgICBtZXNzYWdlID0gVXRpbC5mb3JtYXQuYXBwbHkoVXRpbCwgbWVzc2FnZUFyZ3MpO1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGhlIG1lc3NhZ2UgaWYgaXQncyB0b28gbG9uZ1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gbWVzc2FnZU1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnNsaWNlKDAsIG1lc3NhZ2VNYXhMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbmVlZGVkLCBhZGQgdGhlIGN1cnJlbnQgdGltZSB0byB0aGUgZnJvbnQgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmIChpbmNsdWRlVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFV0aWwuZm9ybWF0KCdbJXNdOiAlcycsIG1vbWVudCgpLmZvcm1hdCgnaDptbTpzcy5TU1MgQScpLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hc2sgc2VjcmV0c1xuICAgICAgICAgICAgbWVzc2FnZSA9IFNlY3JldERldGVjdG9yLm1hc2tTZWNyZXRzKG1lc3NhZ2UpLm1hc2tlZHR4dDtcbiAgICAgICAgICAgIC8vIGxvZyB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgbG9nTWVzc2FnZSh0YXJnZXRMZXZlbE9iamVjdC50YWcsIG1lc3NhZ2UsIGJ1ZmZlck1heExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBsb2dnZXI7XG59O1xuZXhwb3J0cy5pc1ZhbGlkTG9nVGFnID0gZnVuY3Rpb24gKGxvZ1RhZykge1xuICAgIGlmICghVXRpbC5pc1N0cmluZyhsb2dUYWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNQVBfTE9HX1RBR19UT19MRVZFTCwgbG9nVGFnLnRvVXBwZXJDYXNlKCkpO1xufTtcbmV4cG9ydHMubG9nVGFnVG9MZXZlbCA9IGZ1bmN0aW9uIChsb2dUYWcpIHtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc1N0cmluZyhsb2dUYWcpKTtcbiAgICByZXR1cm4gTUFQX0xPR19UQUdfVE9fTEVWRUxbbG9nVGFnLnRvVXBwZXJDYXNlKCldO1xufTtcbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBleHRyYWN0IHRoZSBtZXNzYWdlQXJncyBmcm9tIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gKiB0cmFjZSgpLCBkZWJ1ZygpLCBpbmZvKCksIHdhcm4oKSBhbmQgZXJyb3IoKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBnZXRNZXNzYWdlQXJncyhhcmdzKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fsPromises = __webpack_require__(/*! fs/promises */ \"fs/promises\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { logTagToLevel } = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\nconst { ConfigurationUtil, Levels } = __webpack_require__(/*! ../configuration/client_configuration */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { isFileModeCorrect } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst { exists } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst clientConfiguration = new ConfigurationUtil();\nconst getClientConfig = clientConfiguration.getClientConfig;\nlet initTrialParameters;\n/**\n * @param {string} configFilePathFromConnectionString\n * @returns {Promise<void>}\n */\nexports.init = async function (configFilePathFromConnectionString) {\n    try {\n        if (!allowedToInitialize(configFilePathFromConnectionString)) {\n            return;\n        }\n        Logger.getInstance().info('Trying to initialize Easy Logging');\n        const config = await getClientConfig(configFilePathFromConnectionString);\n        if (!config) {\n            Logger.getInstance().info('Easy Logging is disabled as no config has been found');\n            initTrialParameters = {\n                configFilePathFromConnectionString: configFilePathFromConnectionString,\n            };\n            return;\n        }\n        const logLevel = mapLogLevel(config);\n        const logPath = await getLogPath(config);\n        const logger = Logger.getInstance();\n        logger.info('Initializing Easy Logging with logPath=%s and logLevel=%s from file: %s', logPath, config.loggingConfig.logLevel, config.configPath);\n        logger.configure({\n            level: logLevel,\n            filePath: path.join(logPath, 'snowflake.log'),\n            additionalLogToConsole: false,\n        });\n        logger.easyLoggingConfigureCounter = (logger.easyLoggingConfigureCounter ?? 0) + 1;\n        initTrialParameters = {\n            configFilePathFromConnectionString: configFilePathFromConnectionString,\n        };\n    }\n    catch (err) {\n        const error = new EasyLoggingError('Failed to initialize easy logging', err);\n        Logger.getInstance().error(error);\n        throw error;\n    }\n};\nexports.reset = function () {\n    initTrialParameters = undefined;\n    Logger.getInstance().easyLoggingConfigureCounter = undefined;\n};\nfunction allowedToInitialize(configFilePathFromConnectionString) {\n    const everTriedToInitialize = !!initTrialParameters;\n    const triedToInitializeWithoutConfigFile = everTriedToInitialize && initTrialParameters.configFilePathFromConnectionString == null;\n    const isGivenConfigFilePath = !!configFilePathFromConnectionString;\n    const isAllowedToInitialize = !everTriedToInitialize || (triedToInitializeWithoutConfigFile && isGivenConfigFilePath);\n    if (!isAllowedToInitialize &&\n        initTrialParameters.configFilePathFromConnectionString !== configFilePathFromConnectionString) {\n        Logger.getInstance().warn(`Easy logging will not be configured for CLIENT_CONFIG_FILE=${configFilePathFromConnectionString} because it was previously configured for a different client config`);\n    }\n    return isAllowedToInitialize;\n}\nfunction mapLogLevel(config) {\n    const configLogLevel = getLogLevel(config);\n    const logLevelNumber = logTagToLevel(configLogLevel);\n    if (logLevelNumber === null || logLevelNumber === undefined) {\n        throw new Error('Failed to convert configuration log level into internal one');\n    }\n    return logLevelNumber;\n}\nfunction getLogLevel(config) {\n    const logLevel = config.loggingConfig.logLevel;\n    if (!logLevel) {\n        Logger.getInstance().warn('LogLevel in client config not found. Using default value: OFF');\n        return Levels.Off;\n    }\n    return logLevel;\n}\nasync function getLogPath(config) {\n    let logPath = config.loggingConfig.logPath;\n    if (!logPath) {\n        Logger.getInstance().warn('LogPath in client config not found. Using home directory as a default value');\n        logPath = os.homedir();\n        if (!exists(logPath)) {\n            throw new EasyLoggingError('Home directory does not exist');\n        }\n    }\n    const pathWithNodeJsSubdirectory = path.join(logPath, 'nodejs');\n    await fsPromises\n        .access(pathWithNodeJsSubdirectory, fs.constants.F_OK)\n        .then(async () => {\n        if (!(await isFileModeCorrect(pathWithNodeJsSubdirectory, 0o700, fsPromises))) {\n            Logger.getInstance().warn('Log directory: %s could potentially be accessed by others', pathWithNodeJsSubdirectory);\n        }\n    })\n        .catch(async () => {\n        try {\n            await fsPromises.mkdir(pathWithNodeJsSubdirectory, { recursive: true, mode: 0o700 });\n        }\n        catch (err) {\n            throw new EasyLoggingError(`Failed to create the directory for logs: ${pathWithNodeJsSubdirectory}`);\n        }\n    });\n    return pathWithNodeJsSubdirectory;\n}\nclass EasyLoggingError extends Error {\n    name = 'EasyLoggingError';\n    constructor(message, cause) {\n        super(message);\n        this.cause = cause;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    toString() {\n        return this.message + ': ' + this.cause.toString();\n    }\n}\n//# sourceMappingURL=easy_logging_starter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvZWFzeV9sb2dnaW5nX3N0YXJ0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsZ0NBQWE7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDBFQUFRO0FBQzFDLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyxnSUFBdUM7QUFDckYsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyw4RUFBYztBQUNwRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLG9FQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxvQ0FBb0M7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUVBQWlFLDhCQUE4QjtBQUMvRjtBQUNBO0FBQ0EsbUZBQW1GLDJCQUEyQjtBQUM5RztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvZWFzeV9sb2dnaW5nX3N0YXJ0ZXIuanM/NThhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBmc1Byb21pc2VzID0gcmVxdWlyZSgnZnMvcHJvbWlzZXMnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgbG9nVGFnVG9MZXZlbCB9ID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5jb25zdCB7IENvbmZpZ3VyYXRpb25VdGlsLCBMZXZlbHMgfSA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vY2xpZW50X2NvbmZpZ3VyYXRpb24nKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgeyBpc0ZpbGVNb2RlQ29ycmVjdCB9ID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJyk7XG5jb25zdCB7IGV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgY2xpZW50Q29uZmlndXJhdGlvbiA9IG5ldyBDb25maWd1cmF0aW9uVXRpbCgpO1xuY29uc3QgZ2V0Q2xpZW50Q29uZmlnID0gY2xpZW50Q29uZmlndXJhdGlvbi5nZXRDbGllbnRDb25maWc7XG5sZXQgaW5pdFRyaWFsUGFyYW1ldGVycztcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmdcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnRzLmluaXQgPSBhc3luYyBmdW5jdGlvbiAoY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghYWxsb3dlZFRvSW5pdGlhbGl6ZShjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ1RyeWluZyB0byBpbml0aWFsaXplIEVhc3kgTG9nZ2luZycpO1xuICAgICAgICBjb25zdCBjb25maWcgPSBhd2FpdCBnZXRDbGllbnRDb25maWcoY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZyk7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdFYXN5IExvZ2dpbmcgaXMgZGlzYWJsZWQgYXMgbm8gY29uZmlnIGhhcyBiZWVuIGZvdW5kJyk7XG4gICAgICAgICAgICBpbml0VHJpYWxQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmc6IGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvZ0xldmVsID0gbWFwTG9nTGV2ZWwoY29uZmlnKTtcbiAgICAgICAgY29uc3QgbG9nUGF0aCA9IGF3YWl0IGdldExvZ1BhdGgoY29uZmlnKTtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdJbml0aWFsaXppbmcgRWFzeSBMb2dnaW5nIHdpdGggbG9nUGF0aD0lcyBhbmQgbG9nTGV2ZWw9JXMgZnJvbSBmaWxlOiAlcycsIGxvZ1BhdGgsIGNvbmZpZy5sb2dnaW5nQ29uZmlnLmxvZ0xldmVsLCBjb25maWcuY29uZmlnUGF0aCk7XG4gICAgICAgIGxvZ2dlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgbGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICAgICAgZmlsZVBhdGg6IHBhdGguam9pbihsb2dQYXRoLCAnc25vd2ZsYWtlLmxvZycpLFxuICAgICAgICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIuZWFzeUxvZ2dpbmdDb25maWd1cmVDb3VudGVyID0gKGxvZ2dlci5lYXN5TG9nZ2luZ0NvbmZpZ3VyZUNvdW50ZXIgPz8gMCkgKyAxO1xuICAgICAgICBpbml0VHJpYWxQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZzogY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFYXN5TG9nZ2luZ0Vycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBlYXN5IGxvZ2dpbmcnLCBlcnIpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5leHBvcnRzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGluaXRUcmlhbFBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZWFzeUxvZ2dpbmdDb25maWd1cmVDb3VudGVyID0gdW5kZWZpbmVkO1xufTtcbmZ1bmN0aW9uIGFsbG93ZWRUb0luaXRpYWxpemUoY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZykge1xuICAgIGNvbnN0IGV2ZXJUcmllZFRvSW5pdGlhbGl6ZSA9ICEhaW5pdFRyaWFsUGFyYW1ldGVycztcbiAgICBjb25zdCB0cmllZFRvSW5pdGlhbGl6ZVdpdGhvdXRDb25maWdGaWxlID0gZXZlclRyaWVkVG9Jbml0aWFsaXplICYmIGluaXRUcmlhbFBhcmFtZXRlcnMuY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZyA9PSBudWxsO1xuICAgIGNvbnN0IGlzR2l2ZW5Db25maWdGaWxlUGF0aCA9ICEhY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZztcbiAgICBjb25zdCBpc0FsbG93ZWRUb0luaXRpYWxpemUgPSAhZXZlclRyaWVkVG9Jbml0aWFsaXplIHx8ICh0cmllZFRvSW5pdGlhbGl6ZVdpdGhvdXRDb25maWdGaWxlICYmIGlzR2l2ZW5Db25maWdGaWxlUGF0aCk7XG4gICAgaWYgKCFpc0FsbG93ZWRUb0luaXRpYWxpemUgJiZcbiAgICAgICAgaW5pdFRyaWFsUGFyYW1ldGVycy5jb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nICE9PSBjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYEVhc3kgbG9nZ2luZyB3aWxsIG5vdCBiZSBjb25maWd1cmVkIGZvciBDTElFTlRfQ09ORklHX0ZJTEU9JHtjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nfSBiZWNhdXNlIGl0IHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQgZm9yIGEgZGlmZmVyZW50IGNsaWVudCBjb25maWdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQWxsb3dlZFRvSW5pdGlhbGl6ZTtcbn1cbmZ1bmN0aW9uIG1hcExvZ0xldmVsKGNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZ0xvZ0xldmVsID0gZ2V0TG9nTGV2ZWwoY29uZmlnKTtcbiAgICBjb25zdCBsb2dMZXZlbE51bWJlciA9IGxvZ1RhZ1RvTGV2ZWwoY29uZmlnTG9nTGV2ZWwpO1xuICAgIGlmIChsb2dMZXZlbE51bWJlciA9PT0gbnVsbCB8fCBsb2dMZXZlbE51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbnZlcnQgY29uZmlndXJhdGlvbiBsb2cgbGV2ZWwgaW50byBpbnRlcm5hbCBvbmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ0xldmVsTnVtYmVyO1xufVxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWwoY29uZmlnKSB7XG4gICAgY29uc3QgbG9nTGV2ZWwgPSBjb25maWcubG9nZ2luZ0NvbmZpZy5sb2dMZXZlbDtcbiAgICBpZiAoIWxvZ0xldmVsKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0xvZ0xldmVsIGluIGNsaWVudCBjb25maWcgbm90IGZvdW5kLiBVc2luZyBkZWZhdWx0IHZhbHVlOiBPRkYnKTtcbiAgICAgICAgcmV0dXJuIExldmVscy5PZmY7XG4gICAgfVxuICAgIHJldHVybiBsb2dMZXZlbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldExvZ1BhdGgoY29uZmlnKSB7XG4gICAgbGV0IGxvZ1BhdGggPSBjb25maWcubG9nZ2luZ0NvbmZpZy5sb2dQYXRoO1xuICAgIGlmICghbG9nUGF0aCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdMb2dQYXRoIGluIGNsaWVudCBjb25maWcgbm90IGZvdW5kLiBVc2luZyBob21lIGRpcmVjdG9yeSBhcyBhIGRlZmF1bHQgdmFsdWUnKTtcbiAgICAgICAgbG9nUGF0aCA9IG9zLmhvbWVkaXIoKTtcbiAgICAgICAgaWYgKCFleGlzdHMobG9nUGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFYXN5TG9nZ2luZ0Vycm9yKCdIb21lIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhdGhXaXRoTm9kZUpzU3ViZGlyZWN0b3J5ID0gcGF0aC5qb2luKGxvZ1BhdGgsICdub2RlanMnKTtcbiAgICBhd2FpdCBmc1Byb21pc2VzXG4gICAgICAgIC5hY2Nlc3MocGF0aFdpdGhOb2RlSnNTdWJkaXJlY3RvcnksIGZzLmNvbnN0YW50cy5GX09LKVxuICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghKGF3YWl0IGlzRmlsZU1vZGVDb3JyZWN0KHBhdGhXaXRoTm9kZUpzU3ViZGlyZWN0b3J5LCAwbzcwMCwgZnNQcm9taXNlcykpKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdMb2cgZGlyZWN0b3J5OiAlcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBhY2Nlc3NlZCBieSBvdGhlcnMnLCBwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnNQcm9taXNlcy5ta2RpcihwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSwgeyByZWN1cnNpdmU6IHRydWUsIG1vZGU6IDBvNzAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFYXN5TG9nZ2luZ0Vycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHRoZSBkaXJlY3RvcnkgZm9yIGxvZ3M6ICR7cGF0aFdpdGhOb2RlSnNTdWJkaXJlY3Rvcnl9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aFdpdGhOb2RlSnNTdWJkaXJlY3Rvcnk7XG59XG5jbGFzcyBFYXN5TG9nZ2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIG5hbWUgPSAnRWFzeUxvZ2dpbmdFcnJvcic7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgJzogJyArIHRoaXMuY2F1c2UudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYXN5X2xvZ2dpbmdfc3RhcnRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nfunction ExecutionTimer() {\n    let startTime = null;\n    let endTime = null;\n    // Private function to log and check if the timer was started\n    function wasStarted() {\n        return Util.exists(startTime);\n    }\n    this.start = function () {\n        startTime = performance.now();\n        endTime = null; // Reset endTime if the timer is reused\n        return this;\n    };\n    this.stop = function () {\n        if (!wasStarted()) {\n            // Returning this to allow chaining even after invalid call.\n            // startTime can be used to check, if any start point was ever recorded.\n            Logger.getInstance().debug('Tried to stop timer, that was not started');\n            return this;\n        }\n        endTime = performance.now();\n        return this;\n    };\n    // Get the duration in milliseconds\n    this.getDuration = function () {\n        if (!wasStarted()) {\n            return;\n        }\n        if (endTime === null) {\n            endTime = performance.now();\n        }\n        return Math.round((endTime - startTime) * 100) / 100;\n    };\n}\nmodule.exports = ExecutionTimer;\n//# sourceMappingURL=execution_timer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvZXhlY3V0aW9uX3RpbWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw4QkFBWTtBQUM1QyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvbG9nZ2VyL2V4ZWN1dGlvbl90aW1lci5qcz81MzllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSgncGVyZl9ob29rcycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuZnVuY3Rpb24gRXhlY3V0aW9uVGltZXIoKSB7XG4gICAgbGV0IHN0YXJ0VGltZSA9IG51bGw7XG4gICAgbGV0IGVuZFRpbWUgPSBudWxsO1xuICAgIC8vIFByaXZhdGUgZnVuY3Rpb24gdG8gbG9nIGFuZCBjaGVjayBpZiB0aGUgdGltZXIgd2FzIHN0YXJ0ZWRcbiAgICBmdW5jdGlvbiB3YXNTdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gVXRpbC5leGlzdHMoc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGVuZFRpbWUgPSBudWxsOyAvLyBSZXNldCBlbmRUaW1lIGlmIHRoZSB0aW1lciBpcyByZXVzZWRcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghd2FzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5pbmcgdGhpcyB0byBhbGxvdyBjaGFpbmluZyBldmVuIGFmdGVyIGludmFsaWQgY2FsbC5cbiAgICAgICAgICAgIC8vIHN0YXJ0VGltZSBjYW4gYmUgdXNlZCB0byBjaGVjaywgaWYgYW55IHN0YXJ0IHBvaW50IHdhcyBldmVyIHJlY29yZGVkLlxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1RyaWVkIHRvIHN0b3AgdGltZXIsIHRoYXQgd2FzIG5vdCBzdGFydGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gR2V0IHRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICB0aGlzLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXdhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGVuZFRpbWUgLSBzdGFydFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25UaW1lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4ZWN1dGlvbl90aW1lci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst PROVIDED_TEXT = 'provided';\nconst NOT_PROVIDED_TEXT = 'not provided';\n/**\n * Describes the presence of a given value. If the value is not empty (as a string),\n * returns the corresponding text (by default: 'provided' or 'not provided').\n *\n * @param {*} valueToDescribe - The value to check for presence.\n * @param {Object} [options] - Optional overrides for the \"provided\" and \"not provided\" text.\n * @param {string} [options.overrideProvidedText]\n * @param {string} [options.overrideNotProvidedText]\n * @returns {string} A string indicating the presence of `valueToDescribe`.\n */\nexports.describePresence = function (valueToDescribe, { overrideProvidedText, overrideNotProvidedText } = {}) {\n    const providedText = overrideProvidedText || PROVIDED_TEXT;\n    const notProvidedText = overrideNotProvidedText || NOT_PROVIDED_TEXT;\n    return Util.isNotEmptyAsString(valueToDescribe) ? providedText : notProvidedText;\n};\n/**\n * @param {Object} sourceObject - The object holding attribute values.\n * @param {Array<string>} attributesWithValues - Attributes to show with their values.\n * @param {Array<string>} attributesWithoutValues - Attributes to show as present/not present.\n * @returns {string} Comma-separated string describing the attributes.\n */\nexports.attributesToString = function (sourceObject = {}, attributesWithValues = [], attributesWithoutValues = []) {\n    const withValues = attributesWithValues\n        .filter((attr) => sourceObject[attr] !== undefined)\n        .map((attr) => `${attr}=${String(sourceObject[attr])}`);\n    const withoutValues = attributesWithoutValues\n        .filter((attr) => sourceObject[attr] !== undefined)\n        .map((attr) => `${attr} is ${exports.describePresence(sourceObject[attr])}`);\n    return [...withValues, ...withoutValues].join(', ');\n};\n/**\n * @param {Object} sourceObject - The object holding attribute values.\n * @param {Array<string>} attributesWithValues - Attributes to show with their values.\n * @param {Array<string>} attributesWithoutValues - Attributes to show as present/not present.\n * @returns {string} A bracketed string of described attributes.\n */\nexports.describeAttributes = function (sourceObject, attributesWithValues, attributesWithoutValues) {\n    const attributesDescription = exports.attributesToString(sourceObject, attributesWithValues, attributesWithoutValues);\n    return `[${attributesDescription}]`;\n};\n//# sourceMappingURL=logging_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbG9nZ2luZ191dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHdCQUF3QixnQ0FBZ0MsZ0RBQWdELElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBLDBCQUEwQixLQUFLLEdBQUcsMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxLQUFLLDZDQUE2QztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbG9nZ2luZ191dGlsLmpzPzMwNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgUFJPVklERURfVEVYVCA9ICdwcm92aWRlZCc7XG5jb25zdCBOT1RfUFJPVklERURfVEVYVCA9ICdub3QgcHJvdmlkZWQnO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIHByZXNlbmNlIG9mIGEgZ2l2ZW4gdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBub3QgZW1wdHkgKGFzIGEgc3RyaW5nKSxcbiAqIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCAoYnkgZGVmYXVsdDogJ3Byb3ZpZGVkJyBvciAnbm90IHByb3ZpZGVkJykuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVRvRGVzY3JpYmUgLSBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yIHByZXNlbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIG92ZXJyaWRlcyBmb3IgdGhlIFwicHJvdmlkZWRcIiBhbmQgXCJub3QgcHJvdmlkZWRcIiB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm92ZXJyaWRlUHJvdmlkZWRUZXh0XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm92ZXJyaWRlTm90UHJvdmlkZWRUZXh0XVxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgcHJlc2VuY2Ugb2YgYHZhbHVlVG9EZXNjcmliZWAuXG4gKi9cbmV4cG9ydHMuZGVzY3JpYmVQcmVzZW5jZSA9IGZ1bmN0aW9uICh2YWx1ZVRvRGVzY3JpYmUsIHsgb3ZlcnJpZGVQcm92aWRlZFRleHQsIG92ZXJyaWRlTm90UHJvdmlkZWRUZXh0IH0gPSB7fSkge1xuICAgIGNvbnN0IHByb3ZpZGVkVGV4dCA9IG92ZXJyaWRlUHJvdmlkZWRUZXh0IHx8IFBST1ZJREVEX1RFWFQ7XG4gICAgY29uc3Qgbm90UHJvdmlkZWRUZXh0ID0gb3ZlcnJpZGVOb3RQcm92aWRlZFRleHQgfHwgTk9UX1BST1ZJREVEX1RFWFQ7XG4gICAgcmV0dXJuIFV0aWwuaXNOb3RFbXB0eUFzU3RyaW5nKHZhbHVlVG9EZXNjcmliZSkgPyBwcm92aWRlZFRleHQgOiBub3RQcm92aWRlZFRleHQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqZWN0IC0gVGhlIG9iamVjdCBob2xkaW5nIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF0dHJpYnV0ZXNXaXRoVmFsdWVzIC0gQXR0cmlidXRlcyB0byBzaG93IHdpdGggdGhlaXIgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyAtIEF0dHJpYnV0ZXMgdG8gc2hvdyBhcyBwcmVzZW50L25vdCBwcmVzZW50LlxuICogQHJldHVybnMge3N0cmluZ30gQ29tbWEtc2VwYXJhdGVkIHN0cmluZyBkZXNjcmliaW5nIHRoZSBhdHRyaWJ1dGVzLlxuICovXG5leHBvcnRzLmF0dHJpYnV0ZXNUb1N0cmluZyA9IGZ1bmN0aW9uIChzb3VyY2VPYmplY3QgPSB7fSwgYXR0cmlidXRlc1dpdGhWYWx1ZXMgPSBbXSwgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgPSBbXSkge1xuICAgIGNvbnN0IHdpdGhWYWx1ZXMgPSBhdHRyaWJ1dGVzV2l0aFZhbHVlc1xuICAgICAgICAuZmlsdGVyKChhdHRyKSA9PiBzb3VyY2VPYmplY3RbYXR0cl0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgLm1hcCgoYXR0cikgPT4gYCR7YXR0cn09JHtTdHJpbmcoc291cmNlT2JqZWN0W2F0dHJdKX1gKTtcbiAgICBjb25zdCB3aXRob3V0VmFsdWVzID0gYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXNcbiAgICAgICAgLmZpbHRlcigoYXR0cikgPT4gc291cmNlT2JqZWN0W2F0dHJdICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC5tYXAoKGF0dHIpID0+IGAke2F0dHJ9IGlzICR7ZXhwb3J0cy5kZXNjcmliZVByZXNlbmNlKHNvdXJjZU9iamVjdFthdHRyXSl9YCk7XG4gICAgcmV0dXJuIFsuLi53aXRoVmFsdWVzLCAuLi53aXRob3V0VmFsdWVzXS5qb2luKCcsICcpO1xufTtcbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iamVjdCAtIFRoZSBvYmplY3QgaG9sZGluZyBhdHRyaWJ1dGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdHRyaWJ1dGVzV2l0aFZhbHVlcyAtIEF0dHJpYnV0ZXMgdG8gc2hvdyB3aXRoIHRoZWlyIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgLSBBdHRyaWJ1dGVzIHRvIHNob3cgYXMgcHJlc2VudC9ub3QgcHJlc2VudC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgYnJhY2tldGVkIHN0cmluZyBvZiBkZXNjcmliZWQgYXR0cmlidXRlcy5cbiAqL1xuZXhwb3J0cy5kZXNjcmliZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc291cmNlT2JqZWN0LCBhdHRyaWJ1dGVzV2l0aFZhbHVlcywgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzRGVzY3JpcHRpb24gPSBleHBvcnRzLmF0dHJpYnV0ZXNUb1N0cmluZyhzb3VyY2VPYmplY3QsIGF0dHJpYnV0ZXNXaXRoVmFsdWVzLCBhdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyk7XG4gICAgcmV0dXJuIGBbJHthdHRyaWJ1dGVzRGVzY3JpcHRpb259XWA7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZ191dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/node.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/node.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst winston = __webpack_require__(/*! winston */ \"(rsc)/./node_modules/winston/lib/winston.js\");\nconst Core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst DEFAULT_ADDITIONAL_LOG_TO_CONSOLE = true;\n/**\n * Creates a new Logger instance for when we're running in node.\n *\n * @param {Object} [options]\n *\n * @constructor\n */\nfunction Logger(options) {\n    let winstonLogger;\n    const defaultFilePath = 'snowflake.log';\n    let filePath = getFilePath(options);\n    let additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n    let transportLabels = [];\n    this.setLogger = function (logger) {\n        winstonLogger = logger;\n    };\n    /**\n     * This operation is for purpose of tests only. The idea is to force flushing logs to files.\n     * Winston logger emits 'finish' event before flushes all the transports so waiting for this event on logger is not good enough.\n     * For simplicity, we just close each transport without waiting here.\n     */\n    this.closeTransports = function () {\n        if (transportsCreated()) {\n            for (const transport of winstonLogger.transports) {\n                closeTransport(transport);\n            }\n        }\n    };\n    function transportsCreated() {\n        try {\n            winstonLogger.transports;\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    function closeTransport(transport) {\n        if (!transport.close) {\n            return;\n        }\n        transport.close();\n    }\n    function reconfigureWinstonLogger(filePathInput, additionalLogToConsoleInput) {\n        const currentWinstonLogger = winstonLogger;\n        filePath = filePathInput ?? filePath;\n        if (Util.isBoolean(additionalLogToConsoleInput)) {\n            additionalLogToConsole = additionalLogToConsoleInput;\n        }\n        else {\n            additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n        }\n        winstonLogger = null; // it will be created for the first log operation\n        if (currentWinstonLogger) {\n            currentWinstonLogger.close();\n        }\n    }\n    function setTransportLabels(transportLabelsInput) {\n        transportLabels = transportLabelsInput;\n    }\n    this.getTransportLabels = function () {\n        return transportLabels;\n    };\n    /**\n     * Logs a message at a given level.\n     *\n     * @param {String} levelTag the tag associated with the level at which to log\n     *   the message.\n     * @param {String} message the message to log.\n     */\n    const logMessage = function (levelTag, message) {\n        // initialize the winston logger if needed\n        if (!winstonLogger) {\n            let transports;\n            let transportLabels;\n            if ('STDOUT' === filePath.toUpperCase()) {\n                transports = [new winston.transports.Console()];\n                transportLabels = ['Console'];\n            }\n            else if (additionalLogToConsole === true) {\n                transports = [\n                    new winston.transports.Console(),\n                    new winston.transports.File({ filename: filePath }),\n                ];\n                transportLabels = ['Console', 'File'];\n            }\n            else {\n                transports = [new winston.transports.File({ filename: filePath })];\n                transportLabels = ['File'];\n            }\n            winstonLogger = new winston.createLogger({\n                transports: transports,\n                level: common.getLevelTag(),\n                levels: common.getLevelTagsMap(),\n            });\n            setTransportLabels(transportLabels);\n        }\n        // get the appropriate logging method using the level tag and use this\n        // method to log the message\n        winstonLogger[levelTag](message);\n    };\n    // create an inner implementation to which all our methods will be forwarded\n    const common = Core.createLogger(options, logMessage, reconfigureWinstonLogger);\n    function getFilePath(options) {\n        if (Util.exists(options)) {\n            Errors.assertInternal(Util.isObject(options));\n            return options.filePath ?? defaultFilePath;\n        }\n        return defaultFilePath;\n    }\n    this.getLevelTag = function () {\n        return common.getLevelTag();\n    };\n    this.getLevelTagsMap = function () {\n        return common.getLevelTagsMap();\n    };\n    /**\n     * Configures this logger.\n     *\n     * @param {Object} options\n     */\n    this.configure = function (options) {\n        if (Util.isBoolean(options.additionalLogToConsole)) {\n            additionalLogToConsole = options.additionalLogToConsole;\n        }\n        else {\n            additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n        }\n        common.configure(options);\n    };\n    /**\n     * Returns the current log level.\n     *\n     * @returns {Number}\n     */\n    this.getLevel = function () {\n        return common.getLevelNumber();\n    };\n    /**\n     * Logs a given message at the error level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.error = function (message, ...params) {\n        common.error.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the warning level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.warn = function (message, ...params) {\n        common.warn.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the info level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.info = function (message, ...params) {\n        common.info.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the debug level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.debug = function (message, ...params) {\n        common.debug.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the trace level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.trace = function (message, ...params) {\n        common.trace.apply(common, [message, ...params]);\n    };\n    /**\n     * Returns the log buffer.\n     *\n     * @returns {String[]}\n     */\n    this.getLogBuffer = function () {\n        return common.getLogBuffer();\n    };\n}\nmodule.exports = Logger;\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywwRUFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbm9kZS5qcz9lMWRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoJ3dpbnN0b24nKTtcbmNvbnN0IENvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IERFRkFVTFRfQURESVRJT05BTF9MT0dfVE9fQ09OU09MRSA9IHRydWU7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTG9nZ2VyIGluc3RhbmNlIGZvciB3aGVuIHdlJ3JlIHJ1bm5pbmcgaW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvZ2dlcihvcHRpb25zKSB7XG4gICAgbGV0IHdpbnN0b25Mb2dnZXI7XG4gICAgY29uc3QgZGVmYXVsdEZpbGVQYXRoID0gJ3Nub3dmbGFrZS5sb2cnO1xuICAgIGxldCBmaWxlUGF0aCA9IGdldEZpbGVQYXRoKG9wdGlvbnMpO1xuICAgIGxldCBhZGRpdGlvbmFsTG9nVG9Db25zb2xlID0gREVGQVVMVF9BRERJVElPTkFMX0xPR19UT19DT05TT0xFO1xuICAgIGxldCB0cmFuc3BvcnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLnNldExvZ2dlciA9IGZ1bmN0aW9uIChsb2dnZXIpIHtcbiAgICAgICAgd2luc3RvbkxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgb3BlcmF0aW9uIGlzIGZvciBwdXJwb3NlIG9mIHRlc3RzIG9ubHkuIFRoZSBpZGVhIGlzIHRvIGZvcmNlIGZsdXNoaW5nIGxvZ3MgdG8gZmlsZXMuXG4gICAgICogV2luc3RvbiBsb2dnZXIgZW1pdHMgJ2ZpbmlzaCcgZXZlbnQgYmVmb3JlIGZsdXNoZXMgYWxsIHRoZSB0cmFuc3BvcnRzIHNvIHdhaXRpbmcgZm9yIHRoaXMgZXZlbnQgb24gbG9nZ2VyIGlzIG5vdCBnb29kIGVub3VnaC5cbiAgICAgKiBGb3Igc2ltcGxpY2l0eSwgd2UganVzdCBjbG9zZSBlYWNoIHRyYW5zcG9ydCB3aXRob3V0IHdhaXRpbmcgaGVyZS5cbiAgICAgKi9cbiAgICB0aGlzLmNsb3NlVHJhbnNwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydHNDcmVhdGVkKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNwb3J0IG9mIHdpbnN0b25Mb2dnZXIudHJhbnNwb3J0cykge1xuICAgICAgICAgICAgICAgIGNsb3NlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyYW5zcG9ydHNDcmVhdGVkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luc3RvbkxvZ2dlci50cmFuc3BvcnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgICAgICBpZiAoIXRyYW5zcG9ydC5jbG9zZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbmZpZ3VyZVdpbnN0b25Mb2dnZXIoZmlsZVBhdGhJbnB1dCwgYWRkaXRpb25hbExvZ1RvQ29uc29sZUlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXaW5zdG9uTG9nZ2VyID0gd2luc3RvbkxvZ2dlcjtcbiAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aElucHV0ID8/IGZpbGVQYXRoO1xuICAgICAgICBpZiAoVXRpbC5pc0Jvb2xlYW4oYWRkaXRpb25hbExvZ1RvQ29uc29sZUlucHV0KSkge1xuICAgICAgICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IGFkZGl0aW9uYWxMb2dUb0NvbnNvbGVJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGUgPSBERUZBVUxUX0FERElUSU9OQUxfTE9HX1RPX0NPTlNPTEU7XG4gICAgICAgIH1cbiAgICAgICAgd2luc3RvbkxvZ2dlciA9IG51bGw7IC8vIGl0IHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIGZpcnN0IGxvZyBvcGVyYXRpb25cbiAgICAgICAgaWYgKGN1cnJlbnRXaW5zdG9uTG9nZ2VyKSB7XG4gICAgICAgICAgICBjdXJyZW50V2luc3RvbkxvZ2dlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRyYW5zcG9ydExhYmVscyh0cmFuc3BvcnRMYWJlbHNJbnB1dCkge1xuICAgICAgICB0cmFuc3BvcnRMYWJlbHMgPSB0cmFuc3BvcnRMYWJlbHNJbnB1dDtcbiAgICB9XG4gICAgdGhpcy5nZXRUcmFuc3BvcnRMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnRMYWJlbHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxldmVsVGFnIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBsZXZlbCBhdCB3aGljaCB0byBsb2dcbiAgICAgKiAgIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGxvZy5cbiAgICAgKi9cbiAgICBjb25zdCBsb2dNZXNzYWdlID0gZnVuY3Rpb24gKGxldmVsVGFnLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHdpbnN0b24gbG9nZ2VyIGlmIG5lZWRlZFxuICAgICAgICBpZiAoIXdpbnN0b25Mb2dnZXIpIHtcbiAgICAgICAgICAgIGxldCB0cmFuc3BvcnRzO1xuICAgICAgICAgICAgbGV0IHRyYW5zcG9ydExhYmVscztcbiAgICAgICAgICAgIGlmICgnU1RET1VUJyA9PT0gZmlsZVBhdGgudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHMgPSBbbmV3IHdpbnN0b24udHJhbnNwb3J0cy5Db25zb2xlKCldO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydExhYmVscyA9IFsnQ29uc29sZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyB3aW5zdG9uLnRyYW5zcG9ydHMuQ29uc29sZSgpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgd2luc3Rvbi50cmFuc3BvcnRzLkZpbGUoeyBmaWxlbmFtZTogZmlsZVBhdGggfSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRMYWJlbHMgPSBbJ0NvbnNvbGUnLCAnRmlsZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0cyA9IFtuZXcgd2luc3Rvbi50cmFuc3BvcnRzLkZpbGUoeyBmaWxlbmFtZTogZmlsZVBhdGggfSldO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydExhYmVscyA9IFsnRmlsZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luc3RvbkxvZ2dlciA9IG5ldyB3aW5zdG9uLmNyZWF0ZUxvZ2dlcih7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0czogdHJhbnNwb3J0cyxcbiAgICAgICAgICAgICAgICBsZXZlbDogY29tbW9uLmdldExldmVsVGFnKCksXG4gICAgICAgICAgICAgICAgbGV2ZWxzOiBjb21tb24uZ2V0TGV2ZWxUYWdzTWFwKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFRyYW5zcG9ydExhYmVscyh0cmFuc3BvcnRMYWJlbHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB0aGUgYXBwcm9wcmlhdGUgbG9nZ2luZyBtZXRob2QgdXNpbmcgdGhlIGxldmVsIHRhZyBhbmQgdXNlIHRoaXNcbiAgICAgICAgLy8gbWV0aG9kIHRvIGxvZyB0aGUgbWVzc2FnZVxuICAgICAgICB3aW5zdG9uTG9nZ2VyW2xldmVsVGFnXShtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8vIGNyZWF0ZSBhbiBpbm5lciBpbXBsZW1lbnRhdGlvbiB0byB3aGljaCBhbGwgb3VyIG1ldGhvZHMgd2lsbCBiZSBmb3J3YXJkZWRcbiAgICBjb25zdCBjb21tb24gPSBDb3JlLmNyZWF0ZUxvZ2dlcihvcHRpb25zLCBsb2dNZXNzYWdlLCByZWNvbmZpZ3VyZVdpbnN0b25Mb2dnZXIpO1xuICAgIGZ1bmN0aW9uIGdldEZpbGVQYXRoKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5maWxlUGF0aCA/PyBkZWZhdWx0RmlsZVBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWxlUGF0aDtcbiAgICB9XG4gICAgdGhpcy5nZXRMZXZlbFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbi5nZXRMZXZlbFRhZygpO1xuICAgIH07XG4gICAgdGhpcy5nZXRMZXZlbFRhZ3NNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb24uZ2V0TGV2ZWxUYWdzTWFwKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoaXMgbG9nZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChVdGlsLmlzQm9vbGVhbihvcHRpb25zLmFkZGl0aW9uYWxMb2dUb0NvbnNvbGUpKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsTG9nVG9Db25zb2xlID0gb3B0aW9ucy5hZGRpdGlvbmFsTG9nVG9Db25zb2xlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IERFRkFVTFRfQURESVRJT05BTF9MT0dfVE9fQ09OU09MRTtcbiAgICAgICAgfVxuICAgICAgICBjb21tb24uY29uZmlndXJlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb24uZ2V0TGV2ZWxOdW1iZXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSBlcnJvciBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi5lcnJvci5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB3YXJuaW5nIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgICAgICBjb21tb24ud2Fybi5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSBpbmZvIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgICAgICBjb21tb24uaW5mby5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSBkZWJ1ZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMuZGVidWcgPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi5kZWJ1Zy5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB0cmFjZSBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMudHJhY2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi50cmFjZS5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvZyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5nZXRMb2dCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb24uZ2V0TG9nQnVmZmVyKCk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/parameters.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n/**\n * Creates a new Parameter.\n *\n * @param {Object} options\n * @constructor\n */\nfunction Parameter(options) {\n    // validate input\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isString(options.name));\n    Errors.assertInternal(Util.exists(options.value));\n    const name = options.name;\n    let value = options.value;\n    /**\n     * Returns the name of the parameter.\n     *\n     * @returns {String}\n     */\n    this.getName = function () {\n        return name;\n    };\n    /**\n     * Returns the value of the parameter.\n     *\n     * @returns {*}\n     */\n    this.getValue = function () {\n        return value;\n    };\n    /**\n     * Updates the value of the parameter.\n     *\n     * @param {*} targetValue\n     */\n    this.setValue = function (targetValue) {\n        value = targetValue;\n    };\n}\nconst names = (exports.names = {});\nnames.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS = 'JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS';\nnames.SERVICE_NAME = 'SERVICE_NAME';\nnames.CLIENT_SESSION_KEEP_ALIVE = 'CLIENT_SESSION_KEEP_ALIVE';\nnames.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY =\n    'CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY';\nnames.JS_TREAT_INTEGER_AS_BIGINT = 'JS_TREAT_INTEGER_AS_BIGINT';\nnames.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD = 'CLIENT_STAGE_ARRAY_BINDING_THRESHOLD';\nnames.MULTI_STATEMENT_COUNT = 'MULTI_STATEMENT_COUNT';\nnames.QUERY_CONTEXT_CACHE_SIZE = 'QUERY_CONTEXT_CACHE_SIZE';\nconst parameters = [\n    new Parameter({\n        name: names.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS,\n        value: false,\n        desc: 'Whether to disable OCSP validation in the JavaScript driver ' +\n            'when communicating with non-Snowflake endpoints (e.g. S3/Blob).',\n    }),\n    new Parameter({\n        name: names.SERVICE_NAME,\n        value: '',\n        desc: 'Hint for load balancer.',\n    }),\n    new Parameter({\n        name: names.CLIENT_SESSION_KEEP_ALIVE,\n        value: false,\n        desc: 'When true, enables the driver to keep the session alive indefinitely',\n    }),\n    new Parameter({\n        name: names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY,\n        value: 3600,\n        desc: 'The amount of time (in seconds) between subsequent heartbeat requests to the server.',\n    }),\n    new Parameter({\n        name: names.JS_TREAT_INTEGER_AS_BIGINT,\n        value: false,\n        desc: 'When true, enables the driver converts integer columns into BigInt',\n    }),\n    new Parameter({\n        name: names.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD,\n        value: 100000,\n        desc: 'The client stage array binding threshold',\n    }),\n    new Parameter({\n        name: names.MULTI_STATEMENT_COUNT,\n        value: 1,\n        desc: 'When 1, multi statement is disable, when 0, multi statement is unlimited',\n    }),\n    new Parameter({\n        name: names.QUERY_CONTEXT_CACHE_SIZE,\n        value: 5,\n        desc: 'Query Context Cache Size',\n    }),\n];\n// put all the parameters in a map so they're easy to retrieve and update\nconst mapParamNameToParam = {};\nfor (let index = 0, length = parameters.length; index < length; index++) {\n    const parameter = parameters[index];\n    mapParamNameToParam[parameter.getName()] = parameter;\n}\n/**\n * Returns the value of a given parameter.\n *\n * @param {String} parameterName\n *\n * @returns {*}\n */\nexports.getValue = function (parameterName) {\n    // resolve the parameter name\n    const parameter = mapParamNameToParam[parameterName];\n    // verify that a valid parameter name was specified\n    Errors.assertInternal(Util.exists(parameter), 'invalid parameter name: ' + parameterName);\n    return parameter.getValue();\n};\n/**\n * Updates the parameter values.\n *\n * @param {Object[]} parametersConfig\n */\nexports.update = function (parametersConfig) {\n    // if an input is specified\n    if (Util.exists(parametersConfig)) {\n        Errors.assertInternal(Util.isArray(parametersConfig));\n        // if any of the items in the configs array matches a known\n        // parameter, update the corresponding parameter's value\n        for (let index = 0, length = parametersConfig.length; index < length; index++) {\n            const parameterConfig = parametersConfig[index];\n            if (Object.prototype.hasOwnProperty.call(mapParamNameToParam, parameterConfig.name)) {\n                const parameter = mapParamNameToParam[parameterConfig.name];\n                parameter.setValue(parameterConfig.value);\n            }\n        }\n    }\n};\n//# sourceMappingURL=parameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9wYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG1FQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWEsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvcGFyYW1ldGVycy5qcz8yZjE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYXJhbWV0ZXIob3B0aW9ucykge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzU3RyaW5nKG9wdGlvbnMubmFtZSkpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmV4aXN0cyhvcHRpb25zLnZhbHVlKSk7XG4gICAgY29uc3QgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICBsZXQgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICB9O1xufVxuY29uc3QgbmFtZXMgPSAoZXhwb3J0cy5uYW1lcyA9IHt9KTtcbm5hbWVzLkpTX0RSSVZFUl9ESVNBQkxFX09DU1BfRk9SX05PTl9TRl9FTkRQT0lOVFMgPSAnSlNfRFJJVkVSX0RJU0FCTEVfT0NTUF9GT1JfTk9OX1NGX0VORFBPSU5UUyc7XG5uYW1lcy5TRVJWSUNFX05BTUUgPSAnU0VSVklDRV9OQU1FJztcbm5hbWVzLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkUgPSAnQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRSc7XG5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1kgPVxuICAgICdDTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1knO1xubmFtZXMuSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQgPSAnSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQnO1xubmFtZXMuQ0xJRU5UX1NUQUdFX0FSUkFZX0JJTkRJTkdfVEhSRVNIT0xEID0gJ0NMSUVOVF9TVEFHRV9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCc7XG5uYW1lcy5NVUxUSV9TVEFURU1FTlRfQ09VTlQgPSAnTVVMVElfU1RBVEVNRU5UX0NPVU5UJztcbm5hbWVzLlFVRVJZX0NPTlRFWFRfQ0FDSEVfU0laRSA9ICdRVUVSWV9DT05URVhUX0NBQ0hFX1NJWkUnO1xuY29uc3QgcGFyYW1ldGVycyA9IFtcbiAgICBuZXcgUGFyYW1ldGVyKHtcbiAgICAgICAgbmFtZTogbmFtZXMuSlNfRFJJVkVSX0RJU0FCTEVfT0NTUF9GT1JfTk9OX1NGX0VORFBPSU5UUyxcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBkZXNjOiAnV2hldGhlciB0byBkaXNhYmxlIE9DU1AgdmFsaWRhdGlvbiBpbiB0aGUgSmF2YVNjcmlwdCBkcml2ZXIgJyArXG4gICAgICAgICAgICAnd2hlbiBjb21tdW5pY2F0aW5nIHdpdGggbm9uLVNub3dmbGFrZSBlbmRwb2ludHMgKGUuZy4gUzMvQmxvYikuJyxcbiAgICB9KSxcbiAgICBuZXcgUGFyYW1ldGVyKHtcbiAgICAgICAgbmFtZTogbmFtZXMuU0VSVklDRV9OQU1FLFxuICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgIGRlc2M6ICdIaW50IGZvciBsb2FkIGJhbGFuY2VyLicsXG4gICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcih7XG4gICAgICAgIG5hbWU6IG5hbWVzLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkUsXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgZGVzYzogJ1doZW4gdHJ1ZSwgZW5hYmxlcyB0aGUgZHJpdmVyIHRvIGtlZXAgdGhlIHNlc3Npb24gYWxpdmUgaW5kZWZpbml0ZWx5JyxcbiAgICB9KSxcbiAgICBuZXcgUGFyYW1ldGVyKHtcbiAgICAgICAgbmFtZTogbmFtZXMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZLFxuICAgICAgICB2YWx1ZTogMzYwMCxcbiAgICAgICAgZGVzYzogJ1RoZSBhbW91bnQgb2YgdGltZSAoaW4gc2Vjb25kcykgYmV0d2VlbiBzdWJzZXF1ZW50IGhlYXJ0YmVhdCByZXF1ZXN0cyB0byB0aGUgc2VydmVyLicsXG4gICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcih7XG4gICAgICAgIG5hbWU6IG5hbWVzLkpTX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5ULFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIGRlc2M6ICdXaGVuIHRydWUsIGVuYWJsZXMgdGhlIGRyaXZlciBjb252ZXJ0cyBpbnRlZ2VyIGNvbHVtbnMgaW50byBCaWdJbnQnLFxuICAgIH0pLFxuICAgIG5ldyBQYXJhbWV0ZXIoe1xuICAgICAgICBuYW1lOiBuYW1lcy5DTElFTlRfU1RBR0VfQVJSQVlfQklORElOR19USFJFU0hPTEQsXG4gICAgICAgIHZhbHVlOiAxMDAwMDAsXG4gICAgICAgIGRlc2M6ICdUaGUgY2xpZW50IHN0YWdlIGFycmF5IGJpbmRpbmcgdGhyZXNob2xkJyxcbiAgICB9KSxcbiAgICBuZXcgUGFyYW1ldGVyKHtcbiAgICAgICAgbmFtZTogbmFtZXMuTVVMVElfU1RBVEVNRU5UX0NPVU5ULFxuICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgZGVzYzogJ1doZW4gMSwgbXVsdGkgc3RhdGVtZW50IGlzIGRpc2FibGUsIHdoZW4gMCwgbXVsdGkgc3RhdGVtZW50IGlzIHVubGltaXRlZCcsXG4gICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcih7XG4gICAgICAgIG5hbWU6IG5hbWVzLlFVRVJZX0NPTlRFWFRfQ0FDSEVfU0laRSxcbiAgICAgICAgdmFsdWU6IDUsXG4gICAgICAgIGRlc2M6ICdRdWVyeSBDb250ZXh0IENhY2hlIFNpemUnLFxuICAgIH0pLFxuXTtcbi8vIHB1dCBhbGwgdGhlIHBhcmFtZXRlcnMgaW4gYSBtYXAgc28gdGhleSdyZSBlYXN5IHRvIHJldHJpZXZlIGFuZCB1cGRhdGVcbmNvbnN0IG1hcFBhcmFtTmFtZVRvUGFyYW0gPSB7fTtcbmZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gcGFyYW1ldGVycy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1tpbmRleF07XG4gICAgbWFwUGFyYW1OYW1lVG9QYXJhbVtwYXJhbWV0ZXIuZ2V0TmFtZSgpXSA9IHBhcmFtZXRlcjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtZXRlck5hbWVcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJOYW1lKSB7XG4gICAgLy8gcmVzb2x2ZSB0aGUgcGFyYW1ldGVyIG5hbWVcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBtYXBQYXJhbU5hbWVUb1BhcmFtW3BhcmFtZXRlck5hbWVdO1xuICAgIC8vIHZlcmlmeSB0aGF0IGEgdmFsaWQgcGFyYW1ldGVyIG5hbWUgd2FzIHNwZWNpZmllZFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmV4aXN0cyhwYXJhbWV0ZXIpLCAnaW52YWxpZCBwYXJhbWV0ZXIgbmFtZTogJyArIHBhcmFtZXRlck5hbWUpO1xuICAgIHJldHVybiBwYXJhbWV0ZXIuZ2V0VmFsdWUoKTtcbn07XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gcGFyYW1ldGVyc0NvbmZpZ1xuICovXG5leHBvcnRzLnVwZGF0ZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzQ29uZmlnKSB7XG4gICAgLy8gaWYgYW4gaW5wdXQgaXMgc3BlY2lmaWVkXG4gICAgaWYgKFV0aWwuZXhpc3RzKHBhcmFtZXRlcnNDb25maWcpKSB7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQXJyYXkocGFyYW1ldGVyc0NvbmZpZykpO1xuICAgICAgICAvLyBpZiBhbnkgb2YgdGhlIGl0ZW1zIGluIHRoZSBjb25maWdzIGFycmF5IG1hdGNoZXMgYSBrbm93blxuICAgICAgICAvLyBwYXJhbWV0ZXIsIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIncyB2YWx1ZVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHBhcmFtZXRlcnNDb25maWcubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyQ29uZmlnID0gcGFyYW1ldGVyc0NvbmZpZ1tpbmRleF07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcFBhcmFtTmFtZVRvUGFyYW0sIHBhcmFtZXRlckNvbmZpZy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IG1hcFBhcmFtTmFtZVRvUGFyYW1bcGFyYW1ldGVyQ29uZmlnLm5hbWVdO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlci5zZXRWYWx1ZShwYXJhbWV0ZXJDb25maWcudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/proxy_util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst GlobalConfig = __webpack_require__(/*! ./global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst LoggingUtil = __webpack_require__(/*! ./logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\");\nconst ErrorCodes = Errors.codes;\n/**\n * @typedef {object} Proxy\n * @property {string} host - The host address of the proxy.\n * @property {string} protocol - The protocol used by the proxy (e.g., \"http\" or \"https\")\n * @property {string} user - The username for the proxy\n * @property {number} port - The port number.\n * @property {string} password - The password for the proxy\n * @property {string} noProxy -  Optional list of domains that should bypass the prox\n */\n/**\n * remove http:// or https:// from the input, e.g. used with proxy URL\n * @param input\n * @returns {string}\n */\nexports.removeScheme = function (input) {\n    return input.toString().replace(/(^\\w+:|^)\\/\\//, '');\n};\n/**\n * Try to get the PROXY environmental variables\n * On Windows, envvar name is case-insensitive, but on *nix, it's case-sensitive\n *\n * Compare them with the proxy specified on the Connection, if any\n * Return with the log constructed from the components detection and comparison\n * If there's something to warn the user about, return that too\n *\n * @param {Proxy} agentOptions from agent creation\n * @returns {{messages: string, warnings: string}} log messages\n */\nexports.getCompareAndLogEnvAndAgentProxies = function (agentOptions) {\n    const envProxy = {};\n    const logMessages = { messages: '', warnings: '' };\n    envProxy.httpProxy = process.env.http_proxy || process.env.HTTP_PROXY;\n    envProxy.httpsProxy = process.env.https_proxy || process.env.HTTPS_PROXY;\n    envProxy.noProxy = process.env.no_proxy || process.env.NO_PROXY;\n    envProxy.logHttpProxy = envProxy.httpProxy\n        ? 'HTTP_PROXY: ' + envProxy.httpProxy\n        : 'HTTP_PROXY: <unset>';\n    envProxy.logHttpsProxy = envProxy.httpsProxy\n        ? 'HTTPS_PROXY: ' + envProxy.httpsProxy\n        : 'HTTPS_PROXY: <unset>';\n    envProxy.logNoProxy = envProxy.noProxy ? 'NO_PROXY: ' + envProxy.noProxy : 'NO_PROXY: <unset>';\n    // log PROXY envvars\n    if (envProxy.httpProxy || envProxy.httpsProxy) {\n        logMessages.messages =\n            logMessages.messages +\n                ' // PROXY environment variables: ' +\n                `${envProxy.logHttpProxy} ${envProxy.logHttpsProxy} ${envProxy.logNoProxy}.`;\n    }\n    // log proxy config on Connection, if any set\n    if (agentOptions.host) {\n        const proxyHostAndPort = agentOptions.host + ':' + agentOptions.port;\n        const proxyProtocolHostAndPort = agentOptions.protocol\n            ? ' protocol=' + agentOptions.protocol + ' proxy=' + proxyHostAndPort\n            : ' proxy=' + proxyHostAndPort;\n        const proxyUsername = agentOptions.user ? ' user=' + agentOptions.user : '';\n        const proxyString = `${Util.exists(agentOptions.user) ? `${agentOptions.user}:${agentOptions.password}@` : ''}${proxyHostAndPort}`.toLowerCase();\n        logMessages.messages =\n            logMessages.messages +\n                ` // Proxy configured in Agent:${proxyProtocolHostAndPort}${proxyUsername}`;\n        // check if both the PROXY envvars and Connection proxy config is set\n        // generate warnings if they are, and are also different\n        if (envProxy.httpProxy &&\n            this.removeScheme(envProxy.httpProxy).toLowerCase() !== proxyString.toLowerCase()) {\n            logMessages.warnings =\n                logMessages.warnings +\n                    ` Using both the HTTP_PROXY (${this.describeProxy(this.getProxyFromEnv(false))})` +\n                    ` and the Connection proxy (${this.describeProxy(agentOptions)}), but with different values.` +\n                    ' If you experience connectivity issues, try unsetting one of them.';\n        }\n        if (envProxy.httpsProxy &&\n            this.removeScheme(envProxy.httpsProxy).toLowerCase() !== proxyString.toLowerCase()) {\n            logMessages.warnings =\n                logMessages.warnings +\n                    ` Using both the HTTPS_PROXY (${this.describeProxy(this.getProxyFromEnv(true))})` +\n                    ` and the Connection proxy (${this.describeProxy(agentOptions)}) settings to connect, but with different values.` +\n                    ' If you experience connectivity issues, try unsetting one of them.';\n        }\n    }\n    logMessages.messages = logMessages.messages ? logMessages.messages : ' none.';\n    return logMessages;\n};\n/**\n * Validate whether the proxy object has the appropriate information\n *\n * @param {Proxy} proxy\n * @returns {Proxy}\n */\nexports.validateProxy = function (proxy) {\n    const { host, port, noProxy, user, password } = proxy;\n    // check for missing proxyHost\n    Errors.checkArgumentExists(Util.exists(host), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_HOST);\n    // check for invalid proxyHost\n    Errors.checkArgumentValid(Util.isString(host), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_HOST);\n    // check for missing proxyPort\n    Errors.checkArgumentExists(Util.exists(port), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_PORT);\n    // check for invalid proxyPort\n    Errors.checkArgumentValid(Util.isNumber(port), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_PORT);\n    if (Util.exists(noProxy)) {\n        // check for invalid noProxy\n        Errors.checkArgumentValid(Util.isString(noProxy), ErrorCodes.ERR_CONN_CREATE_INVALID_NO_PROXY);\n    }\n    if (Util.exists(user) || Util.exists(password)) {\n        // check for missing proxyUser\n        Errors.checkArgumentExists(Util.exists(user), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_USER);\n        // check for invalid proxyUser\n        Errors.checkArgumentValid(Util.isString(user), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_USER);\n        // check for missing proxyPassword\n        Errors.checkArgumentExists(Util.exists(password), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_PASS);\n        // check for invalid proxyPassword\n        Errors.checkArgumentValid(Util.isString(password), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_PASS);\n    }\n    else {\n        delete proxy.user;\n        delete proxy.password;\n    }\n};\n/**\n * Obtain the proxy information from the environment variable.\n *\n * @param {boolean} isHttps\n * @returns {Proxy}\n */\nexports.getProxyFromEnv = function (isHttps = true) {\n    const getDefaultPortIfNotSet = (proxyFromEnv) => {\n        const isProxyProtocolHttps = proxyFromEnv.protocol === 'https:';\n        if (!proxyFromEnv.port) {\n            return isProxyProtocolHttps ? 443 : 80;\n        }\n        else {\n            return proxyFromEnv.port;\n        }\n    };\n    const protocol = isHttps ? 'https' : 'http';\n    let proxyFromEnv = Util.getEnvVar(`${protocol}_proxy`);\n    if (!proxyFromEnv) {\n        return null;\n    }\n    Logger.getInstance().debug(`Util.getProxyEnv: Using ${protocol.toUpperCase()}_PROXY from the environment variable`);\n    if (proxyFromEnv.indexOf('://') === -1) {\n        Logger.getInstance().info('Util.getProxyEnv: the protocol was missing from the environment proxy. Use the HTTP protocol.');\n        proxyFromEnv = 'http' + '://' + proxyFromEnv;\n    }\n    proxyFromEnv = new URL(proxyFromEnv);\n    const port = getDefaultPortIfNotSet(proxyFromEnv);\n    const proxy = {\n        host: Util.validateEmptyString(proxyFromEnv.hostname),\n        port: Number(port),\n        user: Util.validateEmptyString(proxyFromEnv.username),\n        password: Util.validateEmptyString(proxyFromEnv.password),\n        protocol: Util.validateEmptyString(proxyFromEnv.protocol),\n        noProxy: this.getNoProxyEnv(),\n        useForOCSP: !isHttps,\n    };\n    this.validateProxy(proxy);\n    return proxy;\n};\n/**\n * Obtain the no proxy information from the environment variable.\n *\n * @returns {string | undefined}\n */\nexports.getNoProxyEnv = function () {\n    const noProxy = Util.getEnvVar('no_proxy');\n    if (noProxy) {\n        return noProxy.split(',').join('|');\n    }\n    return undefined;\n};\n/**\n * Extract the host from the destination URL to check whether the same agent already exists or not.\n *\n * @param {string} destination\n * @returns {string}\n */\nexports.getHostFromURL = function (destination) {\n    if (destination.indexOf('://') === -1) {\n        destination = 'https' + '://' + destination;\n    }\n    try {\n        return new URL(destination).hostname;\n    }\n    catch (err) {\n        Logger.getInstance().error(`Failed to parse the destination to URL with the error: ${err}. Return destination as the host: ${destination}`);\n        return destination;\n    }\n};\n/**\n * if proxy exists, return the proxy. If not and the useEnvProxy is true, return the proxy from the environment variable.\n * @param {Proxy} proxy\n * @param {string} moduleName\n * @param {string} isHttp\n *\n * @returns {Proxy}\n */\nexports.getProxy = function (proxy, moduleName, isHttps) {\n    if (!proxy && GlobalConfig.isEnvProxyActive()) {\n        proxy = this.getProxyFromEnv(isHttps);\n        if (proxy) {\n            Logger.getInstance().debug(`${moduleName} loads the proxy info from the environment variable host: ${proxy.host}`);\n        }\n    }\n    return proxy;\n};\n/**\n * The proxy configuration fields in Azure are different from the proxy fields in the snowflake node.js driver.\n * Because of that, this function converts the snowflake proxy info to the Azure proxy info.\n * @param {Proxy} proxy\n * @returns {{host:string, port:number, user?:string, password?:string}}}\n */\nexports.getAzureProxy = function (proxy) {\n    const AzureProxy = {\n        ...proxy,\n        host: `${proxy.protocol}${proxy.protocol.endsWith(':') ? '' : ':'}//${proxy.host}`,\n    };\n    delete AzureProxy.noProxy;\n    delete AzureProxy.protocol;\n    if (!Util.exists(AzureProxy.user) || !Util.exists(AzureProxy.password)) {\n        delete AzureProxy.user;\n        delete AzureProxy.password;\n    }\n    return AzureProxy;\n};\n/**\n * Currently, there is no way to disable loading the proxy information from the environment path in Azure/blob.\n * To control this proxy option on the driver side, A temporary workaround is hide(remove) the environment proxy from the process\n * when the client is created (At this time, the client loads the proxy from the environment variables internally).\n * After the client is created, restore them with the 'restoreEnvironmentProxy' function.\n */\nlet envProxyList;\nconst proxyEnvList = ['http_proxy', 'https_proxy', 'no_proxy'];\nexports.hideEnvironmentProxy = function () {\n    if (GlobalConfig.isEnvProxyActive()) {\n        return;\n    }\n    Logger.getInstance().debug('As the useEnvProxy option is disabled, the proxy environment variables are temporarily hidden during the creation of an Azure client');\n    envProxyList = [];\n    for (const envVar of proxyEnvList) {\n        saveProxyInfoInList(envVar);\n        if (!Util.isWindows()) {\n            saveProxyInfoInList(envVar.toUpperCase());\n        }\n    }\n};\nfunction saveProxyInfoInList(envVar) {\n    const proxyEnv = process.env[envVar];\n    envProxyList.push(process.env[envVar]);\n    delete process.env[envVar];\n    if (Util.exists(proxyEnv)) {\n        Logger.getInstance().debug(`Temporarily exclude ${envVar} from the environment variable value: ${proxyEnv}`);\n    }\n    else {\n        Logger.getInstance().debug(`${envVar} was not defined, nothing to do`);\n    }\n}\nexports.restoreEnvironmentProxy = function () {\n    if (GlobalConfig.isEnvProxyActive()) {\n        return;\n    }\n    const iterator = envProxyList[Symbol.iterator]();\n    let nextValue = iterator.next().value;\n    for (const envVar of proxyEnvList) {\n        if (Util.exists(nextValue)) {\n            Logger.getInstance().debug(`The ${envVar} value exists with the value: ${nextValue} Restore back the proxy environment variable values`);\n            process.env[envVar] = nextValue;\n        }\n        nextValue = iterator.next().value;\n        if (!Util.isWindows()) {\n            if (Util.exists(nextValue)) {\n                Logger.getInstance().debug(`The ${envVar.toUpperCase()} value exists with the value: ${nextValue} Restore back the proxy environment variable values (for Non-Windows machine)`);\n                process.env[envVar.toUpperCase()] = nextValue;\n            }\n            nextValue = iterator.next().value;\n        }\n    }\n    Logger.getInstance().debug('An Azure client has been created. Restore back the proxy environment variable values');\n};\n/**\n * Provide the details of the proxy info.\n * @param proxy\n * @param destination {string | Regex }\n */\nexports.isByPassProxy = function (proxy, destination) {\n    if (proxy && proxy.noProxy) {\n        const bypassList = proxy.noProxy.split('|');\n        return bypassList.find((noProxy) => {\n            let host = noProxy.trim();\n            host = host.replace('*', '.*?');\n            if (destination instanceof RegExp) {\n                return destination.test(host);\n            }\n            const noProxyRegex = new RegExp(`^${host}`);\n            return noProxyRegex.test(destination);\n        });\n    }\n};\n/**\n * Provide the details of the proxy info.\n * @param proxy\n * @returns {string}\n */\nexports.describeProxy = function (proxy) {\n    if (Util.exists(proxy)) {\n        return (`proxyHost: ${proxy.host}, proxyPort: ${proxy.port}, ` +\n            `${Util.exists(proxy.user) ? `proxyUser: ${proxy.user}, proxyPassword is ${LoggingUtil.describePresence(proxy.password)}, ` : ''}` +\n            `proxyProtocol: ${proxy.protocol}, noProxy: ${proxy.noProxy}`);\n    }\n    else {\n        return 'proxy was not configured';\n    }\n};\n/**\n * Make the proxy string with the proxy info (json format)\n * @param proxy\n * @returns {string}\n */\nexports.stringifyProxy = function (proxy) {\n    if (Util.isEmptyObject(proxy)) {\n        return null;\n    }\n    return (`${proxy.protocol.startsWith('https') ? 'https' : 'http'}://` +\n        `${Util.exists(proxy.user) ? `${proxy.user}:${proxy.password}@` : ''}` +\n        `${proxy.host}:${proxy.port}`);\n};\n//# sourceMappingURL=proxy_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9wcm94eV91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLHVFQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsbUVBQVE7QUFDN0IscUJBQXFCLG1CQUFPLENBQUMscUZBQWlCO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLGlHQUF1QjtBQUNuRDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUIsRUFBRSx3QkFBd0IsRUFBRSxvQkFBb0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQ0FBb0Msa0JBQWtCLEdBQUcsc0JBQXNCLFFBQVEsRUFBRSxpQkFBaUI7QUFDekk7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUIsRUFBRSxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnREFBZ0Q7QUFDbkcsa0RBQWtELGlDQUFpQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0NBQStDO0FBQ25HLGtEQUFrRCxpQ0FBaUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQixZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHVCQUF1QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixJQUFJLG9DQUFvQyxZQUFZO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSwyREFBMkQsV0FBVztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixjQUFjO0FBQ2Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQixlQUFlLEVBQUUsd0NBQXdDLElBQUksV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUSx1Q0FBdUMsU0FBUztBQUNsSDtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRLCtCQUErQixXQUFXO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsc0JBQXNCLCtCQUErQixXQUFXO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsOEJBQThCLFdBQVcsZUFBZSxXQUFXO0FBQ25FLGVBQWUsd0NBQXdDLFdBQVcscUJBQXFCLDZDQUE2QyxTQUFTO0FBQzdJLDhCQUE4QixlQUFlLGFBQWEsY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQXNEO0FBQ3JFLFdBQVcsNkJBQTZCLFdBQVcsR0FBRyxlQUFlLFFBQVE7QUFDN0UsV0FBVyxXQUFXLEdBQUcsV0FBVztBQUNwQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9wcm94eV91dGlsLmpzPzY5NzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgTG9nZ2luZ1V0aWwgPSByZXF1aXJlKCcuL2xvZ2dlci9sb2dnaW5nX3V0aWwnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFByb3h5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdCAtIFRoZSBob3N0IGFkZHJlc3Mgb2YgdGhlIHByb3h5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3RvY29sIC0gVGhlIHByb3RvY29sIHVzZWQgYnkgdGhlIHByb3h5IChlLmcuLCBcImh0dHBcIiBvciBcImh0dHBzXCIpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXNlciAtIFRoZSB1c2VybmFtZSBmb3IgdGhlIHByb3h5XG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9ydCAtIFRoZSBwb3J0IG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCBmb3IgdGhlIHByb3h5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbm9Qcm94eSAtICBPcHRpb25hbCBsaXN0IG9mIGRvbWFpbnMgdGhhdCBzaG91bGQgYnlwYXNzIHRoZSBwcm94XG4gKi9cbi8qKlxuICogcmVtb3ZlIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gZnJvbSB0aGUgaW5wdXQsIGUuZy4gdXNlZCB3aXRoIHByb3h5IFVSTFxuICogQHBhcmFtIGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnJlbW92ZVNjaGVtZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC50b1N0cmluZygpLnJlcGxhY2UoLyheXFx3Kzp8XilcXC9cXC8vLCAnJyk7XG59O1xuLyoqXG4gKiBUcnkgdG8gZ2V0IHRoZSBQUk9YWSBlbnZpcm9ubWVudGFsIHZhcmlhYmxlc1xuICogT24gV2luZG93cywgZW52dmFyIG5hbWUgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgYnV0IG9uICpuaXgsIGl0J3MgY2FzZS1zZW5zaXRpdmVcbiAqXG4gKiBDb21wYXJlIHRoZW0gd2l0aCB0aGUgcHJveHkgc3BlY2lmaWVkIG9uIHRoZSBDb25uZWN0aW9uLCBpZiBhbnlcbiAqIFJldHVybiB3aXRoIHRoZSBsb2cgY29uc3RydWN0ZWQgZnJvbSB0aGUgY29tcG9uZW50cyBkZXRlY3Rpb24gYW5kIGNvbXBhcmlzb25cbiAqIElmIHRoZXJlJ3Mgc29tZXRoaW5nIHRvIHdhcm4gdGhlIHVzZXIgYWJvdXQsIHJldHVybiB0aGF0IHRvb1xuICpcbiAqIEBwYXJhbSB7UHJveHl9IGFnZW50T3B0aW9ucyBmcm9tIGFnZW50IGNyZWF0aW9uXG4gKiBAcmV0dXJucyB7e21lc3NhZ2VzOiBzdHJpbmcsIHdhcm5pbmdzOiBzdHJpbmd9fSBsb2cgbWVzc2FnZXNcbiAqL1xuZXhwb3J0cy5nZXRDb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzID0gZnVuY3Rpb24gKGFnZW50T3B0aW9ucykge1xuICAgIGNvbnN0IGVudlByb3h5ID0ge307XG4gICAgY29uc3QgbG9nTWVzc2FnZXMgPSB7IG1lc3NhZ2VzOiAnJywgd2FybmluZ3M6ICcnIH07XG4gICAgZW52UHJveHkuaHR0cFByb3h5ID0gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBwcm9jZXNzLmVudi5IVFRQX1BST1hZO1xuICAgIGVudlByb3h5Lmh0dHBzUHJveHkgPSBwcm9jZXNzLmVudi5odHRwc19wcm94eSB8fCBwcm9jZXNzLmVudi5IVFRQU19QUk9YWTtcbiAgICBlbnZQcm94eS5ub1Byb3h5ID0gcHJvY2Vzcy5lbnYubm9fcHJveHkgfHwgcHJvY2Vzcy5lbnYuTk9fUFJPWFk7XG4gICAgZW52UHJveHkubG9nSHR0cFByb3h5ID0gZW52UHJveHkuaHR0cFByb3h5XG4gICAgICAgID8gJ0hUVFBfUFJPWFk6ICcgKyBlbnZQcm94eS5odHRwUHJveHlcbiAgICAgICAgOiAnSFRUUF9QUk9YWTogPHVuc2V0Pic7XG4gICAgZW52UHJveHkubG9nSHR0cHNQcm94eSA9IGVudlByb3h5Lmh0dHBzUHJveHlcbiAgICAgICAgPyAnSFRUUFNfUFJPWFk6ICcgKyBlbnZQcm94eS5odHRwc1Byb3h5XG4gICAgICAgIDogJ0hUVFBTX1BST1hZOiA8dW5zZXQ+JztcbiAgICBlbnZQcm94eS5sb2dOb1Byb3h5ID0gZW52UHJveHkubm9Qcm94eSA/ICdOT19QUk9YWTogJyArIGVudlByb3h5Lm5vUHJveHkgOiAnTk9fUFJPWFk6IDx1bnNldD4nO1xuICAgIC8vIGxvZyBQUk9YWSBlbnZ2YXJzXG4gICAgaWYgKGVudlByb3h5Lmh0dHBQcm94eSB8fCBlbnZQcm94eS5odHRwc1Byb3h5KSB7XG4gICAgICAgIGxvZ01lc3NhZ2VzLm1lc3NhZ2VzID1cbiAgICAgICAgICAgIGxvZ01lc3NhZ2VzLm1lc3NhZ2VzICtcbiAgICAgICAgICAgICAgICAnIC8vIFBST1hZIGVudmlyb25tZW50IHZhcmlhYmxlczogJyArXG4gICAgICAgICAgICAgICAgYCR7ZW52UHJveHkubG9nSHR0cFByb3h5fSAke2VudlByb3h5LmxvZ0h0dHBzUHJveHl9ICR7ZW52UHJveHkubG9nTm9Qcm94eX0uYDtcbiAgICB9XG4gICAgLy8gbG9nIHByb3h5IGNvbmZpZyBvbiBDb25uZWN0aW9uLCBpZiBhbnkgc2V0XG4gICAgaWYgKGFnZW50T3B0aW9ucy5ob3N0KSB7XG4gICAgICAgIGNvbnN0IHByb3h5SG9zdEFuZFBvcnQgPSBhZ2VudE9wdGlvbnMuaG9zdCArICc6JyArIGFnZW50T3B0aW9ucy5wb3J0O1xuICAgICAgICBjb25zdCBwcm94eVByb3RvY29sSG9zdEFuZFBvcnQgPSBhZ2VudE9wdGlvbnMucHJvdG9jb2xcbiAgICAgICAgICAgID8gJyBwcm90b2NvbD0nICsgYWdlbnRPcHRpb25zLnByb3RvY29sICsgJyBwcm94eT0nICsgcHJveHlIb3N0QW5kUG9ydFxuICAgICAgICAgICAgOiAnIHByb3h5PScgKyBwcm94eUhvc3RBbmRQb3J0O1xuICAgICAgICBjb25zdCBwcm94eVVzZXJuYW1lID0gYWdlbnRPcHRpb25zLnVzZXIgPyAnIHVzZXI9JyArIGFnZW50T3B0aW9ucy51c2VyIDogJyc7XG4gICAgICAgIGNvbnN0IHByb3h5U3RyaW5nID0gYCR7VXRpbC5leGlzdHMoYWdlbnRPcHRpb25zLnVzZXIpID8gYCR7YWdlbnRPcHRpb25zLnVzZXJ9OiR7YWdlbnRPcHRpb25zLnBhc3N3b3JkfUBgIDogJyd9JHtwcm94eUhvc3RBbmRQb3J0fWAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG9nTWVzc2FnZXMubWVzc2FnZXMgPVxuICAgICAgICAgICAgbG9nTWVzc2FnZXMubWVzc2FnZXMgK1xuICAgICAgICAgICAgICAgIGAgLy8gUHJveHkgY29uZmlndXJlZCBpbiBBZ2VudDoke3Byb3h5UHJvdG9jb2xIb3N0QW5kUG9ydH0ke3Byb3h5VXNlcm5hbWV9YDtcbiAgICAgICAgLy8gY2hlY2sgaWYgYm90aCB0aGUgUFJPWFkgZW52dmFycyBhbmQgQ29ubmVjdGlvbiBwcm94eSBjb25maWcgaXMgc2V0XG4gICAgICAgIC8vIGdlbmVyYXRlIHdhcm5pbmdzIGlmIHRoZXkgYXJlLCBhbmQgYXJlIGFsc28gZGlmZmVyZW50XG4gICAgICAgIGlmIChlbnZQcm94eS5odHRwUHJveHkgJiZcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NoZW1lKGVudlByb3h5Lmh0dHBQcm94eSkudG9Mb3dlckNhc2UoKSAhPT0gcHJveHlTdHJpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgbG9nTWVzc2FnZXMud2FybmluZ3MgPVxuICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2VzLndhcm5pbmdzICtcbiAgICAgICAgICAgICAgICAgICAgYCBVc2luZyBib3RoIHRoZSBIVFRQX1BST1hZICgke3RoaXMuZGVzY3JpYmVQcm94eSh0aGlzLmdldFByb3h5RnJvbUVudihmYWxzZSkpfSlgICtcbiAgICAgICAgICAgICAgICAgICAgYCBhbmQgdGhlIENvbm5lY3Rpb24gcHJveHkgKCR7dGhpcy5kZXNjcmliZVByb3h5KGFnZW50T3B0aW9ucyl9KSwgYnV0IHdpdGggZGlmZmVyZW50IHZhbHVlcy5gICtcbiAgICAgICAgICAgICAgICAgICAgJyBJZiB5b3UgZXhwZXJpZW5jZSBjb25uZWN0aXZpdHkgaXNzdWVzLCB0cnkgdW5zZXR0aW5nIG9uZSBvZiB0aGVtLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudlByb3h5Lmh0dHBzUHJveHkgJiZcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NoZW1lKGVudlByb3h5Lmh0dHBzUHJveHkpLnRvTG93ZXJDYXNlKCkgIT09IHByb3h5U3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGxvZ01lc3NhZ2VzLndhcm5pbmdzID1cbiAgICAgICAgICAgICAgICBsb2dNZXNzYWdlcy53YXJuaW5ncyArXG4gICAgICAgICAgICAgICAgICAgIGAgVXNpbmcgYm90aCB0aGUgSFRUUFNfUFJPWFkgKCR7dGhpcy5kZXNjcmliZVByb3h5KHRoaXMuZ2V0UHJveHlGcm9tRW52KHRydWUpKX0pYCArXG4gICAgICAgICAgICAgICAgICAgIGAgYW5kIHRoZSBDb25uZWN0aW9uIHByb3h5ICgke3RoaXMuZGVzY3JpYmVQcm94eShhZ2VudE9wdGlvbnMpfSkgc2V0dGluZ3MgdG8gY29ubmVjdCwgYnV0IHdpdGggZGlmZmVyZW50IHZhbHVlcy5gICtcbiAgICAgICAgICAgICAgICAgICAgJyBJZiB5b3UgZXhwZXJpZW5jZSBjb25uZWN0aXZpdHkgaXNzdWVzLCB0cnkgdW5zZXR0aW5nIG9uZSBvZiB0aGVtLic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nTWVzc2FnZXMubWVzc2FnZXMgPSBsb2dNZXNzYWdlcy5tZXNzYWdlcyA/IGxvZ01lc3NhZ2VzLm1lc3NhZ2VzIDogJyBub25lLic7XG4gICAgcmV0dXJuIGxvZ01lc3NhZ2VzO1xufTtcbi8qKlxuICogVmFsaWRhdGUgd2hldGhlciB0aGUgcHJveHkgb2JqZWN0IGhhcyB0aGUgYXBwcm9wcmlhdGUgaW5mb3JtYXRpb25cbiAqXG4gKiBAcGFyYW0ge1Byb3h5fSBwcm94eVxuICogQHJldHVybnMge1Byb3h5fVxuICovXG5leHBvcnRzLnZhbGlkYXRlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICBjb25zdCB7IGhvc3QsIHBvcnQsIG5vUHJveHksIHVzZXIsIHBhc3N3b3JkIH0gPSBwcm94eTtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBwcm94eUhvc3RcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhob3N0KSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9IT1NUKTtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBwcm94eUhvc3RcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcoaG9zdCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfSE9TVCk7XG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcHJveHlQb3J0XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMocG9ydCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfUE9SVCk7XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcHJveHlQb3J0XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKHBvcnQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX1BPUlQpO1xuICAgIGlmIChVdGlsLmV4aXN0cyhub1Byb3h5KSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBub1Byb3h5XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhub1Byb3h5KSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9OT19QUk9YWSk7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyh1c2VyKSB8fCBVdGlsLmV4aXN0cyhwYXNzd29yZCkpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcHJveHlVc2VyXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHVzZXIpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1VTRVIpO1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBwcm94eVVzZXJcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHVzZXIpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX1VTRVIpO1xuICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBwcm94eVBhc3N3b3JkXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHBhc3N3b3JkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9QQVNTKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcHJveHlQYXNzd29yZFxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcocGFzc3dvcmQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX1BBU1MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHByb3h5LnVzZXI7XG4gICAgICAgIGRlbGV0ZSBwcm94eS5wYXNzd29yZDtcbiAgICB9XG59O1xuLyoqXG4gKiBPYnRhaW4gdGhlIHByb3h5IGluZm9ybWF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIdHRwc1xuICogQHJldHVybnMge1Byb3h5fVxuICovXG5leHBvcnRzLmdldFByb3h5RnJvbUVudiA9IGZ1bmN0aW9uIChpc0h0dHBzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGdldERlZmF1bHRQb3J0SWZOb3RTZXQgPSAocHJveHlGcm9tRW52KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzUHJveHlQcm90b2NvbEh0dHBzID0gcHJveHlGcm9tRW52LnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgaWYgKCFwcm94eUZyb21FbnYucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJveHlQcm90b2NvbEh0dHBzID8gNDQzIDogODA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJveHlGcm9tRW52LnBvcnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb3RvY29sID0gaXNIdHRwcyA/ICdodHRwcycgOiAnaHR0cCc7XG4gICAgbGV0IHByb3h5RnJvbUVudiA9IFV0aWwuZ2V0RW52VmFyKGAke3Byb3RvY29sfV9wcm94eWApO1xuICAgIGlmICghcHJveHlGcm9tRW52KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVXRpbC5nZXRQcm94eUVudjogVXNpbmcgJHtwcm90b2NvbC50b1VwcGVyQ2FzZSgpfV9QUk9YWSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZWApO1xuICAgIGlmIChwcm94eUZyb21FbnYuaW5kZXhPZignOi8vJykgPT09IC0xKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ1V0aWwuZ2V0UHJveHlFbnY6IHRoZSBwcm90b2NvbCB3YXMgbWlzc2luZyBmcm9tIHRoZSBlbnZpcm9ubWVudCBwcm94eS4gVXNlIHRoZSBIVFRQIHByb3RvY29sLicpO1xuICAgICAgICBwcm94eUZyb21FbnYgPSAnaHR0cCcgKyAnOi8vJyArIHByb3h5RnJvbUVudjtcbiAgICB9XG4gICAgcHJveHlGcm9tRW52ID0gbmV3IFVSTChwcm94eUZyb21FbnYpO1xuICAgIGNvbnN0IHBvcnQgPSBnZXREZWZhdWx0UG9ydElmTm90U2V0KHByb3h5RnJvbUVudik7XG4gICAgY29uc3QgcHJveHkgPSB7XG4gICAgICAgIGhvc3Q6IFV0aWwudmFsaWRhdGVFbXB0eVN0cmluZyhwcm94eUZyb21FbnYuaG9zdG5hbWUpLFxuICAgICAgICBwb3J0OiBOdW1iZXIocG9ydCksXG4gICAgICAgIHVzZXI6IFV0aWwudmFsaWRhdGVFbXB0eVN0cmluZyhwcm94eUZyb21FbnYudXNlcm5hbWUpLFxuICAgICAgICBwYXNzd29yZDogVXRpbC52YWxpZGF0ZUVtcHR5U3RyaW5nKHByb3h5RnJvbUVudi5wYXNzd29yZCksXG4gICAgICAgIHByb3RvY29sOiBVdGlsLnZhbGlkYXRlRW1wdHlTdHJpbmcocHJveHlGcm9tRW52LnByb3RvY29sKSxcbiAgICAgICAgbm9Qcm94eTogdGhpcy5nZXROb1Byb3h5RW52KCksXG4gICAgICAgIHVzZUZvck9DU1A6ICFpc0h0dHBzLFxuICAgIH07XG4gICAgdGhpcy52YWxpZGF0ZVByb3h5KHByb3h5KTtcbiAgICByZXR1cm4gcHJveHk7XG59O1xuLyoqXG4gKiBPYnRhaW4gdGhlIG5vIHByb3h5IGluZm9ybWF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydHMuZ2V0Tm9Qcm94eUVudiA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBub1Byb3h5ID0gVXRpbC5nZXRFbnZWYXIoJ25vX3Byb3h5Jyk7XG4gICAgaWYgKG5vUHJveHkpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHkuc3BsaXQoJywnKS5qb2luKCd8Jyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLyoqXG4gKiBFeHRyYWN0IHRoZSBob3N0IGZyb20gdGhlIGRlc3RpbmF0aW9uIFVSTCB0byBjaGVjayB3aGV0aGVyIHRoZSBzYW1lIGFnZW50IGFscmVhZHkgZXhpc3RzIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuZ2V0SG9zdEZyb21VUkwgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICBpZiAoZGVzdGluYXRpb24uaW5kZXhPZignOi8vJykgPT09IC0xKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gJ2h0dHBzJyArICc6Ly8nICsgZGVzdGluYXRpb247XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgRmFpbGVkIHRvIHBhcnNlIHRoZSBkZXN0aW5hdGlvbiB0byBVUkwgd2l0aCB0aGUgZXJyb3I6ICR7ZXJyfS4gUmV0dXJuIGRlc3RpbmF0aW9uIGFzIHRoZSBob3N0OiAke2Rlc3RpbmF0aW9ufWApO1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxufTtcbi8qKlxuICogaWYgcHJveHkgZXhpc3RzLCByZXR1cm4gdGhlIHByb3h5LiBJZiBub3QgYW5kIHRoZSB1c2VFbnZQcm94eSBpcyB0cnVlLCByZXR1cm4gdGhlIHByb3h5IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICogQHBhcmFtIHtQcm94eX0gcHJveHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNIdHRwXG4gKlxuICogQHJldHVybnMge1Byb3h5fVxuICovXG5leHBvcnRzLmdldFByb3h5ID0gZnVuY3Rpb24gKHByb3h5LCBtb2R1bGVOYW1lLCBpc0h0dHBzKSB7XG4gICAgaWYgKCFwcm94eSAmJiBHbG9iYWxDb25maWcuaXNFbnZQcm94eUFjdGl2ZSgpKSB7XG4gICAgICAgIHByb3h5ID0gdGhpcy5nZXRQcm94eUZyb21FbnYoaXNIdHRwcyk7XG4gICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYCR7bW9kdWxlTmFtZX0gbG9hZHMgdGhlIHByb3h5IGluZm8gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgaG9zdDogJHtwcm94eS5ob3N0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbn07XG4vKipcbiAqIFRoZSBwcm94eSBjb25maWd1cmF0aW9uIGZpZWxkcyBpbiBBenVyZSBhcmUgZGlmZmVyZW50IGZyb20gdGhlIHByb3h5IGZpZWxkcyBpbiB0aGUgc25vd2ZsYWtlIG5vZGUuanMgZHJpdmVyLlxuICogQmVjYXVzZSBvZiB0aGF0LCB0aGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBzbm93Zmxha2UgcHJveHkgaW5mbyB0byB0aGUgQXp1cmUgcHJveHkgaW5mby5cbiAqIEBwYXJhbSB7UHJveHl9IHByb3h5XG4gKiBAcmV0dXJucyB7e2hvc3Q6c3RyaW5nLCBwb3J0Om51bWJlciwgdXNlcj86c3RyaW5nLCBwYXNzd29yZD86c3RyaW5nfX19XG4gKi9cbmV4cG9ydHMuZ2V0QXp1cmVQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgIGNvbnN0IEF6dXJlUHJveHkgPSB7XG4gICAgICAgIC4uLnByb3h5LFxuICAgICAgICBob3N0OiBgJHtwcm94eS5wcm90b2NvbH0ke3Byb3h5LnByb3RvY29sLmVuZHNXaXRoKCc6JykgPyAnJyA6ICc6J30vLyR7cHJveHkuaG9zdH1gLFxuICAgIH07XG4gICAgZGVsZXRlIEF6dXJlUHJveHkubm9Qcm94eTtcbiAgICBkZWxldGUgQXp1cmVQcm94eS5wcm90b2NvbDtcbiAgICBpZiAoIVV0aWwuZXhpc3RzKEF6dXJlUHJveHkudXNlcikgfHwgIVV0aWwuZXhpc3RzKEF6dXJlUHJveHkucGFzc3dvcmQpKSB7XG4gICAgICAgIGRlbGV0ZSBBenVyZVByb3h5LnVzZXI7XG4gICAgICAgIGRlbGV0ZSBBenVyZVByb3h5LnBhc3N3b3JkO1xuICAgIH1cbiAgICByZXR1cm4gQXp1cmVQcm94eTtcbn07XG4vKipcbiAqIEN1cnJlbnRseSwgdGhlcmUgaXMgbm8gd2F5IHRvIGRpc2FibGUgbG9hZGluZyB0aGUgcHJveHkgaW5mb3JtYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgcGF0aCBpbiBBenVyZS9ibG9iLlxuICogVG8gY29udHJvbCB0aGlzIHByb3h5IG9wdGlvbiBvbiB0aGUgZHJpdmVyIHNpZGUsIEEgdGVtcG9yYXJ5IHdvcmthcm91bmQgaXMgaGlkZShyZW1vdmUpIHRoZSBlbnZpcm9ubWVudCBwcm94eSBmcm9tIHRoZSBwcm9jZXNzXG4gKiB3aGVuIHRoZSBjbGllbnQgaXMgY3JlYXRlZCAoQXQgdGhpcyB0aW1lLCB0aGUgY2xpZW50IGxvYWRzIHRoZSBwcm94eSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW50ZXJuYWxseSkuXG4gKiBBZnRlciB0aGUgY2xpZW50IGlzIGNyZWF0ZWQsIHJlc3RvcmUgdGhlbSB3aXRoIHRoZSAncmVzdG9yZUVudmlyb25tZW50UHJveHknIGZ1bmN0aW9uLlxuICovXG5sZXQgZW52UHJveHlMaXN0O1xuY29uc3QgcHJveHlFbnZMaXN0ID0gWydodHRwX3Byb3h5JywgJ2h0dHBzX3Byb3h5JywgJ25vX3Byb3h5J107XG5leHBvcnRzLmhpZGVFbnZpcm9ubWVudFByb3h5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChHbG9iYWxDb25maWcuaXNFbnZQcm94eUFjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0FzIHRoZSB1c2VFbnZQcm94eSBvcHRpb24gaXMgZGlzYWJsZWQsIHRoZSBwcm94eSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIHRlbXBvcmFyaWx5IGhpZGRlbiBkdXJpbmcgdGhlIGNyZWF0aW9uIG9mIGFuIEF6dXJlIGNsaWVudCcpO1xuICAgIGVudlByb3h5TGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgZW52VmFyIG9mIHByb3h5RW52TGlzdCkge1xuICAgICAgICBzYXZlUHJveHlJbmZvSW5MaXN0KGVudlZhcik7XG4gICAgICAgIGlmICghVXRpbC5pc1dpbmRvd3MoKSkge1xuICAgICAgICAgICAgc2F2ZVByb3h5SW5mb0luTGlzdChlbnZWYXIudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gc2F2ZVByb3h5SW5mb0luTGlzdChlbnZWYXIpIHtcbiAgICBjb25zdCBwcm94eUVudiA9IHByb2Nlc3MuZW52W2VudlZhcl07XG4gICAgZW52UHJveHlMaXN0LnB1c2gocHJvY2Vzcy5lbnZbZW52VmFyXSk7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52W2VudlZhcl07XG4gICAgaWYgKFV0aWwuZXhpc3RzKHByb3h5RW52KSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVGVtcG9yYXJpbHkgZXhjbHVkZSAke2VudlZhcn0gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWU6ICR7cHJveHlFbnZ9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgJHtlbnZWYXJ9IHdhcyBub3QgZGVmaW5lZCwgbm90aGluZyB0byBkb2ApO1xuICAgIH1cbn1cbmV4cG9ydHMucmVzdG9yZUVudmlyb25tZW50UHJveHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKEdsb2JhbENvbmZpZy5pc0VudlByb3h5QWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVyYXRvciA9IGVudlByb3h5TGlzdFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgbGV0IG5leHRWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBmb3IgKGNvbnN0IGVudlZhciBvZiBwcm94eUVudkxpc3QpIHtcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBUaGUgJHtlbnZWYXJ9IHZhbHVlIGV4aXN0cyB3aXRoIHRoZSB2YWx1ZTogJHtuZXh0VmFsdWV9IFJlc3RvcmUgYmFjayB0aGUgcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWVzYCk7XG4gICAgICAgICAgICBwcm9jZXNzLmVudltlbnZWYXJdID0gbmV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG5leHRWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgaWYgKCFVdGlsLmlzV2luZG93cygpKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMobmV4dFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBUaGUgJHtlbnZWYXIudG9VcHBlckNhc2UoKX0gdmFsdWUgZXhpc3RzIHdpdGggdGhlIHZhbHVlOiAke25leHRWYWx1ZX0gUmVzdG9yZSBiYWNrIHRoZSBwcm94eSBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZXMgKGZvciBOb24tV2luZG93cyBtYWNoaW5lKWApO1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52W2VudlZhci50b1VwcGVyQ2FzZSgpXSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQW4gQXp1cmUgY2xpZW50IGhhcyBiZWVuIGNyZWF0ZWQuIFJlc3RvcmUgYmFjayB0aGUgcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWVzJyk7XG59O1xuLyoqXG4gKiBQcm92aWRlIHRoZSBkZXRhaWxzIG9mIHRoZSBwcm94eSBpbmZvLlxuICogQHBhcmFtIHByb3h5XG4gKiBAcGFyYW0gZGVzdGluYXRpb24ge3N0cmluZyB8IFJlZ2V4IH1cbiAqL1xuZXhwb3J0cy5pc0J5UGFzc1Byb3h5ID0gZnVuY3Rpb24gKHByb3h5LCBkZXN0aW5hdGlvbikge1xuICAgIGlmIChwcm94eSAmJiBwcm94eS5ub1Byb3h5KSB7XG4gICAgICAgIGNvbnN0IGJ5cGFzc0xpc3QgPSBwcm94eS5ub1Byb3h5LnNwbGl0KCd8Jyk7XG4gICAgICAgIHJldHVybiBieXBhc3NMaXN0LmZpbmQoKG5vUHJveHkpID0+IHtcbiAgICAgICAgICAgIGxldCBob3N0ID0gbm9Qcm94eS50cmltKCk7XG4gICAgICAgICAgICBob3N0ID0gaG9zdC5yZXBsYWNlKCcqJywgJy4qPycpO1xuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnRlc3QoaG9zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub1Byb3h5UmVnZXggPSBuZXcgUmVnRXhwKGBeJHtob3N0fWApO1xuICAgICAgICAgICAgcmV0dXJuIG5vUHJveHlSZWdleC50ZXN0KGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogUHJvdmlkZSB0aGUgZGV0YWlscyBvZiB0aGUgcHJveHkgaW5mby5cbiAqIEBwYXJhbSBwcm94eVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5kZXNjcmliZVByb3h5ID0gZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgaWYgKFV0aWwuZXhpc3RzKHByb3h5KSkge1xuICAgICAgICByZXR1cm4gKGBwcm94eUhvc3Q6ICR7cHJveHkuaG9zdH0sIHByb3h5UG9ydDogJHtwcm94eS5wb3J0fSwgYCArXG4gICAgICAgICAgICBgJHtVdGlsLmV4aXN0cyhwcm94eS51c2VyKSA/IGBwcm94eVVzZXI6ICR7cHJveHkudXNlcn0sIHByb3h5UGFzc3dvcmQgaXMgJHtMb2dnaW5nVXRpbC5kZXNjcmliZVByZXNlbmNlKHByb3h5LnBhc3N3b3JkKX0sIGAgOiAnJ31gICtcbiAgICAgICAgICAgIGBwcm94eVByb3RvY29sOiAke3Byb3h5LnByb3RvY29sfSwgbm9Qcm94eTogJHtwcm94eS5ub1Byb3h5fWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdwcm94eSB3YXMgbm90IGNvbmZpZ3VyZWQnO1xuICAgIH1cbn07XG4vKipcbiAqIE1ha2UgdGhlIHByb3h5IHN0cmluZyB3aXRoIHRoZSBwcm94eSBpbmZvIChqc29uIGZvcm1hdClcbiAqIEBwYXJhbSBwcm94eVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5zdHJpbmdpZnlQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgIGlmIChVdGlsLmlzRW1wdHlPYmplY3QocHJveHkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGAke3Byb3h5LnByb3RvY29sLnN0YXJ0c1dpdGgoJ2h0dHBzJykgPyAnaHR0cHMnIDogJ2h0dHAnfTovL2AgK1xuICAgICAgICBgJHtVdGlsLmV4aXN0cyhwcm94eS51c2VyKSA/IGAke3Byb3h5LnVzZXJ9OiR7cHJveHkucGFzc3dvcmR9QGAgOiAnJ31gICtcbiAgICAgICAgYCR7cHJveHkuaG9zdH06JHtwcm94eS5wb3J0fWApO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3h5X3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/queryContextCache.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/queryContextCache.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n *\n * @param {String} id\n * @param {Number} timestamp\n * @param {Number} priority\n * @param {String} context\n */\nfunction QueryContextElement(id, timestamp, priority, context) {\n    this.id = id;\n    this.timestamp = timestamp;\n    this.priority = priority;\n    this.context = context;\n}\n/**\n * Most Recently Used and Priority based cache. A separate cache for each connection in the driver.\n */\n/**\n * @param {Number} capacity Maximum capacity of the cache.\n * @param {Number} sessionId Session for which the cache is created.\n */\nfunction QueryContextCache(capacity, sessionId) {\n    Logger.getInstance().debug(`Creating new QueryContextCache with capacity ${capacity} for session ${sessionId}`);\n    this.sessionId = sessionId;\n    this.capacity = capacity;\n    this.idMap = new Map(); // Map for id and QCC\n    this.treeSet = new Set(); // Order data as per priority\n    this.priorityMap = new Map(); // Map for priority and QCC\n}\nQueryContextCache.prototype.sortTreeSet = function () {\n    this.treeSet = new Set(Array.from(this.treeSet).sort((a, b) => a.priority - b.priority));\n};\nQueryContextCache.prototype.addQCE = function (qce) {\n    this.idMap.set(qce.id, qce);\n    this.priorityMap.set(qce.priority, qce);\n    this.treeSet.add(qce);\n    this.sortTreeSet();\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - Added QCE: ${JSON.stringify(qce)}`);\n};\n/**\n * Remove an element from the cache.\n *\n * @param {Object} qce element to remove.\n */\nQueryContextCache.prototype.removeQCE = function (qce) {\n    this.idMap.delete(qce.id);\n    this.priorityMap.delete(qce.priority);\n    this.treeSet.delete(qce);\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - Removed QCE: ${JSON.stringify(qce)}`);\n};\n/**\n * Replace the cache element with a new response element. Remove old element exist in the cache\n * and add a new element received.\n *\n * @param {Object} oldQCE an element exist in the cache\n * @param {Object} newQCE a new element just received.\n */\nQueryContextCache.prototype.replaceQCE = function (oldQCE, newQCE) {\n    // Remove old element from the cache\n    this.removeQCE(oldQCE);\n    // Add new element in the cache\n    this.addQCE(newQCE);\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - Replaced QCE: ${JSON.stringify(oldQCE)} with ${JSON.stringify(newQCE)}`);\n};\n/**\n * Merge a new element comes from the server with the existing cache. Merge is based on read time\n * stamp for the same id and based on priority for two different ids.\n *\n * @param {Number} id\n * @param {Number} timestamp\n * @param {Number} priority\n * @param {String} context\n *\n */\nQueryContextCache.prototype.merge = function (newQCE) {\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - Merging QCE: ${JSON.stringify(newQCE)}`);\n    if (this.idMap.has(newQCE.id)) {\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - Element id ${newQCE.id} found in cache`);\n        // ID found in the cache\n        const qce = this.idMap.get(newQCE.id);\n        if (newQCE.timestamp > qce.timestamp) {\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - New element is more recent. Current timestamp: ${qce.timestamp}, new timestamp: ${newQCE.timestamp}`);\n            if (qce.priority === newQCE.priority) {\n                Logger.getInstance().trace(`QCC session ${this.sessionId} - Element priority (${qce.priority}) is the same`);\n                // Same priority, overwrite new data at same place\n                qce.timestamp = newQCE.timestamp;\n                qce.context = newQCE.context;\n            }\n            else {\n                Logger.getInstance().trace(`QCC session ${this.sessionId} - Element priority changed. Current priority: ${qce.priority}, new priority: ${newQCE.priority}`);\n                // Change in priority\n                this.replaceQCE(qce, newQCE);\n            }\n        }\n        else if (newQCE.timestamp === qce.timestamp && qce.priority !== newQCE.priority) {\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - Element timestamp is the same, but priority changes. Current priority: ${qce.priority}, new priority: ${newQCE.priority}`);\n            // Same read timestamp but change in priority\n            this.replaceQCE(qce, newQCE);\n        }\n        else {\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - Element is the same. Doing nothing.`);\n        }\n    }\n    else {\n        Logger.getInstance().trace(`QCC session ${this.sessionId} - New element`);\n        // new id\n        if (this.priorityMap.has(newQCE.priority)) {\n            // Same priority with different id\n            const qce = this.priorityMap.get(newQCE.priority);\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - Element with the same priority found: ${JSON.stringify(qce)}. Replacing with new element: ${JSON.stringify(newQCE)}`);\n            // Replace with new data\n            this.replaceQCE(qce, newQCE);\n        }\n        else {\n            Logger.getInstance().debug(`QCC session ${this.sessionId} - Adding new element to the cache: ${JSON.stringify(newQCE)}`);\n            // new priority\n            // Add new element in the cache\n            this.addQCE(newQCE, newQCE);\n        }\n    }\n};\n/**\n * After the merge, loop through priority list and make sure cache is at most capacity. Remove all\n * other elements from the list based on priority.\n */\nQueryContextCache.prototype.checkCacheCapacity = function () {\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - checkCacheCapacity() called. treeSet size ${this.treeSet.size}, cache capacity ${this.capacity}`);\n    // remove elements based on priority\n    while (this.treeSet.size > this.capacity) {\n        const qce = Array.from(this.treeSet).pop();\n        this.removeQCE(qce);\n    }\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - checkCacheCapacity() returns. treeSet size ${this.treeSet.size}, cache capacity ${this.capacity}`);\n};\n/** Clear the cache. */\nQueryContextCache.prototype.clearCache = function () {\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - clearCache() called`);\n    this.idMap.clear();\n    this.priorityMap.clear();\n    this.treeSet.clear();\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - clearCache() returns. Number of entries in cache now ${this.treeSet.size}`);\n};\nQueryContextCache.prototype.getElements = function () {\n    return this.treeSet;\n};\n/**\n * @param data: the QueryContext Object serialized as a JSON format string\n */\nQueryContextCache.prototype.deserializeQueryContext = function (data) {\n    const stringifyData = JSON.stringify(data);\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContext() called: data from server: ${stringifyData}`);\n    if (!data || stringifyData === '{}' || data.entries === null) {\n        this.clearCache();\n        Logger.getInstance().trace(`QCC session ${this.sessionId} - deserializeQueryContext() returns`);\n        this.logCacheEntries();\n        return;\n    }\n    try {\n        // Deserialize the entries. The first entry with priority is the main entry. An example JSON is:\n        // {\n        //   \"entries\": [\n        //    {\n        //     \"id\": 0,\n        //     \"readtimestamp\": 123456789,\n        //     \"priority\": 0,\n        //     \"context\": \"base64 encoded context\"\n        //    },\n        //     {\n        //       \"id\": 1,\n        //       \"readtimestamp\": 123456789,\n        //       \"priority\": 1,\n        //       \"context\": \"base64 encoded context\"\n        //     },\n        //     {\n        //       \"id\": 2,\n        //       \"readtimestamp\": 123456789,\n        //       \"priority\": 2,\n        //       \"context\": \"base64 encoded context\"\n        //     }\n        //   ]\n        const entries = data.entries;\n        if (entries !== null && Array.isArray(entries)) {\n            for (const entryNode of entries) {\n                const entry = this.deserializeQueryContextElement(entryNode);\n                if (entry != null) {\n                    this.merge(entry);\n                }\n                else {\n                    Logger.getInstance().warn(`QCC session ${this.sessionId} - deserializeQueryContextJson: deserializeQueryContextElement meets mismatch field type. Clear the QueryContextCache.`);\n                    this.clearCache();\n                    return;\n                }\n            }\n        }\n    }\n    catch (e) {\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContextJson: Exception = ${e.getMessage}`);\n        // Not rethrowing. clear the cache as incomplete merge can lead to unexpected behavior.\n        this.clearCache();\n    }\n    this.checkCacheCapacity();\n    this.logCacheEntries();\n};\nQueryContextCache.prototype.deserializeQueryContextElement = function (node) {\n    const { id, timestamp, priority, context } = node;\n    const entry = new QueryContextElement(id, timestamp, priority, null);\n    if (typeof context === 'string') {\n        entry.context = context;\n    }\n    else if (context === null || context === undefined) {\n        entry.context = null;\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContextElement \\`context\\` field is empty`);\n    }\n    else {\n        Logger.getInstance().warn(`QCC session ${this.sessionId} - deserializeQueryContextElement: \\`context\\` field is not String type`);\n        return null;\n    }\n    return entry;\n};\nQueryContextCache.prototype.logCacheEntries = function () {\n    this.treeSet.forEach(function (elem) {\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - Cache Entry: id: ${elem.id} timestamp: ${elem.timestamp} priority: ${elem.priority}`);\n    }, this);\n};\nQueryContextCache.prototype.getSize = function () {\n    return this.treeSet.size;\n};\nQueryContextCache.prototype.getQueryContextDTO = function () {\n    const arr = [];\n    const querycontexts = Array.from(this.getElements());\n    for (let i = 0; i < this.treeSet.size; i++) {\n        arr.push({\n            id: querycontexts[i].id,\n            timestamp: querycontexts[i].timestamp,\n            priority: querycontexts[i].priority,\n            context: { base64Data: querycontexts[i].context } || null,\n        });\n    }\n    return {\n        entries: arr,\n    };\n};\nQueryContextCache.prototype.getSerializeQueryContext = function () {\n    const arr = [];\n    const querycontexts = Array.from(this.getElements());\n    for (let i = 0; i < this.treeSet.size; i++) {\n        arr.push({\n            id: querycontexts[i].id,\n            timestamp: querycontexts[i].timestamp,\n            priority: querycontexts[i].priority,\n            context: querycontexts[i].context || null,\n        });\n    }\n    return {\n        entries: arr,\n    };\n};\nmodule.exports = QueryContextCache;\n//# sourceMappingURL=queryContextCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9xdWVyeUNvbnRleHRDYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSwrRUFBK0UsVUFBVSxjQUFjLFVBQVU7QUFDakg7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IsZUFBZSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IsaUJBQWlCLG9CQUFvQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLGtCQUFrQix3QkFBd0IsT0FBTyx1QkFBdUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDdEc7QUFDQSxrREFBa0QsZ0JBQWdCLGVBQWUsV0FBVztBQUM1RjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCLG1EQUFtRCxjQUFjLG1CQUFtQixpQkFBaUI7QUFDM0s7QUFDQSwwREFBMEQsZ0JBQWdCLHNCQUFzQixhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCLGdEQUFnRCxhQUFhLGtCQUFrQixnQkFBZ0I7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0IsMkVBQTJFLGFBQWEsa0JBQWtCLGdCQUFnQjtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0IsMENBQTBDLG9CQUFvQixnQ0FBZ0MsdUJBQXVCO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQixxQ0FBcUMsdUJBQXVCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLDhDQUE4QyxrQkFBa0IsbUJBQW1CLGNBQWM7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IsK0NBQStDLGtCQUFrQixtQkFBbUIsY0FBYztBQUNoSztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IseURBQXlELGtCQUFrQjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLHdEQUF3RCxjQUFjO0FBQ3BJLHNDQUFzQztBQUN0QztBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0IsNkNBQTZDLGFBQWE7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0IscUJBQXFCLFNBQVMsYUFBYSxnQkFBZ0IsWUFBWSxjQUFjO0FBQ3ZKLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9xdWVyeUNvbnRleHRDYWNoZS5qcz9mMTllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcFxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5XG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGV4dFxuICovXG5mdW5jdGlvbiBRdWVyeUNvbnRleHRFbGVtZW50KGlkLCB0aW1lc3RhbXAsIHByaW9yaXR5LCBjb250ZXh0KSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuLyoqXG4gKiBNb3N0IFJlY2VudGx5IFVzZWQgYW5kIFByaW9yaXR5IGJhc2VkIGNhY2hlLiBBIHNlcGFyYXRlIGNhY2hlIGZvciBlYWNoIGNvbm5lY3Rpb24gaW4gdGhlIGRyaXZlci5cbiAqL1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gY2FwYWNpdHkgTWF4aW11bSBjYXBhY2l0eSBvZiB0aGUgY2FjaGUuXG4gKiBAcGFyYW0ge051bWJlcn0gc2Vzc2lvbklkIFNlc3Npb24gZm9yIHdoaWNoIHRoZSBjYWNoZSBpcyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBRdWVyeUNvbnRleHRDYWNoZShjYXBhY2l0eSwgc2Vzc2lvbklkKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYENyZWF0aW5nIG5ldyBRdWVyeUNvbnRleHRDYWNoZSB3aXRoIGNhcGFjaXR5ICR7Y2FwYWNpdHl9IGZvciBzZXNzaW9uICR7c2Vzc2lvbklkfWApO1xuICAgIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLmlkTWFwID0gbmV3IE1hcCgpOyAvLyBNYXAgZm9yIGlkIGFuZCBRQ0NcbiAgICB0aGlzLnRyZWVTZXQgPSBuZXcgU2V0KCk7IC8vIE9yZGVyIGRhdGEgYXMgcGVyIHByaW9yaXR5XG4gICAgdGhpcy5wcmlvcml0eU1hcCA9IG5ldyBNYXAoKTsgLy8gTWFwIGZvciBwcmlvcml0eSBhbmQgUUNDXG59XG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuc29ydFRyZWVTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmVlU2V0ID0gbmV3IFNldChBcnJheS5mcm9tKHRoaXMudHJlZVNldCkuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpKTtcbn07XG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuYWRkUUNFID0gZnVuY3Rpb24gKHFjZSkge1xuICAgIHRoaXMuaWRNYXAuc2V0KHFjZS5pZCwgcWNlKTtcbiAgICB0aGlzLnByaW9yaXR5TWFwLnNldChxY2UucHJpb3JpdHksIHFjZSk7XG4gICAgdGhpcy50cmVlU2V0LmFkZChxY2UpO1xuICAgIHRoaXMuc29ydFRyZWVTZXQoKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBBZGRlZCBRQ0U6ICR7SlNPTi5zdHJpbmdpZnkocWNlKX1gKTtcbn07XG4vKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBxY2UgZWxlbWVudCB0byByZW1vdmUuXG4gKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5yZW1vdmVRQ0UgPSBmdW5jdGlvbiAocWNlKSB7XG4gICAgdGhpcy5pZE1hcC5kZWxldGUocWNlLmlkKTtcbiAgICB0aGlzLnByaW9yaXR5TWFwLmRlbGV0ZShxY2UucHJpb3JpdHkpO1xuICAgIHRoaXMudHJlZVNldC5kZWxldGUocWNlKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBSZW1vdmVkIFFDRTogJHtKU09OLnN0cmluZ2lmeShxY2UpfWApO1xufTtcbi8qKlxuICogUmVwbGFjZSB0aGUgY2FjaGUgZWxlbWVudCB3aXRoIGEgbmV3IHJlc3BvbnNlIGVsZW1lbnQuIFJlbW92ZSBvbGQgZWxlbWVudCBleGlzdCBpbiB0aGUgY2FjaGVcbiAqIGFuZCBhZGQgYSBuZXcgZWxlbWVudCByZWNlaXZlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUUNFIGFuIGVsZW1lbnQgZXhpc3QgaW4gdGhlIGNhY2hlXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3UUNFIGEgbmV3IGVsZW1lbnQganVzdCByZWNlaXZlZC5cbiAqL1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLnJlcGxhY2VRQ0UgPSBmdW5jdGlvbiAob2xkUUNFLCBuZXdRQ0UpIHtcbiAgICAvLyBSZW1vdmUgb2xkIGVsZW1lbnQgZnJvbSB0aGUgY2FjaGVcbiAgICB0aGlzLnJlbW92ZVFDRShvbGRRQ0UpO1xuICAgIC8vIEFkZCBuZXcgZWxlbWVudCBpbiB0aGUgY2FjaGVcbiAgICB0aGlzLmFkZFFDRShuZXdRQ0UpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIFJlcGxhY2VkIFFDRTogJHtKU09OLnN0cmluZ2lmeShvbGRRQ0UpfSB3aXRoICR7SlNPTi5zdHJpbmdpZnkobmV3UUNFKX1gKTtcbn07XG4vKipcbiAqIE1lcmdlIGEgbmV3IGVsZW1lbnQgY29tZXMgZnJvbSB0aGUgc2VydmVyIHdpdGggdGhlIGV4aXN0aW5nIGNhY2hlLiBNZXJnZSBpcyBiYXNlZCBvbiByZWFkIHRpbWVcbiAqIHN0YW1wIGZvciB0aGUgc2FtZSBpZCBhbmQgYmFzZWQgb24gcHJpb3JpdHkgZm9yIHR3byBkaWZmZXJlbnQgaWRzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcFxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5XG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGV4dFxuICpcbiAqL1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG5ld1FDRSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIE1lcmdpbmcgUUNFOiAke0pTT04uc3RyaW5naWZ5KG5ld1FDRSl9YCk7XG4gICAgaWYgKHRoaXMuaWRNYXAuaGFzKG5ld1FDRS5pZCkpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gRWxlbWVudCBpZCAke25ld1FDRS5pZH0gZm91bmQgaW4gY2FjaGVgKTtcbiAgICAgICAgLy8gSUQgZm91bmQgaW4gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IHFjZSA9IHRoaXMuaWRNYXAuZ2V0KG5ld1FDRS5pZCk7XG4gICAgICAgIGlmIChuZXdRQ0UudGltZXN0YW1wID4gcWNlLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gTmV3IGVsZW1lbnQgaXMgbW9yZSByZWNlbnQuIEN1cnJlbnQgdGltZXN0YW1wOiAke3FjZS50aW1lc3RhbXB9LCBuZXcgdGltZXN0YW1wOiAke25ld1FDRS50aW1lc3RhbXB9YCk7XG4gICAgICAgICAgICBpZiAocWNlLnByaW9yaXR5ID09PSBuZXdRQ0UucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBFbGVtZW50IHByaW9yaXR5ICgke3FjZS5wcmlvcml0eX0pIGlzIHRoZSBzYW1lYCk7XG4gICAgICAgICAgICAgICAgLy8gU2FtZSBwcmlvcml0eSwgb3ZlcndyaXRlIG5ldyBkYXRhIGF0IHNhbWUgcGxhY2VcbiAgICAgICAgICAgICAgICBxY2UudGltZXN0YW1wID0gbmV3UUNFLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBxY2UuY29udGV4dCA9IG5ld1FDRS5jb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gRWxlbWVudCBwcmlvcml0eSBjaGFuZ2VkLiBDdXJyZW50IHByaW9yaXR5OiAke3FjZS5wcmlvcml0eX0sIG5ldyBwcmlvcml0eTogJHtuZXdRQ0UucHJpb3JpdHl9YCk7XG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGluIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlUUNFKHFjZSwgbmV3UUNFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdRQ0UudGltZXN0YW1wID09PSBxY2UudGltZXN0YW1wICYmIHFjZS5wcmlvcml0eSAhPT0gbmV3UUNFLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBFbGVtZW50IHRpbWVzdGFtcCBpcyB0aGUgc2FtZSwgYnV0IHByaW9yaXR5IGNoYW5nZXMuIEN1cnJlbnQgcHJpb3JpdHk6ICR7cWNlLnByaW9yaXR5fSwgbmV3IHByaW9yaXR5OiAke25ld1FDRS5wcmlvcml0eX1gKTtcbiAgICAgICAgICAgIC8vIFNhbWUgcmVhZCB0aW1lc3RhbXAgYnV0IGNoYW5nZSBpbiBwcmlvcml0eVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUUNFKHFjZSwgbmV3UUNFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEVsZW1lbnQgaXMgdGhlIHNhbWUuIERvaW5nIG5vdGhpbmcuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIE5ldyBlbGVtZW50YCk7XG4gICAgICAgIC8vIG5ldyBpZFxuICAgICAgICBpZiAodGhpcy5wcmlvcml0eU1hcC5oYXMobmV3UUNFLnByaW9yaXR5KSkge1xuICAgICAgICAgICAgLy8gU2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCBpZFxuICAgICAgICAgICAgY29uc3QgcWNlID0gdGhpcy5wcmlvcml0eU1hcC5nZXQobmV3UUNFLnByaW9yaXR5KTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEVsZW1lbnQgd2l0aCB0aGUgc2FtZSBwcmlvcml0eSBmb3VuZDogJHtKU09OLnN0cmluZ2lmeShxY2UpfS4gUmVwbGFjaW5nIHdpdGggbmV3IGVsZW1lbnQ6ICR7SlNPTi5zdHJpbmdpZnkobmV3UUNFKX1gKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2Ugd2l0aCBuZXcgZGF0YVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUUNFKHFjZSwgbmV3UUNFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEFkZGluZyBuZXcgZWxlbWVudCB0byB0aGUgY2FjaGU6ICR7SlNPTi5zdHJpbmdpZnkobmV3UUNFKX1gKTtcbiAgICAgICAgICAgIC8vIG5ldyBwcmlvcml0eVxuICAgICAgICAgICAgLy8gQWRkIG5ldyBlbGVtZW50IGluIHRoZSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5hZGRRQ0UobmV3UUNFLCBuZXdRQ0UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQWZ0ZXIgdGhlIG1lcmdlLCBsb29wIHRocm91Z2ggcHJpb3JpdHkgbGlzdCBhbmQgbWFrZSBzdXJlIGNhY2hlIGlzIGF0IG1vc3QgY2FwYWNpdHkuIFJlbW92ZSBhbGxcbiAqIG90aGVyIGVsZW1lbnRzIGZyb20gdGhlIGxpc3QgYmFzZWQgb24gcHJpb3JpdHkuXG4gKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5jaGVja0NhY2hlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gY2hlY2tDYWNoZUNhcGFjaXR5KCkgY2FsbGVkLiB0cmVlU2V0IHNpemUgJHt0aGlzLnRyZWVTZXQuc2l6ZX0sIGNhY2hlIGNhcGFjaXR5ICR7dGhpcy5jYXBhY2l0eX1gKTtcbiAgICAvLyByZW1vdmUgZWxlbWVudHMgYmFzZWQgb24gcHJpb3JpdHlcbiAgICB3aGlsZSAodGhpcy50cmVlU2V0LnNpemUgPiB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgIGNvbnN0IHFjZSA9IEFycmF5LmZyb20odGhpcy50cmVlU2V0KS5wb3AoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVRQ0UocWNlKTtcbiAgICB9XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gY2hlY2tDYWNoZUNhcGFjaXR5KCkgcmV0dXJucy4gdHJlZVNldCBzaXplICR7dGhpcy50cmVlU2V0LnNpemV9LCBjYWNoZSBjYXBhY2l0eSAke3RoaXMuY2FwYWNpdHl9YCk7XG59O1xuLyoqIENsZWFyIHRoZSBjYWNoZS4gKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGNsZWFyQ2FjaGUoKSBjYWxsZWRgKTtcbiAgICB0aGlzLmlkTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5wcmlvcml0eU1hcC5jbGVhcigpO1xuICAgIHRoaXMudHJlZVNldC5jbGVhcigpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGNsZWFyQ2FjaGUoKSByZXR1cm5zLiBOdW1iZXIgb2YgZW50cmllcyBpbiBjYWNoZSBub3cgJHt0aGlzLnRyZWVTZXQuc2l6ZX1gKTtcbn07XG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZVNldDtcbn07XG4vKipcbiAqIEBwYXJhbSBkYXRhOiB0aGUgUXVlcnlDb250ZXh0IE9iamVjdCBzZXJpYWxpemVkIGFzIGEgSlNPTiBmb3JtYXQgc3RyaW5nXG4gKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgY29uc3Qgc3RyaW5naWZ5RGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGRlc2VyaWFsaXplUXVlcnlDb250ZXh0KCkgY2FsbGVkOiBkYXRhIGZyb20gc2VydmVyOiAke3N0cmluZ2lmeURhdGF9YCk7XG4gICAgaWYgKCFkYXRhIHx8IHN0cmluZ2lmeURhdGEgPT09ICd7fScgfHwgZGF0YS5lbnRyaWVzID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBkZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dCgpIHJldHVybnNgKTtcbiAgICAgICAgdGhpcy5sb2dDYWNoZUVudHJpZXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBEZXNlcmlhbGl6ZSB0aGUgZW50cmllcy4gVGhlIGZpcnN0IGVudHJ5IHdpdGggcHJpb3JpdHkgaXMgdGhlIG1haW4gZW50cnkuIEFuIGV4YW1wbGUgSlNPTiBpczpcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIFwiZW50cmllc1wiOiBbXG4gICAgICAgIC8vICAgIHtcbiAgICAgICAgLy8gICAgIFwiaWRcIjogMCxcbiAgICAgICAgLy8gICAgIFwicmVhZHRpbWVzdGFtcFwiOiAxMjM0NTY3ODksXG4gICAgICAgIC8vICAgICBcInByaW9yaXR5XCI6IDAsXG4gICAgICAgIC8vICAgICBcImNvbnRleHRcIjogXCJiYXNlNjQgZW5jb2RlZCBjb250ZXh0XCJcbiAgICAgICAgLy8gICAgfSxcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgXCJpZFwiOiAxLFxuICAgICAgICAvLyAgICAgICBcInJlYWR0aW1lc3RhbXBcIjogMTIzNDU2Nzg5LFxuICAgICAgICAvLyAgICAgICBcInByaW9yaXR5XCI6IDEsXG4gICAgICAgIC8vICAgICAgIFwiY29udGV4dFwiOiBcImJhc2U2NCBlbmNvZGVkIGNvbnRleHRcIlxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgXCJpZFwiOiAyLFxuICAgICAgICAvLyAgICAgICBcInJlYWR0aW1lc3RhbXBcIjogMTIzNDU2Nzg5LFxuICAgICAgICAvLyAgICAgICBcInByaW9yaXR5XCI6IDIsXG4gICAgICAgIC8vICAgICAgIFwiY29udGV4dFwiOiBcImJhc2U2NCBlbmNvZGVkIGNvbnRleHRcIlxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgIF1cbiAgICAgICAgY29uc3QgZW50cmllcyA9IGRhdGEuZW50cmllcztcbiAgICAgICAgaWYgKGVudHJpZXMgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeU5vZGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dEVsZW1lbnQoZW50cnlOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHRKc29uOiBkZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dEVsZW1lbnQgbWVldHMgbWlzbWF0Y2ggZmllbGQgdHlwZS4gQ2xlYXIgdGhlIFF1ZXJ5Q29udGV4dENhY2hlLmApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBkZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dEpzb246IEV4Y2VwdGlvbiA9ICR7ZS5nZXRNZXNzYWdlfWApO1xuICAgICAgICAvLyBOb3QgcmV0aHJvd2luZy4gY2xlYXIgdGhlIGNhY2hlIGFzIGluY29tcGxldGUgbWVyZ2UgY2FuIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tDYWNoZUNhcGFjaXR5KCk7XG4gICAgdGhpcy5sb2dDYWNoZUVudHJpZXMoKTtcbn07XG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBjb25zdCB7IGlkLCB0aW1lc3RhbXAsIHByaW9yaXR5LCBjb250ZXh0IH0gPSBub2RlO1xuICAgIGNvbnN0IGVudHJ5ID0gbmV3IFF1ZXJ5Q29udGV4dEVsZW1lbnQoaWQsIHRpbWVzdGFtcCwgcHJpb3JpdHksIG51bGwpO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW50cnkuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVudHJ5LmNvbnRleHQgPSBudWxsO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBkZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dEVsZW1lbnQgXFxgY29udGV4dFxcYCBmaWVsZCBpcyBlbXB0eWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBkZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dEVsZW1lbnQ6IFxcYGNvbnRleHRcXGAgZmllbGQgaXMgbm90IFN0cmluZyB0eXBlYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG59O1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmxvZ0NhY2hlRW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyZWVTZXQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBDYWNoZSBFbnRyeTogaWQ6ICR7ZWxlbS5pZH0gdGltZXN0YW1wOiAke2VsZW0udGltZXN0YW1wfSBwcmlvcml0eTogJHtlbGVtLnByaW9yaXR5fWApO1xuICAgIH0sIHRoaXMpO1xufTtcblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRyZWVTZXQuc2l6ZTtcbn07XG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZ2V0UXVlcnlDb250ZXh0RFRPID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGNvbnN0IHF1ZXJ5Y29udGV4dHMgPSBBcnJheS5mcm9tKHRoaXMuZ2V0RWxlbWVudHMoKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyZWVTZXQuc2l6ZTsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBxdWVyeWNvbnRleHRzW2ldLmlkLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBxdWVyeWNvbnRleHRzW2ldLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHByaW9yaXR5OiBxdWVyeWNvbnRleHRzW2ldLnByaW9yaXR5LFxuICAgICAgICAgICAgY29udGV4dDogeyBiYXNlNjREYXRhOiBxdWVyeWNvbnRleHRzW2ldLmNvbnRleHQgfSB8fCBudWxsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW50cmllczogYXJyLFxuICAgIH07XG59O1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmdldFNlcmlhbGl6ZVF1ZXJ5Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBjb25zdCBxdWVyeWNvbnRleHRzID0gQXJyYXkuZnJvbSh0aGlzLmdldEVsZW1lbnRzKCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmVlU2V0LnNpemU7IGkrKykge1xuICAgICAgICBhcnIucHVzaCh7XG4gICAgICAgICAgICBpZDogcXVlcnljb250ZXh0c1tpXS5pZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcXVlcnljb250ZXh0c1tpXS50aW1lc3RhbXAsXG4gICAgICAgICAgICBwcmlvcml0eTogcXVlcnljb250ZXh0c1tpXS5wcmlvcml0eSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHF1ZXJ5Y29udGV4dHNbaV0uY29udGV4dCB8fCBudWxsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW50cmllczogYXJyLFxuICAgIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUNvbnRleHRDYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5Q29udGV4dENhY2hlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/queryContextCache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/secret_detector.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/secret_detector.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * The secret detector detects sensitive information.\n * It masks secrets that might be leaked from two potential avenues\n *  1. Out of Band Telemetry\n *  2. Logging\n *\n * @param {Object} customPatterns contains 'regex' and 'mask' for customized masking\n * @param {Object} mock\n *\n * @returns {Object}\n * @constructor\n */\nfunction SecretDetector(customPatterns, mock) {\n    const CUSTOM_PATTERNS_REGEX = [];\n    const CUSTOM_PATTERNS_MASK = [];\n    let CUSTOM_PATTERNS_LENGTH;\n    if (customPatterns) {\n        // Check that the customPatterns object contains the keys 'regex' and 'mask\n        if (!customPatterns.regex) {\n            throw new Error(\"The customPatterns object must contain the 'regex' key\");\n        }\n        if (!customPatterns.mask) {\n            throw new Error(\"The customPatterns object must contain the 'mask' key\");\n        }\n        // Also check that their lengths are equal\n        if (customPatterns.regex.length !== customPatterns.mask.length) {\n            throw new Error(\"The customPatterns object must have equal length for both 'regex' and 'mask'\");\n        }\n        CUSTOM_PATTERNS_LENGTH = customPatterns.regex.length;\n        // Push the regex and mask elements onto their respective arrays\n        for (let index = 0; index < CUSTOM_PATTERNS_LENGTH; index++) {\n            CUSTOM_PATTERNS_REGEX.push(new RegExp(`${customPatterns.regex[index]}`, 'gi'));\n            CUSTOM_PATTERNS_MASK.push(String.raw `${customPatterns.mask[index]}`);\n        }\n    }\n    function maskCustomPattern(text) {\n        let result;\n        for (let index = 0; index < CUSTOM_PATTERNS_LENGTH; index++) {\n            result = text.replace(CUSTOM_PATTERNS_REGEX[index], CUSTOM_PATTERNS_MASK[index]);\n            // If the text is replaced, return the result\n            if (text !== result) {\n                return result;\n            }\n        }\n        // If text is unchanged, return the original\n        return text;\n    }\n    const AWS_KEY_PATTERN = new RegExp(String.raw `(aws_key_id|aws_secret_key|access_key_id|secret_access_key)\\s*=\\s*'([^']+)'`, 'gi');\n    const AWS_TOKEN_PATTERN = new RegExp(String.raw `(accessToken|tempToken|keySecret)\\s*:\\s*\"([a-z0-9/+]{32,}={0,2})\"`, 'gi');\n    const SAS_TOKEN_PATTERN = new RegExp(String.raw `(sig|signature|AWSAccessKeyId|password|passcode)=(\\?P<secret>[a-z0-9%/+]{16,})`, 'gi');\n    const PRIVATE_KEY_PATTERN = new RegExp(String.raw `-----BEGIN PRIVATE KEY-----\\\\n([a-z0-9/+=\\\\n]{32,})\\\\n-----END PRIVATE KEY-----`, // pragma: allowlist secret\n    'gim');\n    const PRIVATE_KEY_DATA_PATTERN = new RegExp(String.raw `\"privateKeyData\": \"([a-z0-9/+=\\\\n]{10,})\"`, 'gim');\n    // Colon in the group ([a-z0-9=/:_%-+]{8,}) was added to detect tokens that contain additional details before the actual token.\n    // Such as version or hint (token=ver:1-hint:1233-realToken...).\n    const CONNECTION_TOKEN_PATTERN = new RegExp(String.raw `(token|assertion content)([\\'\\\"\\s:=]+)([a-z0-9=/:_\\%\\-\\+]{8,})`, 'gi');\n    const PASSWORD_PATTERN = new RegExp(String.raw `(password|pwd)([\\'\\\"\\s:=]+)([a-z0-9!\\\"#\\$%&\\\\\\'\\(\\)\\*\\+\\,-\\./:;<=>\\?\\@\\[\\]\\^_` +\n        '`' +\n        String.raw `\\{\\|\\}~]{8,})`, 'gi');\n    const PASSCODE_PATTERN = new RegExp(String.raw `(passcode|otp|pin|otac)\\s*([:=])\\s*([0-9]{4,6})`, 'gi');\n    const OAUTH_CLIENT_SECRET_PATTERN = new RegExp(String.raw `(oauthClientId|oauthClientSecret|clientSecret)([\\'\\\"\\s:=]+)([a-z0-9!\\\"#\\$%&\\\\\\'\\(\\)\\*\\+\\,-\\./:;<=>\\?\\@\\[\\]\\^_` +\n        '`' +\n        String.raw `\\{\\|\\}~]{8,})`, 'gi');\n    function maskAwsKeys(text) {\n        return text.replace(AWS_KEY_PATTERN, String.raw `$1$2****`);\n    }\n    function maskAwsToken(text) {\n        return text.replace(AWS_TOKEN_PATTERN, String.raw `$1\":\"XXXX\"`);\n    }\n    function maskSasToken(text) {\n        return text.replace(SAS_TOKEN_PATTERN, String.raw `$1=****`);\n    }\n    function maskPrivateKey(text) {\n        return text.replace(PRIVATE_KEY_PATTERN, String.raw `-----BEGIN PRIVATE KEY-----\\\\\\\\nXXXX\\\\\\\\n-----END PRIVATE KEY-----`); // pragma: allowlist secret\n    }\n    function maskPrivateKeyData(text) {\n        return text.replace(PRIVATE_KEY_DATA_PATTERN, String.raw `\"privateKeyData\": \"XXXX\"`);\n    }\n    function maskConnectionToken(text) {\n        return text.replace(CONNECTION_TOKEN_PATTERN, String.raw `$1$2****`);\n    }\n    function maskPassword(text) {\n        return text.replace(PASSWORD_PATTERN, String.raw `$1$2****`);\n    }\n    function maskPasscode(text) {\n        return text.replace(PASSCODE_PATTERN, String.raw `$1$2****`);\n    }\n    function maskClientSecret(text) {\n        return text.replace(OAUTH_CLIENT_SECRET_PATTERN, String.raw `$1$2****`);\n    }\n    /**\n     * Masks any secrets.\n     *\n     * @param {String} text may contain a secret.\n     *\n     * @returns {Object} the masked string.\n     */\n    this.maskSecrets = function (text) {\n        let result;\n        if (!text) {\n            result = {\n                masked: false,\n                maskedtxt: text,\n                errstr: null,\n            };\n            return result;\n        }\n        let masked = false;\n        let maskedtxt = '';\n        let errstr = null;\n        try {\n            if (mock) {\n                mock.execute();\n            }\n            maskedtxt = maskClientSecret(maskPasscode(maskConnectionToken(maskPassword(maskPrivateKeyData(maskPrivateKey(maskAwsToken(maskSasToken(maskAwsKeys(text)))))))));\n            if (CUSTOM_PATTERNS_LENGTH > 0) {\n                maskedtxt = maskCustomPattern(maskedtxt);\n            }\n            if (maskedtxt !== text) {\n                masked = true;\n            }\n        }\n        catch (err) {\n            masked = true;\n            maskedtxt = err.toString();\n            errstr = err.toString();\n        }\n        result = {\n            masked: masked,\n            maskedtxt: maskedtxt,\n            errstr: errstr,\n        };\n        return result;\n    };\n}\nmodule.exports = SecretDetector;\n//# sourceMappingURL=secret_detector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZWNyZXRfZGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVELHFEQUFxRCw0QkFBNEI7QUFDakYsb0RBQW9ELDJCQUEyQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsSUFBSSxFQUFFLElBQUk7QUFDcEgsOEhBQThILElBQUk7QUFDbEkscUdBQXFHLElBQUk7QUFDekc7QUFDQSwrRkFBK0YsSUFBSTtBQUNuRywyQ0FBMkMsR0FBRztBQUM5QztBQUNBLHNIQUFzSCxHQUFHO0FBQ3pILG1IQUFtSDtBQUNuSDtBQUNBLHNCQUFzQixJQUFJLEdBQUcsR0FBRztBQUNoQyw4RkFBOEYsSUFBSTtBQUNsRyw4SkFBOEo7QUFDOUo7QUFDQSxzQkFBc0IsSUFBSSxHQUFHLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZWNyZXRfZGV0ZWN0b3IuanM/ZmRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhlIHNlY3JldCBkZXRlY3RvciBkZXRlY3RzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbi5cbiAqIEl0IG1hc2tzIHNlY3JldHMgdGhhdCBtaWdodCBiZSBsZWFrZWQgZnJvbSB0d28gcG90ZW50aWFsIGF2ZW51ZXNcbiAqICAxLiBPdXQgb2YgQmFuZCBUZWxlbWV0cnlcbiAqICAyLiBMb2dnaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhdHRlcm5zIGNvbnRhaW5zICdyZWdleCcgYW5kICdtYXNrJyBmb3IgY3VzdG9taXplZCBtYXNraW5nXG4gKiBAcGFyYW0ge09iamVjdH0gbW9ja1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2VjcmV0RGV0ZWN0b3IoY3VzdG9tUGF0dGVybnMsIG1vY2spIHtcbiAgICBjb25zdCBDVVNUT01fUEFUVEVSTlNfUkVHRVggPSBbXTtcbiAgICBjb25zdCBDVVNUT01fUEFUVEVSTlNfTUFTSyA9IFtdO1xuICAgIGxldCBDVVNUT01fUEFUVEVSTlNfTEVOR1RIO1xuICAgIGlmIChjdXN0b21QYXR0ZXJucykge1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBjdXN0b21QYXR0ZXJucyBvYmplY3QgY29udGFpbnMgdGhlIGtleXMgJ3JlZ2V4JyBhbmQgJ21hc2tcbiAgICAgICAgaWYgKCFjdXN0b21QYXR0ZXJucy5yZWdleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1c3RvbVBhdHRlcm5zIG9iamVjdCBtdXN0IGNvbnRhaW4gdGhlICdyZWdleCcga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VzdG9tUGF0dGVybnMubWFzaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1c3RvbVBhdHRlcm5zIG9iamVjdCBtdXN0IGNvbnRhaW4gdGhlICdtYXNrJyBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxzbyBjaGVjayB0aGF0IHRoZWlyIGxlbmd0aHMgYXJlIGVxdWFsXG4gICAgICAgIGlmIChjdXN0b21QYXR0ZXJucy5yZWdleC5sZW5ndGggIT09IGN1c3RvbVBhdHRlcm5zLm1hc2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VzdG9tUGF0dGVybnMgb2JqZWN0IG11c3QgaGF2ZSBlcXVhbCBsZW5ndGggZm9yIGJvdGggJ3JlZ2V4JyBhbmQgJ21hc2snXCIpO1xuICAgICAgICB9XG4gICAgICAgIENVU1RPTV9QQVRURVJOU19MRU5HVEggPSBjdXN0b21QYXR0ZXJucy5yZWdleC5sZW5ndGg7XG4gICAgICAgIC8vIFB1c2ggdGhlIHJlZ2V4IGFuZCBtYXNrIGVsZW1lbnRzIG9udG8gdGhlaXIgcmVzcGVjdGl2ZSBhcnJheXNcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IENVU1RPTV9QQVRURVJOU19MRU5HVEg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIENVU1RPTV9QQVRURVJOU19SRUdFWC5wdXNoKG5ldyBSZWdFeHAoYCR7Y3VzdG9tUGF0dGVybnMucmVnZXhbaW5kZXhdfWAsICdnaScpKTtcbiAgICAgICAgICAgIENVU1RPTV9QQVRURVJOU19NQVNLLnB1c2goU3RyaW5nLnJhdyBgJHtjdXN0b21QYXR0ZXJucy5tYXNrW2luZGV4XX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNrQ3VzdG9tUGF0dGVybih0ZXh0KSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBDVVNUT01fUEFUVEVSTlNfTEVOR1RIOyBpbmRleCsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZXh0LnJlcGxhY2UoQ1VTVE9NX1BBVFRFUk5TX1JFR0VYW2luZGV4XSwgQ1VTVE9NX1BBVFRFUk5TX01BU0tbaW5kZXhdKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0ZXh0IGlzIHJlcGxhY2VkLCByZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKHRleHQgIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGV4dCBpcyB1bmNoYW5nZWQsIHJldHVybiB0aGUgb3JpZ2luYWxcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvbnN0IEFXU19LRVlfUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhdyBgKGF3c19rZXlfaWR8YXdzX3NlY3JldF9rZXl8YWNjZXNzX2tleV9pZHxzZWNyZXRfYWNjZXNzX2tleSlcXHMqPVxccyonKFteJ10rKSdgLCAnZ2knKTtcbiAgICBjb25zdCBBV1NfVE9LRU5fUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhdyBgKGFjY2Vzc1Rva2VufHRlbXBUb2tlbnxrZXlTZWNyZXQpXFxzKjpcXHMqXCIoW2EtejAtOS8rXXszMix9PXswLDJ9KVwiYCwgJ2dpJyk7XG4gICAgY29uc3QgU0FTX1RPS0VOX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYChzaWd8c2lnbmF0dXJlfEFXU0FjY2Vzc0tleUlkfHBhc3N3b3JkfHBhc3Njb2RlKT0oXFw/UDxzZWNyZXQ+W2EtejAtOSUvK117MTYsfSlgLCAnZ2knKTtcbiAgICBjb25zdCBQUklWQVRFX0tFWV9QQVRURVJOID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXFxcbihbYS16MC05Lys9XFxcXG5dezMyLH0pXFxcXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYCwgLy8gcHJhZ21hOiBhbGxvd2xpc3Qgc2VjcmV0XG4gICAgJ2dpbScpO1xuICAgIGNvbnN0IFBSSVZBVEVfS0VZX0RBVEFfUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhdyBgXCJwcml2YXRlS2V5RGF0YVwiOiBcIihbYS16MC05Lys9XFxcXG5dezEwLH0pXCJgLCAnZ2ltJyk7XG4gICAgLy8gQ29sb24gaW4gdGhlIGdyb3VwIChbYS16MC05PS86XyUtK117OCx9KSB3YXMgYWRkZWQgdG8gZGV0ZWN0IHRva2VucyB0aGF0IGNvbnRhaW4gYWRkaXRpb25hbCBkZXRhaWxzIGJlZm9yZSB0aGUgYWN0dWFsIHRva2VuLlxuICAgIC8vIFN1Y2ggYXMgdmVyc2lvbiBvciBoaW50ICh0b2tlbj12ZXI6MS1oaW50OjEyMzMtcmVhbFRva2VuLi4uKS5cbiAgICBjb25zdCBDT05ORUNUSU9OX1RPS0VOX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYCh0b2tlbnxhc3NlcnRpb24gY29udGVudCkoW1xcJ1xcXCJcXHM6PV0rKShbYS16MC05PS86X1xcJVxcLVxcK117OCx9KWAsICdnaScpO1xuICAgIGNvbnN0IFBBU1NXT1JEX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYChwYXNzd29yZHxwd2QpKFtcXCdcXFwiXFxzOj1dKykoW2EtejAtOSFcXFwiI1xcJCUmXFxcXFxcJ1xcKFxcKVxcKlxcK1xcLC1cXC4vOjs8PT5cXD9cXEBcXFtcXF1cXF5fYCArXG4gICAgICAgICdgJyArXG4gICAgICAgIFN0cmluZy5yYXcgYFxce1xcfFxcfX5dezgsfSlgLCAnZ2knKTtcbiAgICBjb25zdCBQQVNTQ09ERV9QQVRURVJOID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3IGAocGFzc2NvZGV8b3RwfHBpbnxvdGFjKVxccyooWzo9XSlcXHMqKFswLTldezQsNn0pYCwgJ2dpJyk7XG4gICAgY29uc3QgT0FVVEhfQ0xJRU5UX1NFQ1JFVF9QQVRURVJOID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3IGAob2F1dGhDbGllbnRJZHxvYXV0aENsaWVudFNlY3JldHxjbGllbnRTZWNyZXQpKFtcXCdcXFwiXFxzOj1dKykoW2EtejAtOSFcXFwiI1xcJCUmXFxcXFxcJ1xcKFxcKVxcKlxcK1xcLC1cXC4vOjs8PT5cXD9cXEBcXFtcXF1cXF5fYCArXG4gICAgICAgICdgJyArXG4gICAgICAgIFN0cmluZy5yYXcgYFxce1xcfFxcfX5dezgsfSlgLCAnZ2knKTtcbiAgICBmdW5jdGlvbiBtYXNrQXdzS2V5cyh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoQVdTX0tFWV9QQVRURVJOLCBTdHJpbmcucmF3IGAkMSQyKioqKmApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNrQXdzVG9rZW4odGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKEFXU19UT0tFTl9QQVRURVJOLCBTdHJpbmcucmF3IGAkMVwiOlwiWFhYWFwiYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hc2tTYXNUb2tlbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoU0FTX1RPS0VOX1BBVFRFUk4sIFN0cmluZy5yYXcgYCQxPSoqKipgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFza1ByaXZhdGVLZXkodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFBSSVZBVEVfS0VZX1BBVFRFUk4sIFN0cmluZy5yYXcgYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcXFxcXFxcblhYWFhcXFxcXFxcXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYCk7IC8vIHByYWdtYTogYWxsb3dsaXN0IHNlY3JldFxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNrUHJpdmF0ZUtleURhdGEodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFBSSVZBVEVfS0VZX0RBVEFfUEFUVEVSTiwgU3RyaW5nLnJhdyBgXCJwcml2YXRlS2V5RGF0YVwiOiBcIlhYWFhcImApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNrQ29ubmVjdGlvblRva2VuKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShDT05ORUNUSU9OX1RPS0VOX1BBVFRFUk4sIFN0cmluZy5yYXcgYCQxJDIqKioqYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hc2tQYXNzd29yZCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoUEFTU1dPUkRfUEFUVEVSTiwgU3RyaW5nLnJhdyBgJDEkMioqKipgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFza1Bhc3Njb2RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShQQVNTQ09ERV9QQVRURVJOLCBTdHJpbmcucmF3IGAkMSQyKioqKmApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNrQ2xpZW50U2VjcmV0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShPQVVUSF9DTElFTlRfU0VDUkVUX1BBVFRFUk4sIFN0cmluZy5yYXcgYCQxJDIqKioqYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hc2tzIGFueSBzZWNyZXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgbWF5IGNvbnRhaW4gYSBzZWNyZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgbWFza2VkIHN0cmluZy5cbiAgICAgKi9cbiAgICB0aGlzLm1hc2tTZWNyZXRzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbWFza2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYXNrZWR0eHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgZXJyc3RyOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hc2tlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgbWFza2VkdHh0ID0gJyc7XG4gICAgICAgIGxldCBlcnJzdHIgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG1vY2spIHtcbiAgICAgICAgICAgICAgICBtb2NrLmV4ZWN1dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc2tlZHR4dCA9IG1hc2tDbGllbnRTZWNyZXQobWFza1Bhc3Njb2RlKG1hc2tDb25uZWN0aW9uVG9rZW4obWFza1Bhc3N3b3JkKG1hc2tQcml2YXRlS2V5RGF0YShtYXNrUHJpdmF0ZUtleShtYXNrQXdzVG9rZW4obWFza1Nhc1Rva2VuKG1hc2tBd3NLZXlzKHRleHQpKSkpKSkpKSk7XG4gICAgICAgICAgICBpZiAoQ1VTVE9NX1BBVFRFUk5TX0xFTkdUSCA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXNrZWR0eHQgPSBtYXNrQ3VzdG9tUGF0dGVybihtYXNrZWR0eHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hc2tlZHR4dCAhPT0gdGV4dCkge1xuICAgICAgICAgICAgICAgIG1hc2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbWFza2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hc2tlZHR4dCA9IGVyci50b1N0cmluZygpO1xuICAgICAgICAgICAgZXJyc3RyID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbWFza2VkOiBtYXNrZWQsXG4gICAgICAgICAgICBtYXNrZWR0eHQ6IG1hc2tlZHR4dCxcbiAgICAgICAgICAgIGVycnN0cjogZXJyc3RyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNlY3JldERldGVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcmV0X2RldGVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/secret_detector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst ErrorCodes = Errors.codes;\n/**\n * Creates a new instance of an LargeResultSetService.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @constructor\n */\nfunction LargeResultSetService(connectionConfig, httpClient) {\n    // validate input\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    Errors.assertInternal(Util.isObject(httpClient));\n    /**\n     * Should HTTP client error be retried\n     * @param err Client error or null/undefined\n     * @return {boolean}\n     */\n    function isRetryableClientError(err) {\n        return (err &&\n            (err.code === 'ECONNRESET' ||\n                err.code === 'ETIMEDOUT' ||\n                // error code ECONNABORTED is thrown from axios on timeout\n                (err.name === 'AxiosError' && err.code === 'ECONNABORTED')));\n    }\n    function isRetryableError(response, err) {\n        // https://aws.amazon.com/articles/1904 (Handling Errors)\n        // Note: 403's are retried because of a bug in S3/Blob\n        return Util.isRetryableHttpError(response, true) || isRetryableClientError(err);\n    }\n    function isUnsuccessfulResponse(response) {\n        // even for 200 OK S3 can return xml error (large files are normally binary)\n        return (response &&\n            (response.statusCode !== 200 ||\n                response.getResponseHeader('Content-Type') === 'application/xml'));\n    }\n    /**\n     * Issues a request to get an object from S3/Blob.\n     *\n     * @param {Object} options\n     */\n    this.getObject = function getObject(options) {\n        let numRetries = 0, sleep = 1;\n        // get the maximum number of retries\n        let maxNumRetries = options.maxNumRetries;\n        if (!Util.exists(maxNumRetries)) {\n            maxNumRetries = connectionConfig.getRetryLargeResultSetMaxNumRetries();\n        }\n        Errors.assertInternal(Util.isNumber(maxNumRetries) && maxNumRetries >= 0);\n        // invoked when the request completes\n        const callback = function callback(err, response, body) {\n            // err happens on timeouts and response is passed when server responded\n            if (err || isUnsuccessfulResponse(response)) {\n                // if we're running in DEBUG loglevel, probably we want to see the full error too\n                const logErr = err\n                    ? JSON.stringify(err, Object.getOwnPropertyNames(err))\n                    : `status: ${JSON.stringify(response.status)} ${JSON.stringify(response.statusText)}` +\n                        ` headers: ${JSON.stringify(response.headers)}`;\n                Logger.getInstance().debug('Encountered an error when getting data from cloud storage: ' + logErr);\n                // if we haven't exceeded the maximum number of retries yet and the\n                // server came back with a retryable error code.\n                if (numRetries < maxNumRetries && isRetryableError(response, err)) {\n                    // increment the number of retries\n                    numRetries++;\n                    // use exponential backoff with decorrelated jitter to compute the\n                    // next sleep time:\n                    const cap = connectionConfig.getRetryLargeResultSetMaxSleepTime();\n                    sleep = Util.nextSleepTime(1, cap, sleep);\n                    // wait the appropriate amount of time before retrying the request\n                    const nextSendRequestWaitTimeMs = sleep * 1000;\n                    Logger.getInstance().trace('Request will be retried after %d milliseconds', Math.floor(nextSendRequestWaitTimeMs));\n                    setTimeout(sendRequest, nextSendRequestWaitTimeMs);\n                    return;\n                }\n                else {\n                    Logger.getInstance().trace(\"Request won't be retried\");\n                    if (isUnsuccessfulResponse(response)) {\n                        err = Errors.createLargeResultSetError(ErrorCodes.ERR_LARGE_RESULT_SET_RESPONSE_FAILURE, response);\n                    }\n                    else {\n                        err = Errors.createNetworkError(ErrorCodes.ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT, err);\n                    }\n                }\n            }\n            if (response) {\n                Logger.getInstance().trace(`Response headers are: ${JSON.stringify(response.headers)}`);\n            }\n            // if we have an error, clear the body\n            if (err) {\n                body = null;\n            }\n            // if a callback was specified, invoke it\n            if (Util.isFunction(options.callback)) {\n                try {\n                    options.callback(err, body);\n                }\n                catch (e) {\n                    Logger.getInstance().error(`Callback failed with ${e}`);\n                }\n            }\n        };\n        const sendRequest = function sendRequest() {\n            // issue a request to get the object from S3/Blob\n            httpClient.request({\n                method: 'GET',\n                url: options.url,\n                headers: options.headers,\n                gzip: true, // gunzip the response\n                appendRequestId: false,\n                callback,\n            });\n        };\n        sendRequest();\n    };\n}\nUtil.inherits(LargeResultSetService, EventEmitter);\nmodule.exports = LargeResultSetService;\n//# sourceMappingURL=large_result_set.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZXJ2aWNlcy9sYXJnZV9yZXN1bHRfc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscUJBQXFCLDBEQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQyxFQUFFLG9DQUFvQztBQUN4RyxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxpQ0FBaUM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvc2VydmljZXMvbGFyZ2VfcmVzdWx0X3NldC5qcz82ODg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIExhcmdlUmVzdWx0U2V0U2VydmljZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IGh0dHBDbGllbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMYXJnZVJlc3VsdFNldFNlcnZpY2UoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCkge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29ubmVjdGlvbkNvbmZpZykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGh0dHBDbGllbnQpKTtcbiAgICAvKipcbiAgICAgKiBTaG91bGQgSFRUUCBjbGllbnQgZXJyb3IgYmUgcmV0cmllZFxuICAgICAqIEBwYXJhbSBlcnIgQ2xpZW50IGVycm9yIG9yIG51bGwvdW5kZWZpbmVkXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JldHJ5YWJsZUNsaWVudEVycm9yKGVycikge1xuICAgICAgICByZXR1cm4gKGVyciAmJlxuICAgICAgICAgICAgKGVyci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHxcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9PT0gJ0VUSU1FRE9VVCcgfHxcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBjb2RlIEVDT05OQUJPUlRFRCBpcyB0aHJvd24gZnJvbSBheGlvcyBvbiB0aW1lb3V0XG4gICAgICAgICAgICAgICAgKGVyci5uYW1lID09PSAnQXhpb3NFcnJvcicgJiYgZXJyLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JldHJ5YWJsZUVycm9yKHJlc3BvbnNlLCBlcnIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9hcnRpY2xlcy8xOTA0IChIYW5kbGluZyBFcnJvcnMpXG4gICAgICAgIC8vIE5vdGU6IDQwMydzIGFyZSByZXRyaWVkIGJlY2F1c2Ugb2YgYSBidWcgaW4gUzMvQmxvYlxuICAgICAgICByZXR1cm4gVXRpbC5pc1JldHJ5YWJsZUh0dHBFcnJvcihyZXNwb25zZSwgdHJ1ZSkgfHwgaXNSZXRyeWFibGVDbGllbnRFcnJvcihlcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1Vuc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIGV2ZW4gZm9yIDIwMCBPSyBTMyBjYW4gcmV0dXJuIHhtbCBlcnJvciAobGFyZ2UgZmlsZXMgYXJlIG5vcm1hbGx5IGJpbmFyeSlcbiAgICAgICAgcmV0dXJuIChyZXNwb25zZSAmJlxuICAgICAgICAgICAgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCB8fFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSA9PT0gJ2FwcGxpY2F0aW9uL3htbCcpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXNzdWVzIGEgcmVxdWVzdCB0byBnZXQgYW4gb2JqZWN0IGZyb20gUzMvQmxvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5nZXRPYmplY3QgPSBmdW5jdGlvbiBnZXRPYmplY3Qob3B0aW9ucykge1xuICAgICAgICBsZXQgbnVtUmV0cmllcyA9IDAsIHNsZWVwID0gMTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzXG4gICAgICAgIGxldCBtYXhOdW1SZXRyaWVzID0gb3B0aW9ucy5tYXhOdW1SZXRyaWVzO1xuICAgICAgICBpZiAoIVV0aWwuZXhpc3RzKG1heE51bVJldHJpZXMpKSB7XG4gICAgICAgICAgICBtYXhOdW1SZXRyaWVzID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeUxhcmdlUmVzdWx0U2V0TWF4TnVtUmV0cmllcygpO1xuICAgICAgICB9XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzTnVtYmVyKG1heE51bVJldHJpZXMpICYmIG1heE51bVJldHJpZXMgPj0gMCk7XG4gICAgICAgIC8vIGludm9rZWQgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZXNcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgICAgICAgICAvLyBlcnIgaGFwcGVucyBvbiB0aW1lb3V0cyBhbmQgcmVzcG9uc2UgaXMgcGFzc2VkIHdoZW4gc2VydmVyIHJlc3BvbmRlZFxuICAgICAgICAgICAgaWYgKGVyciB8fCBpc1Vuc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gREVCVUcgbG9nbGV2ZWwsIHByb2JhYmx5IHdlIHdhbnQgdG8gc2VlIHRoZSBmdWxsIGVycm9yIHRvb1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0VyciA9IGVyclxuICAgICAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGVyciwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyKSlcbiAgICAgICAgICAgICAgICAgICAgOiBgc3RhdHVzOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLnN0YXR1cyl9ICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2Uuc3RhdHVzVGV4dCl9YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgIGhlYWRlcnM6ICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuaGVhZGVycyl9YDtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRW5jb3VudGVyZWQgYW4gZXJyb3Igd2hlbiBnZXR0aW5nIGRhdGEgZnJvbSBjbG91ZCBzdG9yYWdlOiAnICsgbG9nRXJyKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IGV4Y2VlZGVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIHlldCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VydmVyIGNhbWUgYmFjayB3aXRoIGEgcmV0cnlhYmxlIGVycm9yIGNvZGUuXG4gICAgICAgICAgICAgICAgaWYgKG51bVJldHJpZXMgPCBtYXhOdW1SZXRyaWVzICYmIGlzUmV0cnlhYmxlRXJyb3IocmVzcG9uc2UsIGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBudW1iZXIgb2YgcmV0cmllc1xuICAgICAgICAgICAgICAgICAgICBudW1SZXRyaWVzKys7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBleHBvbmVudGlhbCBiYWNrb2ZmIHdpdGggZGVjb3JyZWxhdGVkIGppdHRlciB0byBjb21wdXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IHNsZWVwIHRpbWU6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlMYXJnZVJlc3VsdFNldE1heFNsZWVwVGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBzbGVlcCA9IFV0aWwubmV4dFNsZWVwVGltZSgxLCBjYXAsIHNsZWVwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCB0aGUgYXBwcm9wcmlhdGUgYW1vdW50IG9mIHRpbWUgYmVmb3JlIHJldHJ5aW5nIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTZW5kUmVxdWVzdFdhaXRUaW1lTXMgPSBzbGVlcCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0IHdpbGwgYmUgcmV0cmllZCBhZnRlciAlZCBtaWxsaXNlY29uZHMnLCBNYXRoLmZsb29yKG5leHRTZW5kUmVxdWVzdFdhaXRUaW1lTXMpKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChzZW5kUmVxdWVzdCwgbmV4dFNlbmRSZXF1ZXN0V2FpdFRpbWVNcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKFwiUmVxdWVzdCB3b24ndCBiZSByZXRyaWVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVMYXJnZVJlc3VsdFNldEVycm9yKEVycm9yQ29kZXMuRVJSX0xBUkdFX1JFU1VMVF9TRVRfUkVTUE9OU0VfRkFJTFVSRSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZU5ldHdvcmtFcnJvcihFcnJvckNvZGVzLkVSUl9MQVJHRV9SRVNVTFRfU0VUX05FVFdPUktfQ09VTERfTk9UX0NPTk5FQ1QsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUmVzcG9uc2UgaGVhZGVycyBhcmU6ICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuaGVhZGVycyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFuIGVycm9yLCBjbGVhciB0aGUgYm9keVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBpbnZva2UgaXRcbiAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24ob3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVyciwgYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGBDYWxsYmFjayBmYWlsZWQgd2l0aCAke2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KCkge1xuICAgICAgICAgICAgLy8gaXNzdWUgYSByZXF1ZXN0IHRvIGdldCB0aGUgb2JqZWN0IGZyb20gUzMvQmxvYlxuICAgICAgICAgICAgaHR0cENsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGd6aXA6IHRydWUsIC8vIGd1bnppcCB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBhcHBlbmRSZXF1ZXN0SWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbmRSZXF1ZXN0KCk7XG4gICAgfTtcbn1cblV0aWwuaW5oZXJpdHMoTGFyZ2VSZXN1bHRTZXRTZXJ2aWNlLCBFdmVudEVtaXR0ZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBMYXJnZVJlc3VsdFNldFNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXJnZV9yZXN1bHRfc2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/services/sf.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/services/sf.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*\n  SnowflakeService state machine\n\n  Preconnected - enter()      - Preconnected\n               - connect()    - Connecting\n               - request()    - Connecting\n               - destroy()    - Preconnected\n\n  Connecting   - enter()      - async operation\n                                - Connected if operation succeeds\n                                - Disconnected if network error (we need another PreConnected state)\n                                - Disconnected if operation fails\n                 connect()    - error\n                 request()    - enqueue\n                 destroy()    - enqueue\n\n  Connected    - enter()      - Connected\n                 connect()    - error\n                 request()    - async operation\n                                - Connected if operation succeeds\n                                - Connected if network error\n                                - Renewing if GS says session token has expired\n                                - Disconnected if GS says session token is invalid\n                 destroy()    - async operation\n                              - Disconnected if operation succeeds\n                              - Connected if network error\n                              - Connected if operation fails\n\n  Renewing     - enter()      - async operation\n                                - Connected if operation succeeds\n                                - Connected if network error\n                                - Disconnected if operation fails\n               - connect()    - error\n               - request()    - enqueue\n               - destroy()    - enqueue\n\n  Disconnected - enter()      - Disconnected\n               - connect()    - Disconnected\n               - request()    - Disconnected\n               - destroy()    - Disconnected\n */\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst GSErrors = __webpack_require__(/*! ../constants/gs_errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js\");\nconst QueryContextCache = __webpack_require__(/*! ../queryContextCache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/queryContextCache.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst AuthOkta = __webpack_require__(/*! ../authentication/auth_okta */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js\");\nconst AuthKeypair = __webpack_require__(/*! ../authentication/auth_keypair */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js\");\nconst AuthIDToken = __webpack_require__(/*! ../authentication/auth_idtoken */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js\");\nconst Authenticator = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\");\nconst AuthOauthAuthorizationCode = __webpack_require__(/*! ../authentication/auth_oauth_authorization_code */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js\");\nconst sfParams = __webpack_require__(/*! ../constants/sf_params */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js\");\nfunction isRetryableNetworkError(err) {\n    // anything other than REVOKED error can be retryable.\n    return (!Object.prototype.hasOwnProperty.call(err, 'cause') ||\n        err.cause === undefined ||\n        !Object.prototype.hasOwnProperty.call(err.cause, 'code') ||\n        (err.cause.code !== ErrorCodes.ERR_OCSP_REVOKED &&\n            err.cause.code !== 'DEPTH_ZERO_SELF_SIGNED_CERT' &&\n            err.cause.code !== 'CERT_HAS_EXPIRED' &&\n            err.cause.code !== 'UNABLE_TO_VERIFY_LEAF_SIGNATURE' &&\n            err.cause.code !== 'SELF_SIGNED_CERT_IN_CHAIN' &&\n            err.cause.code !== ErrorCodes.ERR_CRL_ERROR));\n}\nfunction isRetryableHttpError(err) {\n    return (Object.prototype.hasOwnProperty.call(err, 'response') &&\n        Util.isRetryableHttpError(err.response, false));\n}\n/**\n * Creates a new SnowflakeService instance.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {Object} [config]\n * @constructor\n */\nfunction SnowflakeService(connectionConfig, httpClient, config) {\n    // validate input\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    Errors.assertInternal(Util.isObject(httpClient));\n    Errors.assertInternal(!Util.exists(config) || Util.isObject(config));\n    // if a config object was specified, verify\n    // that it has all the information we need\n    let tokenInfoConfig;\n    if (Util.exists(config)) {\n        Errors.assertInternal(Util.isObject(config));\n        Errors.assertInternal(Util.isObject(config.tokenInfo));\n        tokenInfoConfig = config.tokenInfo;\n    }\n    else if (connectionConfig.sessionToken) {\n        tokenInfoConfig = {\n            sessionToken: connectionConfig.sessionToken,\n            masterToken: connectionConfig.masterToken || connectionConfig.sessionToken,\n            sessionTokenExpirationTime: connectionConfig.sessionTokenExpirationTime || Date.now() + 1000 * 60 * 60 * 24,\n            masterTokenExpirationTime: connectionConfig.masterTokenExpirationTime || Date.now() + 1000 * 60 * 60 * 24,\n        };\n    }\n    // create a new TokenInfo instance\n    const tokenInfo = new TokenInfo(tokenInfoConfig);\n    try {\n        Logger.getInstance().debug('Retrieving authenticator');\n        this.authenticator = Authenticator.getAuthenticator(connectionConfig, httpClient);\n    }\n    catch (error) {\n        const message = `Failed to initialize authenticator: ${error}`;\n        Logger.getInstance().error(message);\n        throw Errors.createClientError(ErrorCodes.ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED, true, message);\n    }\n    // create state objects for all the different states we can be in\n    const stateOptions = {\n        snowflakeService: this,\n        httpClient: httpClient,\n        connectionConfig: connectionConfig,\n        tokenInfo: tokenInfo,\n    };\n    const statePristine = new StatePristine(stateOptions);\n    const stateConnecting = new StateConnecting(stateOptions);\n    const stateConnected = new StateConnected(stateOptions);\n    const stateRenewing = new StateRenewing(stateOptions);\n    const stateDisconnected = new StateDisconnected(stateOptions);\n    let currentState;\n    /**\n     * Transitions to a given state.\n     *\n     * @param {Object} state\n     * @param {Object} [transitionContext]\n     */\n    const transitionTo = function (state, transitionContext) {\n        // this check is necessary to make sure we don't re-enter a transient state\n        // like Renewing when we're already in it\n        if (currentState !== state) {\n            // if we have a current state, exit it; the null check is necessary\n            // because the currentState is undefined at bootstrap time when we\n            // transition to the first state\n            if (currentState) {\n                currentState.exit();\n            }\n            // update the current state\n            currentState = state;\n            // enter the new state\n            currentState.enter(transitionContext);\n        }\n    };\n    /**\n     * Set the session id for the current SnowflakeService\n     * @param sessionId\n     */\n    this.setSessionId = function (sessionId) {\n        this.sessionId = sessionId;\n    };\n    /**\n     * Get the session id.\n     * @returns {number}\n     */\n    this.getSessionId = function () {\n        return this.sessionId;\n    };\n    /**\n     * Transitions to the Pristine state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToPristine = function (transitionContext) {\n        transitionTo(statePristine, transitionContext);\n    };\n    /**\n     * Transitions to the Connecting state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToConnecting = function (transitionContext) {\n        transitionTo(stateConnecting, transitionContext);\n    };\n    /**\n     * Transitions to the Connected state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToConnected = function (transitionContext) {\n        transitionTo(stateConnected, transitionContext);\n    };\n    /**\n     * Transitions to the Renewing state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToRenewing = function (transitionContext) {\n        transitionTo(stateRenewing, transitionContext);\n    };\n    /**\n     * Transitions to the Disconnected state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToDisconnected = function (transitionContext) {\n        transitionTo(stateDisconnected, transitionContext);\n        // clear the tokens because we're in a fatal state and we don't want the\n        // tokens to be available via getConfig() anymore\n        tokenInfo.clearTokens();\n    };\n    /**\n     * Returns a configuration object that can be passed to the SnowflakeService\n     * constructor to get an equivalent SnowflakeService object.\n     *\n     * @returns {Object}\n     */\n    this.getConfig = function () {\n        return {\n            tokenInfo: tokenInfo.getConfig(),\n        };\n    };\n    /**\n     * Establishes a connection to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.connect = function (options) {\n        new OperationConnect(options).validate().execute();\n    };\n    /**\n     * Issues a connect-continue request to Snowflake.\n     *\n     * @param {Object} [options]\n     */\n    this.continue = function (options) {\n        new OperationContinue(options).validate().execute();\n    };\n    /**\n     * Issues a generic request to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.request = function (options) {\n        new OperationRequest(options).validate().execute();\n    };\n    /**\n     * Issues a generic async request to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.requestAsync = async function (options) {\n        return await new OperationRequest(options).validate().executeAsync();\n    };\n    /**\n     * Terminates the current connection to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.destroy = function (options) {\n        this.clearCache();\n        new OperationDestroy(options).validate().execute();\n    };\n    /**\n     * Creates a new OperationAbstract.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationAbstract(options) {\n        this.options = options;\n    }\n    /**\n     * Validates the operation options.\n     *\n     * @returns {Object} the operation.\n     */\n    OperationAbstract.prototype.validate = function () {\n        return this;\n    };\n    /**\n     * Executes the operation.\n     */\n    OperationAbstract.prototype.execute = function () { };\n    /**\n     * Creates a new OperationConnect.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationConnect(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationConnect, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationConnect.prototype.validate = function () {\n        // verify that the options object contains a callback function\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options) && Util.isFunction(options.callback));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationConnect.prototype.execute = function () {\n        currentState.connect(this.options);\n    };\n    /**\n     * Creates a new OperationContinue.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationContinue(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationContinue, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationContinue.prototype.validate = function () {\n        // verify that the options contain a json object\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options) && Util.isObject(options.json));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationContinue.prototype.execute = function () {\n        currentState.continue(this.options);\n    };\n    /**\n     * Creates a new OperationRequest.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationRequest(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationRequest, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationRequest.prototype.validate = function () {\n        // verify that the options object contains all the necessary information\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options));\n        Errors.assertInternal(Util.isString(options.method));\n        Errors.assertInternal(!Util.exists(options.headers) || Util.isObject(options.headers));\n        Errors.assertInternal(Util.isString(options.url));\n        Errors.assertInternal(!Util.exists(options.json) || Util.isObject(options.json));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationRequest.prototype.execute = function () {\n        currentState.request(this.options);\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationRequest.prototype.executeAsync = async function () {\n        return await currentState.requestAsync(this.options);\n    };\n    /**\n     * Creates a new OperationDestroy.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationDestroy(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationDestroy, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationDestroy.prototype.validate = function () {\n        // verify that the options object contains a callback function\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options) && Util.isFunction(options.callback));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationDestroy.prototype.execute = function () {\n        // delegate to current state\n        currentState.destroy(this.options);\n    };\n    /* All queued operations will be added to this array */\n    const operationQueue = [];\n    /**\n     * Appends a request operation to the queue.\n     *\n     * @param {Object} options\n     */\n    this.enqueueRequest = function (options) {\n        operationQueue.push(new OperationRequest(options));\n    };\n    /**\n     * Appends a destroy operation to the queue.\n     *\n     * @param {Object} options\n     */\n    this.enqueueDestroy = function (options) {\n        operationQueue.push(new OperationDestroy(options));\n    };\n    /**\n     * Executes all the operations in the queue.\n     */\n    this.drainOperationQueue = function () {\n        // execute all the operations in the queue\n        for (let index = 0, length = operationQueue.length; index < length; index++) {\n            operationQueue[index].execute();\n        }\n        // empty the queue\n        operationQueue.length = 0;\n    };\n    this.isConnected = function () {\n        return (currentState === stateConnected ||\n            currentState === stateConnecting ||\n            currentState === stateRenewing);\n    };\n    this.getServiceName = function () {\n        return Parameters.getValue(Parameters.names.SERVICE_NAME);\n    };\n    this.getClientSessionKeepAlive = function () {\n        return Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE);\n    };\n    this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n        return Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY);\n    };\n    this.getJsTreatIntegerAsBigInt = function () {\n        return Parameters.getValue(Parameters.names.JS_TREAT_INTEGER_AS_BIGINT);\n    };\n    this.getAuthenticator = function () {\n        return this.authenticator;\n    };\n    // if we don't have any tokens, start out as pristine\n    if (tokenInfo.isEmpty()) {\n        this.transitionToPristine();\n    }\n    else {\n        // we're already connected\n        this.transitionToConnected();\n    }\n    /**\n     * Issues a post request to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.postAsync = function (options) {\n        return new OperationRequest(options).validate().executeAsync();\n    };\n    this.getQueryContextDTO = function () {\n        if (!this.qcc) {\n            return;\n        }\n        return this.qcc.getQueryContextDTO();\n    };\n    this.deserializeQueryContext = function (data) {\n        if (!this.qcc) {\n            return;\n        }\n        this.qcc.deserializeQueryContext(data);\n    };\n    this.clearCache = function () {\n        if (!this.qcc) {\n            return;\n        }\n        this.qcc.clearCache();\n    };\n    this.initializeQueryContextCache = function (size) {\n        if (!connectionConfig.getDisableQueryContextCache()) {\n            this.qcc = new QueryContextCache(size, this.getSessionId());\n        }\n        else {\n            Logger.getInstance().debug(`QueryContextCache initialization skipped as it is disabled for connection with sessionId: ${this.sessionId}`);\n        }\n    };\n    // testing purpose\n    this.getQueryContextCacheSize = function () {\n        if (!this.qcc) {\n            return;\n        }\n        return this.qcc.getSize();\n    };\n}\nUtil.inherits(SnowflakeService, EventEmitter);\nmodule.exports = SnowflakeService;\n///////////////////////////////////////////////////////////////////////////\n////                StateAbstract                                      ////\n///////////////////////////////////////////////////////////////////////////\n/**\n * Creates a new StateAbstract instance.\n *\n * @param {Object} options\n * @constructor\n */\nfunction StateAbstract(options) {\n    /**\n     * Issues an http request to Snowflake.\n     *\n     * @param {Object} requestOptions\n     * @param {Object} httpClient\n     * @param {Object} auth\n     * @returns {Object} the http request object.\n     */\n    function sendHttpRequest(requestOptions, httpClient, auth) {\n        const params = requestOptions.params || {};\n        if (!requestOptions.excludeGuid) {\n            addGuidToParams(params);\n        }\n        const realRequestOptions = {\n            method: requestOptions.method,\n            headers: requestOptions.headers,\n            url: requestOptions.absoluteUrl,\n            gzip: requestOptions.gzip,\n            json: requestOptions.json,\n            params: params,\n            callback: async function (err, response, body) {\n                // if we got an error, wrap it into a network error\n                if (err) {\n                    // if we're running in DEBUG loglevel, probably we want to see the full error instead\n                    Logger.getInstance().debug('Encountered an error when sending the request. Details: ' +\n                        JSON.stringify(err, Object.getOwnPropertyNames(err)));\n                    err = Errors.createNetworkError(ErrorCodes.ERR_SF_NETWORK_COULD_NOT_CONNECT, err);\n                }\n                else if (!response) {\n                    // empty response\n                    err = Errors.createUnexpectedContentError(ErrorCodes.ERR_SF_RESPONSE_NOT_JSON, '(EMPTY)');\n                }\n                else if (Object.prototype.hasOwnProperty.call(response, 'statusCode') &&\n                    response.statusCode !== 200) {\n                    // if we didn't get a 200, the request failed\n                    if (response.statusCode === 401 && response.body) {\n                        let innerCode;\n                        try {\n                            innerCode = JSON.parse(response.body).code;\n                        }\n                        catch (e) {\n                            err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                            Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                        }\n                        if (innerCode === '390104') {\n                            err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_INVALID_TOKEN, response);\n                            Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                        }\n                        else {\n                            err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                            Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                        }\n                    }\n                    else {\n                        err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                        Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                    }\n                }\n                else {\n                    // if success flag is false, the operation we tried to perform failed\n                    if (body && !body.success) {\n                        const data = body.data;\n                        if ((body.code === GSErrors.code.ID_TOKEN_INVALID && auth instanceof AuthIDToken) ||\n                            (body.code === GSErrors.code.OAUTH_TOKEN_EXPIRED &&\n                                auth instanceof AuthOauthAuthorizationCode)) {\n                            Logger.getInstance().debug('ID Token being used has expired. Reauthenticating');\n                            await auth.reauthenticate(requestOptions.json);\n                            return httpClient.request(realRequestOptions);\n                        }\n                        err = Errors.createOperationFailedError(body.code, data, body.message, data && data.sqlState ? data.sqlState : undefined);\n                    }\n                }\n                // if we have an error, clear the body\n                if (err) {\n                    body = undefined;\n                }\n                // if a callback was specified, invoke it\n                if (Util.isFunction(requestOptions.callback)) {\n                    await requestOptions.callback.apply(requestOptions.scope, [err, body, response]);\n                }\n            },\n        };\n        if (requestOptions.retry > 2) {\n            const includesParam = requestOptions.url.includes('?');\n            realRequestOptions.url += includesParam ? '&' : '?';\n            realRequestOptions.url +=\n                'clientStartTime=' +\n                    requestOptions.startTime +\n                    '&' +\n                    'retryCount=' +\n                    (requestOptions.retry - 1);\n        }\n        return httpClient.request(realRequestOptions);\n    }\n    this.snowflakeService = options.snowflakeService;\n    this.httpClient = options.httpClient;\n    this.connectionConfig = options.connectionConfig;\n    this.tokenInfo = options.tokenInfo;\n    const connectionConfig = options.connectionConfig;\n    const snowflakeService = options.snowflakeService;\n    const httpClient = options.httpClient;\n    ///////////////////////////////////////////////////////////////////////////\n    ////                Request                                            ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * Creates a new Request to Snowflake.\n     *\n     * @param {Object} requestOptions\n     * @constructor\n     */\n    function Request(requestOptions) {\n        this.requestOptions = requestOptions;\n    }\n    /**\n     * Sends out the request.\n     *\n     * @returns {Object} the request that was issued.\n     */\n    Request.prototype.sendAsync = async function () {\n        // pre-process the request options\n        this.preprocessOptions(this.requestOptions);\n        // issue the http request\n        return new Promise((resolve, reject) => {\n            sendHttpRequest({\n                ...this.requestOptions,\n                callback: (err, _body, response) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(response);\n                    }\n                },\n            }, httpClient, snowflakeService.getAuthenticator());\n        });\n    };\n    function addGuidToParams(params) {\n        // In case of repeated requests for the same request ID,\n        // the Global UID is added for better traceability.\n        const guid = uuidv4();\n        params[sfParams.paramsNames.SF_REQUEST_GUID] = guid;\n    }\n    /**\n     * Sends out the request.\n     *\n     * @returns {Object} the request that was issued.\n     */\n    Request.prototype.send = function () {\n        // pre-process the request options\n        this.preprocessOptions(this.requestOptions);\n        // issue the http request\n        sendHttpRequest(this.requestOptions, httpClient, snowflakeService.getAuthenticator());\n    };\n    /**\n     * Pre-processes the request options just before the request is sent.\n     *\n     * @param {Object} requestOptions\n     */\n    Request.prototype.preprocessOptions = function (requestOptions) {\n        // augment the headers with the default request headers\n        requestOptions.headers = Util.apply(this.getDefaultReqHeaders(), requestOptions.headers || {});\n        if (Util.isLoginRequest(requestOptions.url)) {\n            Util.apply(requestOptions.headers, {\n                CLIENT_APP_VERSION: requestOptions.json.data.CLIENT_APP_VERSION,\n                CLIENT_APP_ID: requestOptions.json.data.CLIENT_APP_ID,\n            });\n        }\n        // augment the options with the absolute url\n        requestOptions.absoluteUrl = this.buildFullUrl(requestOptions.url);\n        requestOptions.excludeGuid = !Util.exists(requestOptions.excludeGuid)\n            ? false\n            : requestOptions.excludeGuid;\n    };\n    /**\n     * Converts a relative url to an absolute url.\n     *\n     * @param {String} relativeUrl\n     *\n     * @returns {String}\n     */\n    Request.prototype.buildFullUrl = function (relativeUrl) {\n        return connectionConfig.accessUrl + relativeUrl;\n    };\n    /**\n     * Returns the default headers to send with every request.\n     *\n     * @returns {Object}\n     */\n    Request.prototype.getDefaultReqHeaders = function () {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n        };\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////                SessionTokenRequest                                ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * @constructor\n     */\n    function SessionTokenRequest() {\n        Request.apply(this, arguments);\n    }\n    Util.inherits(SessionTokenRequest, Request);\n    /**\n     * @inheritDoc\n     */\n    SessionTokenRequest.prototype.preprocessOptions = function (requestOptions) {\n        // call super\n        Request.prototype.preprocessOptions.apply(this, arguments);\n        // add the current session token to the request headers\n        requestOptions.headers = requestOptions.headers || {};\n        requestOptions.headers.Authorization =\n            'Snowflake Token=\"' + options.tokenInfo.getSessionToken() + '\"';\n        if (Util.string.isNotNullOrEmpty(Parameters.getValue(Parameters.names.SERVICE_NAME))) {\n            requestOptions.headers['X-Snowflake-Service'] = Parameters.getValue(Parameters.names.SERVICE_NAME);\n        }\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////                MasterTokenRequest                                 ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * @constructor\n     */\n    function MasterTokenRequest() {\n        Request.apply(this, arguments);\n    }\n    Util.inherits(MasterTokenRequest, Request);\n    /**\n     * @inheritDoc\n     */\n    MasterTokenRequest.prototype.preprocessOptions = function (requestOptions) {\n        // call super\n        Request.prototype.preprocessOptions.apply(this, arguments);\n        // add the current master token to the request headers\n        requestOptions.headers = requestOptions.headers || {};\n        requestOptions.headers.Authorization =\n            'Snowflake Token=\"' + options.tokenInfo.getMasterToken() + '\"';\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////                UnauthenticatedRequest                             ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * Creates a new UnauthenticatedRequest.\n     *\n     * @constructor\n     */\n    function UnauthenticatedRequest() {\n        Request.apply(this, arguments);\n    }\n    Util.inherits(UnauthenticatedRequest, Request);\n    /**\n     * Creates a new SessionTokenRequest.\n     *\n     * @param {Object} requestOptions\n     *\n     * @returns {Object}\n     */\n    this.createSessionTokenRequest = function (requestOptions) {\n        return new SessionTokenRequest(requestOptions);\n    };\n    /**\n     * Creates a new MasterTokenRequest.\n     *\n     * @param {Object} requestOptions\n     *\n     * @returns {Object}\n     */\n    this.createMasterTokenRequest = function (requestOptions) {\n        return new MasterTokenRequest(requestOptions);\n    };\n    /**\n     * Creates a new UnauthenticatedRequest.\n     *\n     * @param {Object} requestOptions\n     *\n     * @returns {Object}\n     */\n    this.createUnauthenticatedRequest = function (requestOptions) {\n        return new UnauthenticatedRequest(requestOptions);\n    };\n}\n/**\n * Enters this state.\n * @abstract\n */\nStateAbstract.prototype.enter = function () { };\n/**\n * Exits this state.\n * @abstract\n */\nStateAbstract.prototype.exit = function () { };\n/**\n * Establishes a connection to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.connect = function () { };\n/**\n * Issues a connect-continue request to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.continue = function () { };\n/**\n * Issues a generic request to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.request = function () { };\n/**\n * Terminates the current connection to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.destroy = function () { };\n///////////////////////////////////////////////////////////////////////////\n////                StatePristine                                      ////\n///////////////////////////////////////////////////////////////////////////\nfunction StatePristine() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StatePristine, StateAbstract);\n/**\n * @inheritDoc\n */\nStatePristine.prototype.connect = function (options) {\n    // transition to the Connecting state with the callback in the transition\n    // context\n    this.snowflakeService.transitionToConnecting({\n        options: options,\n    });\n};\n/**\n * @inheritDoc\n */\nStatePristine.prototype.request = function (options) {\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_REQUEST_STATUS_PRISTINE));\n    });\n};\n/**\n * @inheritDoc\n */\nStatePristine.prototype.destroy = function (options) {\n    // we're still in the preconnected state so any\n    // attempts to destroy should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_DESTROY_STATUS_PRISTINE));\n    });\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateConnecting                                    ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateConnecting() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateConnecting, StateAbstract);\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.enter = function (context) {\n    // save the context\n    this.context = context;\n    // initiate the connection process\n    this.continue();\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.exit = function () {\n    // clear the context\n    this.context = null;\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.connect = function (options) {\n    // we're already connecting so any attempts\n    // to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTING));\n    });\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.continue = function () {\n    const context = this.context;\n    const err = context.options.err;\n    let json = context.options.json;\n    // if no json was specified, treat this as the first connect\n    // and get the necessary information from connectionConfig\n    if (!json) {\n        json = {\n            data: {\n                ACCOUNT_NAME: this.connectionConfig.account,\n                LOGIN_NAME: this.connectionConfig.username,\n                PASSWORD: this.connectionConfig.password,\n            },\n        };\n    }\n    // extract the inflight context from the error and put it back in the json\n    if (err && err.data && err.data.inFlightCtx) {\n        json.inFlightCtx = err.data.inFlightCtx;\n    }\n    // initialize the json data if necessary\n    json.data = json.data || {};\n    // add the client-app-id, client-app-version, and client-app-name\n    const clientInfo = {\n        CLIENT_APP_ID: this.connectionConfig.getClientType(),\n        CLIENT_APP_VERSION: this.connectionConfig.getClientVersion(),\n    };\n    // if we have some information about the client environment, add it as well\n    const clientEnvironment = this.connectionConfig.getClientEnvironment();\n    if (Util.isObject(clientEnvironment)) {\n        clientInfo.CLIENT_ENVIRONMENT = {\n            CERT_REVOCATION_CHECK_MODE: this.connectionConfig.crlValidatorConfig.checkMode,\n            ...json.data.CLIENT_ENVIRONMENT,\n            ...clientEnvironment,\n        };\n    }\n    const clientApplication = this.connectionConfig.getClientApplication();\n    if (Util.isString(clientApplication)) {\n        clientEnvironment['APPLICATION'] = clientApplication;\n    }\n    const sessionParameters = {\n        SESSION_PARAMETERS: {},\n    };\n    if (Util.exists(this.connectionConfig.getClientSessionKeepAlive())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_SESSION_KEEP_ALIVE =\n            this.connectionConfig.getClientSessionKeepAlive();\n    }\n    if (Util.exists(this.connectionConfig.getClientSessionKeepAliveHeartbeatFrequency())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY =\n            this.connectionConfig.getClientSessionKeepAliveHeartbeatFrequency();\n    }\n    if (Util.exists(this.connectionConfig.getJsTreatIntegerAsBigInt())) {\n        sessionParameters.SESSION_PARAMETERS.JS_TREAT_INTEGER_AS_BIGINT =\n            this.connectionConfig.getJsTreatIntegerAsBigInt();\n    }\n    if (Util.exists(this.connectionConfig.getGcsUseDownscopedCredential())) {\n        sessionParameters.SESSION_PARAMETERS.GCS_USE_DOWNSCOPED_CREDENTIAL =\n            this.connectionConfig.getGcsUseDownscopedCredential();\n    }\n    if (Util.exists(this.connectionConfig.getClientRequestMFAToken())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_REQUEST_MFA_TOKEN =\n            this.connectionConfig.getClientRequestMFAToken();\n    }\n    if (Util.exists(this.connectionConfig.getClientStoreTemporaryCredential())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_STORE_TEMPORARY_CREDENTIAL =\n            this.connectionConfig.getClientStoreTemporaryCredential();\n    }\n    if (Util.exists(this.connectionConfig.queryTag)) {\n        sessionParameters.SESSION_PARAMETERS.QUERY_TAG = this.connectionConfig.queryTag;\n    }\n    Util.apply(json.data, clientInfo);\n    Util.apply(json.data, sessionParameters);\n    const connectionConfig = this.connectionConfig;\n    const maxLoginRetries = connectionConfig.getRetrySfMaxLoginRetries();\n    const maxRetryTimeout = connectionConfig.getRetryTimeout();\n    const startTime = connectionConfig.accessUrl.startsWith('https://')\n        ? Date.now()\n        : 'FIXEDTIMESTAMP';\n    let numRetries = 0;\n    let sleep = connectionConfig.getRetrySfStartingSleepTime();\n    let totalElapsedTime = 0;\n    Logger.getInstance().debug('Total retryTimeout is for the retries = ' + maxRetryTimeout === 0\n        ? 0\n        : maxRetryTimeout);\n    const parent = this;\n    const requestCallback = async function (err, body) {\n        // clear credential-related information\n        connectionConfig.clearCredentials();\n        // if the request succeeded\n        if (!err) {\n            Errors.assertInternal(Util.exists(body));\n            Errors.assertInternal(Util.exists(body.data));\n            parent.snowflakeService.setSessionId(body.data.sessionId);\n            Logger.getInstance().debug(`New session with id ${parent.snowflakeService.getSessionId()} initialized`);\n            // update the parameters\n            Parameters.update(body.data.parameters);\n            // update all token-related information\n            parent.tokenInfo.update(body.data);\n            if (connectionConfig.getClientRequestMFAToken() && body.data.mfaToken) {\n                const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR);\n                await GlobalConfig.getCredentialManager().write(key, body.data.mfaToken);\n            }\n            if (connectionConfig.getClientStoreTemporaryCredential() && body.data.idToken) {\n                const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n                await GlobalConfig.getCredentialManager().write(key, body.data.idToken);\n            }\n            // we're now connected\n            parent.snowflakeService.transitionToConnected();\n            const qccSize = Parameters.getValue('QUERY_CONTEXT_CACHE_SIZE');\n            parent.snowflakeService.initializeQueryContextCache(qccSize);\n        }\n        else {\n            if (Errors.isNetworkError(err) || Errors.isRequestFailedError(err)) {\n                if (numRetries < maxLoginRetries &&\n                    (isRetryableNetworkError(err) || isRetryableHttpError(err)) &&\n                    (maxRetryTimeout === 0 || totalElapsedTime < maxRetryTimeout)) {\n                    numRetries++;\n                    const jitter = Util.getJitteredSleepTime(numRetries, sleep, totalElapsedTime, maxRetryTimeout);\n                    sleep = jitter.sleep;\n                    totalElapsedTime = jitter.totalElapsedTime;\n                    if (sleep <= 0) {\n                        Logger.getInstance().debug('Reached out to the max Login Timeout');\n                        parent.snowflakeService.transitionToDisconnected();\n                    }\n                    const auth = parent.snowflakeService.getAuthenticator();\n                    if (auth instanceof AuthOkta) {\n                        Logger.getInstance().debug('OKTA authentication requires token refresh.');\n                        const retryOption = {\n                            totalElapsedTime,\n                            numRetries,\n                        };\n                        await auth.reauthenticate(context.options.json, retryOption);\n                        numRetries = retryOption.numRetries;\n                        totalElapsedTime = retryOption.totalElapsedTime;\n                    }\n                    else if (auth instanceof AuthKeypair) {\n                        Logger.getInstance().debug('AuthKeyPair authentication requires token refresh.');\n                        await auth.reauthenticate(context.options.json);\n                    }\n                    setTimeout(sendRequest, sleep * 1000);\n                    return;\n                }\n                else {\n                    Logger.getInstance().debug('Failed to all retries to SF.');\n                    // we're now disconnected\n                    parent.snowflakeService.transitionToDisconnected();\n                }\n            }\n            else {\n                // we're now disconnected\n                parent.snowflakeService.transitionToDisconnected();\n            }\n        }\n        // invoke the transition-context callback that was passed to us by the\n        // Pristine state on connect()\n        if (Util.isFunction(context.options.callback)) {\n            context.options.callback(err);\n        }\n        // all queued operations are now free to go\n        parent.snowflakeService.drainOperationQueue();\n    };\n    // issue a login request\n    const sendRequest = function () {\n        const targetUrl = buildLoginUrl(connectionConfig);\n        Logger.getInstance().debug('Contacting SF: %s, (%s/%s)', targetUrl, numRetries, maxLoginRetries);\n        const request = parent.createUnauthenticatedRequest({\n            method: 'POST',\n            url: targetUrl,\n            json: json,\n            scope: this,\n            startTime: startTime,\n            retry: numRetries,\n            callback: requestCallback,\n        });\n        request.send();\n    };\n    sendRequest();\n};\n/**\n * Builds the url for a login request.\n *\n * @param connectionConfig\n *\n * @returns {*}\n */\nfunction buildLoginUrl(connectionConfig) {\n    const queryParams = [\n        { name: 'warehouse', value: connectionConfig.getWarehouse() },\n        { name: 'databaseName', value: connectionConfig.getDatabase() },\n        { name: 'schemaName', value: connectionConfig.getSchema() },\n        { name: 'roleName', value: connectionConfig.getRole() },\n    ];\n    const queryStringObject = {};\n    if (!connectionConfig.isQaMode()) {\n        // No requestId is attached to login-request in test mode.\n        queryStringObject.requestId = uuidv4();\n    }\n    for (let index = 0, length = queryParams.length; index < length; index++) {\n        const queryParam = queryParams[index];\n        if (Util.string.isNotNullOrEmpty(queryParam.value)) {\n            queryStringObject[queryParam.name] = queryParam.value;\n        }\n    }\n    return Url.format({\n        pathname: '/session/v1/login-request',\n        search: QueryString.stringify(queryStringObject),\n    });\n}\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.request = function (options) {\n    // enqueue the request operation\n    this.snowflakeService.enqueueRequest(options);\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.destroy = function (options) {\n    // enqueue the destroy operation\n    this.snowflakeService.enqueueDestroy(options);\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateConnected                                     ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateConnected() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateConnected, StateAbstract);\n/**\n * @inheritDoc\n */\nStateConnected.prototype.connect = function (options) {\n    // we're already connected so any attempts\n    // to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTED));\n    });\n};\nStateConnected.prototype.requestAsync = async function (options) {\n    // create a session token request from the options and send out the request\n    return await this.createSessionTokenRequest(options).sendAsync();\n};\n/**\n * @inheritDoc\n */\nStateConnected.prototype.request = function (options) {\n    const scopeOrig = options.scope;\n    const callbackOrig = options.callback;\n    // define our own scope and callback\n    options.scope = this;\n    options.callback = async function (err, body) {\n        // if there was no error, invoke the callback if one was specified\n        if (!err) {\n            if (Util.isFunction(callbackOrig)) {\n                await callbackOrig.apply(scopeOrig, [err, body]);\n            }\n        }\n        else {\n            // restore the original scope and callback to the options object because\n            // we might need to repeat the request\n            options.scope = scopeOrig;\n            options.callback = callbackOrig;\n            // if the session token has expired\n            if (err.code === GSErrors.code.SESSION_TOKEN_EXPIRED) {\n                // enqueue the request operation\n                this.snowflakeService.enqueueRequest(options);\n                // if a session token renewal isn't already in progress, issue a\n                // request to renew the session token\n                this.snowflakeService.transitionToRenewing();\n            }\n            else if (err.code === GSErrors.code.SESSION_TOKEN_INVALID ||\n                err.code === GSErrors.code.GONE_SESSION) {\n                // if the session token is invalid or it doesn't exist\n                // enqueue the request operation\n                this.snowflakeService.enqueueRequest(options);\n                // we're disconnected\n                this.snowflakeService.transitionToDisconnected();\n                // all queued operations are now free to go\n                this.snowflakeService.drainOperationQueue();\n                // TODO: remember that a session renewal is no longer in progress\n                // TODO: make sure the last session renewal did not time out\n            }\n            else {\n                // it's a normal failure\n                // if a callback was specified, invoke it\n                if (Util.isFunction(callbackOrig)) {\n                    callbackOrig.apply(scopeOrig, [err, body]);\n                }\n            }\n        }\n    };\n    // create a session token request from the options and send out the request\n    this.createSessionTokenRequest(options).send();\n};\n/**\n * @inheritDoc\n */\nStateConnected.prototype.destroy = function (options) {\n    const requestID = uuidv4();\n    // send out a session token request to terminate the current connection\n    this.createSessionTokenRequest({\n        method: 'POST',\n        url: `/session?delete=true&requestId=${requestID}`,\n        scope: this,\n        callback: function (err) {\n            // if the destroy request succeeded or the session already expired, we're disconnected\n            if (!err ||\n                err.code === GSErrors.code.GONE_SESSION ||\n                err.code === GSErrors.code.SESSION_TOKEN_EXPIRED) {\n                err = undefined;\n                this.snowflakeService.transitionToDisconnected();\n            }\n            // invoke the original callback\n            options.callback(err);\n        },\n    }).send();\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateRenewing                                      ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateRenewing() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateRenewing, StateAbstract);\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.enter = function () {\n    // send out a master token request to renew the current session token\n    this.createMasterTokenRequest({\n        method: 'POST',\n        url: '/session/token-request',\n        headers: {\n            CLIENT_APP_ID: this.connectionConfig.getClientType(),\n            CLIENT_APP_VERSION: this.connectionConfig.getClientVersion(),\n        },\n        json: {\n            REQUEST_TYPE: 'RENEW',\n            oldSessionToken: this.tokenInfo.getSessionToken(),\n        },\n        scope: this,\n        callback: function (err, body) {\n            // if the request succeeded\n            if (!err) {\n                // update the token information\n                this.tokenInfo.update(body.data);\n                // we're now connected again\n                this.snowflakeService.transitionToConnected();\n            }\n            else {\n                // if the master token has expired, transition to the disconnected\n                // state\n                if (err.code === GSErrors.code.MASTER_TOKEN_EXPIRED) {\n                    this.snowflakeService.transitionToDisconnected();\n                }\n                else if (Errors.isNetworkError(err)) {\n                    // go back to the connected state\n                    this.snowflakeService.transitionToConnected();\n                }\n                else {\n                    // if the renewal failed for some other reason, we're\n                    // disconnected\n                    // TODO: what should our state be here? also disconnected?\n                    this.snowflakeService.transitionToDisconnected();\n                }\n            }\n            // all queued operations are now free to go\n            this.snowflakeService.drainOperationQueue();\n        },\n    }).send();\n};\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.connect = function (options) {\n    // we're renewing the session token, which means we're connected,\n    // so any attempts to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTED));\n    });\n};\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.request = function (options) {\n    // enqueue the request operation\n    this.snowflakeService.enqueueRequest(options);\n};\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.destroy = function (options) {\n    // enqueue the destroy operation\n    this.snowflakeService.enqueueDestroy(options);\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateDisconnected                                  ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateDisconnected() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateDisconnected, StateAbstract);\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.connect = function (options) {\n    // we're disconnected -- and fatally so -- so any\n    // attempts to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_DISCONNECTED));\n    });\n};\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.request = function (options) {\n    // we're disconnected, so any attempts to\n    // send a request should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_REQUEST_STATUS_DISCONNECTED, true));\n    });\n};\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.destroy = function (options) {\n    // we're already disconnected so any attempts\n    // to destroy should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_DESTROY_STATUS_DISCONNECTED));\n    });\n};\n/**\n * Creates a TokenInfo object that encapsulates all token-related information,\n * e.g. the master token, the session token, the tokens' expiration times, etc.\n *\n * @param {Object} [config]\n *\n * @constructor\n */\nfunction TokenInfo(config) {\n    let masterToken;\n    let sessionToken;\n    let masterTokenExpirationTime;\n    let sessionTokenExpirationTime;\n    if (Util.isObject(config)) {\n        masterToken = config.masterToken;\n        sessionToken = config.sessionToken;\n        masterTokenExpirationTime = config.masterTokenExpirationTime;\n        sessionTokenExpirationTime = config.sessionTokenExpirationTime;\n    }\n    /**\n     * Returns true if no token-related information is available, false otherwise.\n     *\n     * @returns {Boolean}\n     */\n    this.isEmpty = function () {\n        return (!Util.exists(masterToken) ||\n            !Util.exists(masterTokenExpirationTime) ||\n            !Util.exists(sessionToken) ||\n            !Util.exists(sessionTokenExpirationTime));\n    };\n    /**\n     * Clears all token-related information.\n     */\n    this.clearTokens = function () {\n        masterToken = undefined;\n        masterTokenExpirationTime = undefined;\n        sessionToken = undefined;\n        sessionTokenExpirationTime = undefined;\n    };\n    /**\n     * Updates the tokens and their expiration times.\n     *\n     * @param {Object} data\n     */\n    this.update = function (data) {\n        masterToken = data.masterToken;\n        sessionToken = data.token || data.sessionToken;\n        const currentTime = new Date().getTime();\n        masterTokenExpirationTime =\n            currentTime + 1000 * (data.masterValidityInSeconds || data.validityInSecondsMT);\n        sessionTokenExpirationTime =\n            currentTime + 1000 * (data.validityInSeconds || data.validityInSecondsST);\n    };\n    /**\n     * Returns the master token.\n     *\n     * @returns {String}\n     */\n    this.getMasterToken = function () {\n        return masterToken;\n    };\n    /**\n     * Returns the expiration time of the master token.\n     *\n     * @returns {Number}\n     */\n    this.getMasterTokenExpirationTime = function () {\n        return masterTokenExpirationTime;\n    };\n    /**\n     * Returns the session token.\n     *\n     * @returns {String}\n     */\n    this.getSessionToken = function () {\n        return sessionToken;\n    };\n    /**\n     * Returns the expiration time of the session token.\n     *\n     * @returns {Number}\n     */\n    this.getSessionTokenExpirationTime = function () {\n        return sessionTokenExpirationTime;\n    };\n    /**\n     * Returns a configuration object that can be passed to the TokenInfo\n     * constructor to get an equivalent TokenInfo object.\n     *\n     * @returns {Object}\n     */\n    this.getConfig = function () {\n        return {\n            masterToken: masterToken,\n            masterTokenExpirationTime: masterTokenExpirationTime,\n            sessionToken: sessionToken,\n            sessionTokenExpirationTime: sessionTokenExpirationTime,\n        };\n    };\n}\n//# sourceMappingURL=sf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZXJ2aWNlcy9zZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyw4REFBTTtBQUNyQyxxQkFBcUIsMERBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsa0dBQXdCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLDhGQUFzQjtBQUN4RCxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLGtJQUF3QztBQUM1RSxpQkFBaUIsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsa0hBQWdDO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLGtIQUFnQztBQUM1RCxzQkFBc0IsbUJBQU8sQ0FBQyxzSEFBa0M7QUFDaEUsbUNBQW1DLG1CQUFPLENBQUMsb0pBQWlEO0FBQzVGLGlCQUFpQixtQkFBTyxDQUFDLGtHQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksZUFBZTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsQ0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx3Q0FBd0M7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkRBQTJEO0FBQ3JFLFVBQVUsNkRBQTZEO0FBQ3ZFLFVBQVUseURBQXlEO0FBQ25FLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZXJ2aWNlcy9zZi5qcz9kNjkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAgU25vd2ZsYWtlU2VydmljZSBzdGF0ZSBtYWNoaW5lXG5cbiAgUHJlY29ubmVjdGVkIC0gZW50ZXIoKSAgICAgIC0gUHJlY29ubmVjdGVkXG4gICAgICAgICAgICAgICAtIGNvbm5lY3QoKSAgICAtIENvbm5lY3RpbmdcbiAgICAgICAgICAgICAgIC0gcmVxdWVzdCgpICAgIC0gQ29ubmVjdGluZ1xuICAgICAgICAgICAgICAgLSBkZXN0cm95KCkgICAgLSBQcmVjb25uZWN0ZWRcblxuICBDb25uZWN0aW5nICAgLSBlbnRlcigpICAgICAgLSBhc3luYyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBDb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIG5ldHdvcmsgZXJyb3IgKHdlIG5lZWQgYW5vdGhlciBQcmVDb25uZWN0ZWQgc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIG9wZXJhdGlvbiBmYWlsc1xuICAgICAgICAgICAgICAgICBjb25uZWN0KCkgICAgLSBlcnJvclxuICAgICAgICAgICAgICAgICByZXF1ZXN0KCkgICAgLSBlbnF1ZXVlXG4gICAgICAgICAgICAgICAgIGRlc3Ryb3koKSAgICAtIGVucXVldWVcblxuICBDb25uZWN0ZWQgICAgLSBlbnRlcigpICAgICAgLSBDb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgY29ubmVjdCgpICAgIC0gZXJyb3JcbiAgICAgICAgICAgICAgICAgcmVxdWVzdCgpICAgIC0gYXN5bmMgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQ29ubmVjdGVkIGlmIG9wZXJhdGlvbiBzdWNjZWVkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gUmVuZXdpbmcgaWYgR1Mgc2F5cyBzZXNzaW9uIHRva2VuIGhhcyBleHBpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIEdTIHNheXMgc2Vzc2lvbiB0b2tlbiBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgICAgIGRlc3Ryb3koKSAgICAtIGFzeW5jIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBEaXNjb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBvcGVyYXRpb24gZmFpbHNcblxuICBSZW5ld2luZyAgICAgLSBlbnRlcigpICAgICAgLSBhc3luYyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBDb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQ29ubmVjdGVkIGlmIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBEaXNjb25uZWN0ZWQgaWYgb3BlcmF0aW9uIGZhaWxzXG4gICAgICAgICAgICAgICAtIGNvbm5lY3QoKSAgICAtIGVycm9yXG4gICAgICAgICAgICAgICAtIHJlcXVlc3QoKSAgICAtIGVucXVldWVcbiAgICAgICAgICAgICAgIC0gZGVzdHJveSgpICAgIC0gZW5xdWV1ZVxuXG4gIERpc2Nvbm5lY3RlZCAtIGVudGVyKCkgICAgICAtIERpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgLSBjb25uZWN0KCkgICAgLSBEaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgIC0gcmVxdWVzdCgpICAgIC0gRGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAtIGRlc3Ryb3koKSAgICAtIERpc2Nvbm5lY3RlZFxuICovXG5jb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoJ3V1aWQnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IFF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IFBhcmFtZXRlcnMgPSByZXF1aXJlKCcuLi9wYXJhbWV0ZXJzJyk7XG5jb25zdCBHU0Vycm9ycyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9nc19lcnJvcnMnKTtcbmNvbnN0IFF1ZXJ5Q29udGV4dENhY2hlID0gcmVxdWlyZSgnLi4vcXVlcnlDb250ZXh0Q2FjaGUnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgQXV0aGVudGljYXRpb25UeXBlcyA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBBdXRoT2t0YSA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhfb2t0YScpO1xuY29uc3QgQXV0aEtleXBhaXIgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoX2tleXBhaXInKTtcbmNvbnN0IEF1dGhJRFRva2VuID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aF9pZHRva2VuJyk7XG5jb25zdCBBdXRoZW50aWNhdG9yID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24nKTtcbmNvbnN0IEF1dGhPYXV0aEF1dGhvcml6YXRpb25Db2RlID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aF9vYXV0aF9hdXRob3JpemF0aW9uX2NvZGUnKTtcbmNvbnN0IHNmUGFyYW1zID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL3NmX3BhcmFtcycpO1xuZnVuY3Rpb24gaXNSZXRyeWFibGVOZXR3b3JrRXJyb3IoZXJyKSB7XG4gICAgLy8gYW55dGhpbmcgb3RoZXIgdGhhbiBSRVZPS0VEIGVycm9yIGNhbiBiZSByZXRyeWFibGUuXG4gICAgcmV0dXJuICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ2NhdXNlJykgfHxcbiAgICAgICAgZXJyLmNhdXNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIuY2F1c2UsICdjb2RlJykgfHxcbiAgICAgICAgKGVyci5jYXVzZS5jb2RlICE9PSBFcnJvckNvZGVzLkVSUl9PQ1NQX1JFVk9LRUQgJiZcbiAgICAgICAgICAgIGVyci5jYXVzZS5jb2RlICE9PSAnREVQVEhfWkVST19TRUxGX1NJR05FRF9DRVJUJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09ICdDRVJUX0hBU19FWFBJUkVEJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09ICdVTkFCTEVfVE9fVkVSSUZZX0xFQUZfU0lHTkFUVVJFJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09ICdTRUxGX1NJR05FRF9DRVJUX0lOX0NIQUlOJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09IEVycm9yQ29kZXMuRVJSX0NSTF9FUlJPUikpO1xufVxuZnVuY3Rpb24gaXNSZXRyeWFibGVIdHRwRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAncmVzcG9uc2UnKSAmJlxuICAgICAgICBVdGlsLmlzUmV0cnlhYmxlSHR0cEVycm9yKGVyci5yZXNwb25zZSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTbm93Zmxha2VTZXJ2aWNlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gaHR0cENsaWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU25vd2ZsYWtlU2VydmljZShjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBjb25maWcpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbm5lY3Rpb25Db25maWcpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChodHRwQ2xpZW50KSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKCFVdGlsLmV4aXN0cyhjb25maWcpIHx8IFV0aWwuaXNPYmplY3QoY29uZmlnKSk7XG4gICAgLy8gaWYgYSBjb25maWcgb2JqZWN0IHdhcyBzcGVjaWZpZWQsIHZlcmlmeVxuICAgIC8vIHRoYXQgaXQgaGFzIGFsbCB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZFxuICAgIGxldCB0b2tlbkluZm9Db25maWc7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGNvbmZpZykpIHtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29uZmlnKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbmZpZy50b2tlbkluZm8pKTtcbiAgICAgICAgdG9rZW5JbmZvQ29uZmlnID0gY29uZmlnLnRva2VuSW5mbztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29ubmVjdGlvbkNvbmZpZy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgdG9rZW5JbmZvQ29uZmlnID0ge1xuICAgICAgICAgICAgc2Vzc2lvblRva2VuOiBjb25uZWN0aW9uQ29uZmlnLnNlc3Npb25Ub2tlbixcbiAgICAgICAgICAgIG1hc3RlclRva2VuOiBjb25uZWN0aW9uQ29uZmlnLm1hc3RlclRva2VuIHx8IGNvbm5lY3Rpb25Db25maWcuc2Vzc2lvblRva2VuLFxuICAgICAgICAgICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU6IGNvbm5lY3Rpb25Db25maWcuc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgfHwgRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgICAgICAgICBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lOiBjb25uZWN0aW9uQ29uZmlnLm1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUgfHwgRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIG5ldyBUb2tlbkluZm8gaW5zdGFuY2VcbiAgICBjb25zdCB0b2tlbkluZm8gPSBuZXcgVG9rZW5JbmZvKHRva2VuSW5mb0NvbmZpZyk7XG4gICAgdHJ5IHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JldHJpZXZpbmcgYXV0aGVudGljYXRvcicpO1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0b3IgPSBBdXRoZW50aWNhdG9yLmdldEF1dGhlbnRpY2F0b3IoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBpbml0aWFsaXplIGF1dGhlbnRpY2F0b3I6ICR7ZXJyb3J9YDtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FVVEhfVU5TVVBQT1JURUQsIHRydWUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc3RhdGUgb2JqZWN0cyBmb3IgYWxsIHRoZSBkaWZmZXJlbnQgc3RhdGVzIHdlIGNhbiBiZSBpblxuICAgIGNvbnN0IHN0YXRlT3B0aW9ucyA9IHtcbiAgICAgICAgc25vd2ZsYWtlU2VydmljZTogdGhpcyxcbiAgICAgICAgaHR0cENsaWVudDogaHR0cENsaWVudCxcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZzogY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgdG9rZW5JbmZvOiB0b2tlbkluZm8sXG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZVByaXN0aW5lID0gbmV3IFN0YXRlUHJpc3RpbmUoc3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzdGF0ZUNvbm5lY3RpbmcgPSBuZXcgU3RhdGVDb25uZWN0aW5nKHN0YXRlT3B0aW9ucyk7XG4gICAgY29uc3Qgc3RhdGVDb25uZWN0ZWQgPSBuZXcgU3RhdGVDb25uZWN0ZWQoc3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzdGF0ZVJlbmV3aW5nID0gbmV3IFN0YXRlUmVuZXdpbmcoc3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzdGF0ZURpc2Nvbm5lY3RlZCA9IG5ldyBTdGF0ZURpc2Nvbm5lY3RlZChzdGF0ZU9wdGlvbnMpO1xuICAgIGxldCBjdXJyZW50U3RhdGU7XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgdG8gYSBnaXZlbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdHJhbnNpdGlvbkNvbnRleHRdXG4gICAgICovXG4gICAgY29uc3QgdHJhbnNpdGlvblRvID0gZnVuY3Rpb24gKHN0YXRlLCB0cmFuc2l0aW9uQ29udGV4dCkge1xuICAgICAgICAvLyB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcmUtZW50ZXIgYSB0cmFuc2llbnQgc3RhdGVcbiAgICAgICAgLy8gbGlrZSBSZW5ld2luZyB3aGVuIHdlJ3JlIGFscmVhZHkgaW4gaXRcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBjdXJyZW50IHN0YXRlLCBleGl0IGl0OyB0aGUgbnVsbCBjaGVjayBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGN1cnJlbnRTdGF0ZSBpcyB1bmRlZmluZWQgYXQgYm9vdHN0cmFwIHRpbWUgd2hlbiB3ZVxuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiB0byB0aGUgZmlyc3Qgc3RhdGVcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUuZXhpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIC8vIGVudGVyIHRoZSBuZXcgc3RhdGVcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZS5lbnRlcih0cmFuc2l0aW9uQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2Vzc2lvbiBpZCBmb3IgdGhlIGN1cnJlbnQgU25vd2ZsYWtlU2VydmljZVxuICAgICAqIEBwYXJhbSBzZXNzaW9uSWRcbiAgICAgKi9cbiAgICB0aGlzLnNldFNlc3Npb25JZCA9IGZ1bmN0aW9uIChzZXNzaW9uSWQpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNlc3Npb24gaWQuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldFNlc3Npb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbklkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFByaXN0aW5lIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvUHJpc3RpbmUgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdHJhbnNpdGlvblRvKHN0YXRlUHJpc3RpbmUsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBDb25uZWN0aW5nIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvQ29ubmVjdGluZyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uQ29udGV4dCkge1xuICAgICAgICB0cmFuc2l0aW9uVG8oc3RhdGVDb25uZWN0aW5nLCB0cmFuc2l0aW9uQ29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgQ29ubmVjdGVkIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvQ29ubmVjdGVkID0gZnVuY3Rpb24gKHRyYW5zaXRpb25Db250ZXh0KSB7XG4gICAgICAgIHRyYW5zaXRpb25UbyhzdGF0ZUNvbm5lY3RlZCwgdHJhbnNpdGlvbkNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFJlbmV3aW5nIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvUmVuZXdpbmcgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdHJhbnNpdGlvblRvKHN0YXRlUmVuZXdpbmcsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBEaXNjb25uZWN0ZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiB7T2JqZWN0fSBbdHJhbnNpdGlvbkNvbnRleHRdXG4gICAgICovXG4gICAgdGhpcy50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdHJhbnNpdGlvblRvKHN0YXRlRGlzY29ubmVjdGVkLCB0cmFuc2l0aW9uQ29udGV4dCk7XG4gICAgICAgIC8vIGNsZWFyIHRoZSB0b2tlbnMgYmVjYXVzZSB3ZSdyZSBpbiBhIGZhdGFsIHN0YXRlIGFuZCB3ZSBkb24ndCB3YW50IHRoZVxuICAgICAgICAvLyB0b2tlbnMgdG8gYmUgYXZhaWxhYmxlIHZpYSBnZXRDb25maWcoKSBhbnltb3JlXG4gICAgICAgIHRva2VuSW5mby5jbGVhclRva2VucygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgU25vd2ZsYWtlU2VydmljZVxuICAgICAqIGNvbnN0cnVjdG9yIHRvIGdldCBhbiBlcXVpdmFsZW50IFNub3dmbGFrZVNlcnZpY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuSW5mbzogdG9rZW5JbmZvLmdldENvbmZpZygpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIFNub3dmbGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgbmV3IE9wZXJhdGlvbkNvbm5lY3Qob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJc3N1ZXMgYSBjb25uZWN0LWNvbnRpbnVlIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIHRoaXMuY29udGludWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBuZXcgT3BlcmF0aW9uQ29udGludWUob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJc3N1ZXMgYSBnZW5lcmljIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBuZXcgT3BlcmF0aW9uUmVxdWVzdChvcHRpb25zKS52YWxpZGF0ZSgpLmV4ZWN1dGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElzc3VlcyBhIGdlbmVyaWMgYXN5bmMgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdEFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpLnZhbGlkYXRlKCkuZXhlY3V0ZUFzeW5jKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGVzIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gdG8gU25vd2ZsYWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgbmV3IE9wZXJhdGlvbkRlc3Ryb3kob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wZXJhdGlvbkFic3RyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcGVyYXRpb25BYnN0cmFjdChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgb3BlcmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIE9wZXJhdGlvbkFic3RyYWN0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIE9wZXJhdGlvbkFic3RyYWN0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0aW9uQ29ubmVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uQ29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIE9wZXJhdGlvbkFic3RyYWN0LmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgfVxuICAgIFV0aWwuaW5oZXJpdHMoT3BlcmF0aW9uQ29ubmVjdCwgT3BlcmF0aW9uQWJzdHJhY3QpO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uQ29ubmVjdC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBvcHRpb25zIG9iamVjdCBjb250YWlucyBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpICYmIFV0aWwuaXNGdW5jdGlvbihvcHRpb25zLmNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25Db25uZWN0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50U3RhdGUuY29ubmVjdCh0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25Db250aW51ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uQ29udGludWUob3B0aW9ucykge1xuICAgICAgICBPcGVyYXRpb25BYnN0cmFjdC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIH1cbiAgICBVdGlsLmluaGVyaXRzKE9wZXJhdGlvbkNvbnRpbnVlLCBPcGVyYXRpb25BYnN0cmFjdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25Db250aW51ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBvcHRpb25zIGNvbnRhaW4gYSBqc29uIG9iamVjdFxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSAmJiBVdGlsLmlzT2JqZWN0KG9wdGlvbnMuanNvbikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uQ29udGludWUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5jb250aW51ZSh0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgT3BlcmF0aW9uQWJzdHJhY3QuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICB9XG4gICAgVXRpbC5pbmhlcml0cyhPcGVyYXRpb25SZXF1ZXN0LCBPcGVyYXRpb25BYnN0cmFjdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25SZXF1ZXN0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNTdHJpbmcob3B0aW9ucy5tZXRob2QpKTtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKCFVdGlsLmV4aXN0cyhvcHRpb25zLmhlYWRlcnMpIHx8IFV0aWwuaXNPYmplY3Qob3B0aW9ucy5oZWFkZXJzKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzU3RyaW5nKG9wdGlvbnMudXJsKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbCghVXRpbC5leGlzdHMob3B0aW9ucy5qc29uKSB8fCBVdGlsLmlzT2JqZWN0KG9wdGlvbnMuanNvbikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uUmVxdWVzdC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudFN0YXRlLnJlcXVlc3QodGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uUmVxdWVzdC5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgY3VycmVudFN0YXRlLnJlcXVlc3RBc3luYyh0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25EZXN0cm95LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcGVyYXRpb25EZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgT3BlcmF0aW9uQWJzdHJhY3QuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICB9XG4gICAgVXRpbC5pbmhlcml0cyhPcGVyYXRpb25EZXN0cm95LCBPcGVyYXRpb25BYnN0cmFjdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25EZXN0cm95LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5zIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykgJiYgVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE9wZXJhdGlvbkRlc3Ryb3kucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGRlbGVnYXRlIHRvIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgY3VycmVudFN0YXRlLmRlc3Ryb3kodGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qIEFsbCBxdWV1ZWQgb3BlcmF0aW9ucyB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgYXJyYXkgKi9cbiAgICBjb25zdCBvcGVyYXRpb25RdWV1ZSA9IFtdO1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSByZXF1ZXN0IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZW5xdWV1ZVJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5wdXNoKG5ldyBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBkZXN0cm95IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZW5xdWV1ZURlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5wdXNoKG5ldyBPcGVyYXRpb25EZXN0cm95KG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGFsbCB0aGUgb3BlcmF0aW9ucyBpbiB0aGUgcXVldWUuXG4gICAgICovXG4gICAgdGhpcy5kcmFpbk9wZXJhdGlvblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBleGVjdXRlIGFsbCB0aGUgb3BlcmF0aW9ucyBpbiB0aGUgcXVldWVcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBvcGVyYXRpb25RdWV1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25RdWV1ZVtpbmRleF0uZXhlY3V0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVtcHR5IHRoZSBxdWV1ZVxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50U3RhdGUgPT09IHN0YXRlQ29ubmVjdGVkIHx8XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPT09IHN0YXRlQ29ubmVjdGluZyB8fFxuICAgICAgICAgICAgY3VycmVudFN0YXRlID09PSBzdGF0ZVJlbmV3aW5nKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2VydmljZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJzLmdldFZhbHVlKFBhcmFtZXRlcnMubmFtZXMuU0VSVklDRV9OQU1FKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1kpO1xuICAgIH07XG4gICAgdGhpcy5nZXRKc1RyZWF0SW50ZWdlckFzQmlnSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLkpTX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5UKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0QXV0aGVudGljYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aGVudGljYXRvcjtcbiAgICB9O1xuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IHRva2Vucywgc3RhcnQgb3V0IGFzIHByaXN0aW5lXG4gICAgaWYgKHRva2VuSW5mby5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9QcmlzdGluZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWRcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9Db25uZWN0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXNzdWVzIGEgcG9zdCByZXF1ZXN0IHRvIFNub3dmbGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5wb3N0QXN5bmMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvblJlcXVlc3Qob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlQXN5bmMoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UXVlcnlDb250ZXh0RFRPID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucWNjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucWNjLmdldFF1ZXJ5Q29udGV4dERUTygpO1xuICAgIH07XG4gICAgdGhpcy5kZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5xY2MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnFjYy5kZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dChkYXRhKTtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnFjYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucWNjLmNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZVF1ZXJ5Q29udGV4dENhY2hlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uQ29uZmlnLmdldERpc2FibGVRdWVyeUNvbnRleHRDYWNoZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnFjYyA9IG5ldyBRdWVyeUNvbnRleHRDYWNoZShzaXplLCB0aGlzLmdldFNlc3Npb25JZCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRdWVyeUNvbnRleHRDYWNoZSBpbml0aWFsaXphdGlvbiBza2lwcGVkIGFzIGl0IGlzIGRpc2FibGVkIGZvciBjb25uZWN0aW9uIHdpdGggc2Vzc2lvbklkOiAke3RoaXMuc2Vzc2lvbklkfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB0ZXN0aW5nIHB1cnBvc2VcbiAgICB0aGlzLmdldFF1ZXJ5Q29udGV4dENhY2hlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnFjYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnFjYy5nZXRTaXplKCk7XG4gICAgfTtcbn1cblV0aWwuaW5oZXJpdHMoU25vd2ZsYWtlU2VydmljZSwgRXZlbnRFbWl0dGVyKTtcbm1vZHVsZS5leHBvcnRzID0gU25vd2ZsYWtlU2VydmljZTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZUFic3RyYWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTdGF0ZUFic3RyYWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhdGVBYnN0cmFjdChvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogSXNzdWVzIGFuIGh0dHAgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaHR0cENsaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIGh0dHAgcmVxdWVzdCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZEh0dHBSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBodHRwQ2xpZW50LCBhdXRoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHJlcXVlc3RPcHRpb25zLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5leGNsdWRlR3VpZCkge1xuICAgICAgICAgICAgYWRkR3VpZFRvUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhbFJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0T3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgdXJsOiByZXF1ZXN0T3B0aW9ucy5hYnNvbHV0ZVVybCxcbiAgICAgICAgICAgIGd6aXA6IHJlcXVlc3RPcHRpb25zLmd6aXAsXG4gICAgICAgICAgICBqc29uOiByZXF1ZXN0T3B0aW9ucy5qc29uLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBnb3QgYW4gZXJyb3IsIHdyYXAgaXQgaW50byBhIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gREVCVUcgbG9nbGV2ZWwsIHByb2JhYmx5IHdlIHdhbnQgdG8gc2VlIHRoZSBmdWxsIGVycm9yIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0VuY291bnRlcmVkIGFuIGVycm9yIHdoZW4gc2VuZGluZyB0aGUgcmVxdWVzdC4gRGV0YWlsczogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZU5ldHdvcmtFcnJvcihFcnJvckNvZGVzLkVSUl9TRl9ORVRXT1JLX0NPVUxEX05PVF9DT05ORUNULCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVVuZXhwZWN0ZWRDb250ZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfU0ZfUkVTUE9OU0VfTk9UX0pTT04sICcoRU1QVFkpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXNwb25zZSwgJ3N0YXR1c0NvZGUnKSAmJlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIDIwMCwgdGhlIHJlcXVlc3QgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDEgJiYgcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb2RlID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlUmVxdWVzdEZhaWxlZEVycm9yKEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSFRUUCBFcnJvcjogJXMnLCByZXNwb25zZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lckNvZGUgPT09ICczOTAxMDQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVJlcXVlc3RGYWlsZWRFcnJvcihFcnJvckNvZGVzLkVSUl9TRl9SRVNQT05TRV9JTlZBTElEX1RPS0VOLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0hUVFAgRXJyb3I6ICVzJywgcmVzcG9uc2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlUmVxdWVzdEZhaWxlZEVycm9yKEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSFRUUCBFcnJvcjogJXMnLCByZXNwb25zZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVSZXF1ZXN0RmFpbGVkRXJyb3IoRXJyb3JDb2Rlcy5FUlJfU0ZfUkVTUE9OU0VfRkFJTFVSRSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0hUVFAgRXJyb3I6ICVzJywgcmVzcG9uc2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHN1Y2Nlc3MgZmxhZyBpcyBmYWxzZSwgdGhlIG9wZXJhdGlvbiB3ZSB0cmllZCB0byBwZXJmb3JtIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSAmJiAhYm9keS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYm9keS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChib2R5LmNvZGUgPT09IEdTRXJyb3JzLmNvZGUuSURfVE9LRU5fSU5WQUxJRCAmJiBhdXRoIGluc3RhbmNlb2YgQXV0aElEVG9rZW4pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJvZHkuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5PQVVUSF9UT0tFTl9FWFBJUkVEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGggaW5zdGFuY2VvZiBBdXRoT2F1dGhBdXRob3JpemF0aW9uQ29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSUQgVG9rZW4gYmVpbmcgdXNlZCBoYXMgZXhwaXJlZC4gUmVhdXRoZW50aWNhdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGF1dGgucmVhdXRoZW50aWNhdGUocmVxdWVzdE9wdGlvbnMuanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBDbGllbnQucmVxdWVzdChyZWFsUmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZU9wZXJhdGlvbkZhaWxlZEVycm9yKGJvZHkuY29kZSwgZGF0YSwgYm9keS5tZXNzYWdlLCBkYXRhICYmIGRhdGEuc3FsU3RhdGUgPyBkYXRhLnNxbFN0YXRlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFuIGVycm9yLCBjbGVhciB0aGUgYm9keVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBpbnZva2UgaXRcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHJlcXVlc3RPcHRpb25zLmNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXF1ZXN0T3B0aW9ucy5jYWxsYmFjay5hcHBseShyZXF1ZXN0T3B0aW9ucy5zY29wZSwgW2VyciwgYm9keSwgcmVzcG9uc2VdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMucmV0cnkgPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlc1BhcmFtID0gcmVxdWVzdE9wdGlvbnMudXJsLmluY2x1ZGVzKCc/Jyk7XG4gICAgICAgICAgICByZWFsUmVxdWVzdE9wdGlvbnMudXJsICs9IGluY2x1ZGVzUGFyYW0gPyAnJicgOiAnPyc7XG4gICAgICAgICAgICByZWFsUmVxdWVzdE9wdGlvbnMudXJsICs9XG4gICAgICAgICAgICAgICAgJ2NsaWVudFN0YXJ0VGltZT0nICtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuc3RhcnRUaW1lICtcbiAgICAgICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgJ3JldHJ5Q291bnQ9JyArXG4gICAgICAgICAgICAgICAgICAgIChyZXF1ZXN0T3B0aW9ucy5yZXRyeSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodHRwQ2xpZW50LnJlcXVlc3QocmVhbFJlcXVlc3RPcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlID0gb3B0aW9ucy5zbm93Zmxha2VTZXJ2aWNlO1xuICAgIHRoaXMuaHR0cENsaWVudCA9IG9wdGlvbnMuaHR0cENsaWVudDtcbiAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcgPSBvcHRpb25zLmNvbm5lY3Rpb25Db25maWc7XG4gICAgdGhpcy50b2tlbkluZm8gPSBvcHRpb25zLnRva2VuSW5mbztcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gb3B0aW9ucy5jb25uZWN0aW9uQ29uZmlnO1xuICAgIGNvbnN0IHNub3dmbGFrZVNlcnZpY2UgPSBvcHRpb25zLnNub3dmbGFrZVNlcnZpY2U7XG4gICAgY29uc3QgaHR0cENsaWVudCA9IG9wdGlvbnMuaHR0cENsaWVudDtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vICAgICAgICAgICAgICAgIFJlcXVlc3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVxdWVzdChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gcmVxdWVzdE9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG91dCB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kQXN5bmMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHByZS1wcm9jZXNzIHRoZSByZXF1ZXN0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5wcmVwcm9jZXNzT3B0aW9ucyh0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgLy8gaXNzdWUgdGhlIGh0dHAgcmVxdWVzdFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2VuZEh0dHBSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyLCBfYm9keSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCBodHRwQ2xpZW50LCBzbm93Zmxha2VTZXJ2aWNlLmdldEF1dGhlbnRpY2F0b3IoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkR3VpZFRvUGFyYW1zKHBhcmFtcykge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIHJlcGVhdGVkIHJlcXVlc3RzIGZvciB0aGUgc2FtZSByZXF1ZXN0IElELFxuICAgICAgICAvLyB0aGUgR2xvYmFsIFVJRCBpcyBhZGRlZCBmb3IgYmV0dGVyIHRyYWNlYWJpbGl0eS5cbiAgICAgICAgY29uc3QgZ3VpZCA9IHV1aWR2NCgpO1xuICAgICAgICBwYXJhbXNbc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfUkVRVUVTVF9HVUlEXSA9IGd1aWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG91dCB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBwcmUtcHJvY2VzcyB0aGUgcmVxdWVzdCBvcHRpb25zXG4gICAgICAgIHRoaXMucHJlcHJvY2Vzc09wdGlvbnModGhpcy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIC8vIGlzc3VlIHRoZSBodHRwIHJlcXVlc3RcbiAgICAgICAgc2VuZEh0dHBSZXF1ZXN0KHRoaXMucmVxdWVzdE9wdGlvbnMsIGh0dHBDbGllbnQsIHNub3dmbGFrZVNlcnZpY2UuZ2V0QXV0aGVudGljYXRvcigpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZS1wcm9jZXNzZXMgdGhlIHJlcXVlc3Qgb3B0aW9ucyBqdXN0IGJlZm9yZSB0aGUgcmVxdWVzdCBpcyBzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zXG4gICAgICovXG4gICAgUmVxdWVzdC5wcm90b3R5cGUucHJlcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgLy8gYXVnbWVudCB0aGUgaGVhZGVycyB3aXRoIHRoZSBkZWZhdWx0IHJlcXVlc3QgaGVhZGVyc1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gVXRpbC5hcHBseSh0aGlzLmdldERlZmF1bHRSZXFIZWFkZXJzKCksIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgfHwge30pO1xuICAgICAgICBpZiAoVXRpbC5pc0xvZ2luUmVxdWVzdChyZXF1ZXN0T3B0aW9ucy51cmwpKSB7XG4gICAgICAgICAgICBVdGlsLmFwcGx5KHJlcXVlc3RPcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBDTElFTlRfQVBQX1ZFUlNJT046IHJlcXVlc3RPcHRpb25zLmpzb24uZGF0YS5DTElFTlRfQVBQX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgQ0xJRU5UX0FQUF9JRDogcmVxdWVzdE9wdGlvbnMuanNvbi5kYXRhLkNMSUVOVF9BUFBfSUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdWdtZW50IHRoZSBvcHRpb25zIHdpdGggdGhlIGFic29sdXRlIHVybFxuICAgICAgICByZXF1ZXN0T3B0aW9ucy5hYnNvbHV0ZVVybCA9IHRoaXMuYnVpbGRGdWxsVXJsKHJlcXVlc3RPcHRpb25zLnVybCk7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmV4Y2x1ZGVHdWlkID0gIVV0aWwuZXhpc3RzKHJlcXVlc3RPcHRpb25zLmV4Y2x1ZGVHdWlkKVxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiByZXF1ZXN0T3B0aW9ucy5leGNsdWRlR3VpZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcmVsYXRpdmUgdXJsIHRvIGFuIGFic29sdXRlIHVybC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZVVybFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5idWlsZEZ1bGxVcmwgPSBmdW5jdGlvbiAocmVsYXRpdmVVcmwpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Db25maWcuYWNjZXNzVXJsICsgcmVsYXRpdmVVcmw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGhlYWRlcnMgdG8gc2VuZCB3aXRoIGV2ZXJ5IHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmdldERlZmF1bHRSZXFIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLyAgICAgICAgICAgICAgICBTZXNzaW9uVG9rZW5SZXF1ZXN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2Vzc2lvblRva2VuUmVxdWVzdCgpIHtcbiAgICAgICAgUmVxdWVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBVdGlsLmluaGVyaXRzKFNlc3Npb25Ub2tlblJlcXVlc3QsIFJlcXVlc3QpO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgU2Vzc2lvblRva2VuUmVxdWVzdC5wcm90b3R5cGUucHJlcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2FsbCBzdXBlclxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5wcmVwcm9jZXNzT3B0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyBhZGQgdGhlIGN1cnJlbnQgc2Vzc2lvbiB0b2tlbiB0byB0aGUgcmVxdWVzdCBoZWFkZXJzXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPVxuICAgICAgICAgICAgJ1Nub3dmbGFrZSBUb2tlbj1cIicgKyBvcHRpb25zLnRva2VuSW5mby5nZXRTZXNzaW9uVG9rZW4oKSArICdcIic7XG4gICAgICAgIGlmIChVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5TRVJWSUNFX05BTUUpKSkge1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snWC1Tbm93Zmxha2UtU2VydmljZSddID0gUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLlNFUlZJQ0VfTkFNRSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8gICAgICAgICAgICAgICAgTWFzdGVyVG9rZW5SZXF1ZXN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hc3RlclRva2VuUmVxdWVzdCgpIHtcbiAgICAgICAgUmVxdWVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBVdGlsLmluaGVyaXRzKE1hc3RlclRva2VuUmVxdWVzdCwgUmVxdWVzdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBNYXN0ZXJUb2tlblJlcXVlc3QucHJvdG90eXBlLnByZXByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIC8vIGNhbGwgc3VwZXJcbiAgICAgICAgUmVxdWVzdC5wcm90b3R5cGUucHJlcHJvY2Vzc09wdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgLy8gYWRkIHRoZSBjdXJyZW50IG1hc3RlciB0b2tlbiB0byB0aGUgcmVxdWVzdCBoZWFkZXJzXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPVxuICAgICAgICAgICAgJ1Nub3dmbGFrZSBUb2tlbj1cIicgKyBvcHRpb25zLnRva2VuSW5mby5nZXRNYXN0ZXJUb2tlbigpICsgJ1wiJztcbiAgICB9O1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8gICAgICAgICAgICAgICAgVW5hdXRoZW50aWNhdGVkUmVxdWVzdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVW5hdXRoZW50aWNhdGVkUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuYXV0aGVudGljYXRlZFJlcXVlc3QoKSB7XG4gICAgICAgIFJlcXVlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVXRpbC5pbmhlcml0cyhVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0LCBSZXF1ZXN0KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlc3Npb25Ub2tlblJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVTZXNzaW9uVG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2Vzc2lvblRva2VuUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hc3RlclRva2VuUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZU1hc3RlclRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc3RlclRva2VuUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFVuYXV0aGVudGljYXRlZFJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5hdXRoZW50aWNhdGVkUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbn1cbi8qKlxuICogRW50ZXJzIHRoaXMgc3RhdGUuXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4vKipcbiAqIEV4aXRzIHRoaXMgc3RhdGUuXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuZXhpdCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8qKlxuICogRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIFNub3dmbGFrZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8qKlxuICogSXNzdWVzIGEgY29ubmVjdC1jb250aW51ZSByZXF1ZXN0IHRvIFNub3dmbGFrZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuY29udGludWUgPSBmdW5jdGlvbiAoKSB7IH07XG4vKipcbiAqIElzc3VlcyBhIGdlbmVyaWMgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cblN0YXRlQWJzdHJhY3QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7IH07XG4vKipcbiAqIFRlcm1pbmF0ZXMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB0byBTbm93Zmxha2UuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cblN0YXRlQWJzdHJhY3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gICAgICAgICAgICAgICAgU3RhdGVQcmlzdGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBTdGF0ZVByaXN0aW5lKCkge1xuICAgIFN0YXRlQWJzdHJhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblV0aWwuaW5oZXJpdHMoU3RhdGVQcmlzdGluZSwgU3RhdGVBYnN0cmFjdCk7XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlUHJpc3RpbmUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHRyYW5zaXRpb24gdG8gdGhlIENvbm5lY3Rpbmcgc3RhdGUgd2l0aCB0aGUgY2FsbGJhY2sgaW4gdGhlIHRyYW5zaXRpb25cbiAgICAvLyBjb250ZXh0XG4gICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Nvbm5lY3Rpbmcoe1xuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIH0pO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVQcmlzdGluZS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9SRVFVRVNUX1NUQVRVU19QUklTVElORSkpO1xuICAgIH0pO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVQcmlzdGluZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gd2UncmUgc3RpbGwgaW4gdGhlIHByZWNvbm5lY3RlZCBzdGF0ZSBzbyBhbnlcbiAgICAvLyBhdHRlbXB0cyB0byBkZXN0cm95IHNob3VsZCByZXN1bHQgaW4gYW4gZXJyb3JcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX0RFU1RST1lfU1RBVFVTX1BSSVNUSU5FKSk7XG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vICAgICAgICAgICAgICAgIFN0YXRlQ29ubmVjdGluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gU3RhdGVDb25uZWN0aW5nKCkge1xuICAgIFN0YXRlQWJzdHJhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblV0aWwuaW5oZXJpdHMoU3RhdGVDb25uZWN0aW5nLCBTdGF0ZUFic3RyYWN0KTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgLy8gc2F2ZSB0aGUgY29udGV4dFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgLy8gaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb24gcHJvY2Vzc1xuICAgIHRoaXMuY29udGludWUoKTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGluZy5wcm90b3R5cGUuZXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhciB0aGUgY29udGV4dFxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG59O1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHdlJ3JlIGFscmVhZHkgY29ubmVjdGluZyBzbyBhbnkgYXR0ZW1wdHNcbiAgICAvLyB0byBjb25uZWN0IHNob3VsZCByZXN1bHQgaW4gYW4gZXJyb3JcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX0NPTk5FQ1RfU1RBVFVTX0NPTk5FQ1RJTkcpKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGluZy5wcm90b3R5cGUuY29udGludWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBlcnIgPSBjb250ZXh0Lm9wdGlvbnMuZXJyO1xuICAgIGxldCBqc29uID0gY29udGV4dC5vcHRpb25zLmpzb247XG4gICAgLy8gaWYgbm8ganNvbiB3YXMgc3BlY2lmaWVkLCB0cmVhdCB0aGlzIGFzIHRoZSBmaXJzdCBjb25uZWN0XG4gICAgLy8gYW5kIGdldCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIGZyb20gY29ubmVjdGlvbkNvbmZpZ1xuICAgIGlmICghanNvbikge1xuICAgICAgICBqc29uID0ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIEFDQ09VTlRfTkFNRTogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmFjY291bnQsXG4gICAgICAgICAgICAgICAgTE9HSU5fTkFNRTogdGhpcy5jb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIFBBU1NXT1JEOiB0aGlzLmNvbm5lY3Rpb25Db25maWcucGFzc3dvcmQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBleHRyYWN0IHRoZSBpbmZsaWdodCBjb250ZXh0IGZyb20gdGhlIGVycm9yIGFuZCBwdXQgaXQgYmFjayBpbiB0aGUganNvblxuICAgIGlmIChlcnIgJiYgZXJyLmRhdGEgJiYgZXJyLmRhdGEuaW5GbGlnaHRDdHgpIHtcbiAgICAgICAganNvbi5pbkZsaWdodEN0eCA9IGVyci5kYXRhLmluRmxpZ2h0Q3R4O1xuICAgIH1cbiAgICAvLyBpbml0aWFsaXplIHRoZSBqc29uIGRhdGEgaWYgbmVjZXNzYXJ5XG4gICAganNvbi5kYXRhID0ganNvbi5kYXRhIHx8IHt9O1xuICAgIC8vIGFkZCB0aGUgY2xpZW50LWFwcC1pZCwgY2xpZW50LWFwcC12ZXJzaW9uLCBhbmQgY2xpZW50LWFwcC1uYW1lXG4gICAgY29uc3QgY2xpZW50SW5mbyA9IHtcbiAgICAgICAgQ0xJRU5UX0FQUF9JRDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFR5cGUoKSxcbiAgICAgICAgQ0xJRU5UX0FQUF9WRVJTSU9OOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VmVyc2lvbigpLFxuICAgIH07XG4gICAgLy8gaWYgd2UgaGF2ZSBzb21lIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnQgZW52aXJvbm1lbnQsIGFkZCBpdCBhcyB3ZWxsXG4gICAgY29uc3QgY2xpZW50RW52aXJvbm1lbnQgPSB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50RW52aXJvbm1lbnQoKTtcbiAgICBpZiAoVXRpbC5pc09iamVjdChjbGllbnRFbnZpcm9ubWVudCkpIHtcbiAgICAgICAgY2xpZW50SW5mby5DTElFTlRfRU5WSVJPTk1FTlQgPSB7XG4gICAgICAgICAgICBDRVJUX1JFVk9DQVRJT05fQ0hFQ0tfTU9ERTogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmNybFZhbGlkYXRvckNvbmZpZy5jaGVja01vZGUsXG4gICAgICAgICAgICAuLi5qc29uLmRhdGEuQ0xJRU5UX0VOVklST05NRU5ULFxuICAgICAgICAgICAgLi4uY2xpZW50RW52aXJvbm1lbnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudEFwcGxpY2F0aW9uID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudEFwcGxpY2F0aW9uKCk7XG4gICAgaWYgKFV0aWwuaXNTdHJpbmcoY2xpZW50QXBwbGljYXRpb24pKSB7XG4gICAgICAgIGNsaWVudEVudmlyb25tZW50WydBUFBMSUNBVElPTiddID0gY2xpZW50QXBwbGljYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHNlc3Npb25QYXJhbWV0ZXJzID0ge1xuICAgICAgICBTRVNTSU9OX1BBUkFNRVRFUlM6IHt9LFxuICAgIH07XG4gICAgaWYgKFV0aWwuZXhpc3RzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlKCkpKSB7XG4gICAgICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFID1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlKCk7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSgpKSkge1xuICAgICAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZID1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5KCk7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCgpKSkge1xuICAgICAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQgPVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldEpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQoKTtcbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRHY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCgpKSkge1xuICAgICAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuR0NTX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgPVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldEdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsKCk7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50UmVxdWVzdE1GQVRva2VuKCkpKSB7XG4gICAgICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5DTElFTlRfUkVRVUVTVF9NRkFfVE9LRU4gPVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFJlcXVlc3RNRkFUb2tlbigpO1xuICAgIH1cbiAgICBpZiAoVXRpbC5leGlzdHModGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCgpKSkge1xuICAgICAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuQ0xJRU5UX1NUT1JFX1RFTVBPUkFSWV9DUkVERU5USUFMID1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKTtcbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5xdWVyeVRhZykpIHtcbiAgICAgICAgc2Vzc2lvblBhcmFtZXRlcnMuU0VTU0lPTl9QQVJBTUVURVJTLlFVRVJZX1RBRyA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5xdWVyeVRhZztcbiAgICB9XG4gICAgVXRpbC5hcHBseShqc29uLmRhdGEsIGNsaWVudEluZm8pO1xuICAgIFV0aWwuYXBwbHkoanNvbi5kYXRhLCBzZXNzaW9uUGFyYW1ldGVycyk7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZztcbiAgICBjb25zdCBtYXhMb2dpblJldHJpZXMgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5U2ZNYXhMb2dpblJldHJpZXMoKTtcbiAgICBjb25zdCBtYXhSZXRyeVRpbWVvdXQgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5VGltZW91dCgpO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGNvbm5lY3Rpb25Db25maWcuYWNjZXNzVXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJylcbiAgICAgICAgPyBEYXRlLm5vdygpXG4gICAgICAgIDogJ0ZJWEVEVElNRVNUQU1QJztcbiAgICBsZXQgbnVtUmV0cmllcyA9IDA7XG4gICAgbGV0IHNsZWVwID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmU3RhcnRpbmdTbGVlcFRpbWUoKTtcbiAgICBsZXQgdG90YWxFbGFwc2VkVGltZSA9IDA7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1RvdGFsIHJldHJ5VGltZW91dCBpcyBmb3IgdGhlIHJldHJpZXMgPSAnICsgbWF4UmV0cnlUaW1lb3V0ID09PSAwXG4gICAgICAgID8gJ3VubGltaXRlZCdcbiAgICAgICAgOiBtYXhSZXRyeVRpbWVvdXQpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdENhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgICAgICAvLyBjbGVhciBjcmVkZW50aWFsLXJlbGF0ZWQgaW5mb3JtYXRpb25cbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5jbGVhckNyZWRlbnRpYWxzKCk7XG4gICAgICAgIC8vIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRlZFxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKGJvZHkpKTtcbiAgICAgICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmV4aXN0cyhib2R5LmRhdGEpKTtcbiAgICAgICAgICAgIHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLnNldFNlc3Npb25JZChib2R5LmRhdGEuc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBOZXcgc2Vzc2lvbiB3aXRoIGlkICR7cGFyZW50LnNub3dmbGFrZVNlcnZpY2UuZ2V0U2Vzc2lvbklkKCl9IGluaXRpYWxpemVkYCk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIFBhcmFtZXRlcnMudXBkYXRlKGJvZHkuZGF0YS5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBhbGwgdG9rZW4tcmVsYXRlZCBpbmZvcm1hdGlvblxuICAgICAgICAgICAgcGFyZW50LnRva2VuSW5mby51cGRhdGUoYm9keS5kYXRhKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFJlcXVlc3RNRkFUb2tlbigpICYmIGJvZHkuZGF0YS5tZmFUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IFV0aWwuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoY29ubmVjdGlvbkNvbmZpZy5ob3N0LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLlVTRVJfUFdEX01GQV9BVVRIRU5USUNBVE9SKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKS53cml0ZShrZXksIGJvZHkuZGF0YS5tZmFUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKSAmJiBib2R5LmRhdGEuaWRUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IFV0aWwuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoY29ubmVjdGlvbkNvbmZpZy5ob3N0LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLklEX1RPS0VOX0FVVEhFTlRJQ0FUT1IpO1xuICAgICAgICAgICAgICAgIGF3YWl0IEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLndyaXRlKGtleSwgYm9keS5kYXRhLmlkVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UncmUgbm93IGNvbm5lY3RlZFxuICAgICAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBjb25zdCBxY2NTaXplID0gUGFyYW1ldGVycy5nZXRWYWx1ZSgnUVVFUllfQ09OVEVYVF9DQUNIRV9TSVpFJyk7XG4gICAgICAgICAgICBwYXJlbnQuc25vd2ZsYWtlU2VydmljZS5pbml0aWFsaXplUXVlcnlDb250ZXh0Q2FjaGUocWNjU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoRXJyb3JzLmlzTmV0d29ya0Vycm9yKGVycikgfHwgRXJyb3JzLmlzUmVxdWVzdEZhaWxlZEVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtUmV0cmllcyA8IG1heExvZ2luUmV0cmllcyAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNSZXRyeWFibGVOZXR3b3JrRXJyb3IoZXJyKSB8fCBpc1JldHJ5YWJsZUh0dHBFcnJvcihlcnIpKSAmJlxuICAgICAgICAgICAgICAgICAgICAobWF4UmV0cnlUaW1lb3V0ID09PSAwIHx8IHRvdGFsRWxhcHNlZFRpbWUgPCBtYXhSZXRyeVRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVJldHJpZXMrKztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgaml0dGVyID0gVXRpbC5nZXRKaXR0ZXJlZFNsZWVwVGltZShudW1SZXRyaWVzLCBzbGVlcCwgdG90YWxFbGFwc2VkVGltZSwgbWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgc2xlZXAgPSBqaXR0ZXIuc2xlZXA7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsRWxhcHNlZFRpbWUgPSBqaXR0ZXIudG90YWxFbGFwc2VkVGltZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsZWVwIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdSZWFjaGVkIG91dCB0byB0aGUgbWF4IExvZ2luIFRpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGggPSBwYXJlbnQuc25vd2ZsYWtlU2VydmljZS5nZXRBdXRoZW50aWNhdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRoIGluc3RhbmNlb2YgQXV0aE9rdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdPS1RBIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIHRva2VuIHJlZnJlc2guJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeU9wdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVJldHJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aC5yZWF1dGhlbnRpY2F0ZShjb250ZXh0Lm9wdGlvbnMuanNvbiwgcmV0cnlPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUmV0cmllcyA9IHJldHJ5T3B0aW9uLm51bVJldHJpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEVsYXBzZWRUaW1lID0gcmV0cnlPcHRpb24udG90YWxFbGFwc2VkVGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhdXRoIGluc3RhbmNlb2YgQXV0aEtleXBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBdXRoS2V5UGFpciBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyB0b2tlbiByZWZyZXNoLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aC5yZWF1dGhlbnRpY2F0ZShjb250ZXh0Lm9wdGlvbnMuanNvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChzZW5kUmVxdWVzdCwgc2xlZXAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBhbGwgcmV0cmllcyB0byBTRi4nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgbm93IGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBub3cgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW52b2tlIHRoZSB0cmFuc2l0aW9uLWNvbnRleHQgY2FsbGJhY2sgdGhhdCB3YXMgcGFzc2VkIHRvIHVzIGJ5IHRoZVxuICAgICAgICAvLyBQcmlzdGluZSBzdGF0ZSBvbiBjb25uZWN0KClcbiAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjb250ZXh0Lm9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGwgcXVldWVkIG9wZXJhdGlvbnMgYXJlIG5vdyBmcmVlIHRvIGdvXG4gICAgICAgIHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLmRyYWluT3BlcmF0aW9uUXVldWUoKTtcbiAgICB9O1xuICAgIC8vIGlzc3VlIGEgbG9naW4gcmVxdWVzdFxuICAgIGNvbnN0IHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRVcmwgPSBidWlsZExvZ2luVXJsKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29udGFjdGluZyBTRjogJXMsICglcy8lcyknLCB0YXJnZXRVcmwsIG51bVJldHJpZXMsIG1heExvZ2luUmV0cmllcyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBwYXJlbnQuY3JlYXRlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogdGFyZ2V0VXJsLFxuICAgICAgICAgICAganNvbjoganNvbixcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgICAgICByZXRyeTogbnVtUmV0cmllcyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiByZXF1ZXN0Q2FsbGJhY2ssXG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9O1xuICAgIHNlbmRSZXF1ZXN0KCk7XG59O1xuLyoqXG4gKiBCdWlsZHMgdGhlIHVybCBmb3IgYSBsb2dpbiByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTG9naW5VcmwoY29ubmVjdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gW1xuICAgICAgICB7IG5hbWU6ICd3YXJlaG91c2UnLCB2YWx1ZTogY29ubmVjdGlvbkNvbmZpZy5nZXRXYXJlaG91c2UoKSB9LFxuICAgICAgICB7IG5hbWU6ICdkYXRhYmFzZU5hbWUnLCB2YWx1ZTogY29ubmVjdGlvbkNvbmZpZy5nZXREYXRhYmFzZSgpIH0sXG4gICAgICAgIHsgbmFtZTogJ3NjaGVtYU5hbWUnLCB2YWx1ZTogY29ubmVjdGlvbkNvbmZpZy5nZXRTY2hlbWEoKSB9LFxuICAgICAgICB7IG5hbWU6ICdyb2xlTmFtZScsIHZhbHVlOiBjb25uZWN0aW9uQ29uZmlnLmdldFJvbGUoKSB9LFxuICAgIF07XG4gICAgY29uc3QgcXVlcnlTdHJpbmdPYmplY3QgPSB7fTtcbiAgICBpZiAoIWNvbm5lY3Rpb25Db25maWcuaXNRYU1vZGUoKSkge1xuICAgICAgICAvLyBObyByZXF1ZXN0SWQgaXMgYXR0YWNoZWQgdG8gbG9naW4tcmVxdWVzdCBpbiB0ZXN0IG1vZGUuXG4gICAgICAgIHF1ZXJ5U3RyaW5nT2JqZWN0LnJlcXVlc3RJZCA9IHV1aWR2NCgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHF1ZXJ5UGFyYW1zLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbSA9IHF1ZXJ5UGFyYW1zW2luZGV4XTtcbiAgICAgICAgaWYgKFV0aWwuc3RyaW5nLmlzTm90TnVsbE9yRW1wdHkocXVlcnlQYXJhbS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nT2JqZWN0W3F1ZXJ5UGFyYW0ubmFtZV0gPSBxdWVyeVBhcmFtLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVcmwuZm9ybWF0KHtcbiAgICAgICAgcGF0aG5hbWU6ICcvc2Vzc2lvbi92MS9sb2dpbi1yZXF1ZXN0JyxcbiAgICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkocXVlcnlTdHJpbmdPYmplY3QpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RpbmcucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGVucXVldWUgdGhlIHJlcXVlc3Qgb3BlcmF0aW9uXG4gICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmVucXVldWVSZXF1ZXN0KG9wdGlvbnMpO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBlbnF1ZXVlIHRoZSBkZXN0cm95IG9wZXJhdGlvblxuICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS5lbnF1ZXVlRGVzdHJveShvcHRpb25zKTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gICAgICAgICAgICAgICAgU3RhdGVDb25uZWN0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBTdGF0ZUNvbm5lY3RlZCgpIHtcbiAgICBTdGF0ZUFic3RyYWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5VdGlsLmluaGVyaXRzKFN0YXRlQ29ubmVjdGVkLCBTdGF0ZUFic3RyYWN0KTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0ZWQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkIHNvIGFueSBhdHRlbXB0c1xuICAgIC8vIHRvIGNvbm5lY3Qgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfQ09OTkVDVEVEKSk7XG4gICAgfSk7XG59O1xuU3RhdGVDb25uZWN0ZWQucHJvdG90eXBlLnJlcXVlc3RBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gY3JlYXRlIGEgc2Vzc2lvbiB0b2tlbiByZXF1ZXN0IGZyb20gdGhlIG9wdGlvbnMgYW5kIHNlbmQgb3V0IHRoZSByZXF1ZXN0XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlU2Vzc2lvblRva2VuUmVxdWVzdChvcHRpb25zKS5zZW5kQXN5bmMoKTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGVkLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzY29wZU9yaWcgPSBvcHRpb25zLnNjb3BlO1xuICAgIGNvbnN0IGNhbGxiYWNrT3JpZyA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgLy8gZGVmaW5lIG91ciBvd24gc2NvcGUgYW5kIGNhbGxiYWNrXG4gICAgb3B0aW9ucy5zY29wZSA9IHRoaXM7XG4gICAgb3B0aW9ucy5jYWxsYmFjayA9IGFzeW5jIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIGVycm9yLCBpbnZva2UgdGhlIGNhbGxiYWNrIGlmIG9uZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrT3JpZykpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjYWxsYmFja09yaWcuYXBwbHkoc2NvcGVPcmlnLCBbZXJyLCBib2R5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCBzY29wZSBhbmQgY2FsbGJhY2sgdG8gdGhlIG9wdGlvbnMgb2JqZWN0IGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIG1pZ2h0IG5lZWQgdG8gcmVwZWF0IHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlID0gc2NvcGVPcmlnO1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrT3JpZztcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzZXNzaW9uIHRva2VuIGhhcyBleHBpcmVkXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEdTRXJyb3JzLmNvZGUuU0VTU0lPTl9UT0tFTl9FWFBJUkVEKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5xdWV1ZSB0aGUgcmVxdWVzdCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZW5xdWV1ZVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgYSBzZXNzaW9uIHRva2VuIHJlbmV3YWwgaXNuJ3QgYWxyZWFkeSBpbiBwcm9ncmVzcywgaXNzdWUgYVxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgdG8gcmVuZXcgdGhlIHNlc3Npb24gdG9rZW5cbiAgICAgICAgICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvUmVuZXdpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLlNFU1NJT05fVE9LRU5fSU5WQUxJRCB8fFxuICAgICAgICAgICAgICAgIGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLkdPTkVfU0VTU0lPTikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzZXNzaW9uIHRva2VuIGlzIGludmFsaWQgb3IgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgICAgIC8vIGVucXVldWUgdGhlIHJlcXVlc3Qgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmVucXVldWVSZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAvLyBhbGwgcXVldWVkIG9wZXJhdGlvbnMgYXJlIG5vdyBmcmVlIHRvIGdvXG4gICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmRyYWluT3BlcmF0aW9uUXVldWUoKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1lbWJlciB0aGF0IGEgc2Vzc2lvbiByZW5ld2FsIGlzIG5vIGxvbmdlciBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2Ugc3VyZSB0aGUgbGFzdCBzZXNzaW9uIHJlbmV3YWwgZGlkIG5vdCB0aW1lIG91dFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaXQncyBhIG5vcm1hbCBmYWlsdXJlXG4gICAgICAgICAgICAgICAgLy8gaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBpbnZva2UgaXRcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrT3JpZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tPcmlnLmFwcGx5KHNjb3BlT3JpZywgW2VyciwgYm9keV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gY3JlYXRlIGEgc2Vzc2lvbiB0b2tlbiByZXF1ZXN0IGZyb20gdGhlIG9wdGlvbnMgYW5kIHNlbmQgb3V0IHRoZSByZXF1ZXN0XG4gICAgdGhpcy5jcmVhdGVTZXNzaW9uVG9rZW5SZXF1ZXN0KG9wdGlvbnMpLnNlbmQoKTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGVkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXF1ZXN0SUQgPSB1dWlkdjQoKTtcbiAgICAvLyBzZW5kIG91dCBhIHNlc3Npb24gdG9rZW4gcmVxdWVzdCB0byB0ZXJtaW5hdGUgdGhlIGN1cnJlbnQgY29ubmVjdGlvblxuICAgIHRoaXMuY3JlYXRlU2Vzc2lvblRva2VuUmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB1cmw6IGAvc2Vzc2lvbj9kZWxldGU9dHJ1ZSZyZXF1ZXN0SWQ9JHtyZXF1ZXN0SUR9YCxcbiAgICAgICAgc2NvcGU6IHRoaXMsXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZGVzdHJveSByZXF1ZXN0IHN1Y2NlZWRlZCBvciB0aGUgc2Vzc2lvbiBhbHJlYWR5IGV4cGlyZWQsIHdlJ3JlIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKCFlcnIgfHxcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5HT05FX1NFU1NJT04gfHxcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5TRVNTSU9OX1RPS0VOX0VYUElSRUQpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBvcmlnaW5hbCBjYWxsYmFja1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIpO1xuICAgICAgICB9LFxuICAgIH0pLnNlbmQoKTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gICAgICAgICAgICAgICAgU3RhdGVSZW5ld2luZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBTdGF0ZVJlbmV3aW5nKCkge1xuICAgIFN0YXRlQWJzdHJhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblV0aWwuaW5oZXJpdHMoU3RhdGVSZW5ld2luZywgU3RhdGVBYnN0cmFjdCk7XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlUmVuZXdpbmcucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNlbmQgb3V0IGEgbWFzdGVyIHRva2VuIHJlcXVlc3QgdG8gcmVuZXcgdGhlIGN1cnJlbnQgc2Vzc2lvbiB0b2tlblxuICAgIHRoaXMuY3JlYXRlTWFzdGVyVG9rZW5SZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHVybDogJy9zZXNzaW9uL3Rva2VuLXJlcXVlc3QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBDTElFTlRfQVBQX0lEOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLFxuICAgICAgICAgICAgQ0xJRU5UX0FQUF9WRVJTSU9OOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VmVyc2lvbigpLFxuICAgICAgICB9LFxuICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICBSRVFVRVNUX1RZUEU6ICdSRU5FVycsXG4gICAgICAgICAgICBvbGRTZXNzaW9uVG9rZW46IHRoaXMudG9rZW5JbmZvLmdldFNlc3Npb25Ub2tlbigpLFxuICAgICAgICB9LFxuICAgICAgICBzY29wZTogdGhpcyxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRlZFxuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHRva2VuIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbkluZm8udXBkYXRlKGJvZHkuZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgbm93IGNvbm5lY3RlZCBhZ2FpblxuICAgICAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9Db25uZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBtYXN0ZXIgdG9rZW4gaGFzIGV4cGlyZWQsIHRyYW5zaXRpb24gdG8gdGhlIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIC8vIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLk1BU1RFUl9UT0tFTl9FWFBJUkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoRXJyb3JzLmlzTmV0d29ya0Vycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ28gYmFjayB0byB0aGUgY29ubmVjdGVkIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9Db25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZW5ld2FsIGZhaWxlZCBmb3Igc29tZSBvdGhlciByZWFzb24sIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IHNob3VsZCBvdXIgc3RhdGUgYmUgaGVyZT8gYWxzbyBkaXNjb25uZWN0ZWQ/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbGwgcXVldWVkIG9wZXJhdGlvbnMgYXJlIG5vdyBmcmVlIHRvIGdvXG4gICAgICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZHJhaW5PcGVyYXRpb25RdWV1ZSgpO1xuICAgICAgICB9LFxuICAgIH0pLnNlbmQoKTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlUmVuZXdpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHdlJ3JlIHJlbmV3aW5nIHRoZSBzZXNzaW9uIHRva2VuLCB3aGljaCBtZWFucyB3ZSdyZSBjb25uZWN0ZWQsXG4gICAgLy8gc28gYW55IGF0dGVtcHRzIHRvIGNvbm5lY3Qgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfQ09OTkVDVEVEKSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZVJlbmV3aW5nLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBlbnF1ZXVlIHRoZSByZXF1ZXN0IG9wZXJhdGlvblxuICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS5lbnF1ZXVlUmVxdWVzdChvcHRpb25zKTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlUmVuZXdpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGVucXVldWUgdGhlIGRlc3Ryb3kgb3BlcmF0aW9uXG4gICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmVucXVldWVEZXN0cm95KG9wdGlvbnMpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZURpc2Nvbm5lY3RlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIFN0YXRlRGlzY29ubmVjdGVkKCkge1xuICAgIFN0YXRlQWJzdHJhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblV0aWwuaW5oZXJpdHMoU3RhdGVEaXNjb25uZWN0ZWQsIFN0YXRlQWJzdHJhY3QpO1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZURpc2Nvbm5lY3RlZC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gd2UncmUgZGlzY29ubmVjdGVkIC0tIGFuZCBmYXRhbGx5IHNvIC0tIHNvIGFueVxuICAgIC8vIGF0dGVtcHRzIHRvIGNvbm5lY3Qgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfRElTQ09OTkVDVEVEKSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZURpc2Nvbm5lY3RlZC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gd2UncmUgZGlzY29ubmVjdGVkLCBzbyBhbnkgYXR0ZW1wdHMgdG9cbiAgICAvLyBzZW5kIGEgcmVxdWVzdCBzaG91bGQgcmVzdWx0IGluIGFuIGVycm9yXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9SRVFVRVNUX1NUQVRVU19ESVNDT05ORUNURUQsIHRydWUpKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlRGlzY29ubmVjdGVkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyB3ZSdyZSBhbHJlYWR5IGRpc2Nvbm5lY3RlZCBzbyBhbnkgYXR0ZW1wdHNcbiAgICAvLyB0byBkZXN0cm95IHNob3VsZCByZXN1bHQgaW4gYW4gZXJyb3JcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX0RFU1RST1lfU1RBVFVTX0RJU0NPTk5FQ1RFRCkpO1xuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuSW5mbyBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgYWxsIHRva2VuLXJlbGF0ZWQgaW5mb3JtYXRpb24sXG4gKiBlLmcuIHRoZSBtYXN0ZXIgdG9rZW4sIHRoZSBzZXNzaW9uIHRva2VuLCB0aGUgdG9rZW5zJyBleHBpcmF0aW9uIHRpbWVzLCBldGMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRva2VuSW5mbyhjb25maWcpIHtcbiAgICBsZXQgbWFzdGVyVG9rZW47XG4gICAgbGV0IHNlc3Npb25Ub2tlbjtcbiAgICBsZXQgbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICBsZXQgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKFV0aWwuaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgICBtYXN0ZXJUb2tlbiA9IGNvbmZpZy5tYXN0ZXJUb2tlbjtcbiAgICAgICAgc2Vzc2lvblRva2VuID0gY29uZmlnLnNlc3Npb25Ub2tlbjtcbiAgICAgICAgbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IGNvbmZpZy5tYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lO1xuICAgICAgICBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA9IGNvbmZpZy5zZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG5vIHRva2VuLXJlbGF0ZWQgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoIVV0aWwuZXhpc3RzKG1hc3RlclRva2VuKSB8fFxuICAgICAgICAgICAgIVV0aWwuZXhpc3RzKG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUpIHx8XG4gICAgICAgICAgICAhVXRpbC5leGlzdHMoc2Vzc2lvblRva2VuKSB8fFxuICAgICAgICAgICAgIVV0aWwuZXhpc3RzKHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHRva2VuLXJlbGF0ZWQgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgdGhpcy5jbGVhclRva2VucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWFzdGVyVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlc3Npb25Ub2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0b2tlbnMgYW5kIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgbWFzdGVyVG9rZW4gPSBkYXRhLm1hc3RlclRva2VuO1xuICAgICAgICBzZXNzaW9uVG9rZW4gPSBkYXRhLnRva2VuIHx8IGRhdGEuc2Vzc2lvblRva2VuO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lID1cbiAgICAgICAgICAgIGN1cnJlbnRUaW1lICsgMTAwMCAqIChkYXRhLm1hc3RlclZhbGlkaXR5SW5TZWNvbmRzIHx8IGRhdGEudmFsaWRpdHlJblNlY29uZHNNVCk7XG4gICAgICAgIHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lID1cbiAgICAgICAgICAgIGN1cnJlbnRUaW1lICsgMTAwMCAqIChkYXRhLnZhbGlkaXR5SW5TZWNvbmRzIHx8IGRhdGEudmFsaWRpdHlJblNlY29uZHNTVCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXN0ZXIgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TWFzdGVyVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtYXN0ZXJUb2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4cGlyYXRpb24gdGltZSBvZiB0aGUgbWFzdGVyIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldE1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Vzc2lvbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRTZXNzaW9uVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uVG9rZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBleHBpcmF0aW9uIHRpbWUgb2YgdGhlIHNlc3Npb24gdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFRva2VuSW5mb1xuICAgICAqIGNvbnN0cnVjdG9yIHRvIGdldCBhbiBlcXVpdmFsZW50IFRva2VuSW5mbyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFzdGVyVG9rZW46IG1hc3RlclRva2VuLFxuICAgICAgICAgICAgbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZTogbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSxcbiAgICAgICAgICAgIHNlc3Npb25Ub2tlbjogc2Vzc2lvblRva2VuLFxuICAgICAgICAgICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU6IHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lLFxuICAgICAgICB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/services/sf.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/snowflake.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/snowflake.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/core.js\");\nconst Util = __importStar(__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\"));\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst clientEnvironment = process.versions;\n// if we're not using the minimum supported version of node.js, raise an error\nconst minimumNodeVersion = '6.0.0';\nif (Util.string.compareVersions(clientEnvironment.node, minimumNodeVersion) < 0) {\n    throw (0, errors_1.createClientError)(errors_1.codes.ERR_UNSUPPORTED_NODE_JS_VERSION, true, minimumNodeVersion);\n}\nmodule.exports = core({\n    httpClientClass: (__webpack_require__(/*! ./http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\").NodeHttpClient),\n    loggerClass: __webpack_require__(/*! ./logger/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/node.js\"),\n    client: {\n        version: Util.driverVersion,\n        name: Util.driverName,\n        environment: clientEnvironment,\n    },\n});\n//# sourceMappingURL=snowflake.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zbm93Zmxha2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1FQUFRO0FBQzdCLDBCQUEwQixtQkFBTyxDQUFDLG1FQUFRO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1IQUFxQztBQUMxRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL3Nub3dmbGFrZS5qcz80ZTFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5jb25zdCBVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBjbGllbnRFbnZpcm9ubWVudCA9IHByb2Nlc3MudmVyc2lvbnM7XG4vLyBpZiB3ZSdyZSBub3QgdXNpbmcgdGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb24gb2Ygbm9kZS5qcywgcmFpc2UgYW4gZXJyb3JcbmNvbnN0IG1pbmltdW1Ob2RlVmVyc2lvbiA9ICc2LjAuMCc7XG5pZiAoVXRpbC5zdHJpbmcuY29tcGFyZVZlcnNpb25zKGNsaWVudEVudmlyb25tZW50Lm5vZGUsIG1pbmltdW1Ob2RlVmVyc2lvbikgPCAwKSB7XG4gICAgdGhyb3cgKDAsIGVycm9yc18xLmNyZWF0ZUNsaWVudEVycm9yKShlcnJvcnNfMS5jb2Rlcy5FUlJfVU5TVVBQT1JURURfTk9ERV9KU19WRVJTSU9OLCB0cnVlLCBtaW5pbXVtTm9kZVZlcnNpb24pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBjb3JlKHtcbiAgICBodHRwQ2xpZW50Q2xhc3M6IHJlcXVpcmUoJy4vaHR0cC9ub2RlJykuTm9kZUh0dHBDbGllbnQsXG4gICAgbG9nZ2VyQ2xhc3M6IHJlcXVpcmUoJy4vbG9nZ2VyL25vZGUnKSxcbiAgICBjbGllbnQ6IHtcbiAgICAgICAgdmVyc2lvbjogVXRpbC5kcml2ZXJWZXJzaW9uLFxuICAgICAgICBuYW1lOiBVdGlsLmRyaXZlck5hbWUsXG4gICAgICAgIGVudmlyb25tZW50OiBjbGllbnRFbnZpcm9ubWVudCxcbiAgICB9LFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbm93Zmxha2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/snowflake.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/url_util.js":
/*!*********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/url_util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * Determines if a given URL is valid.\n *\n * @param url\n *\n * @returns {Boolean}\n */\nexports.isValidURL = function (url) {\n    const regex = '^http(s?)\\\\:\\\\/\\\\/[0-9a-zA-Z]([-.\\\\w]*[0-9a-zA-Z@:])*(:(0-9)*)*(\\\\/?)([a-zA-Z0-9\\\\-\\\\.\\\\?\\\\,\\\\&\\\\(\\\\)\\\\/\\\\\\\\\\\\+&%\\\\$#_=@]*)?$';\n    if (!url.match(regex)) {\n        Logger.getInstance().debug('The provided URL is not a valid URL. URL: %s', url);\n        return false;\n    }\n    return true;\n};\n/**\n * Encodes the given URL.\n *\n * @param {String} url\n *\n * @returns {String} the encoded URL\n */\nexports.urlEncode = function (url) {\n    /** The encodeURIComponent() method encodes special characters including: , / ? : @ & = + $ #\n       but escapes space as %20B. Replace with + for consistency across drivers. */\n    return encodeURIComponent(url).replace(/%20/g, '+');\n};\n//# sourceMappingURL=url_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi91cmxfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL3VybF91dGlsLmpzP2M3MzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gVVJMIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB1cmxcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkVVJMID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGNvbnN0IHJlZ2V4ID0gJ15odHRwKHM/KVxcXFw6XFxcXC9cXFxcL1swLTlhLXpBLVpdKFstLlxcXFx3XSpbMC05YS16QS1aQDpdKSooOigwLTkpKikqKFxcXFwvPykoW2EtekEtWjAtOVxcXFwtXFxcXC5cXFxcP1xcXFwsXFxcXCZcXFxcKFxcXFwpXFxcXC9cXFxcXFxcXFxcXFwrJiVcXFxcJCNfPUBdKik/JCc7XG4gICAgaWYgKCF1cmwubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdUaGUgcHJvdmlkZWQgVVJMIGlzIG5vdCBhIHZhbGlkIFVSTC4gVVJMOiAlcycsIHVybCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBVUkwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBlbmNvZGVkIFVSTFxuICovXG5leHBvcnRzLnVybEVuY29kZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAvKiogVGhlIGVuY29kZVVSSUNvbXBvbmVudCgpIG1ldGhvZCBlbmNvZGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbmNsdWRpbmc6ICwgLyA/IDogQCAmID0gKyAkICNcbiAgICAgICBidXQgZXNjYXBlcyBzcGFjZSBhcyAlMjBCLiBSZXBsYWNlIHdpdGggKyBmb3IgY29uc2lzdGVuY3kgYWNyb3NzIGRyaXZlcnMuICovXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh1cmwpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybF91dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/url_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/util.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.url = exports.string = exports.number = exports.userAgent = exports.driverVersion = exports.driverName = void 0;\nexports.inherits = inherits;\nexports.format = format;\nexports.isFunction = isFunction;\nexports.isObject = isObject;\nexports.isDate = isDate;\nexports.isArray = isArray;\nexports.isString = isString;\nexports.isBoolean = isBoolean;\nexports.isNumber = isNumber;\nexports.isPrivateKey = isPrivateKey;\nexports.exists = exists;\nexports.apply = apply;\nexports.isBrowser = isBrowser;\nexports.isNode = isNode;\nexports.nextSleepTime = nextSleepTime;\nexports.getJitteredSleepTime = getJitteredSleepTime;\nexports.chooseRandom = chooseRandom;\nexports.getNextSleepTime = getNextSleepTime;\nexports.getJitter = getJitter;\nexports.isLoginRequest = isLoginRequest;\nexports.isRetryableHttpError = isRetryableHttpError;\nexports.validateClientSessionKeepAliveHeartbeatFrequency = validateClientSessionKeepAliveHeartbeatFrequency;\nexports.constructHostname = constructHostname;\nexports.isPrivateLink = isPrivateLink;\nexports.createOcspResponseCacheServerUrl = createOcspResponseCacheServerUrl;\nexports.isPutCommand = isPutCommand;\nexports.isGetCommand = isGetCommand;\nexports.convertSmkIdToString = convertSmkIdToString;\nexports.getCircularReplacer = getCircularReplacer;\nexports.isCorrectSubdomain = isCorrectSubdomain;\nexports.buildCredentialCacheKey = buildCredentialCacheKey;\nexports.checkValidCustomCredentialManager = checkValidCustomCredentialManager;\nexports.checkParametersDefined = checkParametersDefined;\nexports.isFileModeCorrect = isFileModeCorrect;\nexports.isFileNotWritableByGroupOrOthers = isFileNotWritableByGroupOrOthers;\nexports.shouldRetryOktaAuth = shouldRetryOktaAuth;\nexports.getDriverDirectory = getDriverDirectory;\nexports.validatePath = validatePath;\nexports.getEnvVar = getEnvVar;\nexports.validateEmptyString = validateEmptyString;\nexports.isNotEmptyAsString = isNotEmptyAsString;\nexports.isNotEmptyString = isNotEmptyString;\nexports.isEmptyObject = isEmptyObject;\nexports.isWindows = isWindows;\nexports.getFreePort = getFreePort;\nexports.isPortOpen = isPortOpen;\nexports.lstrip = lstrip;\nexports.escapeHTML = escapeHTML;\nexports.dynamicImportESMInTypescriptWithCommonJS = dynamicImportESMInTypescriptWithCommonJS;\nconst util_1 = __importDefault(__webpack_require__(/*! util */ \"util\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst os_1 = __importDefault(__webpack_require__(/*! os */ \"os\"));\nconst Logger = __importStar(__webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\n// NOTE: keeping require as it's a circular dependency so * as Errors doesn't work\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst package_json_1 = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/snowflake-sdk/dist/package.json\");\nObject.defineProperty(exports, \"driverName\", ({ enumerable: true, get: function () { return package_json_1.name; } }));\nObject.defineProperty(exports, \"driverVersion\", ({ enumerable: true, get: function () { return package_json_1.version; } }));\nconst nodeJSVersion = process.version?.startsWith('v')\n    ? process.version.substring(1)\n    : process.version;\nexports.userAgent = `JavaScript/${package_json_1.version} (${process.platform}-${process.arch}) NodeJS/${nodeJSVersion}`;\n/**\n * Note: A simple wrapper around util.inherits() for now, but this might change\n * in the future.\n *\n * Inherits the prototype methods from one constructor into another. The\n * prototype of constructor will be set to a new object created from\n * superConstructor.\n *\n * @param constructor\n * @param superConstructor\n *\n * @returns {Object}\n */\nfunction inherits(constructor, superConstructor) {\n    return util_1.default.inherits.apply(util_1.default, [constructor, superConstructor]);\n}\n/**\n * Note: A simple wrapper around util.format() for now, but this will likely\n * change in the future.\n *\n * Returns a formatted string using the first argument as a printf-like format.\n *\n * The first argument is a string that contains zero or more placeholders.\n * Each placeholder is replaced with the converted value from its corresponding\n * argument. Supported placeholders are:\n *   %s - String.\n *   %d - Number (both integer and float).\n *   %j - JSON. Replaced with the string '[Circular]' if the argument contains\n *        circular references.\n *   %% - single percent sign ('%'). This does not consume an argument.\n *\n * If the placeholder does not have a corresponding argument, the placeholder is\n * not replaced.\n *\n * If there are more arguments than placeholders, the extra arguments are\n * coerced to strings (for objects and symbols, util.inspect() is used) and then\n * concatenated, delimited by a space.\n *\n * If the first argument is not a format string then util.format() returns a\n * string that is the concatenation of all its arguments separated by spaces.\n * Each argument is converted to a string with util.inspect().\n */\nfunction format(format, ...params) {\n    return util_1.default.format.apply(util_1.default, [format, ...params]);\n}\n/**\n * Determines if a given value is a function.\n */\nfunction isFunction(value) {\n    return !!value && typeof value === 'function';\n}\nconst toString = Object.prototype.toString;\n/**\n * Determines if a given value is an object.\n */\nfunction isObject(value) {\n    return toString.call(value) === '[object Object]';\n}\n/**\n * Determines if a given value is a Date.\n */\nfunction isDate(value) {\n    return toString.call(value) === '[object Date]';\n}\n/**\n * Determines if a given value is an array.\n */\nfunction isArray(value) {\n    return toString.call(value) === '[object Array]';\n}\n/**\n * Determines if a given value is a string.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\n/**\n * Determines if a given value is a boolean.\n */\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\n/**\n * Determines if a given value is a number.\n */\nfunction isNumber(value) {\n    return typeof value === 'number' && isFinite(value);\n}\n/**\n * Determines if a given value is a private key string in pem format of type pkcs8.\n */\nfunction isPrivateKey(value) {\n    const trimmedValue = value.trim();\n    // The private key is expected to be decrypted when set in the connection string\n    // secret scanner complains about first check since it looks like private key, but it's only check\n    // pragma: allowlist nextline secret\n    return (trimmedValue.startsWith('-----BEGIN PRIVATE KEY-----') &&\n        trimmedValue.endsWith('\\n-----END PRIVATE KEY-----'));\n}\n/**\n * A collection of number-related utility functions.\n */\nexports.number = {\n    /**\n     * Determines if a given value is a positive number.\n     */\n    isPositive: function (value) {\n        return isNumber(value) && value > 0;\n    },\n    /**\n     * Determines if a given value is a non-negative number.\n     */\n    isNonNegative: function (value) {\n        return isNumber(value) && value >= 0;\n    },\n    /**\n     * Determines if a given value is an integer.\n     */\n    isInteger: function (value) {\n        return isNumber(value) && Math.floor(value) === value;\n    },\n    /**\n     * Determines if a given value is a positive integer.\n     */\n    isPositiveInteger: function (value) {\n        return this.isInteger(value) && value > 0;\n    },\n    /**\n     * Determines if a given value is a non-negative integer.\n     */\n    isNonNegativeInteger: function (value) {\n        return this.isInteger(value) && value >= 0;\n    },\n};\n/**\n * A collection of string-related utility functions.\n */\nexports.string = {\n    /**\n     * Determines if a given string is not null or empty.\n     */\n    isNotNullOrEmpty: function (value) {\n        return isString(value) && value;\n    },\n    /**\n     * Compares two version numbers of the form 'a.b.c' where a, b and c are\n     * numbers (e.g. '1.0.12'). If one or both inputs are invalid versions, the\n     * function will return NaN, otherwise, it will return -1 if the first\n     * version is smaller, 1 if the first version is bigger, and 0 if the two\n     * versions are equal.\n     */\n    compareVersions: function (version1, version2) {\n        // if one or both inputs are valid, return NaN\n        if (!isString(version1) || !isString(version2)) {\n            return NaN;\n        }\n        // split on dot\n        const version1Parts = version1.split('.');\n        const version2Parts = version2.split('.');\n        // add trailing zeros to make the parts arrays the same length\n        while (version1Parts.length < version2Parts.length) {\n            version1Parts.push('0');\n        }\n        while (version2Parts.length < version1Parts.length) {\n            version2Parts.push('0');\n        }\n        // compare elements in the two arrays one by one\n        let result = 0;\n        let version1Part, version2Part;\n        for (let index = 0, length = version1Parts.length; index < length; index++) {\n            // convert to number before doing any arithmetic\n            version1Part = Number(version1Parts[index]);\n            version2Part = Number(version2Parts[index]);\n            // if one or both values are not numerical, consider the input invalid\n            if (!isNumber(version1Part) || !isNumber(version2Part)) {\n                result = NaN;\n                break;\n            }\n            // if the two values are different, pick the\n            // correct result based on which value is smaller\n            if (version1Part !== version2Part) {\n                result = version1Part < version2Part ? -1 : 1;\n                break;\n            }\n        }\n        return result;\n    },\n};\n/**\n * Determines if a given value is not null or undefined.\n *\n * @deprecated Just use if (!value) instead\n */\nfunction exists(value) {\n    return value !== null && value !== undefined;\n}\n/**\n * A collection of url-related utility functions.\n */\nexports.url = {\n    /**\n     * Appends a query parameter to a url. If an invalid url is specified, an\n     * exception is thrown.\n     *\n     * @param url\n     * @param paramName the name of the query parameter.\n     * @param paramValue the value of the query parameter.\n     */\n    appendParam: function (url, paramName, paramValue) {\n        // if the specified url is valid\n        const urlAsObject = url_1.default.parse(url);\n        if (urlAsObject) {\n            // if the url already has query parameters, use '&' as the separator\n            // when appending the additional query parameter, otherwise use '?'\n            url += (urlAsObject.search ? '&' : '?') + paramName + '=' + paramValue;\n        }\n        return url;\n    },\n    appendRetryParam: function (option) {\n        let retryUrl = this.appendParam(option.url, 'retryCount', option.retryCount);\n        if (option.includeRetryReason) {\n            retryUrl = this.appendParam(retryUrl, 'retryReason', option.retryReason);\n        }\n        return retryUrl;\n    },\n};\n/**\n * Shallow-copies everything from a source object into a destination object.\n *\n * @param {Object} dst the object to copy properties to.\n * @param {Object} src the object to copy properties from.\n */\nfunction apply(dst, src) {\n    // if both dst and src are objects, copy everything from src to dst\n    if (isObject(dst) && isObject(src)) {\n        for (const key in src) {\n            if (Object.prototype.hasOwnProperty.call(src, key)) {\n                dst[key] = src[key];\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Returns true if the code is currently being run in the browser, false\n * otherwise.\n */\nfunction isBrowser() {\n    // @ts-ignore TS2339: Property 'browser' does not exist on type 'Process'\n    return !!(process && false);\n}\n/**\n * Returns true if the code is currently being run in node, false otherwise.\n */\nfunction isNode() {\n    return !isBrowser();\n}\n/**\n * Returns the next sleep time calculated by exponential backoff with\n * decorrelated jitter.\n * sleep = min(cap, random_between(base, sleep * 3))\n * for more details, check out:\n * http://www.awsarchitectureblog.com/2015/03/backoff.html\n * @param base minimum seconds\n * @param cap maximum seconds\n * @param previousSleep previous sleep time\n */\nfunction nextSleepTime(base, cap, previousSleep) {\n    return Math.min(cap, Math.abs(previousSleep * 3 - base) * Math.random() + Math.min(base, previousSleep * 3));\n}\n/**\n * Return next sleep time calculated by the jitter rule.\n */\nfunction getJitteredSleepTime(numofRetries, currentSleepTime, totalElapsedTime, maxRetryTimeout) {\n    const nextsleep = getNextSleepTime(numofRetries, currentSleepTime);\n    const sleep = maxRetryTimeout !== 0 ? Math.min(maxRetryTimeout - totalElapsedTime, nextsleep) : nextsleep;\n    totalElapsedTime += sleep;\n    return { sleep, totalElapsedTime };\n}\n/**\n * Choose one of the number between two numbers.\n */\nfunction chooseRandom(firstNumber, secondNumber) {\n    return Math.random() * (firstNumber - secondNumber) + secondNumber;\n}\n/**\n * return the next sleep Time.\n */\nfunction getNextSleepTime(numofRetries, currentSleepTime) {\n    const nextSleep = 2 ** numofRetries;\n    return chooseRandom(currentSleepTime + getJitter(currentSleepTime), nextSleep + getJitter(currentSleepTime));\n}\n/**\n * return the jitter value.\n */\nfunction getJitter(currentSleepTime) {\n    const multiplicationFactor = chooseRandom(1, -1);\n    return 0.5 * currentSleepTime * multiplicationFactor;\n}\n/**\n * Check whether the request is the login-request or not.\n */\nfunction isLoginRequest(loginUrl) {\n    const endPoints = ['/v1/login-request', '/authenticator-request'];\n    return endPoints.some((endPoint) => loginUrl.includes(endPoint));\n}\n/**\n * Checks if the HTTP response code is retryable\n *\n * @param response HTTP response object\n * @param retry403 will retry HTTP 403?\n */\nfunction isRetryableHttpError(response, retry403) {\n    return (response &&\n        ((response.statusCode >= 500 && response.statusCode < 600) ||\n            (retry403 && response.statusCode === 403) ||\n            response.statusCode === 408 ||\n            response.statusCode === 429));\n}\nfunction validateClientSessionKeepAliveHeartbeatFrequency(input, masterValidity) {\n    let heartbeatFrequency = input;\n    const realMax = Math.floor(masterValidity / 4);\n    const realMin = Math.floor(realMax / 4);\n    if (input > realMax) {\n        heartbeatFrequency = realMax;\n    }\n    else if (input < realMin) {\n        heartbeatFrequency = realMin;\n    }\n    heartbeatFrequency = Math.floor(heartbeatFrequency);\n    return heartbeatFrequency;\n}\n/**\n * Constructs host name using region and account\n *\n * @param region where the account is located\n * @param account which account to connect to\n */\nfunction constructHostname(region, account) {\n    let host;\n    if (region === 'us-west-2') {\n        host = account + '.snowflakecomputing.com';\n    }\n    else if (region != null) {\n        if (account.indexOf('.') > 0) {\n            account = account.substring(0, account.indexOf('.'));\n        }\n        if (region.startsWith('cn-') || region.startsWith('CN-')) {\n            host = account + '.' + region + '.snowflakecomputing.cn';\n        }\n        else {\n            host = account + '.' + region + '.snowflakecomputing.com';\n        }\n    }\n    else {\n        host = account + '.snowflakecomputing.com';\n    }\n    return host;\n}\n/**\n * Returns true if host indicates private link\n */\nfunction isPrivateLink(host) {\n    Errors.checkArgumentExists(exists(host), Errors.codes.ERR_CONN_CREATE_MISSING_HOST);\n    return host.toLowerCase().includes('privatelink.snowflakecomputing.');\n}\nfunction createOcspResponseCacheServerUrl(host) {\n    return `http://ocsp.${host}/ocsp_response_cache.json`;\n}\n/**\n * Returns if command is a PUT command\n */\nfunction isPutCommand(sqlText) {\n    return sqlText.trim().substring(0, 3).toUpperCase() === 'PUT';\n}\n/**\n * Returns if command is a GET command\n */\nfunction isGetCommand(sqlText) {\n    return sqlText.trim().substring(0, 3).toUpperCase() === 'GET';\n}\n/**\n * Add double quotes to smkId's value to parse it as a string instead of integer\n * to preserve precision of numbers exceeding JavaScript's max safe integer\n * e.g (inputting 32621973126123526\toutputs 32621973126123530)\n *\n * @param body the data in JSON\n */\nfunction convertSmkIdToString(body) {\n    return body.replace(/\"smkId\"(\\s*):(\\s*)([0-9]+)/g, '\"smkId\"$1:$2\"$3\"');\n}\n/**\n * Under some circumstances the object passed to JSON.stringify in exception handling\n * can contain circular reference, on which JSON.stringify bails out\n * MDN way of handling such error\n */\nfunction getCircularReplacer() {\n    const ancestors = [];\n    return function (key, value) {\n        if (typeof value !== 'object' || value === null) {\n            return value;\n        }\n        // `this` is the object that value is contained in,\n        // i.e., its direct parent.\n        // @ts-ignore TS2683: 'this' implicitly has type 'any' because it does not have a type annotation.\n        while (ancestors.length > 0 && ancestors[ancestors.length - 1] !== this) {\n            ancestors.pop();\n        }\n        if (ancestors.includes(value)) {\n            return '[Circular]';\n        }\n        ancestors.push(value);\n        return value;\n    };\n}\n/**\n * Returns if the provided string is a valid subdomain.\n */\nfunction isCorrectSubdomain(value) {\n    const subdomainRegex = RegExp(/^\\w+([.-]\\w+)*$/i);\n    return subdomainRegex.test(value);\n}\nfunction buildCredentialCacheKey(host, username, credType) {\n    if (!host || !username || !credType) {\n        Logger.getInstance().debug('Cannot build the credential cache key because one of host, username, and credType is null');\n        return null;\n    }\n    return `{${host.toUpperCase()}}:{${username.toUpperCase()}}:{${credType.toUpperCase()}}`;\n}\nfunction checkValidCustomCredentialManager(customCredentialManager) {\n    if (typeof customCredentialManager !== 'object') {\n        return false;\n    }\n    const requireMethods = ['write', 'read', 'remove'];\n    for (const method of requireMethods) {\n        if (!Object.hasOwnProperty.call(customCredentialManager, method) ||\n            typeof customCredentialManager[method] !== 'function') {\n            return false;\n        }\n    }\n    return true;\n}\nfunction checkParametersDefined(...parameters) {\n    return parameters.every((element) => element !== undefined && element !== null);\n}\n/**\n * Checks if the provided file or directory permissions are correct.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nasync function isFileModeCorrect(filePath, expectedMode, fsPromises) {\n    if (os_1.default.platform() === 'win32') {\n        return true;\n    }\n    return await fsPromises.stat(filePath).then((stats) => {\n        // we have to limit the number of LSB bits to 9 with the mask, as the stats.mode starts with the file type,\n        // e.g. the directory with permissions 755 will have stats.mask of 40755.\n        const mask = (1 << 9) - 1;\n        return (stats.mode & mask) === expectedMode;\n    });\n}\n/**\n * Checks if the provided file or directory is writable only by the user.\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nasync function isFileNotWritableByGroupOrOthers(configFilePath, fsPromises) {\n    if (os_1.default.platform() === 'win32') {\n        return true;\n    }\n    const stats = await fsPromises.stat(configFilePath);\n    return (stats.mode & (1 << 4)) === 0 && (stats.mode & (1 << 1)) === 0;\n}\nfunction shouldRetryOktaAuth({ maxRetryTimeout, maxRetryCount, numRetries, startTime, remainingTimeout, }) {\n    return ((maxRetryTimeout === 0 || Date.now() < startTime + remainingTimeout) &&\n        numRetries <= maxRetryCount);\n}\nfunction getDriverDirectory() {\n    return __dirname;\n}\nfunction validatePath(dir) {\n    try {\n        const stat = fs_1.default.statSync(dir);\n        return stat.isDirectory();\n    }\n    catch {\n        Logger.getInstance().error('The location is invalid. Please check this location is accessible or existing');\n        return false;\n    }\n}\nfunction getEnvVar(variable) {\n    return process.env[variable.toLowerCase()] || process.env[variable.toUpperCase()];\n}\nfunction validateEmptyString(value) {\n    return value !== '' ? value : undefined;\n}\nfunction isNotEmptyAsString(variable) {\n    if (typeof variable === 'string') {\n        return variable;\n    }\n    return exists(variable);\n}\nfunction isNotEmptyString(variable) {\n    return exists(variable) && variable !== '';\n}\n/**\n * Checks Whether the object is empty (can be null or undefined) or not.\n */\nfunction isEmptyObject(object) {\n    if (!exists(object)) {\n        return true;\n    }\n    if (typeof object !== 'object') {\n        return false;\n    }\n    return Object.keys(object).length === 0;\n}\nfunction isWindows() {\n    return os_1.default.platform() === 'win32';\n}\nasync function getFreePort() {\n    return new Promise((res) => {\n        const srv = net_1.default.createServer();\n        srv.listen(0, () => {\n            // @ts-ignore TS2339: Property 'port' does not exist on type 'string | AddressInfo'\n            const port = srv.address().port;\n            srv.close(() => res(port));\n        });\n    });\n}\nasync function isPortOpen(port) {\n    return new Promise((resolve, reject) => {\n        const s = net_1.default.createServer();\n        s.once('error', (err) => {\n            s.close();\n            if (err['code'] === 'EADDRINUSE') {\n                Logger.getInstance().trace(`Port: ${port} is not available. Verification failed`);\n                reject('Port not available.');\n            }\n            else {\n                Logger.getInstance().trace(`There is unexpected error during verification of port availability. Port: ${port}. Error: ${JSON.stringify(err)}`);\n            }\n        });\n        s.once('listening', () => {\n            s.close();\n            Logger.getInstance().trace(`Closing server run for verification whether the port is available. Port: ${port}`);\n            resolve('Listening');\n        });\n        s.listen(port);\n    });\n}\n/**\n * Left strip the specified character from a string.\n */\nfunction lstrip(str, remove) {\n    while (str.length > 0 && remove.indexOf(str.charAt(0)) !== -1) {\n        str = str.substr(1);\n    }\n    return str;\n}\n/**\n * This method transforms HTML special characters into their corresponding entity representations.\n */\nfunction escapeHTML(value) {\n    if (!exists(value)) {\n        return value;\n    }\n    return value\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n/**\n * Typescript with \"module\": \"commonjs\" will transform every import() to a require() statement.\n *\n * This will break ESM dynamic imports resulting in a runtime error:\n * -require() of ES Module... from ... not supported.\n *\n * A hacky solution - https://github.com/microsoft/TypeScript/issues/43329\n *\n * This could be removed once we drop node 18 support as Node 20+ support esm in require()\n */\nasync function dynamicImportESMInTypescriptWithCommonJS(moduleName) {\n    return Function(`return import(\"${moduleName}\")`)();\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCO0FBQzlHLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixjQUFjO0FBQ2QsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLHdEQUF3RDtBQUN4RCx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHdDQUF3QztBQUN4QyxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qix3Q0FBd0M7QUFDeEMsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLGdEQUFnRDtBQUNoRCwrQkFBK0IsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQyw2QkFBNkIsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pDLDRCQUE0QixtQkFBTyxDQUFDLHVFQUFVO0FBQzlDLDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekM7QUFDQSxlQUFlLG1CQUFPLENBQUMsdUVBQVU7QUFDakMsOEJBQThCLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0MsdUJBQXVCLG1CQUFPLENBQUMsNkVBQWlCO0FBQ2hELDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCxpREFBZ0QsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQix3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLFdBQVcsY0FBYztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUUsb0JBQW9CLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxFQUFFLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEVBQTBFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILEtBQUssV0FBVyxvQkFBb0I7QUFDNUo7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1IQUFtSCxLQUFLO0FBQ3hIO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvdXRpbC5qcz8yMzdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVybCA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnVzZXJBZ2VudCA9IGV4cG9ydHMuZHJpdmVyVmVyc2lvbiA9IGV4cG9ydHMuZHJpdmVyTmFtZSA9IHZvaWQgMDtcbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc1ByaXZhdGVLZXkgPSBpc1ByaXZhdGVLZXk7XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmV4cG9ydHMuYXBwbHkgPSBhcHBseTtcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyO1xuZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG5leHBvcnRzLm5leHRTbGVlcFRpbWUgPSBuZXh0U2xlZXBUaW1lO1xuZXhwb3J0cy5nZXRKaXR0ZXJlZFNsZWVwVGltZSA9IGdldEppdHRlcmVkU2xlZXBUaW1lO1xuZXhwb3J0cy5jaG9vc2VSYW5kb20gPSBjaG9vc2VSYW5kb207XG5leHBvcnRzLmdldE5leHRTbGVlcFRpbWUgPSBnZXROZXh0U2xlZXBUaW1lO1xuZXhwb3J0cy5nZXRKaXR0ZXIgPSBnZXRKaXR0ZXI7XG5leHBvcnRzLmlzTG9naW5SZXF1ZXN0ID0gaXNMb2dpblJlcXVlc3Q7XG5leHBvcnRzLmlzUmV0cnlhYmxlSHR0cEVycm9yID0gaXNSZXRyeWFibGVIdHRwRXJyb3I7XG5leHBvcnRzLnZhbGlkYXRlQ2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IHZhbGlkYXRlQ2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeTtcbmV4cG9ydHMuY29uc3RydWN0SG9zdG5hbWUgPSBjb25zdHJ1Y3RIb3N0bmFtZTtcbmV4cG9ydHMuaXNQcml2YXRlTGluayA9IGlzUHJpdmF0ZUxpbms7XG5leHBvcnRzLmNyZWF0ZU9jc3BSZXNwb25zZUNhY2hlU2VydmVyVXJsID0gY3JlYXRlT2NzcFJlc3BvbnNlQ2FjaGVTZXJ2ZXJVcmw7XG5leHBvcnRzLmlzUHV0Q29tbWFuZCA9IGlzUHV0Q29tbWFuZDtcbmV4cG9ydHMuaXNHZXRDb21tYW5kID0gaXNHZXRDb21tYW5kO1xuZXhwb3J0cy5jb252ZXJ0U21rSWRUb1N0cmluZyA9IGNvbnZlcnRTbWtJZFRvU3RyaW5nO1xuZXhwb3J0cy5nZXRDaXJjdWxhclJlcGxhY2VyID0gZ2V0Q2lyY3VsYXJSZXBsYWNlcjtcbmV4cG9ydHMuaXNDb3JyZWN0U3ViZG9tYWluID0gaXNDb3JyZWN0U3ViZG9tYWluO1xuZXhwb3J0cy5idWlsZENyZWRlbnRpYWxDYWNoZUtleSA9IGJ1aWxkQ3JlZGVudGlhbENhY2hlS2V5O1xuZXhwb3J0cy5jaGVja1ZhbGlkQ3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIgPSBjaGVja1ZhbGlkQ3VzdG9tQ3JlZGVudGlhbE1hbmFnZXI7XG5leHBvcnRzLmNoZWNrUGFyYW1ldGVyc0RlZmluZWQgPSBjaGVja1BhcmFtZXRlcnNEZWZpbmVkO1xuZXhwb3J0cy5pc0ZpbGVNb2RlQ29ycmVjdCA9IGlzRmlsZU1vZGVDb3JyZWN0O1xuZXhwb3J0cy5pc0ZpbGVOb3RXcml0YWJsZUJ5R3JvdXBPck90aGVycyA9IGlzRmlsZU5vdFdyaXRhYmxlQnlHcm91cE9yT3RoZXJzO1xuZXhwb3J0cy5zaG91bGRSZXRyeU9rdGFBdXRoID0gc2hvdWxkUmV0cnlPa3RhQXV0aDtcbmV4cG9ydHMuZ2V0RHJpdmVyRGlyZWN0b3J5ID0gZ2V0RHJpdmVyRGlyZWN0b3J5O1xuZXhwb3J0cy52YWxpZGF0ZVBhdGggPSB2YWxpZGF0ZVBhdGg7XG5leHBvcnRzLmdldEVudlZhciA9IGdldEVudlZhcjtcbmV4cG9ydHMudmFsaWRhdGVFbXB0eVN0cmluZyA9IHZhbGlkYXRlRW1wdHlTdHJpbmc7XG5leHBvcnRzLmlzTm90RW1wdHlBc1N0cmluZyA9IGlzTm90RW1wdHlBc1N0cmluZztcbmV4cG9ydHMuaXNOb3RFbXB0eVN0cmluZyA9IGlzTm90RW1wdHlTdHJpbmc7XG5leHBvcnRzLmlzRW1wdHlPYmplY3QgPSBpc0VtcHR5T2JqZWN0O1xuZXhwb3J0cy5pc1dpbmRvd3MgPSBpc1dpbmRvd3M7XG5leHBvcnRzLmdldEZyZWVQb3J0ID0gZ2V0RnJlZVBvcnQ7XG5leHBvcnRzLmlzUG9ydE9wZW4gPSBpc1BvcnRPcGVuO1xuZXhwb3J0cy5sc3RyaXAgPSBsc3RyaXA7XG5leHBvcnRzLmVzY2FwZUhUTUwgPSBlc2NhcGVIVE1MO1xuZXhwb3J0cy5keW5hbWljSW1wb3J0RVNNSW5UeXBlc2NyaXB0V2l0aENvbW1vbkpTID0gZHluYW1pY0ltcG9ydEVTTUluVHlwZXNjcmlwdFdpdGhDb21tb25KUztcbmNvbnN0IHV0aWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidXRpbFwiKSk7XG5jb25zdCB1cmxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidXJsXCIpKTtcbmNvbnN0IG9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm9zXCIpKTtcbmNvbnN0IExvZ2dlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnZXJcIikpO1xuY29uc3QgZnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnNcIikpO1xuLy8gTk9URToga2VlcGluZyByZXF1aXJlIGFzIGl0J3MgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHNvICogYXMgRXJyb3JzIGRvZXNuJ3Qgd29ya1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IG5ldF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgcGFja2FnZV9qc29uXzEgPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZHJpdmVyTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFja2FnZV9qc29uXzEubmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRyaXZlclZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhY2thZ2VfanNvbl8xLnZlcnNpb247IH0gfSk7XG5jb25zdCBub2RlSlNWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uPy5zdGFydHNXaXRoKCd2JylcbiAgICA/IHByb2Nlc3MudmVyc2lvbi5zdWJzdHJpbmcoMSlcbiAgICA6IHByb2Nlc3MudmVyc2lvbjtcbmV4cG9ydHMudXNlckFnZW50ID0gYEphdmFTY3JpcHQvJHtwYWNrYWdlX2pzb25fMS52ZXJzaW9ufSAoJHtwcm9jZXNzLnBsYXRmb3JtfS0ke3Byb2Nlc3MuYXJjaH0pIE5vZGVKUy8ke25vZGVKU1ZlcnNpb259YDtcbi8qKlxuICogTm90ZTogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdXRpbC5pbmhlcml0cygpIGZvciBub3csIGJ1dCB0aGlzIG1pZ2h0IGNoYW5nZVxuICogaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBJbmhlcml0cyB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLiBUaGVcbiAqIHByb3RvdHlwZSBvZiBjb25zdHJ1Y3RvciB3aWxsIGJlIHNldCB0byBhIG5ldyBvYmplY3QgY3JlYXRlZCBmcm9tXG4gKiBzdXBlckNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHN1cGVyQ29uc3RydWN0b3JcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBpbmhlcml0cyhjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiB1dGlsXzEuZGVmYXVsdC5pbmhlcml0cy5hcHBseSh1dGlsXzEuZGVmYXVsdCwgW2NvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yXSk7XG59XG4vKipcbiAqIE5vdGU6IEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHV0aWwuZm9ybWF0KCkgZm9yIG5vdywgYnV0IHRoaXMgd2lsbCBsaWtlbHlcbiAqIGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHVzaW5nIHRoZSBmaXJzdCBhcmd1bWVudCBhcyBhIHByaW50Zi1saWtlIGZvcm1hdC5cbiAqXG4gKiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgdGhhdCBjb250YWlucyB6ZXJvIG9yIG1vcmUgcGxhY2Vob2xkZXJzLlxuICogRWFjaCBwbGFjZWhvbGRlciBpcyByZXBsYWNlZCB3aXRoIHRoZSBjb252ZXJ0ZWQgdmFsdWUgZnJvbSBpdHMgY29ycmVzcG9uZGluZ1xuICogYXJndW1lbnQuIFN1cHBvcnRlZCBwbGFjZWhvbGRlcnMgYXJlOlxuICogICAlcyAtIFN0cmluZy5cbiAqICAgJWQgLSBOdW1iZXIgKGJvdGggaW50ZWdlciBhbmQgZmxvYXQpLlxuICogICAlaiAtIEpTT04uIFJlcGxhY2VkIHdpdGggdGhlIHN0cmluZyAnW0NpcmN1bGFyXScgaWYgdGhlIGFyZ3VtZW50IGNvbnRhaW5zXG4gKiAgICAgICAgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqICAgJSUgLSBzaW5nbGUgcGVyY2VudCBzaWduICgnJScpLiBUaGlzIGRvZXMgbm90IGNvbnN1bWUgYW4gYXJndW1lbnQuXG4gKlxuICogSWYgdGhlIHBsYWNlaG9sZGVyIGRvZXMgbm90IGhhdmUgYSBjb3JyZXNwb25kaW5nIGFyZ3VtZW50LCB0aGUgcGxhY2Vob2xkZXIgaXNcbiAqIG5vdCByZXBsYWNlZC5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgbW9yZSBhcmd1bWVudHMgdGhhbiBwbGFjZWhvbGRlcnMsIHRoZSBleHRyYSBhcmd1bWVudHMgYXJlXG4gKiBjb2VyY2VkIHRvIHN0cmluZ3MgKGZvciBvYmplY3RzIGFuZCBzeW1ib2xzLCB1dGlsLmluc3BlY3QoKSBpcyB1c2VkKSBhbmQgdGhlblxuICogY29uY2F0ZW5hdGVkLCBkZWxpbWl0ZWQgYnkgYSBzcGFjZS5cbiAqXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGEgZm9ybWF0IHN0cmluZyB0aGVuIHV0aWwuZm9ybWF0KCkgcmV0dXJucyBhXG4gKiBzdHJpbmcgdGhhdCBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaXRzIGFyZ3VtZW50cyBzZXBhcmF0ZWQgYnkgc3BhY2VzLlxuICogRWFjaCBhcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgd2l0aCB1dGlsLmluc3BlY3QoKS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGZvcm1hdCwgLi4ucGFyYW1zKSB7XG4gICAgcmV0dXJuIHV0aWxfMS5kZWZhdWx0LmZvcm1hdC5hcHBseSh1dGlsXzEuZGVmYXVsdCwgW2Zvcm1hdCwgLi4ucGFyYW1zXSk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIERhdGUuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBwcml2YXRlIGtleSBzdHJpbmcgaW4gcGVtIGZvcm1hdCBvZiB0eXBlIHBrY3M4LlxuICovXG5mdW5jdGlvbiBpc1ByaXZhdGVLZXkodmFsdWUpIHtcbiAgICBjb25zdCB0cmltbWVkVmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgLy8gVGhlIHByaXZhdGUga2V5IGlzIGV4cGVjdGVkIHRvIGJlIGRlY3J5cHRlZCB3aGVuIHNldCBpbiB0aGUgY29ubmVjdGlvbiBzdHJpbmdcbiAgICAvLyBzZWNyZXQgc2Nhbm5lciBjb21wbGFpbnMgYWJvdXQgZmlyc3QgY2hlY2sgc2luY2UgaXQgbG9va3MgbGlrZSBwcml2YXRlIGtleSwgYnV0IGl0J3Mgb25seSBjaGVja1xuICAgIC8vIHByYWdtYTogYWxsb3dsaXN0IG5leHRsaW5lIHNlY3JldFxuICAgIHJldHVybiAodHJpbW1lZFZhbHVlLnN0YXJ0c1dpdGgoJy0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLScpICYmXG4gICAgICAgIHRyaW1tZWRWYWx1ZS5lbmRzV2l0aCgnXFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLScpKTtcbn1cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG51bWJlci1yZWxhdGVkIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5leHBvcnRzLm51bWJlciA9IHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBwb3NpdGl2ZSBudW1iZXIuXG4gICAgICovXG4gICAgaXNQb3NpdGl2ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPiAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cbiAgICAgKi9cbiAgICBpc05vbk5lZ2F0aXZlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gICAgICovXG4gICAgaXNJbnRlZ2VyOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGlzUG9zaXRpdmVJbnRlZ2VyOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAgICAgKi9cbiAgICBpc05vbk5lZ2F0aXZlSW50ZWdlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbiAgICB9LFxufTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHN0cmluZy1yZWxhdGVkIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5leHBvcnRzLnN0cmluZyA9IHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIG5vdCBudWxsIG9yIGVtcHR5LlxuICAgICAqL1xuICAgIGlzTm90TnVsbE9yRW1wdHk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIHZlcnNpb24gbnVtYmVycyBvZiB0aGUgZm9ybSAnYS5iLmMnIHdoZXJlIGEsIGIgYW5kIGMgYXJlXG4gICAgICogbnVtYmVycyAoZS5nLiAnMS4wLjEyJykuIElmIG9uZSBvciBib3RoIGlucHV0cyBhcmUgaW52YWxpZCB2ZXJzaW9ucywgdGhlXG4gICAgICogZnVuY3Rpb24gd2lsbCByZXR1cm4gTmFOLCBvdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIC0xIGlmIHRoZSBmaXJzdFxuICAgICAqIHZlcnNpb24gaXMgc21hbGxlciwgMSBpZiB0aGUgZmlyc3QgdmVyc2lvbiBpcyBiaWdnZXIsIGFuZCAwIGlmIHRoZSB0d29cbiAgICAgKiB2ZXJzaW9ucyBhcmUgZXF1YWwuXG4gICAgICovXG4gICAgY29tcGFyZVZlcnNpb25zOiBmdW5jdGlvbiAodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gICAgICAgIC8vIGlmIG9uZSBvciBib3RoIGlucHV0cyBhcmUgdmFsaWQsIHJldHVybiBOYU5cbiAgICAgICAgaWYgKCFpc1N0cmluZyh2ZXJzaW9uMSkgfHwgIWlzU3RyaW5nKHZlcnNpb24yKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGxpdCBvbiBkb3RcbiAgICAgICAgY29uc3QgdmVyc2lvbjFQYXJ0cyA9IHZlcnNpb24xLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24yUGFydHMgPSB2ZXJzaW9uMi5zcGxpdCgnLicpO1xuICAgICAgICAvLyBhZGQgdHJhaWxpbmcgemVyb3MgdG8gbWFrZSB0aGUgcGFydHMgYXJyYXlzIHRoZSBzYW1lIGxlbmd0aFxuICAgICAgICB3aGlsZSAodmVyc2lvbjFQYXJ0cy5sZW5ndGggPCB2ZXJzaW9uMlBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmVyc2lvbjFQYXJ0cy5wdXNoKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHZlcnNpb24yUGFydHMubGVuZ3RoIDwgdmVyc2lvbjFQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZlcnNpb24yUGFydHMucHVzaCgnMCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBhcmUgZWxlbWVudHMgaW4gdGhlIHR3byBhcnJheXMgb25lIGJ5IG9uZVxuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgbGV0IHZlcnNpb24xUGFydCwgdmVyc2lvbjJQYXJ0O1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHZlcnNpb24xUGFydHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gY29udmVydCB0byBudW1iZXIgYmVmb3JlIGRvaW5nIGFueSBhcml0aG1ldGljXG4gICAgICAgICAgICB2ZXJzaW9uMVBhcnQgPSBOdW1iZXIodmVyc2lvbjFQYXJ0c1tpbmRleF0pO1xuICAgICAgICAgICAgdmVyc2lvbjJQYXJ0ID0gTnVtYmVyKHZlcnNpb24yUGFydHNbaW5kZXhdKTtcbiAgICAgICAgICAgIC8vIGlmIG9uZSBvciBib3RoIHZhbHVlcyBhcmUgbm90IG51bWVyaWNhbCwgY29uc2lkZXIgdGhlIGlucHV0IGludmFsaWRcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmVyc2lvbjFQYXJ0KSB8fCAhaXNOdW1iZXIodmVyc2lvbjJQYXJ0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE5hTjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSB0d28gdmFsdWVzIGFyZSBkaWZmZXJlbnQsIHBpY2sgdGhlXG4gICAgICAgICAgICAvLyBjb3JyZWN0IHJlc3VsdCBiYXNlZCBvbiB3aGljaCB2YWx1ZSBpcyBzbWFsbGVyXG4gICAgICAgICAgICBpZiAodmVyc2lvbjFQYXJ0ICE9PSB2ZXJzaW9uMlBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2ZXJzaW9uMVBhcnQgPCB2ZXJzaW9uMlBhcnQgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBKdXN0IHVzZSBpZiAoIXZhbHVlKSBpbnN0ZWFkXG4gKi9cbmZ1bmN0aW9uIGV4aXN0cyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXJsLXJlbGF0ZWQgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKi9cbmV4cG9ydHMudXJsID0ge1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBxdWVyeSBwYXJhbWV0ZXIgdG8gYSB1cmwuIElmIGFuIGludmFsaWQgdXJsIGlzIHNwZWNpZmllZCwgYW5cbiAgICAgKiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqIEBwYXJhbSBwYXJhbU5hbWUgdGhlIG5hbWUgb2YgdGhlIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0gcGFyYW1WYWx1ZSB0aGUgdmFsdWUgb2YgdGhlIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBhcHBlbmRQYXJhbTogZnVuY3Rpb24gKHVybCwgcGFyYW1OYW1lLCBwYXJhbVZhbHVlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBzcGVjaWZpZWQgdXJsIGlzIHZhbGlkXG4gICAgICAgIGNvbnN0IHVybEFzT2JqZWN0ID0gdXJsXzEuZGVmYXVsdC5wYXJzZSh1cmwpO1xuICAgICAgICBpZiAodXJsQXNPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB1cmwgYWxyZWFkeSBoYXMgcXVlcnkgcGFyYW1ldGVycywgdXNlICcmJyBhcyB0aGUgc2VwYXJhdG9yXG4gICAgICAgICAgICAvLyB3aGVuIGFwcGVuZGluZyB0aGUgYWRkaXRpb25hbCBxdWVyeSBwYXJhbWV0ZXIsIG90aGVyd2lzZSB1c2UgJz8nXG4gICAgICAgICAgICB1cmwgKz0gKHVybEFzT2JqZWN0LnNlYXJjaCA/ICcmJyA6ICc/JykgKyBwYXJhbU5hbWUgKyAnPScgKyBwYXJhbVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSxcbiAgICBhcHBlbmRSZXRyeVBhcmFtOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIGxldCByZXRyeVVybCA9IHRoaXMuYXBwZW5kUGFyYW0ob3B0aW9uLnVybCwgJ3JldHJ5Q291bnQnLCBvcHRpb24ucmV0cnlDb3VudCk7XG4gICAgICAgIGlmIChvcHRpb24uaW5jbHVkZVJldHJ5UmVhc29uKSB7XG4gICAgICAgICAgICByZXRyeVVybCA9IHRoaXMuYXBwZW5kUGFyYW0ocmV0cnlVcmwsICdyZXRyeVJlYXNvbicsIG9wdGlvbi5yZXRyeVJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHJ5VXJsO1xuICAgIH0sXG59O1xuLyoqXG4gKiBTaGFsbG93LWNvcGllcyBldmVyeXRoaW5nIGZyb20gYSBzb3VyY2Ugb2JqZWN0IGludG8gYSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRzdCB0aGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgdGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZHN0LCBzcmMpIHtcbiAgICAvLyBpZiBib3RoIGRzdCBhbmQgc3JjIGFyZSBvYmplY3RzLCBjb3B5IGV2ZXJ5dGhpbmcgZnJvbSBzcmMgdG8gZHN0XG4gICAgaWYgKGlzT2JqZWN0KGRzdCkgJiYgaXNPYmplY3Qoc3JjKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvZGUgaXMgY3VycmVudGx5IGJlaW5nIHJ1biBpbiB0aGUgYnJvd3NlciwgZmFsc2VcbiAqIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIC8vIEB0cy1pZ25vcmUgVFMyMzM5OiBQcm9wZXJ0eSAnYnJvd3NlcicgZG9lcyBub3QgZXhpc3Qgb24gdHlwZSAnUHJvY2VzcydcbiAgICByZXR1cm4gISEocHJvY2VzcyAmJiBwcm9jZXNzLmJyb3dzZXIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvZGUgaXMgY3VycmVudGx5IGJlaW5nIHJ1biBpbiBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICByZXR1cm4gIWlzQnJvd3NlcigpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IHNsZWVwIHRpbWUgY2FsY3VsYXRlZCBieSBleHBvbmVudGlhbCBiYWNrb2ZmIHdpdGhcbiAqIGRlY29ycmVsYXRlZCBqaXR0ZXIuXG4gKiBzbGVlcCA9IG1pbihjYXAsIHJhbmRvbV9iZXR3ZWVuKGJhc2UsIHNsZWVwICogMykpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLCBjaGVjayBvdXQ6XG4gKiBodHRwOi8vd3d3LmF3c2FyY2hpdGVjdHVyZWJsb2cuY29tLzIwMTUvMDMvYmFja29mZi5odG1sXG4gKiBAcGFyYW0gYmFzZSBtaW5pbXVtIHNlY29uZHNcbiAqIEBwYXJhbSBjYXAgbWF4aW11bSBzZWNvbmRzXG4gKiBAcGFyYW0gcHJldmlvdXNTbGVlcCBwcmV2aW91cyBzbGVlcCB0aW1lXG4gKi9cbmZ1bmN0aW9uIG5leHRTbGVlcFRpbWUoYmFzZSwgY2FwLCBwcmV2aW91c1NsZWVwKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKGNhcCwgTWF0aC5hYnMocHJldmlvdXNTbGVlcCAqIDMgLSBiYXNlKSAqIE1hdGgucmFuZG9tKCkgKyBNYXRoLm1pbihiYXNlLCBwcmV2aW91c1NsZWVwICogMykpO1xufVxuLyoqXG4gKiBSZXR1cm4gbmV4dCBzbGVlcCB0aW1lIGNhbGN1bGF0ZWQgYnkgdGhlIGppdHRlciBydWxlLlxuICovXG5mdW5jdGlvbiBnZXRKaXR0ZXJlZFNsZWVwVGltZShudW1vZlJldHJpZXMsIGN1cnJlbnRTbGVlcFRpbWUsIHRvdGFsRWxhcHNlZFRpbWUsIG1heFJldHJ5VGltZW91dCkge1xuICAgIGNvbnN0IG5leHRzbGVlcCA9IGdldE5leHRTbGVlcFRpbWUobnVtb2ZSZXRyaWVzLCBjdXJyZW50U2xlZXBUaW1lKTtcbiAgICBjb25zdCBzbGVlcCA9IG1heFJldHJ5VGltZW91dCAhPT0gMCA/IE1hdGgubWluKG1heFJldHJ5VGltZW91dCAtIHRvdGFsRWxhcHNlZFRpbWUsIG5leHRzbGVlcCkgOiBuZXh0c2xlZXA7XG4gICAgdG90YWxFbGFwc2VkVGltZSArPSBzbGVlcDtcbiAgICByZXR1cm4geyBzbGVlcCwgdG90YWxFbGFwc2VkVGltZSB9O1xufVxuLyoqXG4gKiBDaG9vc2Ugb25lIG9mIHRoZSBudW1iZXIgYmV0d2VlbiB0d28gbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gY2hvb3NlUmFuZG9tKGZpcnN0TnVtYmVyLCBzZWNvbmROdW1iZXIpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChmaXJzdE51bWJlciAtIHNlY29uZE51bWJlcikgKyBzZWNvbmROdW1iZXI7XG59XG4vKipcbiAqIHJldHVybiB0aGUgbmV4dCBzbGVlcCBUaW1lLlxuICovXG5mdW5jdGlvbiBnZXROZXh0U2xlZXBUaW1lKG51bW9mUmV0cmllcywgY3VycmVudFNsZWVwVGltZSkge1xuICAgIGNvbnN0IG5leHRTbGVlcCA9IDIgKiogbnVtb2ZSZXRyaWVzO1xuICAgIHJldHVybiBjaG9vc2VSYW5kb20oY3VycmVudFNsZWVwVGltZSArIGdldEppdHRlcihjdXJyZW50U2xlZXBUaW1lKSwgbmV4dFNsZWVwICsgZ2V0Sml0dGVyKGN1cnJlbnRTbGVlcFRpbWUpKTtcbn1cbi8qKlxuICogcmV0dXJuIHRoZSBqaXR0ZXIgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldEppdHRlcihjdXJyZW50U2xlZXBUaW1lKSB7XG4gICAgY29uc3QgbXVsdGlwbGljYXRpb25GYWN0b3IgPSBjaG9vc2VSYW5kb20oMSwgLTEpO1xuICAgIHJldHVybiAwLjUgKiBjdXJyZW50U2xlZXBUaW1lICogbXVsdGlwbGljYXRpb25GYWN0b3I7XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgdGhlIGxvZ2luLXJlcXVlc3Qgb3Igbm90LlxuICovXG5mdW5jdGlvbiBpc0xvZ2luUmVxdWVzdChsb2dpblVybCkge1xuICAgIGNvbnN0IGVuZFBvaW50cyA9IFsnL3YxL2xvZ2luLXJlcXVlc3QnLCAnL2F1dGhlbnRpY2F0b3ItcmVxdWVzdCddO1xuICAgIHJldHVybiBlbmRQb2ludHMuc29tZSgoZW5kUG9pbnQpID0+IGxvZ2luVXJsLmluY2x1ZGVzKGVuZFBvaW50KSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgSFRUUCByZXNwb25zZSBjb2RlIGlzIHJldHJ5YWJsZVxuICpcbiAqIEBwYXJhbSByZXNwb25zZSBIVFRQIHJlc3BvbnNlIG9iamVjdFxuICogQHBhcmFtIHJldHJ5NDAzIHdpbGwgcmV0cnkgSFRUUCA0MDM/XG4gKi9cbmZ1bmN0aW9uIGlzUmV0cnlhYmxlSHR0cEVycm9yKHJlc3BvbnNlLCByZXRyeTQwMykge1xuICAgIHJldHVybiAocmVzcG9uc2UgJiZcbiAgICAgICAgKChyZXNwb25zZS5zdGF0dXNDb2RlID49IDUwMCAmJiByZXNwb25zZS5zdGF0dXNDb2RlIDwgNjAwKSB8fFxuICAgICAgICAgICAgKHJldHJ5NDAzICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwMykgfHxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwOCB8fFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3koaW5wdXQsIG1hc3RlclZhbGlkaXR5KSB7XG4gICAgbGV0IGhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGlucHV0O1xuICAgIGNvbnN0IHJlYWxNYXggPSBNYXRoLmZsb29yKG1hc3RlclZhbGlkaXR5IC8gNCk7XG4gICAgY29uc3QgcmVhbE1pbiA9IE1hdGguZmxvb3IocmVhbE1heCAvIDQpO1xuICAgIGlmIChpbnB1dCA+IHJlYWxNYXgpIHtcbiAgICAgICAgaGVhcnRiZWF0RnJlcXVlbmN5ID0gcmVhbE1heDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgPCByZWFsTWluKSB7XG4gICAgICAgIGhlYXJ0YmVhdEZyZXF1ZW5jeSA9IHJlYWxNaW47XG4gICAgfVxuICAgIGhlYXJ0YmVhdEZyZXF1ZW5jeSA9IE1hdGguZmxvb3IoaGVhcnRiZWF0RnJlcXVlbmN5KTtcbiAgICByZXR1cm4gaGVhcnRiZWF0RnJlcXVlbmN5O1xufVxuLyoqXG4gKiBDb25zdHJ1Y3RzIGhvc3QgbmFtZSB1c2luZyByZWdpb24gYW5kIGFjY291bnRcbiAqXG4gKiBAcGFyYW0gcmVnaW9uIHdoZXJlIHRoZSBhY2NvdW50IGlzIGxvY2F0ZWRcbiAqIEBwYXJhbSBhY2NvdW50IHdoaWNoIGFjY291bnQgdG8gY29ubmVjdCB0b1xuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RIb3N0bmFtZShyZWdpb24sIGFjY291bnQpIHtcbiAgICBsZXQgaG9zdDtcbiAgICBpZiAocmVnaW9uID09PSAndXMtd2VzdC0yJykge1xuICAgICAgICBob3N0ID0gYWNjb3VudCArICcuc25vd2ZsYWtlY29tcHV0aW5nLmNvbSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZ2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhY2NvdW50LmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgICAgIGFjY291bnQgPSBhY2NvdW50LnN1YnN0cmluZygwLCBhY2NvdW50LmluZGV4T2YoJy4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ2lvbi5zdGFydHNXaXRoKCdjbi0nKSB8fCByZWdpb24uc3RhcnRzV2l0aCgnQ04tJykpIHtcbiAgICAgICAgICAgIGhvc3QgPSBhY2NvdW50ICsgJy4nICsgcmVnaW9uICsgJy5zbm93Zmxha2Vjb21wdXRpbmcuY24nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdCA9IGFjY291bnQgKyAnLicgKyByZWdpb24gKyAnLnNub3dmbGFrZWNvbXB1dGluZy5jb20nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBob3N0ID0gYWNjb3VudCArICcuc25vd2ZsYWtlY29tcHV0aW5nLmNvbSc7XG4gICAgfVxuICAgIHJldHVybiBob3N0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaG9zdCBpbmRpY2F0ZXMgcHJpdmF0ZSBsaW5rXG4gKi9cbmZ1bmN0aW9uIGlzUHJpdmF0ZUxpbmsoaG9zdCkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKGV4aXN0cyhob3N0KSwgRXJyb3JzLmNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0hPU1QpO1xuICAgIHJldHVybiBob3N0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3ByaXZhdGVsaW5rLnNub3dmbGFrZWNvbXB1dGluZy4nKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9jc3BSZXNwb25zZUNhY2hlU2VydmVyVXJsKGhvc3QpIHtcbiAgICByZXR1cm4gYGh0dHA6Ly9vY3NwLiR7aG9zdH0vb2NzcF9yZXNwb25zZV9jYWNoZS5qc29uYDtcbn1cbi8qKlxuICogUmV0dXJucyBpZiBjb21tYW5kIGlzIGEgUFVUIGNvbW1hbmRcbiAqL1xuZnVuY3Rpb24gaXNQdXRDb21tYW5kKHNxbFRleHQpIHtcbiAgICByZXR1cm4gc3FsVGV4dC50cmltKCkuc3Vic3RyaW5nKDAsIDMpLnRvVXBwZXJDYXNlKCkgPT09ICdQVVQnO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGNvbW1hbmQgaXMgYSBHRVQgY29tbWFuZFxuICovXG5mdW5jdGlvbiBpc0dldENvbW1hbmQoc3FsVGV4dCkge1xuICAgIHJldHVybiBzcWxUZXh0LnRyaW0oKS5zdWJzdHJpbmcoMCwgMykudG9VcHBlckNhc2UoKSA9PT0gJ0dFVCc7XG59XG4vKipcbiAqIEFkZCBkb3VibGUgcXVvdGVzIHRvIHNta0lkJ3MgdmFsdWUgdG8gcGFyc2UgaXQgYXMgYSBzdHJpbmcgaW5zdGVhZCBvZiBpbnRlZ2VyXG4gKiB0byBwcmVzZXJ2ZSBwcmVjaXNpb24gb2YgbnVtYmVycyBleGNlZWRpbmcgSmF2YVNjcmlwdCdzIG1heCBzYWZlIGludGVnZXJcbiAqIGUuZyAoaW5wdXR0aW5nIDMyNjIxOTczMTI2MTIzNTI2XHRvdXRwdXRzIDMyNjIxOTczMTI2MTIzNTMwKVxuICpcbiAqIEBwYXJhbSBib2R5IHRoZSBkYXRhIGluIEpTT05cbiAqL1xuZnVuY3Rpb24gY29udmVydFNta0lkVG9TdHJpbmcoYm9keSkge1xuICAgIHJldHVybiBib2R5LnJlcGxhY2UoL1wic21rSWRcIihcXHMqKTooXFxzKikoWzAtOV0rKS9nLCAnXCJzbWtJZFwiJDE6JDJcIiQzXCInKTtcbn1cbi8qKlxuICogVW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzIHRoZSBvYmplY3QgcGFzc2VkIHRvIEpTT04uc3RyaW5naWZ5IGluIGV4Y2VwdGlvbiBoYW5kbGluZ1xuICogY2FuIGNvbnRhaW4gY2lyY3VsYXIgcmVmZXJlbmNlLCBvbiB3aGljaCBKU09OLnN0cmluZ2lmeSBiYWlscyBvdXRcbiAqIE1ETiB3YXkgb2YgaGFuZGxpbmcgc3VjaCBlcnJvclxuICovXG5mdW5jdGlvbiBnZXRDaXJjdWxhclJlcGxhY2VyKCkge1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGB0aGlzYCBpcyB0aGUgb2JqZWN0IHRoYXQgdmFsdWUgaXMgY29udGFpbmVkIGluLFxuICAgICAgICAvLyBpLmUuLCBpdHMgZGlyZWN0IHBhcmVudC5cbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzI2ODM6ICd0aGlzJyBpbXBsaWNpdGx5IGhhcyB0eXBlICdhbnknIGJlY2F1c2UgaXQgZG9lcyBub3QgaGF2ZSBhIHR5cGUgYW5ub3RhdGlvbi5cbiAgICAgICAgd2hpbGUgKGFuY2VzdG9ycy5sZW5ndGggPiAwICYmIGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMV0gIT09IHRoaXMpIHtcbiAgICAgICAgICAgIGFuY2VzdG9ycy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jZXN0b3JzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvcnMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzdWJkb21haW4uXG4gKi9cbmZ1bmN0aW9uIGlzQ29ycmVjdFN1YmRvbWFpbih2YWx1ZSkge1xuICAgIGNvbnN0IHN1YmRvbWFpblJlZ2V4ID0gUmVnRXhwKC9eXFx3KyhbLi1dXFx3KykqJC9pKTtcbiAgICByZXR1cm4gc3ViZG9tYWluUmVnZXgudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBidWlsZENyZWRlbnRpYWxDYWNoZUtleShob3N0LCB1c2VybmFtZSwgY3JlZFR5cGUpIHtcbiAgICBpZiAoIWhvc3QgfHwgIXVzZXJuYW1lIHx8ICFjcmVkVHlwZSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ2Fubm90IGJ1aWxkIHRoZSBjcmVkZW50aWFsIGNhY2hlIGtleSBiZWNhdXNlIG9uZSBvZiBob3N0LCB1c2VybmFtZSwgYW5kIGNyZWRUeXBlIGlzIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBgeyR7aG9zdC50b1VwcGVyQ2FzZSgpfX06eyR7dXNlcm5hbWUudG9VcHBlckNhc2UoKX19Onske2NyZWRUeXBlLnRvVXBwZXJDYXNlKCl9fWA7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkQ3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIpIHtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVNZXRob2RzID0gWyd3cml0ZScsICdyZWFkJywgJ3JlbW92ZSddO1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHJlcXVpcmVNZXRob2RzKSB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIsIG1ldGhvZCkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjdXN0b21DcmVkZW50aWFsTWFuYWdlclttZXRob2RdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjaGVja1BhcmFtZXRlcnNEZWZpbmVkKC4uLnBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gcGFyYW1ldGVycy5ldmVyeSgoZWxlbWVudCkgPT4gZWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnQgIT09IG51bGwpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGZpbGUgb3IgZGlyZWN0b3J5IHBlcm1pc3Npb25zIGFyZSBjb3JyZWN0LlxuICogQHBhcmFtIGZpbGVQYXRoXG4gKiBAcGFyYW0gZXhwZWN0ZWRNb2RlXG4gKiBAcGFyYW0gZnNQcm9taXNlc1xuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHJlc29sdmVzIGFsd2F5cyB0byB0cnVlIGZvciBXaW5kb3dzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzRmlsZU1vZGVDb3JyZWN0KGZpbGVQYXRoLCBleHBlY3RlZE1vZGUsIGZzUHJvbWlzZXMpIHtcbiAgICBpZiAob3NfMS5kZWZhdWx0LnBsYXRmb3JtKCkgPT09ICd3aW4zMicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBmc1Byb21pc2VzLnN0YXQoZmlsZVBhdGgpLnRoZW4oKHN0YXRzKSA9PiB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gbGltaXQgdGhlIG51bWJlciBvZiBMU0IgYml0cyB0byA5IHdpdGggdGhlIG1hc2ssIGFzIHRoZSBzdGF0cy5tb2RlIHN0YXJ0cyB3aXRoIHRoZSBmaWxlIHR5cGUsXG4gICAgICAgIC8vIGUuZy4gdGhlIGRpcmVjdG9yeSB3aXRoIHBlcm1pc3Npb25zIDc1NSB3aWxsIGhhdmUgc3RhdHMubWFzayBvZiA0MDc1NS5cbiAgICAgICAgY29uc3QgbWFzayA9ICgxIDw8IDkpIC0gMTtcbiAgICAgICAgcmV0dXJuIChzdGF0cy5tb2RlICYgbWFzaykgPT09IGV4cGVjdGVkTW9kZTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBmaWxlIG9yIGRpcmVjdG9yeSBpcyB3cml0YWJsZSBvbmx5IGJ5IHRoZSB1c2VyLlxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHJlc29sdmVzIGFsd2F5cyB0byB0cnVlIGZvciBXaW5kb3dzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzRmlsZU5vdFdyaXRhYmxlQnlHcm91cE9yT3RoZXJzKGNvbmZpZ0ZpbGVQYXRoLCBmc1Byb21pc2VzKSB7XG4gICAgaWYgKG9zXzEuZGVmYXVsdC5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzUHJvbWlzZXMuc3RhdChjb25maWdGaWxlUGF0aCk7XG4gICAgcmV0dXJuIChzdGF0cy5tb2RlICYgKDEgPDwgNCkpID09PSAwICYmIChzdGF0cy5tb2RlICYgKDEgPDwgMSkpID09PSAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnlPa3RhQXV0aCh7IG1heFJldHJ5VGltZW91dCwgbWF4UmV0cnlDb3VudCwgbnVtUmV0cmllcywgc3RhcnRUaW1lLCByZW1haW5pbmdUaW1lb3V0LCB9KSB7XG4gICAgcmV0dXJuICgobWF4UmV0cnlUaW1lb3V0ID09PSAwIHx8IERhdGUubm93KCkgPCBzdGFydFRpbWUgKyByZW1haW5pbmdUaW1lb3V0KSAmJlxuICAgICAgICBudW1SZXRyaWVzIDw9IG1heFJldHJ5Q291bnQpO1xufVxuZnVuY3Rpb24gZ2V0RHJpdmVyRGlyZWN0b3J5KCkge1xuICAgIHJldHVybiBfX2Rpcm5hbWU7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGgoZGlyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdCA9IGZzXzEuZGVmYXVsdC5zdGF0U3luYyhkaXIpO1xuICAgICAgICByZXR1cm4gc3RhdC5pc0RpcmVjdG9yeSgpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdUaGUgbG9jYXRpb24gaXMgaW52YWxpZC4gUGxlYXNlIGNoZWNrIHRoaXMgbG9jYXRpb24gaXMgYWNjZXNzaWJsZSBvciBleGlzdGluZycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RW52VmFyKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52W3ZhcmlhYmxlLnRvTG93ZXJDYXNlKCldIHx8IHByb2Nlc3MuZW52W3ZhcmlhYmxlLnRvVXBwZXJDYXNlKCldO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFbXB0eVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gJycgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTm90RW1wdHlBc1N0cmluZyh2YXJpYWJsZSkge1xuICAgIGlmICh0eXBlb2YgdmFyaWFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0cyh2YXJpYWJsZSk7XG59XG5mdW5jdGlvbiBpc05vdEVtcHR5U3RyaW5nKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIGV4aXN0cyh2YXJpYWJsZSkgJiYgdmFyaWFibGUgIT09ICcnO1xufVxuLyoqXG4gKiBDaGVja3MgV2hldGhlciB0aGUgb2JqZWN0IGlzIGVtcHR5IChjYW4gYmUgbnVsbCBvciB1bmRlZmluZWQpIG9yIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmplY3QpIHtcbiAgICBpZiAoIWV4aXN0cyhvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBpc1dpbmRvd3MoKSB7XG4gICAgcmV0dXJuIG9zXzEuZGVmYXVsdC5wbGF0Zm9ybSgpID09PSAnd2luMzInO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RnJlZVBvcnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgY29uc3Qgc3J2ID0gbmV0XzEuZGVmYXVsdC5jcmVhdGVTZXJ2ZXIoKTtcbiAgICAgICAgc3J2Lmxpc3RlbigwLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTMjMzOTogUHJvcGVydHkgJ3BvcnQnIGRvZXMgbm90IGV4aXN0IG9uIHR5cGUgJ3N0cmluZyB8IEFkZHJlc3NJbmZvJ1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IHNydi5hZGRyZXNzKCkucG9ydDtcbiAgICAgICAgICAgIHNydi5jbG9zZSgoKSA9PiByZXMocG9ydCkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlzUG9ydE9wZW4ocG9ydCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBuZXRfMS5kZWZhdWx0LmNyZWF0ZVNlcnZlcigpO1xuICAgICAgICBzLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgcy5jbG9zZSgpO1xuICAgICAgICAgICAgaWYgKGVyclsnY29kZSddID09PSAnRUFERFJJTlVTRScpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUG9ydDogJHtwb3J0fSBpcyBub3QgYXZhaWxhYmxlLiBWZXJpZmljYXRpb24gZmFpbGVkYCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCdQb3J0IG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgVGhlcmUgaXMgdW5leHBlY3RlZCBlcnJvciBkdXJpbmcgdmVyaWZpY2F0aW9uIG9mIHBvcnQgYXZhaWxhYmlsaXR5LiBQb3J0OiAke3BvcnR9LiBFcnJvcjogJHtKU09OLnN0cmluZ2lmeShlcnIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcy5vbmNlKCdsaXN0ZW5pbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBzLmNsb3NlKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgQ2xvc2luZyBzZXJ2ZXIgcnVuIGZvciB2ZXJpZmljYXRpb24gd2hldGhlciB0aGUgcG9ydCBpcyBhdmFpbGFibGUuIFBvcnQ6ICR7cG9ydH1gKTtcbiAgICAgICAgICAgIHJlc29sdmUoJ0xpc3RlbmluZycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcy5saXN0ZW4ocG9ydCk7XG4gICAgfSk7XG59XG4vKipcbiAqIExlZnQgc3RyaXAgdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXIgZnJvbSBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbHN0cmlwKHN0ciwgcmVtb3ZlKSB7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPiAwICYmIHJlbW92ZS5pbmRleE9mKHN0ci5jaGFyQXQoMCkpICE9PSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0cmFuc2Zvcm1zIEhUTUwgc3BlY2lhbCBjaGFyYWN0ZXJzIGludG8gdGhlaXIgY29ycmVzcG9uZGluZyBlbnRpdHkgcmVwcmVzZW50YXRpb25zLlxuICovXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHZhbHVlKSB7XG4gICAgaWYgKCFleGlzdHModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuLyoqXG4gKiBUeXBlc2NyaXB0IHdpdGggXCJtb2R1bGVcIjogXCJjb21tb25qc1wiIHdpbGwgdHJhbnNmb3JtIGV2ZXJ5IGltcG9ydCgpIHRvIGEgcmVxdWlyZSgpIHN0YXRlbWVudC5cbiAqXG4gKiBUaGlzIHdpbGwgYnJlYWsgRVNNIGR5bmFtaWMgaW1wb3J0cyByZXN1bHRpbmcgaW4gYSBydW50aW1lIGVycm9yOlxuICogLXJlcXVpcmUoKSBvZiBFUyBNb2R1bGUuLi4gZnJvbSAuLi4gbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBBIGhhY2t5IHNvbHV0aW9uIC0gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80MzMyOVxuICpcbiAqIFRoaXMgY291bGQgYmUgcmVtb3ZlZCBvbmNlIHdlIGRyb3Agbm9kZSAxOCBzdXBwb3J0IGFzIE5vZGUgMjArIHN1cHBvcnQgZXNtIGluIHJlcXVpcmUoKVxuICovXG5hc3luYyBmdW5jdGlvbiBkeW5hbWljSW1wb3J0RVNNSW5UeXBlc2NyaXB0V2l0aENvbW1vbkpTKG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oYHJldHVybiBpbXBvcnQoXCIke21vZHVsZU5hbWV9XCIpYCkoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    this.length = num === 0 ? 1 : this.length;\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsb0RBQXdCO0FBQ3ZDO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQSxtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsY0FBYztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLE1BQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzPzY0ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtudW1iZXIgJiAweDNmZmZmZmZdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgaWYgKGMgPj0gNDggJiYgYyA8PSA1Nykge1xuICAgICAgcmV0dXJuIGMgLSA0ODtcbiAgICAvLyAnQScgLSAnRidcbiAgICB9IGVsc2UgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ0ludmFsaWQgY2hhcmFjdGVyIGluICcgKyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZSAoc3RyaW5nLCBsb3dlckJvdW5kLCBpbmRleCkge1xuICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggLSAxID49IGxvd2VyQm91bmQpIHtcbiAgICAgIHIgfD0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4IC0gMSkgPDwgNDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyAyNC1iaXRzIGNodW5rc1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpIC09IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VMZW5ndGggPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICBmb3IgKGkgPSBwYXJzZUxlbmd0aCAlIDIgPT09IDAgPyBzdGFydCArIDEgOiBzdGFydDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICBiID0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICBiID0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSBjO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGMgPj0gMCAmJiBiIDwgbXVsLCAnSW52YWxpZCBjaGFyYWN0ZXInKTtcbiAgICAgIHIgKz0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gbW92ZSAoZGVzdCwgc3JjKSB7XG4gICAgZGVzdC53b3JkcyA9IHNyYy53b3JkcztcbiAgICBkZXN0Lmxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHNyYy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHNyYy5yZWQ7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiBfbW92ZSAoZGVzdCkge1xuICAgIG1vdmUoZGVzdCwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQ2hlY2sgU3ltYm9sLmZvciBiZWNhdXNlIG5vdCBldmVyeXdoZXJlIHdoZXJlIFN5bWJvbCBkZWZpbmVkXG4gIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TeW1ib2wjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBCTi5wcm90b3R5cGVbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBpbnNwZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH1cblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2Rybihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gIH07XG5cbiAgaWYgKEJ1ZmZlcikge1xuICAgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlIChBcnJheVR5cGUsIHNpemUpIHtcbiAgICBpZiAoQXJyYXlUeXBlLmFsbG9jVW5zYWZlKSB7XG4gICAgICByZXR1cm4gQXJyYXlUeXBlLmFsbG9jVW5zYWZlKHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5VHlwZShzaXplKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB2YXIgcmVzID0gYWxsb2NhdGUoQXJyYXlUeXBlLCByZXFMZW5ndGgpO1xuICAgIHZhciBwb3N0Zml4ID0gZW5kaWFuID09PSAnbGUnID8gJ0xFJyA6ICdCRSc7XG4gICAgdGhpc1snX3RvQXJyYXlMaWtlJyArIHBvc3RmaXhdKHJlcywgYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlTEUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VMRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlQkUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHJlcy5sZW5ndGggLSAxO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSA+Pj4gd2JpdCkgJiAweDAxO1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIC8vIFRlbXBvcmFyeSBkaXNhYmxlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvaXNzdWVzLzIxMVxuICAgIC8vIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICAvLyByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgICByZXR1cm4gYmlnTXVsVG8oc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IG51bSA9PT0gMCA/IDEgOiB0aGlzLmxlbmd0aDtcblxuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPD0gbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5fc3RyaXAoKTtcbiAgICB9XG4gICAgYS5fc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgKHIyID09PSAxICYmIGNtcCA9PT0gMCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZHJuID0gZnVuY3Rpb24gbW9kcm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gLWFjYyA6IGFjYztcbiAgfTtcblxuICAvLyBXQVJOSU5HOiBERVBSRUNBVEVEXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kcm4obnVtKTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjUgaW5zdGFuY2VcbiAgICAgICAgci5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIG1vdmUoYSwgYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpKTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/package.json":
/*!******************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/package.json ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"snowflake-sdk","version":"2.3.1","description":"Node.js driver for Snowflake","dependencies":{"@aws-crypto/sha256-js":"^5.2.0","@aws-sdk/client-s3":"^3.726.0","@aws-sdk/client-sts":"^3.899.0","@aws-sdk/credential-provider-node":"^3.823.0","@aws-sdk/ec2-metadata-service":"^3.826.0","@azure/identity":"^4.10.1","@azure/storage-blob":"12.26.x","@google-cloud/storage":"^7.7.0","@smithy/node-http-handler":"^4.0.1","@smithy/protocol-http":"^5.1.3","@smithy/signature-v4":"^5.2.1","@techteamer/ocsp":"1.0.1","asn1.js-rfc2560":"^5.0.0","asn1.js-rfc5280":"^3.0.0","axios":"^1.12.2","big-integer":"^1.6.43","bignumber.js":"^9.1.2","bn.js":"^5.2.1","browser-request":"^0.3.3","expand-tilde":"^2.0.2","fast-xml-parser":"^4.2.5","fastest-levenshtein":"^1.0.16","generic-pool":"^3.8.2","glob":"^10.0.0","google-auth-library":"^10.1.0","https-proxy-agent":"^7.0.2","jsonwebtoken":"^9.0.0","mime-types":"^2.1.29","moment":"^2.29.4","moment-timezone":"^0.5.15","oauth4webapi":"^3.0.1","open":"^7.3.1","simple-lru-cache":"^0.0.2","toml":"^3.0.0","uuid":"^8.3.2","winston":"^3.1.0"},"devDependencies":{"@aws-sdk/types":"^3.387.0","@types/mocha":"^10.0.10","@types/node":"^22.15.18","@types/sinon":"^17.0.4","async":"^3.2.3","eslint":"^8.41.0","husky":"^9.1.7","lint-staged":"^16.0.0","mocha":"^11.1.0","mock-require":"^3.0.3","nyc":"^15.1.0","prettier":"^3.5.3","rewiremock":"^3.14.6","sinon":"^20.0.0","test-console":"^2.0.0","ts-node":"^10.9.2","typescript":"^5.8.3","wiremock":"^3.10.0","wiremock-rest-client":"^1.11.0"},"peerDependencies":{"asn1.js":"^5.4.1"},"overrides":{"semver":"^7.5.2"},"repository":{"type":"git","url":"https://github.com/snowflakedb/snowflake-connector-nodejs"},"main":"./dist/index.js","typings":"./dist/index.d.ts","lint-staged":{"*":"npm run prettier:format","*.js":"npm run lint:check"},"scripts":{"prepack":"node ci/build_typescript.js","prepare":"husky","check-ts":"npm run prepack && tsc --noEmit ci/typescript-test.ts","lint:check":"eslint .","lint:fix":"eslint --fix","prettier:check":"prettier --check .","prettier:format":"prettier -w .","test":"mocha \'test/unit/**/*.{js,ts}\'","test:authentication":"mocha \'test/authentication/**/*.{js,ts}\'","test:auth-workload-identity-e2e":"mocha test/auth-workload-identity-e2e.ts","test:integration":"mocha \'test/integration/**/*.{js,ts}\'","test:single":"mocha","test:system":"mocha \'system_test/**/*.{js,ts}\'","test:unit":"mocha \'test/unit/**/*.{js,ts}\'","test:unit:coverage":"nyc npm run test:unit","test:ci":"mocha \'test/{unit,integration}/**/*.{js,ts}\'","test:ci:coverage":"nyc npm run test:ci","test:ci:withSystemTests":"mocha \'test/{unit,integration}/**/*.{js,ts}\' \'system_test/**/*.{js,ts}\'","test:ci:withSystemTests:coverage":"nyc npm run test:ci:withSystemTests","test:manual":"mocha test/integration/testManualConnection.js","serve-wiremock":"wiremock --enable-browser-proxying --proxy-pass-through  false --port 8081","wiremock":"npm run serve-wiremock"},"author":{"name":"Snowflake Computing, Inc.","email":"support@snowflake.com","url":"https://www.snowflake.com/"},"license":"Apache-2.0"}');

/***/ })

};
;