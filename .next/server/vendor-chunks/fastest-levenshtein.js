"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fastest-levenshtein";
exports.ids = ["vendor-chunks/fastest-levenshtein"];
exports.modules = {

/***/ "(rsc)/./node_modules/fastest-levenshtein/esm/mod.js":
/*!*****************************************************!*\
  !*** ./node_modules/fastest-levenshtein/esm/mod.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closest: () => (/* binding */ closest),\n/* harmony export */   distance: () => (/* binding */ distance)\n/* harmony export */ });\nconst peq = new Uint32Array(0x10000);\nconst myers_32 = (a, b) => {\n    const n = a.length;\n    const m = b.length;\n    const lst = 1 << (n - 1);\n    let pv = -1;\n    let mv = 0;\n    let sc = n;\n    let i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] |= 1 << i;\n    }\n    for (i = 0; i < m; i++) {\n        let eq = peq[b.charCodeAt(i)];\n        const xv = eq | mv;\n        eq |= ((eq & pv) + pv) ^ pv;\n        mv |= ~(eq | pv);\n        pv &= eq;\n        if (mv & lst) {\n            sc++;\n        }\n        if (pv & lst) {\n            sc--;\n        }\n        mv = (mv << 1) | 1;\n        pv = (pv << 1) | ~(xv | mv);\n        mv &= xv;\n    }\n    i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] = 0;\n    }\n    return sc;\n};\nconst myers_x = (b, a) => {\n    const n = a.length;\n    const m = b.length;\n    const mhc = [];\n    const phc = [];\n    const hsize = Math.ceil(n / 32);\n    const vsize = Math.ceil(m / 32);\n    for (let i = 0; i < hsize; i++) {\n        phc[i] = -1;\n        mhc[i] = 0;\n    }\n    let j = 0;\n    for (; j < vsize - 1; j++) {\n        let mv = 0;\n        let pv = -1;\n        const start = j * 32;\n        const vlen = Math.min(32, m) + start;\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] |= 1 << k;\n        }\n        for (let i = 0; i < n; i++) {\n            const eq = peq[a.charCodeAt(i)];\n            const pb = (phc[(i / 32) | 0] >>> i) & 1;\n            const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n            const xv = eq | mv;\n            const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n            let ph = mv | ~(xh | pv);\n            let mh = pv & xh;\n            if ((ph >>> 31) ^ pb) {\n                phc[(i / 32) | 0] ^= 1 << i;\n            }\n            if ((mh >>> 31) ^ mb) {\n                mhc[(i / 32) | 0] ^= 1 << i;\n            }\n            ph = (ph << 1) | pb;\n            mh = (mh << 1) | mb;\n            pv = mh | ~(xv | ph);\n            mv = ph & xv;\n        }\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] = 0;\n        }\n    }\n    let mv = 0;\n    let pv = -1;\n    const start = j * 32;\n    const vlen = Math.min(32, m - start) + start;\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] |= 1 << k;\n    }\n    let score = m;\n    for (let i = 0; i < n; i++) {\n        const eq = peq[a.charCodeAt(i)];\n        const pb = (phc[(i / 32) | 0] >>> i) & 1;\n        const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n        const xv = eq | mv;\n        const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n        let ph = mv | ~(xh | pv);\n        let mh = pv & xh;\n        score += (ph >>> (m - 1)) & 1;\n        score -= (mh >>> (m - 1)) & 1;\n        if ((ph >>> 31) ^ pb) {\n            phc[(i / 32) | 0] ^= 1 << i;\n        }\n        if ((mh >>> 31) ^ mb) {\n            mhc[(i / 32) | 0] ^= 1 << i;\n        }\n        ph = (ph << 1) | pb;\n        mh = (mh << 1) | mb;\n        pv = mh | ~(xv | ph);\n        mv = ph & xv;\n    }\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] = 0;\n    }\n    return score;\n};\nconst distance = (a, b) => {\n    if (a.length < b.length) {\n        const tmp = b;\n        b = a;\n        a = tmp;\n    }\n    if (b.length === 0) {\n        return a.length;\n    }\n    if (a.length <= 32) {\n        return myers_32(a, b);\n    }\n    return myers_x(a, b);\n};\nconst closest = (str, arr) => {\n    let min_distance = Infinity;\n    let min_index = 0;\n    for (let i = 0; i < arr.length; i++) {\n        const dist = distance(str, arr[i]);\n        if (dist < min_distance) {\n            min_distance = dist;\n            min_index = i;\n        }\n    }\n    return arr[min_index];\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdGVzdC1sZXZlbnNodGVpbi9lc20vbW9kLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9mYXN0ZXN0LWxldmVuc2h0ZWluL2VzbS9tb2QuanM/NDdkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwZXEgPSBuZXcgVWludDMyQXJyYXkoMHgxMDAwMCk7XG5jb25zdCBteWVyc18zMiA9IChhLCBiKSA9PiB7XG4gICAgY29uc3QgbiA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IG0gPSBiLmxlbmd0aDtcbiAgICBjb25zdCBsc3QgPSAxIDw8IChuIC0gMSk7XG4gICAgbGV0IHB2ID0gLTE7XG4gICAgbGV0IG12ID0gMDtcbiAgICBsZXQgc2MgPSBuO1xuICAgIGxldCBpID0gbjtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHBlcVthLmNoYXJDb2RlQXQoaSldIHw9IDEgPDwgaTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICBsZXQgZXEgPSBwZXFbYi5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgY29uc3QgeHYgPSBlcSB8IG12O1xuICAgICAgICBlcSB8PSAoKGVxICYgcHYpICsgcHYpIF4gcHY7XG4gICAgICAgIG12IHw9IH4oZXEgfCBwdik7XG4gICAgICAgIHB2ICY9IGVxO1xuICAgICAgICBpZiAobXYgJiBsc3QpIHtcbiAgICAgICAgICAgIHNjKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB2ICYgbHN0KSB7XG4gICAgICAgICAgICBzYy0tO1xuICAgICAgICB9XG4gICAgICAgIG12ID0gKG12IDw8IDEpIHwgMTtcbiAgICAgICAgcHYgPSAocHYgPDwgMSkgfCB+KHh2IHwgbXYpO1xuICAgICAgICBtdiAmPSB4djtcbiAgICB9XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBwZXFbYS5jaGFyQ29kZUF0KGkpXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzYztcbn07XG5jb25zdCBteWVyc194ID0gKGIsIGEpID0+IHtcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XG4gICAgY29uc3QgbSA9IGIubGVuZ3RoO1xuICAgIGNvbnN0IG1oYyA9IFtdO1xuICAgIGNvbnN0IHBoYyA9IFtdO1xuICAgIGNvbnN0IGhzaXplID0gTWF0aC5jZWlsKG4gLyAzMik7XG4gICAgY29uc3QgdnNpemUgPSBNYXRoLmNlaWwobSAvIDMyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhzaXplOyBpKyspIHtcbiAgICAgICAgcGhjW2ldID0gLTE7XG4gICAgICAgIG1oY1tpXSA9IDA7XG4gICAgfVxuICAgIGxldCBqID0gMDtcbiAgICBmb3IgKDsgaiA8IHZzaXplIC0gMTsgaisrKSB7XG4gICAgICAgIGxldCBtdiA9IDA7XG4gICAgICAgIGxldCBwdiA9IC0xO1xuICAgICAgICBjb25zdCBzdGFydCA9IGogKiAzMjtcbiAgICAgICAgY29uc3QgdmxlbiA9IE1hdGgubWluKDMyLCBtKSArIHN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBrID0gc3RhcnQ7IGsgPCB2bGVuOyBrKyspIHtcbiAgICAgICAgICAgIHBlcVtiLmNoYXJDb2RlQXQoayldIHw9IDEgPDwgaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZXEgPSBwZXFbYS5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIGNvbnN0IHBiID0gKHBoY1soaSAvIDMyKSB8IDBdID4+PiBpKSAmIDE7XG4gICAgICAgICAgICBjb25zdCBtYiA9IChtaGNbKGkgLyAzMikgfCAwXSA+Pj4gaSkgJiAxO1xuICAgICAgICAgICAgY29uc3QgeHYgPSBlcSB8IG12O1xuICAgICAgICAgICAgY29uc3QgeGggPSAoKCgoZXEgfCBtYikgJiBwdikgKyBwdikgXiBwdikgfCBlcSB8IG1iO1xuICAgICAgICAgICAgbGV0IHBoID0gbXYgfCB+KHhoIHwgcHYpO1xuICAgICAgICAgICAgbGV0IG1oID0gcHYgJiB4aDtcbiAgICAgICAgICAgIGlmICgocGggPj4+IDMxKSBeIHBiKSB7XG4gICAgICAgICAgICAgICAgcGhjWyhpIC8gMzIpIHwgMF0gXj0gMSA8PCBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtaCA+Pj4gMzEpIF4gbWIpIHtcbiAgICAgICAgICAgICAgICBtaGNbKGkgLyAzMikgfCAwXSBePSAxIDw8IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaCA9IChwaCA8PCAxKSB8IHBiO1xuICAgICAgICAgICAgbWggPSAobWggPDwgMSkgfCBtYjtcbiAgICAgICAgICAgIHB2ID0gbWggfCB+KHh2IHwgcGgpO1xuICAgICAgICAgICAgbXYgPSBwaCAmIHh2O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGsgPSBzdGFydDsgayA8IHZsZW47IGsrKykge1xuICAgICAgICAgICAgcGVxW2IuY2hhckNvZGVBdChrKV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtdiA9IDA7XG4gICAgbGV0IHB2ID0gLTE7XG4gICAgY29uc3Qgc3RhcnQgPSBqICogMzI7XG4gICAgY29uc3QgdmxlbiA9IE1hdGgubWluKDMyLCBtIC0gc3RhcnQpICsgc3RhcnQ7XG4gICAgZm9yIChsZXQgayA9IHN0YXJ0OyBrIDwgdmxlbjsgaysrKSB7XG4gICAgICAgIHBlcVtiLmNoYXJDb2RlQXQoayldIHw9IDEgPDwgaztcbiAgICB9XG4gICAgbGV0IHNjb3JlID0gbTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCBlcSA9IHBlcVthLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBjb25zdCBwYiA9IChwaGNbKGkgLyAzMikgfCAwXSA+Pj4gaSkgJiAxO1xuICAgICAgICBjb25zdCBtYiA9IChtaGNbKGkgLyAzMikgfCAwXSA+Pj4gaSkgJiAxO1xuICAgICAgICBjb25zdCB4diA9IGVxIHwgbXY7XG4gICAgICAgIGNvbnN0IHhoID0gKCgoKGVxIHwgbWIpICYgcHYpICsgcHYpIF4gcHYpIHwgZXEgfCBtYjtcbiAgICAgICAgbGV0IHBoID0gbXYgfCB+KHhoIHwgcHYpO1xuICAgICAgICBsZXQgbWggPSBwdiAmIHhoO1xuICAgICAgICBzY29yZSArPSAocGggPj4+IChtIC0gMSkpICYgMTtcbiAgICAgICAgc2NvcmUgLT0gKG1oID4+PiAobSAtIDEpKSAmIDE7XG4gICAgICAgIGlmICgocGggPj4+IDMxKSBeIHBiKSB7XG4gICAgICAgICAgICBwaGNbKGkgLyAzMikgfCAwXSBePSAxIDw8IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtaCA+Pj4gMzEpIF4gbWIpIHtcbiAgICAgICAgICAgIG1oY1soaSAvIDMyKSB8IDBdIF49IDEgPDwgaTtcbiAgICAgICAgfVxuICAgICAgICBwaCA9IChwaCA8PCAxKSB8IHBiO1xuICAgICAgICBtaCA9IChtaCA8PCAxKSB8IG1iO1xuICAgICAgICBwdiA9IG1oIHwgfih4diB8IHBoKTtcbiAgICAgICAgbXYgPSBwaCAmIHh2O1xuICAgIH1cbiAgICBmb3IgKGxldCBrID0gc3RhcnQ7IGsgPCB2bGVuOyBrKyspIHtcbiAgICAgICAgcGVxW2IuY2hhckNvZGVBdChrKV0gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG59O1xuY29uc3QgZGlzdGFuY2UgPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IGI7XG4gICAgICAgIGIgPSBhO1xuICAgICAgICBhID0gdG1wO1xuICAgIH1cbiAgICBpZiAoYi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggPD0gMzIpIHtcbiAgICAgICAgcmV0dXJuIG15ZXJzXzMyKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gbXllcnNfeChhLCBiKTtcbn07XG5jb25zdCBjbG9zZXN0ID0gKHN0ciwgYXJyKSA9PiB7XG4gICAgbGV0IG1pbl9kaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCBtaW5faW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBkaXN0YW5jZShzdHIsIGFycltpXSk7XG4gICAgICAgIGlmIChkaXN0IDwgbWluX2Rpc3RhbmNlKSB7XG4gICAgICAgICAgICBtaW5fZGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgbWluX2luZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyW21pbl9pbmRleF07XG59O1xuZXhwb3J0IHsgY2xvc2VzdCwgZGlzdGFuY2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fastest-levenshtein/esm/mod.js\n");

/***/ })

};
;