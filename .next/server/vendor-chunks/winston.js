"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/winston";
exports.ids = ["vendor-chunks/winston"];
exports.modules = {

/***/ "(rsc)/./node_modules/winston/lib/winston.js":
/*!*********************************************!*\
  !*** ./node_modules/winston/lib/winston.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * winston.js: Top-level include defining Winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst logform = __webpack_require__(/*! logform */ \"(rsc)/./node_modules/logform/index.js\");\nconst { warn } = __webpack_require__(/*! ./winston/common */ \"(rsc)/./node_modules/winston/lib/winston/common.js\");\n\n/**\n * Expose version. Use `require` method for `webpack` support.\n * @type {string}\n */\nexports.version = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/winston/package.json\").version;\n/**\n * Include transports defined by default by winston\n * @type {Array}\n */\nexports.transports = __webpack_require__(/*! ./winston/transports */ \"(rsc)/./node_modules/winston/lib/winston/transports/index.js\");\n/**\n * Expose utility methods\n * @type {Object}\n */\nexports.config = __webpack_require__(/*! ./winston/config */ \"(rsc)/./node_modules/winston/lib/winston/config/index.js\");\n/**\n * Hoist format-related functionality from logform.\n * @type {Object}\n */\nexports.addColors = logform.levels;\n/**\n * Hoist format-related functionality from logform.\n * @type {Object}\n */\nexports.format = logform.format;\n/**\n * Expose core Logging-related prototypes.\n * @type {function}\n */\nexports.createLogger = __webpack_require__(/*! ./winston/create-logger */ \"(rsc)/./node_modules/winston/lib/winston/create-logger.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {function}\n */\nexports.Logger = __webpack_require__(/*! ./winston/logger */ \"(rsc)/./node_modules/winston/lib/winston/logger.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Object}\n */\nexports.ExceptionHandler = __webpack_require__(/*! ./winston/exception-handler */ \"(rsc)/./node_modules/winston/lib/winston/exception-handler.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Object}\n */\nexports.RejectionHandler = __webpack_require__(/*! ./winston/rejection-handler */ \"(rsc)/./node_modules/winston/lib/winston/rejection-handler.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Container}\n */\nexports.Container = __webpack_require__(/*! ./winston/container */ \"(rsc)/./node_modules/winston/lib/winston/container.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Object}\n */\nexports.Transport = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\n/**\n * We create and expose a default `Container` to `winston.loggers` so that the\n * programmer may manage multiple `winston.Logger` instances without any\n * additional overhead.\n * @example\n *   // some-file1.js\n *   const logger = require('winston').loggers.get('something');\n *\n *   // some-file2.js\n *   const logger = require('winston').loggers.get('something');\n */\nexports.loggers = new exports.Container();\n\n/**\n * We create and expose a 'defaultLogger' so that the programmer may do the\n * following without the need to create an instance of winston.Logger directly:\n * @example\n *   const winston = require('winston');\n *   winston.log('info', 'some message');\n *   winston.error('some error');\n */\nconst defaultLogger = exports.createLogger();\n\n// Pass through the target methods onto `winston.\nObject.keys(exports.config.npm.levels)\n  .concat([\n    'log',\n    'query',\n    'stream',\n    'add',\n    'remove',\n    'clear',\n    'profile',\n    'startTimer',\n    'handleExceptions',\n    'unhandleExceptions',\n    'handleRejections',\n    'unhandleRejections',\n    'configure',\n    'child'\n  ])\n  .forEach(\n    method => (exports[method] = (...args) => defaultLogger[method](...args))\n  );\n\n/**\n * Define getter / setter for the default logger level which need to be exposed\n * by winston.\n * @type {string}\n */\nObject.defineProperty(exports, \"level\", ({\n  get() {\n    return defaultLogger.level;\n  },\n  set(val) {\n    defaultLogger.level = val;\n  }\n}));\n\n/**\n * Define getter for `exceptions` which replaces `handleExceptions` and\n * `unhandleExceptions`.\n * @type {Object}\n */\nObject.defineProperty(exports, \"exceptions\", ({\n  get() {\n    return defaultLogger.exceptions;\n  }\n}));\n\n/**\n * Define getter for `rejections` which replaces `handleRejections` and\n * `unhandleRejections`.\n * @type {Object}\n */\nObject.defineProperty(exports, \"rejections\", ({\n  get() {\n    return defaultLogger.rejections;\n  }\n}));\n\n/**\n * Define getters / setters for appropriate properties of the default logger\n * which need to be exposed by winston.\n * @type {Logger}\n */\n['exitOnError'].forEach(prop => {\n  Object.defineProperty(exports, prop, {\n    get() {\n      return defaultLogger[prop];\n    },\n    set(val) {\n      defaultLogger[prop] = val;\n    }\n  });\n});\n\n/**\n * The default transports and exceptionHandlers for the default winston logger.\n * @type {Object}\n */\nObject.defineProperty(exports, \"default\", ({\n  get() {\n    return {\n      exceptionHandlers: defaultLogger.exceptionHandlers,\n      rejectionHandlers: defaultLogger.rejectionHandlers,\n      transports: defaultLogger.transports\n    };\n  }\n}));\n\n// Have friendlier breakage notices for properties that were exposed by default\n// on winston < 3.0.\nwarn.deprecated(exports, 'setLevels');\nwarn.forFunctions(exports, 'useFormat', ['cli']);\nwarn.forProperties(exports, 'useFormat', ['padLevels', 'stripColors']);\nwarn.forFunctions(exports, 'deprecated', [\n  'addRewriter',\n  'addFilter',\n  'clone',\n  'extend'\n]);\nwarn.forProperties(exports, 'deprecated', ['emitErrs', 'levelLength']);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQVM7QUFDakMsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyw0RUFBa0I7O0FBRTNDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpSEFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG9JQUFvRDtBQUNwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0hBQTRDO0FBQzVDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esc0lBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxrSEFBNEM7QUFDNUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGtKQUFpRTtBQUNqRTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0pBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwySEFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG1IQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlDQUF3QztBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uLmpzPzdlODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB3aW5zdG9uLmpzOiBUb3AtbGV2ZWwgaW5jbHVkZSBkZWZpbmluZyBXaW5zdG9uLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGxvZ2Zvcm0gPSByZXF1aXJlKCdsb2dmb3JtJyk7XG5jb25zdCB7IHdhcm4gfSA9IHJlcXVpcmUoJy4vd2luc3Rvbi9jb21tb24nKTtcblxuLyoqXG4gKiBFeHBvc2UgdmVyc2lvbi4gVXNlIGByZXF1aXJlYCBtZXRob2QgZm9yIGB3ZWJwYWNrYCBzdXBwb3J0LlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbi8qKlxuICogSW5jbHVkZSB0cmFuc3BvcnRzIGRlZmluZWQgYnkgZGVmYXVsdCBieSB3aW5zdG9uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbmV4cG9ydHMudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vd2luc3Rvbi90cmFuc3BvcnRzJyk7XG4vKipcbiAqIEV4cG9zZSB1dGlsaXR5IG1ldGhvZHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY29uZmlnID0gcmVxdWlyZSgnLi93aW5zdG9uL2NvbmZpZycpO1xuLyoqXG4gKiBIb2lzdCBmb3JtYXQtcmVsYXRlZCBmdW5jdGlvbmFsaXR5IGZyb20gbG9nZm9ybS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuYWRkQ29sb3JzID0gbG9nZm9ybS5sZXZlbHM7XG4vKipcbiAqIEhvaXN0IGZvcm1hdC1yZWxhdGVkIGZ1bmN0aW9uYWxpdHkgZnJvbSBsb2dmb3JtLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5mb3JtYXQgPSBsb2dmb3JtLmZvcm1hdDtcbi8qKlxuICogRXhwb3NlIGNvcmUgTG9nZ2luZy1yZWxhdGVkIHByb3RvdHlwZXMuXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuY3JlYXRlTG9nZ2VyID0gcmVxdWlyZSgnLi93aW5zdG9uL2NyZWF0ZS1sb2dnZXInKTtcbi8qKlxuICogRXhwb3NlIGNvcmUgTG9nZ2luZy1yZWxhdGVkIHByb3RvdHlwZXMuXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuTG9nZ2VyID0gcmVxdWlyZSgnLi93aW5zdG9uL2xvZ2dlcicpO1xuLyoqXG4gKiBFeHBvc2UgY29yZSBMb2dnaW5nLXJlbGF0ZWQgcHJvdG90eXBlcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuRXhjZXB0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4vd2luc3Rvbi9leGNlcHRpb24taGFuZGxlcicpO1xuLyoqXG4gKiBFeHBvc2UgY29yZSBMb2dnaW5nLXJlbGF0ZWQgcHJvdG90eXBlcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuUmVqZWN0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4vd2luc3Rvbi9yZWplY3Rpb24taGFuZGxlcicpO1xuLyoqXG4gKiBFeHBvc2UgY29yZSBMb2dnaW5nLXJlbGF0ZWQgcHJvdG90eXBlcy5cbiAqIEB0eXBlIHtDb250YWluZXJ9XG4gKi9cbmV4cG9ydHMuQ29udGFpbmVyID0gcmVxdWlyZSgnLi93aW5zdG9uL2NvbnRhaW5lcicpO1xuLyoqXG4gKiBFeHBvc2UgY29yZSBMb2dnaW5nLXJlbGF0ZWQgcHJvdG90eXBlcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuVHJhbnNwb3J0ID0gcmVxdWlyZSgnd2luc3Rvbi10cmFuc3BvcnQnKTtcbi8qKlxuICogV2UgY3JlYXRlIGFuZCBleHBvc2UgYSBkZWZhdWx0IGBDb250YWluZXJgIHRvIGB3aW5zdG9uLmxvZ2dlcnNgIHNvIHRoYXQgdGhlXG4gKiBwcm9ncmFtbWVyIG1heSBtYW5hZ2UgbXVsdGlwbGUgYHdpbnN0b24uTG9nZ2VyYCBpbnN0YW5jZXMgd2l0aG91dCBhbnlcbiAqIGFkZGl0aW9uYWwgb3ZlcmhlYWQuXG4gKiBAZXhhbXBsZVxuICogICAvLyBzb21lLWZpbGUxLmpzXG4gKiAgIGNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJ3dpbnN0b24nKS5sb2dnZXJzLmdldCgnc29tZXRoaW5nJyk7XG4gKlxuICogICAvLyBzb21lLWZpbGUyLmpzXG4gKiAgIGNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJ3dpbnN0b24nKS5sb2dnZXJzLmdldCgnc29tZXRoaW5nJyk7XG4gKi9cbmV4cG9ydHMubG9nZ2VycyA9IG5ldyBleHBvcnRzLkNvbnRhaW5lcigpO1xuXG4vKipcbiAqIFdlIGNyZWF0ZSBhbmQgZXhwb3NlIGEgJ2RlZmF1bHRMb2dnZXInIHNvIHRoYXQgdGhlIHByb2dyYW1tZXIgbWF5IGRvIHRoZVxuICogZm9sbG93aW5nIHdpdGhvdXQgdGhlIG5lZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIHdpbnN0b24uTG9nZ2VyIGRpcmVjdGx5OlxuICogQGV4YW1wbGVcbiAqICAgY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoJ3dpbnN0b24nKTtcbiAqICAgd2luc3Rvbi5sb2coJ2luZm8nLCAnc29tZSBtZXNzYWdlJyk7XG4gKiAgIHdpbnN0b24uZXJyb3IoJ3NvbWUgZXJyb3InKTtcbiAqL1xuY29uc3QgZGVmYXVsdExvZ2dlciA9IGV4cG9ydHMuY3JlYXRlTG9nZ2VyKCk7XG5cbi8vIFBhc3MgdGhyb3VnaCB0aGUgdGFyZ2V0IG1ldGhvZHMgb250byBgd2luc3Rvbi5cbk9iamVjdC5rZXlzKGV4cG9ydHMuY29uZmlnLm5wbS5sZXZlbHMpXG4gIC5jb25jYXQoW1xuICAgICdsb2cnLFxuICAgICdxdWVyeScsXG4gICAgJ3N0cmVhbScsXG4gICAgJ2FkZCcsXG4gICAgJ3JlbW92ZScsXG4gICAgJ2NsZWFyJyxcbiAgICAncHJvZmlsZScsXG4gICAgJ3N0YXJ0VGltZXInLFxuICAgICdoYW5kbGVFeGNlcHRpb25zJyxcbiAgICAndW5oYW5kbGVFeGNlcHRpb25zJyxcbiAgICAnaGFuZGxlUmVqZWN0aW9ucycsXG4gICAgJ3VuaGFuZGxlUmVqZWN0aW9ucycsXG4gICAgJ2NvbmZpZ3VyZScsXG4gICAgJ2NoaWxkJ1xuICBdKVxuICAuZm9yRWFjaChcbiAgICBtZXRob2QgPT4gKGV4cG9ydHNbbWV0aG9kXSA9ICguLi5hcmdzKSA9PiBkZWZhdWx0TG9nZ2VyW21ldGhvZF0oLi4uYXJncykpXG4gICk7XG5cbi8qKlxuICogRGVmaW5lIGdldHRlciAvIHNldHRlciBmb3IgdGhlIGRlZmF1bHQgbG9nZ2VyIGxldmVsIHdoaWNoIG5lZWQgdG8gYmUgZXhwb3NlZFxuICogYnkgd2luc3Rvbi5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbGV2ZWwnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlci5sZXZlbDtcbiAgfSxcbiAgc2V0KHZhbCkge1xuICAgIGRlZmF1bHRMb2dnZXIubGV2ZWwgPSB2YWw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIERlZmluZSBnZXR0ZXIgZm9yIGBleGNlcHRpb25zYCB3aGljaCByZXBsYWNlcyBgaGFuZGxlRXhjZXB0aW9uc2AgYW5kXG4gKiBgdW5oYW5kbGVFeGNlcHRpb25zYC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZXhjZXB0aW9ucycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyLmV4Y2VwdGlvbnM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIERlZmluZSBnZXR0ZXIgZm9yIGByZWplY3Rpb25zYCB3aGljaCByZXBsYWNlcyBgaGFuZGxlUmVqZWN0aW9uc2AgYW5kXG4gKiBgdW5oYW5kbGVSZWplY3Rpb25zYC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVqZWN0aW9ucycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyLnJlamVjdGlvbnM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIERlZmluZSBnZXR0ZXJzIC8gc2V0dGVycyBmb3IgYXBwcm9wcmlhdGUgcHJvcGVydGllcyBvZiB0aGUgZGVmYXVsdCBsb2dnZXJcbiAqIHdoaWNoIG5lZWQgdG8gYmUgZXhwb3NlZCBieSB3aW5zdG9uLlxuICogQHR5cGUge0xvZ2dlcn1cbiAqL1xuWydleGl0T25FcnJvciddLmZvckVhY2gocHJvcCA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBwcm9wLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXJbcHJvcF07XG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICBkZWZhdWx0TG9nZ2VyW3Byb3BdID0gdmFsO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB0cmFuc3BvcnRzIGFuZCBleGNlcHRpb25IYW5kbGVycyBmb3IgdGhlIGRlZmF1bHQgd2luc3RvbiBsb2dnZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHQnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhjZXB0aW9uSGFuZGxlcnM6IGRlZmF1bHRMb2dnZXIuZXhjZXB0aW9uSGFuZGxlcnMsXG4gICAgICByZWplY3Rpb25IYW5kbGVyczogZGVmYXVsdExvZ2dlci5yZWplY3Rpb25IYW5kbGVycyxcbiAgICAgIHRyYW5zcG9ydHM6IGRlZmF1bHRMb2dnZXIudHJhbnNwb3J0c1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBIYXZlIGZyaWVuZGxpZXIgYnJlYWthZ2Ugbm90aWNlcyBmb3IgcHJvcGVydGllcyB0aGF0IHdlcmUgZXhwb3NlZCBieSBkZWZhdWx0XG4vLyBvbiB3aW5zdG9uIDwgMy4wLlxud2Fybi5kZXByZWNhdGVkKGV4cG9ydHMsICdzZXRMZXZlbHMnKTtcbndhcm4uZm9yRnVuY3Rpb25zKGV4cG9ydHMsICd1c2VGb3JtYXQnLCBbJ2NsaSddKTtcbndhcm4uZm9yUHJvcGVydGllcyhleHBvcnRzLCAndXNlRm9ybWF0JywgWydwYWRMZXZlbHMnLCAnc3RyaXBDb2xvcnMnXSk7XG53YXJuLmZvckZ1bmN0aW9ucyhleHBvcnRzLCAnZGVwcmVjYXRlZCcsIFtcbiAgJ2FkZFJld3JpdGVyJyxcbiAgJ2FkZEZpbHRlcicsXG4gICdjbG9uZScsXG4gICdleHRlbmQnXG5dKTtcbndhcm4uZm9yUHJvcGVydGllcyhleHBvcnRzLCAnZGVwcmVjYXRlZCcsIFsnZW1pdEVycnMnLCAnbGV2ZWxMZW5ndGgnXSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/common.js":
/*!****************************************************!*\
  !*** ./node_modules/winston/lib/winston/common.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * common.js: Internal helper and utility functions for winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { format } = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Set of simple deprecation notices and a way to expose them for a set of\n * properties.\n * @type {Object}\n * @private\n */\nexports.warn = {\n  deprecated(prop) {\n    return () => {\n      throw new Error(format('{ %s } was removed in winston@3.0.0.', prop));\n    };\n  },\n  useFormat(prop) {\n    return () => {\n      throw new Error([\n        format('{ %s } was removed in winston@3.0.0.', prop),\n        'Use a custom winston.format = winston.format(function) instead.'\n      ].join('\\n'));\n    };\n  },\n  forFunctions(obj, type, props) {\n    props.forEach(prop => {\n      obj[prop] = exports.warn[type](prop);\n    });\n  },\n  forProperties(obj, type, props) {\n    props.forEach(prop => {\n      const notice = exports.warn[type](prop);\n      Object.defineProperty(obj, prop, {\n        get: notice,\n        set: notice\n      });\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2NvbW1vbi5qcz9iODc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY29tbW9uLmpzOiBJbnRlcm5hbCBoZWxwZXIgYW5kIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB3aW5zdG9uLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogU2V0IG9mIHNpbXBsZSBkZXByZWNhdGlvbiBub3RpY2VzIGFuZCBhIHdheSB0byBleHBvc2UgdGhlbSBmb3IgYSBzZXQgb2ZcbiAqIHByb3BlcnRpZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy53YXJuID0ge1xuICBkZXByZWNhdGVkKHByb3ApIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgneyAlcyB9IHdhcyByZW1vdmVkIGluIHdpbnN0b25AMy4wLjAuJywgcHJvcCkpO1xuICAgIH07XG4gIH0sXG4gIHVzZUZvcm1hdChwcm9wKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGZvcm1hdCgneyAlcyB9IHdhcyByZW1vdmVkIGluIHdpbnN0b25AMy4wLjAuJywgcHJvcCksXG4gICAgICAgICdVc2UgYSBjdXN0b20gd2luc3Rvbi5mb3JtYXQgPSB3aW5zdG9uLmZvcm1hdChmdW5jdGlvbikgaW5zdGVhZC4nXG4gICAgICBdLmpvaW4oJ1xcbicpKTtcbiAgICB9O1xuICB9LFxuICBmb3JGdW5jdGlvbnMob2JqLCB0eXBlLCBwcm9wcykge1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBvYmpbcHJvcF0gPSBleHBvcnRzLndhcm5bdHlwZV0ocHJvcCk7XG4gICAgfSk7XG4gIH0sXG4gIGZvclByb3BlcnRpZXMob2JqLCB0eXBlLCBwcm9wcykge1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBjb25zdCBub3RpY2UgPSBleHBvcnRzLndhcm5bdHlwZV0ocHJvcCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgIGdldDogbm90aWNlLFxuICAgICAgICBzZXQ6IG5vdGljZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/config/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/winston/lib/winston/config/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * index.js: Default settings for all levels that winston knows about.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst logform = __webpack_require__(/*! logform */ \"(rsc)/./node_modules/logform/index.js\");\nconst { configs } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\n\n/**\n * Export config set for the CLI.\n * @type {Object}\n */\nexports.cli = logform.levels(configs.cli);\n\n/**\n * Export config set for npm.\n * @type {Object}\n */\nexports.npm = logform.levels(configs.npm);\n\n/**\n * Export config set for the syslog.\n * @type {Object}\n */\nexports.syslog = logform.levels(configs.syslog);\n\n/**\n * Hoist addColors from logform where it was refactored into in winston@3.\n * @type {Object}\n */\nexports.addColors = logform.levels;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb25maWcvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFTO0FBQ2pDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsOERBQWE7O0FBRXpDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2NvbmZpZy9pbmRleC5qcz81OGUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogaW5kZXguanM6IERlZmF1bHQgc2V0dGluZ3MgZm9yIGFsbCBsZXZlbHMgdGhhdCB3aW5zdG9uIGtub3dzIGFib3V0LlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGxvZ2Zvcm0gPSByZXF1aXJlKCdsb2dmb3JtJyk7XG5jb25zdCB7IGNvbmZpZ3MgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5cbi8qKlxuICogRXhwb3J0IGNvbmZpZyBzZXQgZm9yIHRoZSBDTEkuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmNsaSA9IGxvZ2Zvcm0ubGV2ZWxzKGNvbmZpZ3MuY2xpKTtcblxuLyoqXG4gKiBFeHBvcnQgY29uZmlnIHNldCBmb3IgbnBtLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5ucG0gPSBsb2dmb3JtLmxldmVscyhjb25maWdzLm5wbSk7XG5cbi8qKlxuICogRXhwb3J0IGNvbmZpZyBzZXQgZm9yIHRoZSBzeXNsb2cuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLnN5c2xvZyA9IGxvZ2Zvcm0ubGV2ZWxzKGNvbmZpZ3Muc3lzbG9nKTtcblxuLyoqXG4gKiBIb2lzdCBhZGRDb2xvcnMgZnJvbSBsb2dmb3JtIHdoZXJlIGl0IHdhcyByZWZhY3RvcmVkIGludG8gaW4gd2luc3RvbkAzLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5hZGRDb2xvcnMgPSBsb2dmb3JtLmxldmVscztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/config/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/container.js":
/*!*******************************************************!*\
  !*** ./node_modules/winston/lib/winston/container.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * container.js: Inversion of control container for winston logger instances.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst createLogger = __webpack_require__(/*! ./create-logger */ \"(rsc)/./node_modules/winston/lib/winston/create-logger.js\");\n\n/**\n * Inversion of control container for winston logger instances.\n * @type {Container}\n */\nmodule.exports = class Container {\n  /**\n   * Constructor function for the Container object responsible for managing a\n   * set of `winston.Logger` instances based on string ids.\n   * @param {!Object} [options={}] - Default pass-thru options for Loggers.\n   */\n  constructor(options = {}) {\n    this.loggers = new Map();\n    this.options = options;\n  }\n\n  /**\n   * Retrieves a `winston.Logger` instance for the specified `id`. If an\n   * instance does not exist, one is created.\n   * @param {!string} id - The id of the Logger to get.\n   * @param {?Object} [options] - Options for the Logger instance.\n   * @returns {Logger} - A configured Logger instance with a specified id.\n   */\n  add(id, options) {\n    if (!this.loggers.has(id)) {\n      // Remark: Simple shallow clone for configuration options in case we pass\n      // in instantiated protoypal objects\n      options = Object.assign({}, options || this.options);\n      const existing = options.transports || this.options.transports;\n\n      // Remark: Make sure if we have an array of transports we slice it to\n      // make copies of those references.\n      if (existing) {\n        options.transports = Array.isArray(existing) ? existing.slice() : [existing];\n      } else {\n        options.transports = [];\n      }\n\n      const logger = createLogger(options);\n      logger.on('close', () => this._delete(id));\n      this.loggers.set(id, logger);\n    }\n\n    return this.loggers.get(id);\n  }\n\n  /**\n   * Retreives a `winston.Logger` instance for the specified `id`. If\n   * an instance does not exist, one is created.\n   * @param {!string} id - The id of the Logger to get.\n   * @param {?Object} [options] - Options for the Logger instance.\n   * @returns {Logger} - A configured Logger instance with a specified id.\n   */\n  get(id, options) {\n    return this.add(id, options);\n  }\n\n  /**\n   * Check if the container has a logger with the id.\n   * @param {?string} id - The id of the Logger instance to find.\n   * @returns {boolean} - Boolean value indicating if this instance has a\n   * logger with the specified `id`.\n   */\n  has(id) {\n    return !!this.loggers.has(id);\n  }\n\n  /**\n   * Closes a `Logger` instance with the specified `id` if it exists.\n   * If no `id` is supplied then all Loggers are closed.\n   * @param {?string} id - The id of the Logger instance to close.\n   * @returns {undefined}\n   */\n  close(id) {\n    if (id) {\n      return this._removeLogger(id);\n    }\n\n    this.loggers.forEach((val, key) => this._removeLogger(key));\n  }\n\n  /**\n   * Remove a logger based on the id.\n   * @param {!string} id - The id of the logger to remove.\n   * @returns {undefined}\n   * @private\n   */\n  _removeLogger(id) {\n    if (!this.loggers.has(id)) {\n      return;\n    }\n\n    const logger = this.loggers.get(id);\n    logger.close();\n    this._delete(id);\n  }\n\n  /**\n   * Deletes a `Logger` instance with the specified `id`.\n   * @param {!string} id - The id of the Logger instance to delete from\n   * container.\n   * @returns {undefined}\n   * @private\n   */\n  _delete(id) {\n    this.loggers.delete(id);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb250YWluZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFpQjs7QUFFOUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLFdBQVc7QUFDakM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb250YWluZXIuanM/MDMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGNvbnRhaW5lci5qczogSW52ZXJzaW9uIG9mIGNvbnRyb2wgY29udGFpbmVyIGZvciB3aW5zdG9uIGxvZ2dlciBpbnN0YW5jZXMuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgY3JlYXRlTG9nZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGUtbG9nZ2VyJyk7XG5cbi8qKlxuICogSW52ZXJzaW9uIG9mIGNvbnRyb2wgY29udGFpbmVyIGZvciB3aW5zdG9uIGxvZ2dlciBpbnN0YW5jZXMuXG4gKiBAdHlwZSB7Q29udGFpbmVyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIENvbnRhaW5lciBvYmplY3QgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIGFcbiAgICogc2V0IG9mIGB3aW5zdG9uLkxvZ2dlcmAgaW5zdGFuY2VzIGJhc2VkIG9uIHN0cmluZyBpZHMuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBwYXNzLXRocnUgb3B0aW9ucyBmb3IgTG9nZ2Vycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMubG9nZ2VycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGB3aW5zdG9uLkxvZ2dlcmAgaW5zdGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgYGlkYC4gSWYgYW5cbiAgICogaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QsIG9uZSBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBMb2dnZXIgdG8gZ2V0LlxuICAgKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtMb2dnZXJ9IC0gQSBjb25maWd1cmVkIExvZ2dlciBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWVkIGlkLlxuICAgKi9cbiAgYWRkKGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmxvZ2dlcnMuaGFzKGlkKSkge1xuICAgICAgLy8gUmVtYXJrOiBTaW1wbGUgc2hhbGxvdyBjbG9uZSBmb3IgY29uZmlndXJhdGlvbiBvcHRpb25zIGluIGNhc2Ugd2UgcGFzc1xuICAgICAgLy8gaW4gaW5zdGFudGlhdGVkIHByb3RveXBhbCBvYmplY3RzXG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMpO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBvcHRpb25zLnRyYW5zcG9ydHMgfHwgdGhpcy5vcHRpb25zLnRyYW5zcG9ydHM7XG5cbiAgICAgIC8vIFJlbWFyazogTWFrZSBzdXJlIGlmIHdlIGhhdmUgYW4gYXJyYXkgb2YgdHJhbnNwb3J0cyB3ZSBzbGljZSBpdCB0b1xuICAgICAgLy8gbWFrZSBjb3BpZXMgb2YgdGhvc2UgcmVmZXJlbmNlcy5cbiAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICBvcHRpb25zLnRyYW5zcG9ydHMgPSBBcnJheS5pc0FycmF5KGV4aXN0aW5nKSA/IGV4aXN0aW5nLnNsaWNlKCkgOiBbZXhpc3RpbmddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnRzID0gW107XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihvcHRpb25zKTtcbiAgICAgIGxvZ2dlci5vbignY2xvc2UnLCAoKSA9PiB0aGlzLl9kZWxldGUoaWQpKTtcbiAgICAgIHRoaXMubG9nZ2Vycy5zZXQoaWQsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9nZ2Vycy5nZXQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJlaXZlcyBhIGB3aW5zdG9uLkxvZ2dlcmAgaW5zdGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgYGlkYC4gSWZcbiAgICogYW4gaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QsIG9uZSBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBMb2dnZXIgdG8gZ2V0LlxuICAgKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtMb2dnZXJ9IC0gQSBjb25maWd1cmVkIExvZ2dlciBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWVkIGlkLlxuICAgKi9cbiAgZ2V0KGlkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKGlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgY29udGFpbmVyIGhhcyBhIGxvZ2dlciB3aXRoIHRoZSBpZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBpZCAtIFRoZSBpZCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhXG4gICAqIGxvZ2dlciB3aXRoIHRoZSBzcGVjaWZpZWQgYGlkYC5cbiAgICovXG4gIGhhcyhpZCkge1xuICAgIHJldHVybiAhIXRoaXMubG9nZ2Vycy5oYXMoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhIGBMb2dnZXJgIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBgaWRgIGlmIGl0IGV4aXN0cy5cbiAgICogSWYgbm8gYGlkYCBpcyBzdXBwbGllZCB0aGVuIGFsbCBMb2dnZXJzIGFyZSBjbG9zZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIExvZ2dlciBpbnN0YW5jZSB0byBjbG9zZS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGNsb3NlKGlkKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlTG9nZ2VyKGlkKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlcnMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHRoaXMuX3JlbW92ZUxvZ2dlcihrZXkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBsb2dnZXIgYmFzZWQgb24gdGhlIGlkLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBsb2dnZXIgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbW92ZUxvZ2dlcihpZCkge1xuICAgIGlmICghdGhpcy5sb2dnZXJzLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlcnMuZ2V0KGlkKTtcbiAgICBsb2dnZXIuY2xvc2UoKTtcbiAgICB0aGlzLl9kZWxldGUoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBgTG9nZ2VyYCBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgYGlkYC5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBpZCAtIFRoZSBpZCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlIHRvIGRlbGV0ZSBmcm9tXG4gICAqIGNvbnRhaW5lci5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWxldGUoaWQpIHtcbiAgICB0aGlzLmxvZ2dlcnMuZGVsZXRlKGlkKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/container.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/create-logger.js":
/*!***********************************************************!*\
  !*** ./node_modules/winston/lib/winston/create-logger.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * create-logger.js: Logger factory for winston logger instances.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { LEVEL } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst config = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/winston/lib/winston/config/index.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/winston/lib/winston/logger.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:create-logger');\n\nfunction isLevelEnabledFunctionName(level) {\n  return 'is' + level.charAt(0).toUpperCase() + level.slice(1) + 'Enabled';\n}\n\n/**\n * Create a new instance of a winston Logger. Creates a new\n * prototype for each instance.\n * @param {!Object} opts - Options for the created logger.\n * @returns {Logger} - A newly created logger instance.\n */\nmodule.exports = function (opts = {}) {\n  //\n  // Default levels: npm\n  //\n  opts.levels = opts.levels || config.npm.levels;\n\n  /**\n   * DerivedLogger to attach the logs level methods.\n   * @type {DerivedLogger}\n   * @extends {Logger}\n   */\n  class DerivedLogger extends Logger {\n    /**\n     * Create a new class derived logger for which the levels can be attached to\n     * the prototype of. This is a V8 optimization that is well know to increase\n     * performance of prototype functions.\n     * @param {!Object} options - Options for the created logger.\n     */\n    constructor(options) {\n      super(options);\n    }\n  }\n\n  const logger = new DerivedLogger(opts);\n\n  //\n  // Create the log level methods for the derived logger.\n  //\n  Object.keys(opts.levels).forEach(function (level) {\n    debug('Define prototype method for \"%s\"', level);\n    if (level === 'log') {\n      // eslint-disable-next-line no-console\n      console.warn('Level \"log\" not defined: conflicts with the method \"log\". Use a different level name.');\n      return;\n    }\n\n    //\n    // Define prototype methods for each log level e.g.:\n    // logger.log('info', msg) implies these methods are defined:\n    // - logger.info(msg)\n    // - logger.isInfoEnabled()\n    //\n    // Remark: to support logger.child this **MUST** be a function\n    // so it'll always be called on the instance instead of a fixed\n    // place in the prototype chain.\n    //\n    DerivedLogger.prototype[level] = function (...args) {\n      // Prefer any instance scope, but default to \"root\" logger\n      const self = this || logger;\n\n      // Optimize the hot-path which is the single object.\n      if (args.length === 1) {\n        const [msg] = args;\n        const info = msg && msg.message && msg || { message: msg };\n        info.level = info[LEVEL] = level;\n        self._addDefaultMeta(info);\n        self.write(info);\n        return (this || logger);\n      }\n\n      // When provided nothing assume the empty string\n      if (args.length === 0) {\n        self.log(level, '');\n        return self;\n      }\n\n      // Otherwise build argument list which could potentially conform to\n      // either:\n      // . v3 API: log(obj)\n      // 2. v1/v2 API: log(level, msg, ... [string interpolate], [{metadata}], [callback])\n      return self.log(level, ...args);\n    };\n\n    DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function () {\n      return (this || logger).isLevelEnabled(level);\n    };\n  });\n\n  return logger;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jcmVhdGUtbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQywwRUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsb0VBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLCtFQUFtQjs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vY3JlYXRlLWxvZ2dlci5qcz9jM2RjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY3JlYXRlLWxvZ2dlci5qczogTG9nZ2VyIGZhY3RvcnkgZm9yIHdpbnN0b24gbG9nZ2VyIGluc3RhbmNlcy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IExFVkVMIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ0BkYWJoL2RpYWdub3N0aWNzJykoJ3dpbnN0b246Y3JlYXRlLWxvZ2dlcicpO1xuXG5mdW5jdGlvbiBpc0xldmVsRW5hYmxlZEZ1bmN0aW9uTmFtZShsZXZlbCkge1xuICByZXR1cm4gJ2lzJyArIGxldmVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbGV2ZWwuc2xpY2UoMSkgKyAnRW5hYmxlZCc7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgd2luc3RvbiBMb2dnZXIuIENyZWF0ZXMgYSBuZXdcbiAqIHByb3RvdHlwZSBmb3IgZWFjaCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb3B0cyAtIE9wdGlvbnMgZm9yIHRoZSBjcmVhdGVkIGxvZ2dlci5cbiAqIEByZXR1cm5zIHtMb2dnZXJ9IC0gQSBuZXdseSBjcmVhdGVkIGxvZ2dlciBpbnN0YW5jZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cyA9IHt9KSB7XG4gIC8vXG4gIC8vIERlZmF1bHQgbGV2ZWxzOiBucG1cbiAgLy9cbiAgb3B0cy5sZXZlbHMgPSBvcHRzLmxldmVscyB8fCBjb25maWcubnBtLmxldmVscztcblxuICAvKipcbiAgICogRGVyaXZlZExvZ2dlciB0byBhdHRhY2ggdGhlIGxvZ3MgbGV2ZWwgbWV0aG9kcy5cbiAgICogQHR5cGUge0Rlcml2ZWRMb2dnZXJ9XG4gICAqIEBleHRlbmRzIHtMb2dnZXJ9XG4gICAqL1xuICBjbGFzcyBEZXJpdmVkTG9nZ2VyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2xhc3MgZGVyaXZlZCBsb2dnZXIgZm9yIHdoaWNoIHRoZSBsZXZlbHMgY2FuIGJlIGF0dGFjaGVkIHRvXG4gICAgICogdGhlIHByb3RvdHlwZSBvZi4gVGhpcyBpcyBhIFY4IG9wdGltaXphdGlvbiB0aGF0IGlzIHdlbGwga25vdyB0byBpbmNyZWFzZVxuICAgICAqIHBlcmZvcm1hbmNlIG9mIHByb3RvdHlwZSBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGNyZWF0ZWQgbG9nZ2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxvZ2dlciA9IG5ldyBEZXJpdmVkTG9nZ2VyKG9wdHMpO1xuXG4gIC8vXG4gIC8vIENyZWF0ZSB0aGUgbG9nIGxldmVsIG1ldGhvZHMgZm9yIHRoZSBkZXJpdmVkIGxvZ2dlci5cbiAgLy9cbiAgT2JqZWN0LmtleXMob3B0cy5sZXZlbHMpLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgZGVidWcoJ0RlZmluZSBwcm90b3R5cGUgbWV0aG9kIGZvciBcIiVzXCInLCBsZXZlbCk7XG4gICAgaWYgKGxldmVsID09PSAnbG9nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignTGV2ZWwgXCJsb2dcIiBub3QgZGVmaW5lZDogY29uZmxpY3RzIHdpdGggdGhlIG1ldGhvZCBcImxvZ1wiLiBVc2UgYSBkaWZmZXJlbnQgbGV2ZWwgbmFtZS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIERlZmluZSBwcm90b3R5cGUgbWV0aG9kcyBmb3IgZWFjaCBsb2cgbGV2ZWwgZS5nLjpcbiAgICAvLyBsb2dnZXIubG9nKCdpbmZvJywgbXNnKSBpbXBsaWVzIHRoZXNlIG1ldGhvZHMgYXJlIGRlZmluZWQ6XG4gICAgLy8gLSBsb2dnZXIuaW5mbyhtc2cpXG4gICAgLy8gLSBsb2dnZXIuaXNJbmZvRW5hYmxlZCgpXG4gICAgLy9cbiAgICAvLyBSZW1hcms6IHRvIHN1cHBvcnQgbG9nZ2VyLmNoaWxkIHRoaXMgKipNVVNUKiogYmUgYSBmdW5jdGlvblxuICAgIC8vIHNvIGl0J2xsIGFsd2F5cyBiZSBjYWxsZWQgb24gdGhlIGluc3RhbmNlIGluc3RlYWQgb2YgYSBmaXhlZFxuICAgIC8vIHBsYWNlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgLy9cbiAgICBEZXJpdmVkTG9nZ2VyLnByb3RvdHlwZVtsZXZlbF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgLy8gUHJlZmVyIGFueSBpbnN0YW5jZSBzY29wZSwgYnV0IGRlZmF1bHQgdG8gXCJyb290XCIgbG9nZ2VyXG4gICAgICBjb25zdCBzZWxmID0gdGhpcyB8fCBsb2dnZXI7XG5cbiAgICAgIC8vIE9wdGltaXplIHRoZSBob3QtcGF0aCB3aGljaCBpcyB0aGUgc2luZ2xlIG9iamVjdC5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBbbXNnXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IGluZm8gPSBtc2cgJiYgbXNnLm1lc3NhZ2UgJiYgbXNnIHx8IHsgbWVzc2FnZTogbXNnIH07XG4gICAgICAgIGluZm8ubGV2ZWwgPSBpbmZvW0xFVkVMXSA9IGxldmVsO1xuICAgICAgICBzZWxmLl9hZGREZWZhdWx0TWV0YShpbmZvKTtcbiAgICAgICAgc2VsZi53cml0ZShpbmZvKTtcbiAgICAgICAgcmV0dXJuICh0aGlzIHx8IGxvZ2dlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gcHJvdmlkZWQgbm90aGluZyBhc3N1bWUgdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYubG9nKGxldmVsLCAnJyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UgYnVpbGQgYXJndW1lbnQgbGlzdCB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBjb25mb3JtIHRvXG4gICAgICAvLyBlaXRoZXI6XG4gICAgICAvLyAuIHYzIEFQSTogbG9nKG9iailcbiAgICAgIC8vIDIuIHYxL3YyIEFQSTogbG9nKGxldmVsLCBtc2csIC4uLiBbc3RyaW5nIGludGVycG9sYXRlXSwgW3ttZXRhZGF0YX1dLCBbY2FsbGJhY2tdKVxuICAgICAgcmV0dXJuIHNlbGYubG9nKGxldmVsLCAuLi5hcmdzKTtcbiAgICB9O1xuXG4gICAgRGVyaXZlZExvZ2dlci5wcm90b3R5cGVbaXNMZXZlbEVuYWJsZWRGdW5jdGlvbk5hbWUobGV2ZWwpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcyB8fCBsb2dnZXIpLmlzTGV2ZWxFbmFibGVkKGxldmVsKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gbG9nZ2VyO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/create-logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/exception-handler.js":
/*!***************************************************************!*\
  !*** ./node_modules/winston/lib/winston/exception-handler.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * exception-handler.js: Object for handling uncaughtException events.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst asyncForEach = __webpack_require__(/*! async/forEach */ \"(rsc)/./node_modules/async/forEach.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:exception');\nconst once = __webpack_require__(/*! one-time */ \"(rsc)/./node_modules/one-time/index.js\");\nconst stackTrace = __webpack_require__(/*! stack-trace */ \"(rsc)/./node_modules/stack-trace/lib/stack-trace.js\");\nconst ExceptionStream = __webpack_require__(/*! ./exception-stream */ \"(rsc)/./node_modules/winston/lib/winston/exception-stream.js\");\n\n/**\n * Object for handling uncaughtException events.\n * @type {ExceptionHandler}\n */\nmodule.exports = class ExceptionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger} logger - TODO: add param description\n   */\n  constructor(logger) {\n    if (!logger) {\n      throw new Error('Logger is required to handle exceptions');\n    }\n\n    this.logger = logger;\n    this.handlers = new Map();\n  }\n\n  /**\n   * Handles `uncaughtException` events for the current process by adding any\n   * handlers passed in.\n   * @returns {undefined}\n   */\n  handle(...args) {\n    args.forEach(arg => {\n      if (Array.isArray(arg)) {\n        return arg.forEach(handler => this._addHandler(handler));\n      }\n\n      this._addHandler(arg);\n    });\n\n    if (!this.catcher) {\n      this.catcher = this._uncaughtException.bind(this);\n      process.on('uncaughtException', this.catcher);\n    }\n  }\n\n  /**\n   * Removes any handlers to `uncaughtException` events for the current\n   * process. This does not modify the state of the `this.handlers` set.\n   * @returns {undefined}\n   */\n  unhandle() {\n    if (this.catcher) {\n      process.removeListener('uncaughtException', this.catcher);\n      this.catcher = false;\n\n      Array.from(this.handlers.values())\n        .forEach(wrapper => this.logger.unpipe(wrapper));\n    }\n  }\n\n  /**\n   * TODO: add method description\n   * @param {Error} err - Error to get information about.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getAllInfo(err) {\n    let message = null;\n    if (err) {\n      message = typeof err === 'string' ? err : err.message;\n    }\n\n    return {\n      error: err,\n      // TODO (indexzero): how do we configure this?\n      level: 'error',\n      message: [\n        `uncaughtException: ${(message || '(no error message)')}`,\n        err && err.stack || '  No stack trace'\n      ].join('\\n'),\n      stack: err && err.stack,\n      exception: true,\n      date: new Date().toString(),\n      process: this.getProcessInfo(),\n      os: this.getOsInfo(),\n      trace: this.getTrace(err)\n    };\n  }\n\n  /**\n   * Gets all relevant process information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getProcessInfo() {\n    return {\n      pid: process.pid,\n      uid: process.getuid ? process.getuid() : null,\n      gid: process.getgid ? process.getgid() : null,\n      cwd: process.cwd(),\n      execPath: process.execPath,\n      version: process.version,\n      argv: process.argv,\n      memoryUsage: process.memoryUsage()\n    };\n  }\n\n  /**\n   * Gets all relevant OS information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getOsInfo() {\n    return {\n      loadavg: os.loadavg(),\n      uptime: os.uptime()\n    };\n  }\n\n  /**\n   * Gets a stack trace for the specified error.\n   * @param {mixed} err - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getTrace(err) {\n    const trace = err ? stackTrace.parse(err) : stackTrace.get();\n    return trace.map(site => {\n      return {\n        column: site.getColumnNumber(),\n        file: site.getFileName(),\n        function: site.getFunctionName(),\n        line: site.getLineNumber(),\n        method: site.getMethodName(),\n        native: site.isNative()\n      };\n    });\n  }\n\n  /**\n   * Helper method to add a transport as an exception handler.\n   * @param {Transport} handler - The transport to add as an exception handler.\n   * @returns {void}\n   */\n  _addHandler(handler) {\n    if (!this.handlers.has(handler)) {\n      handler.handleExceptions = true;\n      const wrapper = new ExceptionStream(handler);\n      this.handlers.set(handler, wrapper);\n      this.logger.pipe(wrapper);\n    }\n  }\n\n  /**\n   * Logs all relevant information around the `err` and exits the current\n   * process.\n   * @param {Error} err - Error to handle\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _uncaughtException(err) {\n    const info = this.getAllInfo(err);\n    const handlers = this._getExceptionHandlers();\n    // Calculate if we should exit on this error\n    let doExit = typeof this.logger.exitOnError === 'function'\n      ? this.logger.exitOnError(err)\n      : this.logger.exitOnError;\n    let timeout;\n\n    if (!handlers.length && doExit) {\n      // eslint-disable-next-line no-console\n      console.warn('winston: exitOnError cannot be true with no exception handlers.');\n      // eslint-disable-next-line no-console\n      console.warn('winston: not exiting process.');\n      doExit = false;\n    }\n\n    function gracefulExit() {\n      debug('doExit', doExit);\n      debug('process._exiting', process._exiting);\n\n      if (doExit && !process._exiting) {\n        // Remark: Currently ignoring any exceptions from transports when\n        // catching uncaught exceptions.\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }\n    }\n\n    if (!handlers || handlers.length === 0) {\n      return process.nextTick(gracefulExit);\n    }\n\n    // Log to all transports attempting to listen for when they are completed.\n    asyncForEach(handlers, (handler, next) => {\n      const done = once(next);\n      const transport = handler.transport || handler;\n\n      // Debug wrapping so that we can inspect what's going on under the covers.\n      function onDone(event) {\n        return () => {\n          debug(event);\n          done();\n        };\n      }\n\n      transport._ending = true;\n      transport.once('finish', onDone('finished'));\n      transport.once('error', onDone('error'));\n    }, () => doExit && gracefulExit());\n\n    this.logger.log(info);\n\n    // If exitOnError is true, then only allow the logging of exceptions to\n    // take up to `3000ms`.\n    if (doExit) {\n      timeout = setTimeout(gracefulExit, 3000);\n    }\n  }\n\n  /**\n   * Returns the list of transports and exceptionHandlers for this instance.\n   * @returns {Array} - List of transports and exceptionHandlers for this\n   * instance.\n   * @private\n   */\n  _getExceptionHandlers() {\n    // Remark (indexzero): since `logger.transports` returns all of the pipes\n    // from the _readableState of the stream we actually get the join of the\n    // explicit handlers and the implicit transports with\n    // `handleExceptions: true`\n    return this.logger.transports.filter(wrap => {\n      const transport = wrap.transport || wrap;\n      return transport.handleExceptions;\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9leGNlcHRpb24taGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCLG1CQUFPLENBQUMsNERBQWU7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLCtFQUFtQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsd0RBQVU7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWE7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQW9COztBQUVwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vZXhjZXB0aW9uLWhhbmRsZXIuanM/Njg5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGV4Y2VwdGlvbi1oYW5kbGVyLmpzOiBPYmplY3QgZm9yIGhhbmRsaW5nIHVuY2F1Z2h0RXhjZXB0aW9uIGV2ZW50cy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBhc3luY0ZvckVhY2ggPSByZXF1aXJlKCdhc3luYy9mb3JFYWNoJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ0BkYWJoL2RpYWdub3N0aWNzJykoJ3dpbnN0b246ZXhjZXB0aW9uJyk7XG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25lLXRpbWUnKTtcbmNvbnN0IHN0YWNrVHJhY2UgPSByZXF1aXJlKCdzdGFjay10cmFjZScpO1xuY29uc3QgRXhjZXB0aW9uU3RyZWFtID0gcmVxdWlyZSgnLi9leGNlcHRpb24tc3RyZWFtJyk7XG5cbi8qKlxuICogT2JqZWN0IGZvciBoYW5kbGluZyB1bmNhdWdodEV4Y2VwdGlvbiBldmVudHMuXG4gKiBAdHlwZSB7RXhjZXB0aW9uSGFuZGxlcn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFeGNlcHRpb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIFRPRE86IGFkZCBjb250cnVjdG9yIGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7IUxvZ2dlcn0gbG9nZ2VyIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dnZXIgaXMgcmVxdWlyZWQgdG8gaGFuZGxlIGV4Y2VwdGlvbnMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYHVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudHMgZm9yIHRoZSBjdXJyZW50IHByb2Nlc3MgYnkgYWRkaW5nIGFueVxuICAgKiBoYW5kbGVycyBwYXNzZWQgaW4uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBoYW5kbGUoLi4uYXJncykge1xuICAgIGFyZ3MuZm9yRWFjaChhcmcgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnLmZvckVhY2goaGFuZGxlciA9PiB0aGlzLl9hZGRIYW5kbGVyKGhhbmRsZXIpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkSGFuZGxlcihhcmcpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmNhdGNoZXIpIHtcbiAgICAgIHRoaXMuY2F0Y2hlciA9IHRoaXMuX3VuY2F1Z2h0RXhjZXB0aW9uLmJpbmQodGhpcyk7XG4gICAgICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIHRoaXMuY2F0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIHRvIGB1bmNhdWdodEV4Y2VwdGlvbmAgZXZlbnRzIGZvciB0aGUgY3VycmVudFxuICAgKiBwcm9jZXNzLiBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgc3RhdGUgb2YgdGhlIGB0aGlzLmhhbmRsZXJzYCBzZXQuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICB1bmhhbmRsZSgpIHtcbiAgICBpZiAodGhpcy5jYXRjaGVyKSB7XG4gICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIHRoaXMuY2F0Y2hlcik7XG4gICAgICB0aGlzLmNhdGNoZXIgPSBmYWxzZTtcblxuICAgICAgQXJyYXkuZnJvbSh0aGlzLmhhbmRsZXJzLnZhbHVlcygpKVxuICAgICAgICAuZm9yRWFjaCh3cmFwcGVyID0+IHRoaXMubG9nZ2VyLnVucGlwZSh3cmFwcGVyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0LlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldEFsbEluZm8oZXJyKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBudWxsO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIG1lc3NhZ2UgPSB0eXBlb2YgZXJyID09PSAnc3RyaW5nJyA/IGVyciA6IGVyci5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyLFxuICAgICAgLy8gVE9ETyAoaW5kZXh6ZXJvKTogaG93IGRvIHdlIGNvbmZpZ3VyZSB0aGlzP1xuICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlOiBbXG4gICAgICAgIGB1bmNhdWdodEV4Y2VwdGlvbjogJHsobWVzc2FnZSB8fCAnKG5vIGVycm9yIG1lc3NhZ2UpJyl9YCxcbiAgICAgICAgZXJyICYmIGVyci5zdGFjayB8fCAnICBObyBzdGFjayB0cmFjZSdcbiAgICAgIF0uam9pbignXFxuJyksXG4gICAgICBzdGFjazogZXJyICYmIGVyci5zdGFjayxcbiAgICAgIGV4Y2VwdGlvbjogdHJ1ZSxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKSxcbiAgICAgIHByb2Nlc3M6IHRoaXMuZ2V0UHJvY2Vzc0luZm8oKSxcbiAgICAgIG9zOiB0aGlzLmdldE9zSW5mbygpLFxuICAgICAgdHJhY2U6IHRoaXMuZ2V0VHJhY2UoZXJyKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgcmVsZXZhbnQgcHJvY2VzcyBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0UHJvY2Vzc0luZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpZDogcHJvY2Vzcy5waWQsXG4gICAgICB1aWQ6IHByb2Nlc3MuZ2V0dWlkID8gcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGwsXG4gICAgICBnaWQ6IHByb2Nlc3MuZ2V0Z2lkID8gcHJvY2Vzcy5nZXRnaWQoKSA6IG51bGwsXG4gICAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgICBleGVjUGF0aDogcHJvY2Vzcy5leGVjUGF0aCxcbiAgICAgIHZlcnNpb246IHByb2Nlc3MudmVyc2lvbixcbiAgICAgIGFyZ3Y6IHByb2Nlc3MuYXJndixcbiAgICAgIG1lbW9yeVVzYWdlOiBwcm9jZXNzLm1lbW9yeVVzYWdlKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHJlbGV2YW50IE9TIGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgcHJvY2Vzcy5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBnZXRPc0luZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRhdmc6IG9zLmxvYWRhdmcoKSxcbiAgICAgIHVwdGltZTogb3MudXB0aW1lKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzdGFjayB0cmFjZSBmb3IgdGhlIHNwZWNpZmllZCBlcnJvci5cbiAgICogQHBhcmFtIHttaXhlZH0gZXJyIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldFRyYWNlKGVycikge1xuICAgIGNvbnN0IHRyYWNlID0gZXJyID8gc3RhY2tUcmFjZS5wYXJzZShlcnIpIDogc3RhY2tUcmFjZS5nZXQoKTtcbiAgICByZXR1cm4gdHJhY2UubWFwKHNpdGUgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1uOiBzaXRlLmdldENvbHVtbk51bWJlcigpLFxuICAgICAgICBmaWxlOiBzaXRlLmdldEZpbGVOYW1lKCksXG4gICAgICAgIGZ1bmN0aW9uOiBzaXRlLmdldEZ1bmN0aW9uTmFtZSgpLFxuICAgICAgICBsaW5lOiBzaXRlLmdldExpbmVOdW1iZXIoKSxcbiAgICAgICAgbWV0aG9kOiBzaXRlLmdldE1ldGhvZE5hbWUoKSxcbiAgICAgICAgbmF0aXZlOiBzaXRlLmlzTmF0aXZlKClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSB0cmFuc3BvcnQgYXMgYW4gZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7VHJhbnNwb3J0fSBoYW5kbGVyIC0gVGhlIHRyYW5zcG9ydCB0byBhZGQgYXMgYW4gZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2FkZEhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5oYW5kbGVycy5oYXMoaGFuZGxlcikpIHtcbiAgICAgIGhhbmRsZXIuaGFuZGxlRXhjZXB0aW9ucyA9IHRydWU7XG4gICAgICBjb25zdCB3cmFwcGVyID0gbmV3IEV4Y2VwdGlvblN0cmVhbShoYW5kbGVyKTtcbiAgICAgIHRoaXMuaGFuZGxlcnMuc2V0KGhhbmRsZXIsIHdyYXBwZXIpO1xuICAgICAgdGhpcy5sb2dnZXIucGlwZSh3cmFwcGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhbGwgcmVsZXZhbnQgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBgZXJyYCBhbmQgZXhpdHMgdGhlIGN1cnJlbnRcbiAgICogcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgdG8gaGFuZGxlXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VuY2F1Z2h0RXhjZXB0aW9uKGVycikge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldEFsbEluZm8oZXJyKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2dldEV4Y2VwdGlvbkhhbmRsZXJzKCk7XG4gICAgLy8gQ2FsY3VsYXRlIGlmIHdlIHNob3VsZCBleGl0IG9uIHRoaXMgZXJyb3JcbiAgICBsZXQgZG9FeGl0ID0gdHlwZW9mIHRoaXMubG9nZ2VyLmV4aXRPbkVycm9yID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRoaXMubG9nZ2VyLmV4aXRPbkVycm9yKGVycilcbiAgICAgIDogdGhpcy5sb2dnZXIuZXhpdE9uRXJyb3I7XG4gICAgbGV0IHRpbWVvdXQ7XG5cbiAgICBpZiAoIWhhbmRsZXJzLmxlbmd0aCAmJiBkb0V4aXQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ3dpbnN0b246IGV4aXRPbkVycm9yIGNhbm5vdCBiZSB0cnVlIHdpdGggbm8gZXhjZXB0aW9uIGhhbmRsZXJzLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybignd2luc3Rvbjogbm90IGV4aXRpbmcgcHJvY2Vzcy4nKTtcbiAgICAgIGRvRXhpdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyYWNlZnVsRXhpdCgpIHtcbiAgICAgIGRlYnVnKCdkb0V4aXQnLCBkb0V4aXQpO1xuICAgICAgZGVidWcoJ3Byb2Nlc3MuX2V4aXRpbmcnLCBwcm9jZXNzLl9leGl0aW5nKTtcblxuICAgICAgaWYgKGRvRXhpdCAmJiAhcHJvY2Vzcy5fZXhpdGluZykge1xuICAgICAgICAvLyBSZW1hcms6IEN1cnJlbnRseSBpZ25vcmluZyBhbnkgZXhjZXB0aW9ucyBmcm9tIHRyYW5zcG9ydHMgd2hlblxuICAgICAgICAvLyBjYXRjaGluZyB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1leGl0XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8IGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZ3JhY2VmdWxFeGl0KTtcbiAgICB9XG5cbiAgICAvLyBMb2cgdG8gYWxsIHRyYW5zcG9ydHMgYXR0ZW1wdGluZyB0byBsaXN0ZW4gZm9yIHdoZW4gdGhleSBhcmUgY29tcGxldGVkLlxuICAgIGFzeW5jRm9yRWFjaChoYW5kbGVycywgKGhhbmRsZXIsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGRvbmUgPSBvbmNlKG5leHQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaGFuZGxlci50cmFuc3BvcnQgfHwgaGFuZGxlcjtcblxuICAgICAgLy8gRGVidWcgd3JhcHBpbmcgc28gdGhhdCB3ZSBjYW4gaW5zcGVjdCB3aGF0J3MgZ29pbmcgb24gdW5kZXIgdGhlIGNvdmVycy5cbiAgICAgIGZ1bmN0aW9uIG9uRG9uZShldmVudCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKGV2ZW50KTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRyYW5zcG9ydC5fZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRyYW5zcG9ydC5vbmNlKCdmaW5pc2gnLCBvbkRvbmUoJ2ZpbmlzaGVkJykpO1xuICAgICAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25Eb25lKCdlcnJvcicpKTtcbiAgICB9LCAoKSA9PiBkb0V4aXQgJiYgZ3JhY2VmdWxFeGl0KCkpO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKGluZm8pO1xuXG4gICAgLy8gSWYgZXhpdE9uRXJyb3IgaXMgdHJ1ZSwgdGhlbiBvbmx5IGFsbG93IHRoZSBsb2dnaW5nIG9mIGV4Y2VwdGlvbnMgdG9cbiAgICAvLyB0YWtlIHVwIHRvIGAzMDAwbXNgLlxuICAgIGlmIChkb0V4aXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGdyYWNlZnVsRXhpdCwgMzAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNwb3J0cyBhbmQgZXhjZXB0aW9uSGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gLSBMaXN0IG9mIHRyYW5zcG9ydHMgYW5kIGV4Y2VwdGlvbkhhbmRsZXJzIGZvciB0aGlzXG4gICAqIGluc3RhbmNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEV4Y2VwdGlvbkhhbmRsZXJzKCkge1xuICAgIC8vIFJlbWFyayAoaW5kZXh6ZXJvKTogc2luY2UgYGxvZ2dlci50cmFuc3BvcnRzYCByZXR1cm5zIGFsbCBvZiB0aGUgcGlwZXNcbiAgICAvLyBmcm9tIHRoZSBfcmVhZGFibGVTdGF0ZSBvZiB0aGUgc3RyZWFtIHdlIGFjdHVhbGx5IGdldCB0aGUgam9pbiBvZiB0aGVcbiAgICAvLyBleHBsaWNpdCBoYW5kbGVycyBhbmQgdGhlIGltcGxpY2l0IHRyYW5zcG9ydHMgd2l0aFxuICAgIC8vIGBoYW5kbGVFeGNlcHRpb25zOiB0cnVlYFxuICAgIHJldHVybiB0aGlzLmxvZ2dlci50cmFuc3BvcnRzLmZpbHRlcih3cmFwID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHdyYXAudHJhbnNwb3J0IHx8IHdyYXA7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0LmhhbmRsZUV4Y2VwdGlvbnM7XG4gICAgfSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/exception-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/exception-stream.js":
/*!**************************************************************!*\
  !*** ./node_modules/winston/lib/winston/exception-stream.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * exception-stream.js: TODO: add file header handler.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { Writable } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\n\n/**\n * TODO: add class description.\n * @type {ExceptionStream}\n * @extends {Writable}\n */\nmodule.exports = class ExceptionStream extends Writable {\n  /**\n   * Constructor function for the ExceptionStream responsible for wrapping a\n   * TransportStream; only allowing writes of `info` objects with\n   * `info.exception` set to true.\n   * @param {!TransportStream} transport - Stream to filter to exceptions\n   */\n  constructor(transport) {\n    super({ objectMode: true });\n\n    if (!transport) {\n      throw new Error('ExceptionStream requires a TransportStream instance.');\n    }\n\n    // Remark (indexzero): we set `handleExceptions` here because it's the\n    // predicate checked in ExceptionHandler.prototype.__getExceptionHandlers\n    this.handleExceptions = true;\n    this.transport = transport;\n  }\n\n  /**\n   * Writes the info object to our transport instance if (and only if) the\n   * `exception` property is set on the info.\n   * @param {mixed} info - TODO: add param description.\n   * @param {mixed} enc - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _write(info, enc, callback) {\n    if (info.exception) {\n      return this.transport.log(info, callback);\n    }\n\n    callback();\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9leGNlcHRpb24tc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHlFQUFpQjs7QUFFOUM7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2V4Y2VwdGlvbi1zdHJlYW0uanM/ODQwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGV4Y2VwdGlvbi1zdHJlYW0uanM6IFRPRE86IGFkZCBmaWxlIGhlYWRlciBoYW5kbGVyLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpO1xuXG4vKipcbiAqIFRPRE86IGFkZCBjbGFzcyBkZXNjcmlwdGlvbi5cbiAqIEB0eXBlIHtFeGNlcHRpb25TdHJlYW19XG4gKiBAZXh0ZW5kcyB7V3JpdGFibGV9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRXhjZXB0aW9uU3RyZWFtIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBFeGNlcHRpb25TdHJlYW0gcmVzcG9uc2libGUgZm9yIHdyYXBwaW5nIGFcbiAgICogVHJhbnNwb3J0U3RyZWFtOyBvbmx5IGFsbG93aW5nIHdyaXRlcyBvZiBgaW5mb2Agb2JqZWN0cyB3aXRoXG4gICAqIGBpbmZvLmV4Y2VwdGlvbmAgc2V0IHRvIHRydWUuXG4gICAqIEBwYXJhbSB7IVRyYW5zcG9ydFN0cmVhbX0gdHJhbnNwb3J0IC0gU3RyZWFtIHRvIGZpbHRlciB0byBleGNlcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG5cbiAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlcHRpb25TdHJlYW0gcmVxdWlyZXMgYSBUcmFuc3BvcnRTdHJlYW0gaW5zdGFuY2UuJyk7XG4gICAgfVxuXG4gICAgLy8gUmVtYXJrIChpbmRleHplcm8pOiB3ZSBzZXQgYGhhbmRsZUV4Y2VwdGlvbnNgIGhlcmUgYmVjYXVzZSBpdCdzIHRoZVxuICAgIC8vIHByZWRpY2F0ZSBjaGVja2VkIGluIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLl9fZ2V0RXhjZXB0aW9uSGFuZGxlcnNcbiAgICB0aGlzLmhhbmRsZUV4Y2VwdGlvbnMgPSB0cnVlO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgaW5mbyBvYmplY3QgdG8gb3VyIHRyYW5zcG9ydCBpbnN0YW5jZSBpZiAoYW5kIG9ubHkgaWYpIHRoZVxuICAgKiBgZXhjZXB0aW9uYCBwcm9wZXJ0eSBpcyBzZXQgb24gdGhlIGluZm8uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGluZm8gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGVuYyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dyaXRlKGluZm8sIGVuYywgY2FsbGJhY2spIHtcbiAgICBpZiAoaW5mby5leGNlcHRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/exception-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/winston/lib/winston/logger.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * logger.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { Stream, Transform } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\nconst asyncForEach = __webpack_require__(/*! async/forEach */ \"(rsc)/./node_modules/async/forEach.js\");\nconst { LEVEL, SPLAT } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst isStream = __webpack_require__(/*! is-stream */ \"(rsc)/./node_modules/is-stream/index.js\");\nconst ExceptionHandler = __webpack_require__(/*! ./exception-handler */ \"(rsc)/./node_modules/winston/lib/winston/exception-handler.js\");\nconst RejectionHandler = __webpack_require__(/*! ./rejection-handler */ \"(rsc)/./node_modules/winston/lib/winston/rejection-handler.js\");\nconst LegacyTransportStream = __webpack_require__(/*! winston-transport/legacy */ \"(rsc)/./node_modules/winston-transport/legacy.js\");\nconst Profiler = __webpack_require__(/*! ./profiler */ \"(rsc)/./node_modules/winston/lib/winston/profiler.js\");\nconst { warn } = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/winston/lib/winston/common.js\");\nconst config = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/winston/lib/winston/config/index.js\");\n\n/**\n * Captures the number of format (i.e. %s strings) in a given string.\n * Based on `util.format`, see Node.js source:\n * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230\n * @type {RegExp}\n */\nconst formatRegExp = /%[scdjifoO%]/g;\n\n/**\n * TODO: add class description.\n * @type {Logger}\n * @extends {Transform}\n */\nclass Logger extends Transform {\n  /**\n   * Constructor function for the Logger object responsible for persisting log\n   * messages and metadata to one or more transports.\n   * @param {!Object} options - foo\n   */\n  constructor(options) {\n    super({ objectMode: true });\n    this.configure(options);\n  }\n\n  child(defaultRequestMetadata) {\n    const logger = this;\n    return Object.create(logger, {\n      write: {\n        value: function (info) {\n          const infoClone = Object.assign(\n            {},\n            defaultRequestMetadata,\n            info\n          );\n\n          // Object.assign doesn't copy inherited Error\n          // properties so we have to do that explicitly\n          //\n          // Remark (indexzero): we should remove this\n          // since the errors format will handle this case.\n          //\n          if (info instanceof Error) {\n            infoClone.stack = info.stack;\n            infoClone.message = info.message;\n          }\n\n          logger.write(infoClone);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will wholesale reconfigure this instance by:\n   * 1. Resetting all transports. Older transports will be removed implicitly.\n   * 2. Set all other options including levels, colors, rewriters, filters,\n   *    exceptionHandlers, etc.\n   * @param {!Object} options - TODO: add param description.\n   * @returns {undefined}\n   */\n  configure({\n    silent,\n    format,\n    defaultMeta,\n    levels,\n    level = 'info',\n    exitOnError = true,\n    transports,\n    colors,\n    emitErrs,\n    formatters,\n    padLevels,\n    rewriters,\n    stripColors,\n    exceptionHandlers,\n    rejectionHandlers\n  } = {}) {\n    // Reset transports if we already have them\n    if (this.transports.length) {\n      this.clear();\n    }\n\n    this.silent = silent;\n    this.format = format || this.format || __webpack_require__(/*! logform/json */ \"(rsc)/./node_modules/logform/json.js\")();\n\n    this.defaultMeta = defaultMeta || null;\n    // Hoist other options onto this instance.\n    this.levels = levels || this.levels || config.npm.levels;\n    this.level = level;\n    if (this.exceptions) {\n      this.exceptions.unhandle();\n    }\n    if (this.rejections) {\n      this.rejections.unhandle();\n    }\n    this.exceptions = new ExceptionHandler(this);\n    this.rejections = new RejectionHandler(this);\n    this.profilers = {};\n    this.exitOnError = exitOnError;\n\n    // Add all transports we have been provided.\n    if (transports) {\n      transports = Array.isArray(transports) ? transports : [transports];\n      transports.forEach(transport => this.add(transport));\n    }\n\n    if (\n      colors ||\n      emitErrs ||\n      formatters ||\n      padLevels ||\n      rewriters ||\n      stripColors\n    ) {\n      throw new Error(\n        [\n          '{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.',\n          'Use a custom winston.format(function) instead.',\n          'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'\n        ].join('\\n')\n      );\n    }\n\n    if (exceptionHandlers) {\n      this.exceptions.handle(exceptionHandlers);\n    }\n    if (rejectionHandlers) {\n      this.rejections.handle(rejectionHandlers);\n    }\n  }\n\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Helper method to get the highest logging level associated with a logger\n   *\n   * @returns { number | null } - The highest configured logging level, null\n   * for invalid configuration\n   */\n  getHighestLogLevel() {\n    // This can be null, if this.level has an invalid value\n    const configuredLevelValue = getLevelValue(this.levels, this.level);\n\n    // If there are no transports, return the level configured at the logger level\n    if (!this.transports || this.transports.length === 0) {\n      return configuredLevelValue;\n    }\n\n    return this.transports.reduce((max, transport) => {\n      const levelValue = getLevelValue(this.levels, transport.level);\n      return levelValue !== null && levelValue > max ? levelValue : max;\n    }, configuredLevelValue);\n  }\n\n  isLevelEnabled(level) {\n    const givenLevelValue = getLevelValue(this.levels, level);\n    if (givenLevelValue === null) {\n      return false;\n    }\n\n    const configuredLevelValue = getLevelValue(this.levels, this.level);\n    if (configuredLevelValue === null) {\n      return false;\n    }\n\n    if (!this.transports || this.transports.length === 0) {\n      return configuredLevelValue >= givenLevelValue;\n    }\n\n    const index = this.transports.findIndex(transport => {\n      let transportLevelValue = getLevelValue(this.levels, transport.level);\n      if (transportLevelValue === null) {\n        transportLevelValue = configuredLevelValue;\n      }\n      return transportLevelValue >= givenLevelValue;\n    });\n    return index !== -1;\n  }\n\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Ensure backwards compatibility with a `log` method\n   * @param {mixed} level - Level the log message is written at.\n   * @param {mixed} msg - TODO: add param description.\n   * @param {mixed} meta - TODO: add param description.\n   * @returns {Logger} - TODO: add return description.\n   *\n   * @example\n   *    // Supports the existing API:\n   *    logger.log('info', 'Hello world', { custom: true });\n   *    logger.log('info', new Error('Yo, it\\'s on fire'));\n   *\n   *    // Requires winston.format.splat()\n   *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });\n   *\n   *    // And the new API with a single JSON literal:\n   *    logger.log({ level: 'info', message: 'Hello world', custom: true });\n   *    logger.log({ level: 'info', message: new Error('Yo, it\\'s on fire') });\n   *\n   *    // Also requires winston.format.splat()\n   *    logger.log({\n   *      level: 'info',\n   *      message: '%s %d%%',\n   *      [SPLAT]: ['A string', 50],\n   *      meta: { thisIsMeta: true }\n   *    });\n   *\n   */\n  /* eslint-enable valid-jsdoc */\n  log(level, msg, ...splat) {\n    // eslint-disable-line max-params\n    // Optimize for the hotpath of logging JSON literals\n    if (arguments.length === 1) {\n      // Yo dawg, I heard you like levels ... seriously ...\n      // In this context the LHS `level` here is actually the `info` so read\n      // this as: info[LEVEL] = info.level;\n      level[LEVEL] = level.level;\n      this._addDefaultMeta(level);\n      this.write(level);\n      return this;\n    }\n\n    // Slightly less hotpath, but worth optimizing for.\n    if (arguments.length === 2) {\n      if (msg && typeof msg === 'object') {\n        msg[LEVEL] = msg.level = level;\n        this._addDefaultMeta(msg);\n        this.write(msg);\n        return this;\n      }\n\n      msg = { [LEVEL]: level, level, message: msg };\n      this._addDefaultMeta(msg);\n      this.write(msg);\n      return this;\n    }\n\n    const [meta] = splat;\n    if (typeof meta === 'object' && meta !== null) {\n      // Extract tokens, if none available default to empty array to\n      // ensure consistancy in expected results\n      const tokens = msg && msg.match && msg.match(formatRegExp);\n\n      if (!tokens) {\n        const info = Object.assign({}, this.defaultMeta, meta, {\n          [LEVEL]: level,\n          [SPLAT]: splat,\n          level,\n          message: msg\n        });\n\n        if (meta.message) info.message = `${info.message} ${meta.message}`;\n        if (meta.stack) info.stack = meta.stack;\n        if (meta.cause) info.cause = meta.cause;\n\n        this.write(info);\n        return this;\n      }\n    }\n\n    this.write(Object.assign({}, this.defaultMeta, {\n      [LEVEL]: level,\n      [SPLAT]: splat,\n      level,\n      message: msg\n    }));\n\n    return this;\n  }\n\n  /**\n   * Pushes data so that it can be picked up by all of our pipe targets.\n   * @param {mixed} info - TODO: add param description.\n   * @param {mixed} enc - TODO: add param description.\n   * @param {mixed} callback - Continues stream processing.\n   * @returns {undefined}\n   * @private\n   */\n  _transform(info, enc, callback) {\n    if (this.silent) {\n      return callback();\n    }\n\n    // [LEVEL] is only soft guaranteed to be set here since we are a proper\n    // stream. It is likely that `info` came in through `.log(info)` or\n    // `.info(info)`. If it is not defined, however, define it.\n    // This LEVEL symbol is provided by `triple-beam` and also used in:\n    // - logform\n    // - winston-transport\n    // - abstract-winston-transport\n    if (!info[LEVEL]) {\n      info[LEVEL] = info.level;\n    }\n\n    // Remark: really not sure what to do here, but this has been reported as\n    // very confusing by pre winston@2.0.0 users as quite confusing when using\n    // custom levels.\n    if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {\n      // eslint-disable-next-line no-console\n      console.error('[winston] Unknown logger level: %s', info[LEVEL]);\n    }\n\n    // Remark: not sure if we should simply error here.\n    if (!this._readableState.pipes) {\n      // eslint-disable-next-line no-console\n      console.error(\n        '[winston] Attempt to write logs with no transports, which can increase memory usage: %j',\n        info\n      );\n    }\n\n    // Here we write to the `format` pipe-chain, which on `readable` above will\n    // push the formatted `info` Object onto the buffer for this instance. We trap\n    // (and re-throw) any errors generated by the user-provided format, but also\n    // guarantee that the streams callback is invoked so that we can continue flowing.\n    try {\n      this.push(this.format.transform(info, this.format.options));\n    } finally {\n      this._writableState.sync = false;\n      // eslint-disable-next-line callback-return\n      callback();\n    }\n  }\n\n  /**\n   * Delays the 'finish' event until all transport pipe targets have\n   * also emitted 'finish' or are already finished.\n   * @param {mixed} callback - Continues stream processing.\n   */\n  _final(callback) {\n    const transports = this.transports.slice();\n    asyncForEach(\n      transports,\n      (transport, next) => {\n        if (!transport || transport.finished) return setImmediate(next);\n        transport.once('finish', next);\n        transport.end();\n      },\n      callback\n    );\n  }\n\n  /**\n   * Adds the transport to this logger instance by piping to it.\n   * @param {mixed} transport - TODO: add param description.\n   * @returns {Logger} - TODO: add return description.\n   */\n  add(transport) {\n    // Support backwards compatibility with all existing `winston < 3.x.x`\n    // transports which meet one of two criteria:\n    // 1. They inherit from winston.Transport in  < 3.x.x which is NOT a stream.\n    // 2. They expose a log method which has a length greater than 2 (i.e. more then\n    //    just `log(info, callback)`.\n    const target =\n      !isStream(transport) || transport.log.length > 2\n        ? new LegacyTransportStream({ transport })\n        : transport;\n\n    if (!target._writableState || !target._writableState.objectMode) {\n      throw new Error(\n        'Transports must WritableStreams in objectMode. Set { objectMode: true }.'\n      );\n    }\n\n    // Listen for the `error` event and the `warn` event on the new Transport.\n    this._onEvent('error', target);\n    this._onEvent('warn', target);\n    this.pipe(target);\n\n    if (transport.handleExceptions) {\n      this.exceptions.handle();\n    }\n\n    if (transport.handleRejections) {\n      this.rejections.handle();\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes the transport from this logger instance by unpiping from it.\n   * @param {mixed} transport - TODO: add param description.\n   * @returns {Logger} - TODO: add return description.\n   */\n  remove(transport) {\n    if (!transport) return this;\n    let target = transport;\n    if (!isStream(transport) || transport.log.length > 2) {\n      target = this.transports.filter(\n        match => match.transport === transport\n      )[0];\n    }\n\n    if (target) {\n      this.unpipe(target);\n    }\n    return this;\n  }\n\n  /**\n   * Removes all transports from this logger instance.\n   * @returns {Logger} - TODO: add return description.\n   */\n  clear() {\n    this.unpipe();\n    return this;\n  }\n\n  /**\n   * Cleans up resources (streams, event listeners) for all transports\n   * associated with this instance (if necessary).\n   * @returns {Logger} - TODO: add return description.\n   */\n  close() {\n    this.exceptions.unhandle();\n    this.rejections.unhandle();\n    this.clear();\n    this.emit('close');\n    return this;\n  }\n\n  /**\n   * Sets the `target` levels specified on this instance.\n   * @param {Object} Target levels to use on this instance.\n   */\n  setLevels() {\n    warn.deprecated('setLevels');\n  }\n\n  /**\n   * Queries the all transports for this instance with the specified `options`.\n   * This will aggregate each transport's results into one object containing\n   * a property per transport.\n   * @param {Object} options - Query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    const results = {};\n    const queryObject = Object.assign({}, options.query || {});\n\n    // Helper function to query a single transport\n    function queryTransport(transport, next) {\n      if (options.query && typeof transport.formatQuery === 'function') {\n        options.query = transport.formatQuery(queryObject);\n      }\n\n      transport.query(options, (err, res) => {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof transport.formatResults === 'function') {\n          res = transport.formatResults(res, options.format);\n        }\n\n        next(null, res);\n      });\n    }\n\n    // Helper function to accumulate the results from `queryTransport` into\n    // the `results`.\n    function addResults(transport, next) {\n      queryTransport(transport, (err, result) => {\n        // queryTransport could potentially invoke the callback multiple times\n        // since Transport code can be unpredictable.\n        if (next) {\n          result = err || result;\n          if (result) {\n            results[transport.name] = result;\n          }\n\n          // eslint-disable-next-line callback-return\n          next();\n        }\n\n        next = null;\n      });\n    }\n\n    // Iterate over the transports in parallel setting the appropriate key in\n    // the `results`.\n    asyncForEach(\n      this.transports.filter(transport => !!transport.query),\n      addResults,\n      () => callback(null, results)\n    );\n  }\n\n  /**\n   * Returns a log stream for all transports. Options object is optional.\n   * @param{Object} options={} - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   */\n  stream(options = {}) {\n    const out = new Stream();\n    const streams = [];\n\n    out._streams = streams;\n    out.destroy = () => {\n      let i = streams.length;\n      while (i--) {\n        streams[i].destroy();\n      }\n    };\n\n    // Create a list of all transports for this instance.\n    this.transports\n      .filter(transport => !!transport.stream)\n      .forEach(transport => {\n        const str = transport.stream(options);\n        if (!str) {\n          return;\n        }\n\n        streams.push(str);\n\n        str.on('log', log => {\n          log.transport = log.transport || [];\n          log.transport.push(transport.name);\n          out.emit('log', log);\n        });\n\n        str.on('error', err => {\n          err.transport = err.transport || [];\n          err.transport.push(transport.name);\n          out.emit('error', err);\n        });\n      });\n\n    return out;\n  }\n\n  /**\n   * Returns an object corresponding to a specific timing. When done is called\n   * the timer will finish and log the duration. e.g.:\n   * @returns {Profile} - TODO: add return description.\n   * @example\n   *    const timer = winston.startTimer()\n   *    setTimeout(() => {\n   *      timer.done({\n   *        message: 'Logging message'\n   *      });\n   *    }, 1000);\n   */\n  startTimer() {\n    return new Profiler(this);\n  }\n\n  /**\n   * Tracks the time inbetween subsequent calls to this method with the same\n   * `id` parameter. The second call to this method will log the difference in\n   * milliseconds along with the message.\n   * @param {string} id Unique id of the profiler\n   * @returns {Logger} - TODO: add return description.\n   */\n  profile(id, ...args) {\n    const time = Date.now();\n    if (this.profilers[id]) {\n      const timeEnd = this.profilers[id];\n      delete this.profilers[id];\n\n      // Attempt to be kind to users if they are still using older APIs.\n      if (typeof args[args.length - 2] === 'function') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Callback function no longer supported as of winston@3.0.0'\n        );\n        args.pop();\n      }\n\n      // Set the duration property of the metadata\n      const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n      info.level = info.level || 'info';\n      info.durationMs = time - timeEnd;\n      info.message = info.message || id;\n      return this.write(info);\n    }\n\n    this.profilers[id] = time;\n    return this;\n  }\n\n  /**\n   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.\n   * @returns {undefined}\n   * @deprecated\n   */\n  handleExceptions(...args) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()'\n    );\n    this.exceptions.handle(...args);\n  }\n\n  /**\n   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.\n   * @returns {undefined}\n   * @deprecated\n   */\n  unhandleExceptions(...args) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()'\n    );\n    this.exceptions.unhandle(...args);\n  }\n\n  /**\n   * Throw a more meaningful deprecation notice\n   * @throws {Error} - TODO: add throws description.\n   */\n  cli() {\n    throw new Error(\n      [\n        'Logger.cli() was removed in winston@3.0.0',\n        'Use a custom winston.formats.cli() instead.',\n        'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'\n      ].join('\\n')\n    );\n  }\n\n  /**\n   * Bubbles the `event` that occured on the specified `transport` up\n   * from this instance.\n   * @param {string} event - The event that occured\n   * @param {Object} transport - Transport on which the event occured\n   * @private\n   */\n  _onEvent(event, transport) {\n    function transportEvent(err) {\n      // https://github.com/winstonjs/winston/issues/1364\n      if (event === 'error' && !this.transports.includes(transport)) {\n        this.add(transport);\n      }\n      this.emit(event, err, transport);\n    }\n\n    if (!transport['__winston' + event]) {\n      transport['__winston' + event] = transportEvent.bind(this);\n      transport.on(event, transport['__winston' + event]);\n    }\n  }\n\n  _addDefaultMeta(msg) {\n    if (this.defaultMeta) {\n      Object.assign(msg, this.defaultMeta);\n    }\n  }\n}\n\nfunction getLevelValue(levels, level) {\n  const value = levels[level];\n  if (!value && value !== 0) {\n    return null;\n  }\n  return value;\n}\n\n/**\n * Represents the current readableState pipe targets for this Logger instance.\n * @type {Array|Object}\n */\nObject.defineProperty(Logger.prototype, 'transports', {\n  configurable: false,\n  enumerable: true,\n  get() {\n    const { pipes } = this._readableState;\n    return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;\n  }\n});\n\nmodule.exports = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDdkQscUJBQXFCLG1CQUFPLENBQUMsNERBQWU7QUFDNUMsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyw4REFBYTtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQywwREFBVztBQUNwQyx5QkFBeUIsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsMEZBQXFCO0FBQ3RELDhCQUE4QixtQkFBTyxDQUFDLGtGQUEwQjtBQUNoRSxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBWTtBQUNyQyxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywwRUFBVTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxtQkFBTyxDQUFDLDBEQUFjOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0EscUJBQXFCLHFEQUFxRDtBQUMxRSxxQkFBcUIsd0RBQXdEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDRDQUE0QyxjQUFjLEVBQUUsYUFBYTtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUSxXQUFXO0FBQy9CLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9sb2dnZXIuanM/NzUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZ2dlci5qczogVE9ETzogYWRkIGZpbGUgaGVhZGVyIGRlc2NyaXB0aW9uLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgU3RyZWFtLCBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpO1xuY29uc3QgYXN5bmNGb3JFYWNoID0gcmVxdWlyZSgnYXN5bmMvZm9yRWFjaCcpO1xuY29uc3QgeyBMRVZFTCwgU1BMQVQgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5jb25zdCBpc1N0cmVhbSA9IHJlcXVpcmUoJ2lzLXN0cmVhbScpO1xuY29uc3QgRXhjZXB0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uLWhhbmRsZXInKTtcbmNvbnN0IFJlamVjdGlvbkhhbmRsZXIgPSByZXF1aXJlKCcuL3JlamVjdGlvbi1oYW5kbGVyJyk7XG5jb25zdCBMZWdhY3lUcmFuc3BvcnRTdHJlYW0gPSByZXF1aXJlKCd3aW5zdG9uLXRyYW5zcG9ydC9sZWdhY3knKTtcbmNvbnN0IFByb2ZpbGVyID0gcmVxdWlyZSgnLi9wcm9maWxlcicpO1xuY29uc3QgeyB3YXJuIH0gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgbnVtYmVyIG9mIGZvcm1hdCAoaS5lLiAlcyBzdHJpbmdzKSBpbiBhIGdpdmVuIHN0cmluZy5cbiAqIEJhc2VkIG9uIGB1dGlsLmZvcm1hdGAsIHNlZSBOb2RlLmpzIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IxYzhmMTVjNWYxNjllMDIxZjdjNDZlYjdiMjE5ZGU5NWZlOTc2MDMvbGliL3V0aWwuanMjTDIwMS1MMjMwXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBmb3JtYXRSZWdFeHAgPSAvJVtzY2RqaWZvTyVdL2c7XG5cbi8qKlxuICogVE9ETzogYWRkIGNsYXNzIGRlc2NyaXB0aW9uLlxuICogQHR5cGUge0xvZ2dlcn1cbiAqIEBleHRlbmRzIHtUcmFuc2Zvcm19XG4gKi9cbmNsYXNzIExvZ2dlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIExvZ2dlciBvYmplY3QgcmVzcG9uc2libGUgZm9yIHBlcnNpc3RpbmcgbG9nXG4gICAqIG1lc3NhZ2VzIGFuZCBtZXRhZGF0YSB0byBvbmUgb3IgbW9yZSB0cmFuc3BvcnRzLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnMgLSBmb29cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgdGhpcy5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cblxuICBjaGlsZChkZWZhdWx0UmVxdWVzdE1ldGFkYXRhKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gdGhpcztcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShsb2dnZXIsIHtcbiAgICAgIHdyaXRlOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgIGNvbnN0IGluZm9DbG9uZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGRlZmF1bHRSZXF1ZXN0TWV0YWRhdGEsXG4gICAgICAgICAgICBpbmZvXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIE9iamVjdC5hc3NpZ24gZG9lc24ndCBjb3B5IGluaGVyaXRlZCBFcnJvclxuICAgICAgICAgIC8vIHByb3BlcnRpZXMgc28gd2UgaGF2ZSB0byBkbyB0aGF0IGV4cGxpY2l0bHlcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFJlbWFyayAoaW5kZXh6ZXJvKTogd2Ugc2hvdWxkIHJlbW92ZSB0aGlzXG4gICAgICAgICAgLy8gc2luY2UgdGhlIGVycm9ycyBmb3JtYXQgd2lsbCBoYW5kbGUgdGhpcyBjYXNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKGluZm8gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaW5mb0Nsb25lLnN0YWNrID0gaW5mby5zdGFjaztcbiAgICAgICAgICAgIGluZm9DbG9uZS5tZXNzYWdlID0gaW5mby5tZXNzYWdlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxvZ2dlci53cml0ZShpbmZvQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyB3aWxsIHdob2xlc2FsZSByZWNvbmZpZ3VyZSB0aGlzIGluc3RhbmNlIGJ5OlxuICAgKiAxLiBSZXNldHRpbmcgYWxsIHRyYW5zcG9ydHMuIE9sZGVyIHRyYW5zcG9ydHMgd2lsbCBiZSByZW1vdmVkIGltcGxpY2l0bHkuXG4gICAqIDIuIFNldCBhbGwgb3RoZXIgb3B0aW9ucyBpbmNsdWRpbmcgbGV2ZWxzLCBjb2xvcnMsIHJld3JpdGVycywgZmlsdGVycyxcbiAgICogICAgZXhjZXB0aW9uSGFuZGxlcnMsIGV0Yy5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgY29uZmlndXJlKHtcbiAgICBzaWxlbnQsXG4gICAgZm9ybWF0LFxuICAgIGRlZmF1bHRNZXRhLFxuICAgIGxldmVscyxcbiAgICBsZXZlbCA9ICdpbmZvJyxcbiAgICBleGl0T25FcnJvciA9IHRydWUsXG4gICAgdHJhbnNwb3J0cyxcbiAgICBjb2xvcnMsXG4gICAgZW1pdEVycnMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBwYWRMZXZlbHMsXG4gICAgcmV3cml0ZXJzLFxuICAgIHN0cmlwQ29sb3JzLFxuICAgIGV4Y2VwdGlvbkhhbmRsZXJzLFxuICAgIHJlamVjdGlvbkhhbmRsZXJzXG4gIH0gPSB7fSkge1xuICAgIC8vIFJlc2V0IHRyYW5zcG9ydHMgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZW1cbiAgICBpZiAodGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cblxuICAgIHRoaXMuc2lsZW50ID0gc2lsZW50O1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuZm9ybWF0IHx8IHJlcXVpcmUoJ2xvZ2Zvcm0vanNvbicpKCk7XG5cbiAgICB0aGlzLmRlZmF1bHRNZXRhID0gZGVmYXVsdE1ldGEgfHwgbnVsbDtcbiAgICAvLyBIb2lzdCBvdGhlciBvcHRpb25zIG9udG8gdGhpcyBpbnN0YW5jZS5cbiAgICB0aGlzLmxldmVscyA9IGxldmVscyB8fCB0aGlzLmxldmVscyB8fCBjb25maWcubnBtLmxldmVscztcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgaWYgKHRoaXMuZXhjZXB0aW9ucykge1xuICAgICAgdGhpcy5leGNlcHRpb25zLnVuaGFuZGxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlamVjdGlvbnMpIHtcbiAgICAgIHRoaXMucmVqZWN0aW9ucy51bmhhbmRsZSgpO1xuICAgIH1cbiAgICB0aGlzLmV4Y2VwdGlvbnMgPSBuZXcgRXhjZXB0aW9uSGFuZGxlcih0aGlzKTtcbiAgICB0aGlzLnJlamVjdGlvbnMgPSBuZXcgUmVqZWN0aW9uSGFuZGxlcih0aGlzKTtcbiAgICB0aGlzLnByb2ZpbGVycyA9IHt9O1xuICAgIHRoaXMuZXhpdE9uRXJyb3IgPSBleGl0T25FcnJvcjtcblxuICAgIC8vIEFkZCBhbGwgdHJhbnNwb3J0cyB3ZSBoYXZlIGJlZW4gcHJvdmlkZWQuXG4gICAgaWYgKHRyYW5zcG9ydHMpIHtcbiAgICAgIHRyYW5zcG9ydHMgPSBBcnJheS5pc0FycmF5KHRyYW5zcG9ydHMpID8gdHJhbnNwb3J0cyA6IFt0cmFuc3BvcnRzXTtcbiAgICAgIHRyYW5zcG9ydHMuZm9yRWFjaCh0cmFuc3BvcnQgPT4gdGhpcy5hZGQodHJhbnNwb3J0KSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgY29sb3JzIHx8XG4gICAgICBlbWl0RXJycyB8fFxuICAgICAgZm9ybWF0dGVycyB8fFxuICAgICAgcGFkTGV2ZWxzIHx8XG4gICAgICByZXdyaXRlcnMgfHxcbiAgICAgIHN0cmlwQ29sb3JzXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFtcbiAgICAgICAgICAneyBjb2xvcnMsIGVtaXRFcnJzLCBmb3JtYXR0ZXJzLCBwYWRMZXZlbHMsIHJld3JpdGVycywgc3RyaXBDb2xvcnMgfSB3ZXJlIHJlbW92ZWQgaW4gd2luc3RvbkAzLjAuMC4nLFxuICAgICAgICAgICdVc2UgYSBjdXN0b20gd2luc3Rvbi5mb3JtYXQoZnVuY3Rpb24pIGluc3RlYWQuJyxcbiAgICAgICAgICAnU2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2luc3RvbmpzL3dpbnN0b24vdHJlZS9tYXN0ZXIvVVBHUkFERS0zLjAubWQnXG4gICAgICAgIF0uam9pbignXFxuJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGV4Y2VwdGlvbkhhbmRsZXJzKSB7XG4gICAgICB0aGlzLmV4Y2VwdGlvbnMuaGFuZGxlKGV4Y2VwdGlvbkhhbmRsZXJzKTtcbiAgICB9XG4gICAgaWYgKHJlamVjdGlvbkhhbmRsZXJzKSB7XG4gICAgICB0aGlzLnJlamVjdGlvbnMuaGFuZGxlKHJlamVjdGlvbkhhbmRsZXJzKTtcbiAgICB9XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBnZXQgdGhlIGhpZ2hlc3QgbG9nZ2luZyBsZXZlbCBhc3NvY2lhdGVkIHdpdGggYSBsb2dnZXJcbiAgICpcbiAgICogQHJldHVybnMgeyBudW1iZXIgfCBudWxsIH0gLSBUaGUgaGlnaGVzdCBjb25maWd1cmVkIGxvZ2dpbmcgbGV2ZWwsIG51bGxcbiAgICogZm9yIGludmFsaWQgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0SGlnaGVzdExvZ0xldmVsKCkge1xuICAgIC8vIFRoaXMgY2FuIGJlIG51bGwsIGlmIHRoaXMubGV2ZWwgaGFzIGFuIGludmFsaWQgdmFsdWVcbiAgICBjb25zdCBjb25maWd1cmVkTGV2ZWxWYWx1ZSA9IGdldExldmVsVmFsdWUodGhpcy5sZXZlbHMsIHRoaXMubGV2ZWwpO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMsIHJldHVybiB0aGUgbGV2ZWwgY29uZmlndXJlZCBhdCB0aGUgbG9nZ2VyIGxldmVsXG4gICAgaWYgKCF0aGlzLnRyYW5zcG9ydHMgfHwgdGhpcy50cmFuc3BvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyZWRMZXZlbFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHMucmVkdWNlKChtYXgsIHRyYW5zcG9ydCkgPT4ge1xuICAgICAgY29uc3QgbGV2ZWxWYWx1ZSA9IGdldExldmVsVmFsdWUodGhpcy5sZXZlbHMsIHRyYW5zcG9ydC5sZXZlbCk7XG4gICAgICByZXR1cm4gbGV2ZWxWYWx1ZSAhPT0gbnVsbCAmJiBsZXZlbFZhbHVlID4gbWF4ID8gbGV2ZWxWYWx1ZSA6IG1heDtcbiAgICB9LCBjb25maWd1cmVkTGV2ZWxWYWx1ZSk7XG4gIH1cblxuICBpc0xldmVsRW5hYmxlZChsZXZlbCkge1xuICAgIGNvbnN0IGdpdmVuTGV2ZWxWYWx1ZSA9IGdldExldmVsVmFsdWUodGhpcy5sZXZlbHMsIGxldmVsKTtcbiAgICBpZiAoZ2l2ZW5MZXZlbFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlndXJlZExldmVsVmFsdWUgPSBnZXRMZXZlbFZhbHVlKHRoaXMubGV2ZWxzLCB0aGlzLmxldmVsKTtcbiAgICBpZiAoY29uZmlndXJlZExldmVsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0cyB8fCB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJlZExldmVsVmFsdWUgPj0gZ2l2ZW5MZXZlbFZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy50cmFuc3BvcnRzLmZpbmRJbmRleCh0cmFuc3BvcnQgPT4ge1xuICAgICAgbGV0IHRyYW5zcG9ydExldmVsVmFsdWUgPSBnZXRMZXZlbFZhbHVlKHRoaXMubGV2ZWxzLCB0cmFuc3BvcnQubGV2ZWwpO1xuICAgICAgaWYgKHRyYW5zcG9ydExldmVsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdHJhbnNwb3J0TGV2ZWxWYWx1ZSA9IGNvbmZpZ3VyZWRMZXZlbFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zcG9ydExldmVsVmFsdWUgPj0gZ2l2ZW5MZXZlbFZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBpbmRleCAhPT0gLTE7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAvKipcbiAgICogRW5zdXJlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggYSBgbG9nYCBtZXRob2RcbiAgICogQHBhcmFtIHttaXhlZH0gbGV2ZWwgLSBMZXZlbCB0aGUgbG9nIG1lc3NhZ2UgaXMgd3JpdHRlbiBhdC5cbiAgICogQHBhcmFtIHttaXhlZH0gbXNnIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBtZXRhIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIC8vIFN1cHBvcnRzIHRoZSBleGlzdGluZyBBUEk6XG4gICAqICAgIGxvZ2dlci5sb2coJ2luZm8nLCAnSGVsbG8gd29ybGQnLCB7IGN1c3RvbTogdHJ1ZSB9KTtcbiAgICogICAgbG9nZ2VyLmxvZygnaW5mbycsIG5ldyBFcnJvcignWW8sIGl0XFwncyBvbiBmaXJlJykpO1xuICAgKlxuICAgKiAgICAvLyBSZXF1aXJlcyB3aW5zdG9uLmZvcm1hdC5zcGxhdCgpXG4gICAqICAgIGxvZ2dlci5sb2coJ2luZm8nLCAnJXMgJWQlJScsICdBIHN0cmluZycsIDUwLCB7IHRoaXNJc01ldGE6IHRydWUgfSk7XG4gICAqXG4gICAqICAgIC8vIEFuZCB0aGUgbmV3IEFQSSB3aXRoIGEgc2luZ2xlIEpTT04gbGl0ZXJhbDpcbiAgICogICAgbG9nZ2VyLmxvZyh7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6ICdIZWxsbyB3b3JsZCcsIGN1c3RvbTogdHJ1ZSB9KTtcbiAgICogICAgbG9nZ2VyLmxvZyh7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6IG5ldyBFcnJvcignWW8sIGl0XFwncyBvbiBmaXJlJykgfSk7XG4gICAqXG4gICAqICAgIC8vIEFsc28gcmVxdWlyZXMgd2luc3Rvbi5mb3JtYXQuc3BsYXQoKVxuICAgKiAgICBsb2dnZXIubG9nKHtcbiAgICogICAgICBsZXZlbDogJ2luZm8nLFxuICAgKiAgICAgIG1lc3NhZ2U6ICclcyAlZCUlJyxcbiAgICogICAgICBbU1BMQVRdOiBbJ0Egc3RyaW5nJywgNTBdLFxuICAgKiAgICAgIG1ldGE6IHsgdGhpc0lzTWV0YTogdHJ1ZSB9XG4gICAqICAgIH0pO1xuICAgKlxuICAgKi9cbiAgLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuICBsb2cobGV2ZWwsIG1zZywgLi4uc3BsYXQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1wYXJhbXNcbiAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGhvdHBhdGggb2YgbG9nZ2luZyBKU09OIGxpdGVyYWxzXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFlvIGRhd2csIEkgaGVhcmQgeW91IGxpa2UgbGV2ZWxzIC4uLiBzZXJpb3VzbHkgLi4uXG4gICAgICAvLyBJbiB0aGlzIGNvbnRleHQgdGhlIExIUyBgbGV2ZWxgIGhlcmUgaXMgYWN0dWFsbHkgdGhlIGBpbmZvYCBzbyByZWFkXG4gICAgICAvLyB0aGlzIGFzOiBpbmZvW0xFVkVMXSA9IGluZm8ubGV2ZWw7XG4gICAgICBsZXZlbFtMRVZFTF0gPSBsZXZlbC5sZXZlbDtcbiAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhKGxldmVsKTtcbiAgICAgIHRoaXMud3JpdGUobGV2ZWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gU2xpZ2h0bHkgbGVzcyBob3RwYXRoLCBidXQgd29ydGggb3B0aW1pemluZyBmb3IuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbXNnW0xFVkVMXSA9IG1zZy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YShtc2cpO1xuICAgICAgICB0aGlzLndyaXRlKG1zZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSB7IFtMRVZFTF06IGxldmVsLCBsZXZlbCwgbWVzc2FnZTogbXNnIH07XG4gICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YShtc2cpO1xuICAgICAgdGhpcy53cml0ZShtc2cpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgW21ldGFdID0gc3BsYXQ7XG4gICAgaWYgKHR5cGVvZiBtZXRhID09PSAnb2JqZWN0JyAmJiBtZXRhICE9PSBudWxsKSB7XG4gICAgICAvLyBFeHRyYWN0IHRva2VucywgaWYgbm9uZSBhdmFpbGFibGUgZGVmYXVsdCB0byBlbXB0eSBhcnJheSB0b1xuICAgICAgLy8gZW5zdXJlIGNvbnNpc3RhbmN5IGluIGV4cGVjdGVkIHJlc3VsdHNcbiAgICAgIGNvbnN0IHRva2VucyA9IG1zZyAmJiBtc2cubWF0Y2ggJiYgbXNnLm1hdGNoKGZvcm1hdFJlZ0V4cCk7XG5cbiAgICAgIGlmICghdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRNZXRhLCBtZXRhLCB7XG4gICAgICAgICAgW0xFVkVMXTogbGV2ZWwsXG4gICAgICAgICAgW1NQTEFUXTogc3BsYXQsXG4gICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtZXRhLm1lc3NhZ2UpIGluZm8ubWVzc2FnZSA9IGAke2luZm8ubWVzc2FnZX0gJHttZXRhLm1lc3NhZ2V9YDtcbiAgICAgICAgaWYgKG1ldGEuc3RhY2spIGluZm8uc3RhY2sgPSBtZXRhLnN0YWNrO1xuICAgICAgICBpZiAobWV0YS5jYXVzZSkgaW5mby5jYXVzZSA9IG1ldGEuY2F1c2U7XG5cbiAgICAgICAgdGhpcy53cml0ZShpbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy53cml0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRNZXRhLCB7XG4gICAgICBbTEVWRUxdOiBsZXZlbCxcbiAgICAgIFtTUExBVF06IHNwbGF0LFxuICAgICAgbGV2ZWwsXG4gICAgICBtZXNzYWdlOiBtc2dcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgZGF0YSBzbyB0aGF0IGl0IGNhbiBiZSBwaWNrZWQgdXAgYnkgYWxsIG9mIG91ciBwaXBlIHRhcmdldHMuXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGluZm8gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGVuYyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gY2FsbGJhY2sgLSBDb250aW51ZXMgc3RyZWFtIHByb2Nlc3NpbmcuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJhbnNmb3JtKGluZm8sIGVuYywgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zaWxlbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8vIFtMRVZFTF0gaXMgb25seSBzb2Z0IGd1YXJhbnRlZWQgdG8gYmUgc2V0IGhlcmUgc2luY2Ugd2UgYXJlIGEgcHJvcGVyXG4gICAgLy8gc3RyZWFtLiBJdCBpcyBsaWtlbHkgdGhhdCBgaW5mb2AgY2FtZSBpbiB0aHJvdWdoIGAubG9nKGluZm8pYCBvclxuICAgIC8vIGAuaW5mbyhpbmZvKWAuIElmIGl0IGlzIG5vdCBkZWZpbmVkLCBob3dldmVyLCBkZWZpbmUgaXQuXG4gICAgLy8gVGhpcyBMRVZFTCBzeW1ib2wgaXMgcHJvdmlkZWQgYnkgYHRyaXBsZS1iZWFtYCBhbmQgYWxzbyB1c2VkIGluOlxuICAgIC8vIC0gbG9nZm9ybVxuICAgIC8vIC0gd2luc3Rvbi10cmFuc3BvcnRcbiAgICAvLyAtIGFic3RyYWN0LXdpbnN0b24tdHJhbnNwb3J0XG4gICAgaWYgKCFpbmZvW0xFVkVMXSkge1xuICAgICAgaW5mb1tMRVZFTF0gPSBpbmZvLmxldmVsO1xuICAgIH1cblxuICAgIC8vIFJlbWFyazogcmVhbGx5IG5vdCBzdXJlIHdoYXQgdG8gZG8gaGVyZSwgYnV0IHRoaXMgaGFzIGJlZW4gcmVwb3J0ZWQgYXNcbiAgICAvLyB2ZXJ5IGNvbmZ1c2luZyBieSBwcmUgd2luc3RvbkAyLjAuMCB1c2VycyBhcyBxdWl0ZSBjb25mdXNpbmcgd2hlbiB1c2luZ1xuICAgIC8vIGN1c3RvbSBsZXZlbHMuXG4gICAgaWYgKCF0aGlzLmxldmVsc1tpbmZvW0xFVkVMXV0gJiYgdGhpcy5sZXZlbHNbaW5mb1tMRVZFTF1dICE9PSAwKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcignW3dpbnN0b25dIFVua25vd24gbG9nZ2VyIGxldmVsOiAlcycsIGluZm9bTEVWRUxdKTtcbiAgICB9XG5cbiAgICAvLyBSZW1hcms6IG5vdCBzdXJlIGlmIHdlIHNob3VsZCBzaW1wbHkgZXJyb3IgaGVyZS5cbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUucGlwZXMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnW3dpbnN0b25dIEF0dGVtcHQgdG8gd3JpdGUgbG9ncyB3aXRoIG5vIHRyYW5zcG9ydHMsIHdoaWNoIGNhbiBpbmNyZWFzZSBtZW1vcnkgdXNhZ2U6ICVqJyxcbiAgICAgICAgaW5mb1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBIZXJlIHdlIHdyaXRlIHRvIHRoZSBgZm9ybWF0YCBwaXBlLWNoYWluLCB3aGljaCBvbiBgcmVhZGFibGVgIGFib3ZlIHdpbGxcbiAgICAvLyBwdXNoIHRoZSBmb3JtYXR0ZWQgYGluZm9gIE9iamVjdCBvbnRvIHRoZSBidWZmZXIgZm9yIHRoaXMgaW5zdGFuY2UuIFdlIHRyYXBcbiAgICAvLyAoYW5kIHJlLXRocm93KSBhbnkgZXJyb3JzIGdlbmVyYXRlZCBieSB0aGUgdXNlci1wcm92aWRlZCBmb3JtYXQsIGJ1dCBhbHNvXG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIHN0cmVhbXMgY2FsbGJhY2sgaXMgaW52b2tlZCBzbyB0aGF0IHdlIGNhbiBjb250aW51ZSBmbG93aW5nLlxuICAgIHRyeSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5mb3JtYXQudHJhbnNmb3JtKGluZm8sIHRoaXMuZm9ybWF0Lm9wdGlvbnMpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheXMgdGhlICdmaW5pc2gnIGV2ZW50IHVudGlsIGFsbCB0cmFuc3BvcnQgcGlwZSB0YXJnZXRzIGhhdmVcbiAgICogYWxzbyBlbWl0dGVkICdmaW5pc2gnIG9yIGFyZSBhbHJlYWR5IGZpbmlzaGVkLlxuICAgKiBAcGFyYW0ge21peGVkfSBjYWxsYmFjayAtIENvbnRpbnVlcyBzdHJlYW0gcHJvY2Vzc2luZy5cbiAgICovXG4gIF9maW5hbChjYWxsYmFjaykge1xuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSB0aGlzLnRyYW5zcG9ydHMuc2xpY2UoKTtcbiAgICBhc3luY0ZvckVhY2goXG4gICAgICB0cmFuc3BvcnRzLFxuICAgICAgKHRyYW5zcG9ydCwgbmV4dCkgPT4ge1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCB8fCB0cmFuc3BvcnQuZmluaXNoZWQpIHJldHVybiBzZXRJbW1lZGlhdGUobmV4dCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKCdmaW5pc2gnLCBuZXh0KTtcbiAgICAgICAgdHJhbnNwb3J0LmVuZCgpO1xuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSB0cmFuc3BvcnQgdG8gdGhpcyBsb2dnZXIgaW5zdGFuY2UgYnkgcGlwaW5nIHRvIGl0LlxuICAgKiBAcGFyYW0ge21peGVkfSB0cmFuc3BvcnQgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtMb2dnZXJ9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGFkZCh0cmFuc3BvcnQpIHtcbiAgICAvLyBTdXBwb3J0IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggYWxsIGV4aXN0aW5nIGB3aW5zdG9uIDwgMy54LnhgXG4gICAgLy8gdHJhbnNwb3J0cyB3aGljaCBtZWV0IG9uZSBvZiB0d28gY3JpdGVyaWE6XG4gICAgLy8gMS4gVGhleSBpbmhlcml0IGZyb20gd2luc3Rvbi5UcmFuc3BvcnQgaW4gIDwgMy54Lnggd2hpY2ggaXMgTk9UIGEgc3RyZWFtLlxuICAgIC8vIDIuIFRoZXkgZXhwb3NlIGEgbG9nIG1ldGhvZCB3aGljaCBoYXMgYSBsZW5ndGggZ3JlYXRlciB0aGFuIDIgKGkuZS4gbW9yZSB0aGVuXG4gICAgLy8gICAganVzdCBgbG9nKGluZm8sIGNhbGxiYWNrKWAuXG4gICAgY29uc3QgdGFyZ2V0ID1cbiAgICAgICFpc1N0cmVhbSh0cmFuc3BvcnQpIHx8IHRyYW5zcG9ydC5sb2cubGVuZ3RoID4gMlxuICAgICAgICA/IG5ldyBMZWdhY3lUcmFuc3BvcnRTdHJlYW0oeyB0cmFuc3BvcnQgfSlcbiAgICAgICAgOiB0cmFuc3BvcnQ7XG5cbiAgICBpZiAoIXRhcmdldC5fd3JpdGFibGVTdGF0ZSB8fCAhdGFyZ2V0Ll93cml0YWJsZVN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RyYW5zcG9ydHMgbXVzdCBXcml0YWJsZVN0cmVhbXMgaW4gb2JqZWN0TW9kZS4gU2V0IHsgb2JqZWN0TW9kZTogdHJ1ZSB9LidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gTGlzdGVuIGZvciB0aGUgYGVycm9yYCBldmVudCBhbmQgdGhlIGB3YXJuYCBldmVudCBvbiB0aGUgbmV3IFRyYW5zcG9ydC5cbiAgICB0aGlzLl9vbkV2ZW50KCdlcnJvcicsIHRhcmdldCk7XG4gICAgdGhpcy5fb25FdmVudCgnd2FybicsIHRhcmdldCk7XG4gICAgdGhpcy5waXBlKHRhcmdldCk7XG5cbiAgICBpZiAodHJhbnNwb3J0LmhhbmRsZUV4Y2VwdGlvbnMpIHtcbiAgICAgIHRoaXMuZXhjZXB0aW9ucy5oYW5kbGUoKTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNwb3J0LmhhbmRsZVJlamVjdGlvbnMpIHtcbiAgICAgIHRoaXMucmVqZWN0aW9ucy5oYW5kbGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB0cmFuc3BvcnQgZnJvbSB0aGlzIGxvZ2dlciBpbnN0YW5jZSBieSB1bnBpcGluZyBmcm9tIGl0LlxuICAgKiBAcGFyYW0ge21peGVkfSB0cmFuc3BvcnQgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtMb2dnZXJ9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIHJlbW92ZSh0cmFuc3BvcnQpIHtcbiAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuIHRoaXM7XG4gICAgbGV0IHRhcmdldCA9IHRyYW5zcG9ydDtcbiAgICBpZiAoIWlzU3RyZWFtKHRyYW5zcG9ydCkgfHwgdHJhbnNwb3J0LmxvZy5sZW5ndGggPiAyKSB7XG4gICAgICB0YXJnZXQgPSB0aGlzLnRyYW5zcG9ydHMuZmlsdGVyKFxuICAgICAgICBtYXRjaCA9PiBtYXRjaC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydFxuICAgICAgKVswXTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLnVucGlwZSh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0cmFuc3BvcnRzIGZyb20gdGhpcyBsb2dnZXIgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtMb2dnZXJ9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMudW5waXBlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHJlc291cmNlcyAoc3RyZWFtcywgZXZlbnQgbGlzdGVuZXJzKSBmb3IgYWxsIHRyYW5zcG9ydHNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UgKGlmIG5lY2Vzc2FyeSkuXG4gICAqIEByZXR1cm5zIHtMb2dnZXJ9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuZXhjZXB0aW9ucy51bmhhbmRsZSgpO1xuICAgIHRoaXMucmVqZWN0aW9ucy51bmhhbmRsZSgpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYHRhcmdldGAgbGV2ZWxzIHNwZWNpZmllZCBvbiB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gVGFyZ2V0IGxldmVscyB0byB1c2Ugb24gdGhpcyBpbnN0YW5jZS5cbiAgICovXG4gIHNldExldmVscygpIHtcbiAgICB3YXJuLmRlcHJlY2F0ZWQoJ3NldExldmVscycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgdGhlIGFsbCB0cmFuc3BvcnRzIGZvciB0aGlzIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBgb3B0aW9uc2AuXG4gICAqIFRoaXMgd2lsbCBhZ2dyZWdhdGUgZWFjaCB0cmFuc3BvcnQncyByZXN1bHRzIGludG8gb25lIG9iamVjdCBjb250YWluaW5nXG4gICAqIGEgcHJvcGVydHkgcGVyIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBRdWVyeSBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqL1xuICBxdWVyeShvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICBjb25zdCBxdWVyeU9iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucXVlcnkgfHwge30pO1xuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHF1ZXJ5IGEgc2luZ2xlIHRyYW5zcG9ydFxuICAgIGZ1bmN0aW9uIHF1ZXJ5VHJhbnNwb3J0KHRyYW5zcG9ydCwgbmV4dCkge1xuICAgICAgaWYgKG9wdGlvbnMucXVlcnkgJiYgdHlwZW9mIHRyYW5zcG9ydC5mb3JtYXRRdWVyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRpb25zLnF1ZXJ5ID0gdHJhbnNwb3J0LmZvcm1hdFF1ZXJ5KHF1ZXJ5T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNwb3J0LnF1ZXJ5KG9wdGlvbnMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNwb3J0LmZvcm1hdFJlc3VsdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXMgPSB0cmFuc3BvcnQuZm9ybWF0UmVzdWx0cyhyZXMsIG9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQobnVsbCwgcmVzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhY2N1bXVsYXRlIHRoZSByZXN1bHRzIGZyb20gYHF1ZXJ5VHJhbnNwb3J0YCBpbnRvXG4gICAgLy8gdGhlIGByZXN1bHRzYC5cbiAgICBmdW5jdGlvbiBhZGRSZXN1bHRzKHRyYW5zcG9ydCwgbmV4dCkge1xuICAgICAgcXVlcnlUcmFuc3BvcnQodHJhbnNwb3J0LCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgLy8gcXVlcnlUcmFuc3BvcnQgY291bGQgcG90ZW50aWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAvLyBzaW5jZSBUcmFuc3BvcnQgY29kZSBjYW4gYmUgdW5wcmVkaWN0YWJsZS5cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICByZXN1bHQgPSBlcnIgfHwgcmVzdWx0O1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbdHJhbnNwb3J0Lm5hbWVdID0gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJhbnNwb3J0cyBpbiBwYXJhbGxlbCBzZXR0aW5nIHRoZSBhcHByb3ByaWF0ZSBrZXkgaW5cbiAgICAvLyB0aGUgYHJlc3VsdHNgLlxuICAgIGFzeW5jRm9yRWFjaChcbiAgICAgIHRoaXMudHJhbnNwb3J0cy5maWx0ZXIodHJhbnNwb3J0ID0+ICEhdHJhbnNwb3J0LnF1ZXJ5KSxcbiAgICAgIGFkZFJlc3VsdHMsXG4gICAgICAoKSA9PiBjYWxsYmFjayhudWxsLCByZXN1bHRzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvZyBzdHJlYW0gZm9yIGFsbCB0cmFuc3BvcnRzLiBPcHRpb25zIG9iamVjdCBpcyBvcHRpb25hbC5cbiAgICogQHBhcmFte09iamVjdH0gb3B0aW9ucz17fSAtIFN0cmVhbSBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7U3RyZWFtfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBzdHJlYW0ob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3V0ID0gbmV3IFN0cmVhbSgpO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcblxuICAgIG91dC5fc3RyZWFtcyA9IHN0cmVhbXM7XG4gICAgb3V0LmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICBsZXQgaSA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBzdHJlYW1zW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhbGwgdHJhbnNwb3J0cyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICB0aGlzLnRyYW5zcG9ydHNcbiAgICAgIC5maWx0ZXIodHJhbnNwb3J0ID0+ICEhdHJhbnNwb3J0LnN0cmVhbSlcbiAgICAgIC5mb3JFYWNoKHRyYW5zcG9ydCA9PiB7XG4gICAgICAgIGNvbnN0IHN0ciA9IHRyYW5zcG9ydC5zdHJlYW0ob3B0aW9ucyk7XG4gICAgICAgIGlmICghc3RyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtcy5wdXNoKHN0cik7XG5cbiAgICAgICAgc3RyLm9uKCdsb2cnLCBsb2cgPT4ge1xuICAgICAgICAgIGxvZy50cmFuc3BvcnQgPSBsb2cudHJhbnNwb3J0IHx8IFtdO1xuICAgICAgICAgIGxvZy50cmFuc3BvcnQucHVzaCh0cmFuc3BvcnQubmFtZSk7XG4gICAgICAgICAgb3V0LmVtaXQoJ2xvZycsIGxvZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0ci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgIGVyci50cmFuc3BvcnQgPSBlcnIudHJhbnNwb3J0IHx8IFtdO1xuICAgICAgICAgIGVyci50cmFuc3BvcnQucHVzaCh0cmFuc3BvcnQubmFtZSk7XG4gICAgICAgICAgb3V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgY29ycmVzcG9uZGluZyB0byBhIHNwZWNpZmljIHRpbWluZy4gV2hlbiBkb25lIGlzIGNhbGxlZFxuICAgKiB0aGUgdGltZXIgd2lsbCBmaW5pc2ggYW5kIGxvZyB0aGUgZHVyYXRpb24uIGUuZy46XG4gICAqIEByZXR1cm5zIHtQcm9maWxlfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGNvbnN0IHRpbWVyID0gd2luc3Rvbi5zdGFydFRpbWVyKClcbiAgICogICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAqICAgICAgdGltZXIuZG9uZSh7XG4gICAqICAgICAgICBtZXNzYWdlOiAnTG9nZ2luZyBtZXNzYWdlJ1xuICAgKiAgICAgIH0pO1xuICAgKiAgICB9LCAxMDAwKTtcbiAgICovXG4gIHN0YXJ0VGltZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9maWxlcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIHRpbWUgaW5iZXR3ZWVuIHN1YnNlcXVlbnQgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2l0aCB0aGUgc2FtZVxuICAgKiBgaWRgIHBhcmFtZXRlci4gVGhlIHNlY29uZCBjYWxsIHRvIHRoaXMgbWV0aG9kIHdpbGwgbG9nIHRoZSBkaWZmZXJlbmNlIGluXG4gICAqIG1pbGxpc2Vjb25kcyBhbG9uZyB3aXRoIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pcXVlIGlkIG9mIHRoZSBwcm9maWxlclxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBwcm9maWxlKGlkLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKHRoaXMucHJvZmlsZXJzW2lkXSkge1xuICAgICAgY29uc3QgdGltZUVuZCA9IHRoaXMucHJvZmlsZXJzW2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnByb2ZpbGVyc1tpZF07XG5cbiAgICAgIC8vIEF0dGVtcHQgdG8gYmUga2luZCB0byB1c2VycyBpZiB0aGV5IGFyZSBzdGlsbCB1c2luZyBvbGRlciBBUElzLlxuICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdDYWxsYmFjayBmdW5jdGlvbiBubyBsb25nZXIgc3VwcG9ydGVkIGFzIG9mIHdpbnN0b25AMy4wLjAnXG4gICAgICAgICk7XG4gICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgZHVyYXRpb24gcHJvcGVydHkgb2YgdGhlIG1ldGFkYXRhXG4gICAgICBjb25zdCBpbmZvID0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcgPyBhcmdzLnBvcCgpIDoge307XG4gICAgICBpbmZvLmxldmVsID0gaW5mby5sZXZlbCB8fCAnaW5mbyc7XG4gICAgICBpbmZvLmR1cmF0aW9uTXMgPSB0aW1lIC0gdGltZUVuZDtcbiAgICAgIGluZm8ubWVzc2FnZSA9IGluZm8ubWVzc2FnZSB8fCBpZDtcbiAgICAgIHJldHVybiB0aGlzLndyaXRlKGluZm8pO1xuICAgIH1cblxuICAgIHRoaXMucHJvZmlsZXJzW2lkXSA9IHRpbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdG8gYGV4Y2VwdGlvbnMuaGFuZGxlYCBpbiB3aW5zdG9uIDwgMy4wLjAuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBoYW5kbGVFeGNlcHRpb25zKC4uLmFyZ3MpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdEZXByZWNhdGVkOiAuaGFuZGxlRXhjZXB0aW9ucygpIHdpbGwgYmUgcmVtb3ZlZCBpbiB3aW5zdG9uQDQuIFVzZSAuZXhjZXB0aW9ucy5oYW5kbGUoKSdcbiAgICApO1xuICAgIHRoaXMuZXhjZXB0aW9ucy5oYW5kbGUoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdG8gYGV4Y2VwdGlvbnMuaGFuZGxlYCBpbiB3aW5zdG9uIDwgMy4wLjAuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB1bmhhbmRsZUV4Y2VwdGlvbnMoLi4uYXJncykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ0RlcHJlY2F0ZWQ6IC51bmhhbmRsZUV4Y2VwdGlvbnMoKSB3aWxsIGJlIHJlbW92ZWQgaW4gd2luc3RvbkA0LiBVc2UgLmV4Y2VwdGlvbnMudW5oYW5kbGUoKSdcbiAgICApO1xuICAgIHRoaXMuZXhjZXB0aW9ucy51bmhhbmRsZSguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvdyBhIG1vcmUgbWVhbmluZ2Z1bCBkZXByZWNhdGlvbiBub3RpY2VcbiAgICogQHRocm93cyB7RXJyb3J9IC0gVE9ETzogYWRkIHRocm93cyBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGNsaSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBbXG4gICAgICAgICdMb2dnZXIuY2xpKCkgd2FzIHJlbW92ZWQgaW4gd2luc3RvbkAzLjAuMCcsXG4gICAgICAgICdVc2UgYSBjdXN0b20gd2luc3Rvbi5mb3JtYXRzLmNsaSgpIGluc3RlYWQuJyxcbiAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uL3RyZWUvbWFzdGVyL1VQR1JBREUtMy4wLm1kJ1xuICAgICAgXS5qb2luKCdcXG4nKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQnViYmxlcyB0aGUgYGV2ZW50YCB0aGF0IG9jY3VyZWQgb24gdGhlIHNwZWNpZmllZCBgdHJhbnNwb3J0YCB1cFxuICAgKiBmcm9tIHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCB0aGF0IG9jY3VyZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zcG9ydCAtIFRyYW5zcG9ydCBvbiB3aGljaCB0aGUgZXZlbnQgb2NjdXJlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRXZlbnQoZXZlbnQsIHRyYW5zcG9ydCkge1xuICAgIGZ1bmN0aW9uIHRyYW5zcG9ydEV2ZW50KGVycikge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uL2lzc3Vlcy8xMzY0XG4gICAgICBpZiAoZXZlbnQgPT09ICdlcnJvcicgJiYgIXRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyh0cmFuc3BvcnQpKSB7XG4gICAgICAgIHRoaXMuYWRkKHRyYW5zcG9ydCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoZXZlbnQsIGVyciwgdHJhbnNwb3J0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYW5zcG9ydFsnX193aW5zdG9uJyArIGV2ZW50XSkge1xuICAgICAgdHJhbnNwb3J0WydfX3dpbnN0b24nICsgZXZlbnRdID0gdHJhbnNwb3J0RXZlbnQuYmluZCh0aGlzKTtcbiAgICAgIHRyYW5zcG9ydC5vbihldmVudCwgdHJhbnNwb3J0WydfX3dpbnN0b24nICsgZXZlbnRdKTtcbiAgICB9XG4gIH1cblxuICBfYWRkRGVmYXVsdE1ldGEobXNnKSB7XG4gICAgaWYgKHRoaXMuZGVmYXVsdE1ldGEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obXNnLCB0aGlzLmRlZmF1bHRNZXRhKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGV2ZWxWYWx1ZShsZXZlbHMsIGxldmVsKSB7XG4gIGNvbnN0IHZhbHVlID0gbGV2ZWxzW2xldmVsXTtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHJlYWRhYmxlU3RhdGUgcGlwZSB0YXJnZXRzIGZvciB0aGlzIExvZ2dlciBpbnN0YW5jZS5cbiAqIEB0eXBlIHtBcnJheXxPYmplY3R9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dnZXIucHJvdG90eXBlLCAndHJhbnNwb3J0cycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIGNvbnN0IHsgcGlwZXMgfSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHBpcGVzKSA/IFtwaXBlc10uZmlsdGVyKEJvb2xlYW4pIDogcGlwZXM7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ2dlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/profiler.js":
/*!******************************************************!*\
  !*** ./node_modules/winston/lib/winston/profiler.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * profiler.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n/**\n * TODO: add class description.\n * @type {Profiler}\n * @private\n */\nclass Profiler {\n  /**\n   * Constructor function for the Profiler instance used by\n   * `Logger.prototype.startTimer`. When done is called the timer will finish\n   * and log the duration.\n   * @param {!Logger} logger - TODO: add param description.\n   * @private\n   */\n  constructor(logger) {\n    const Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/winston/lib/winston/logger.js\");\n    if (typeof logger !== 'object' || Array.isArray(logger) || !(logger instanceof Logger)) {\n      throw new Error('Logger is required for profiling');\n    } else {\n      this.logger = logger;\n      this.start = Date.now();\n    }\n  }\n\n  /**\n   * Ends the current timer (i.e. Profiler) instance and logs the `msg` along\n   * with the duration since creation.\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  done(...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      // eslint-disable-next-line no-console\n      console.warn('Callback function no longer supported as of winston@3.0.0');\n      args.pop();\n    }\n\n    const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n    info.level = info.level || 'info';\n    info.durationMs = (Date.now()) - this.start;\n\n    return this.logger.write(info);\n  }\n};\n\nmodule.exports = Profiler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9wcm9maWxlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFVO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vcHJvZmlsZXIuanM/MjI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHByb2ZpbGVyLmpzOiBUT0RPOiBhZGQgZmlsZSBoZWFkZXIgZGVzY3JpcHRpb24uXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0Jztcbi8qKlxuICogVE9ETzogYWRkIGNsYXNzIGRlc2NyaXB0aW9uLlxuICogQHR5cGUge1Byb2ZpbGVyfVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJvZmlsZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBQcm9maWxlciBpbnN0YW5jZSB1c2VkIGJ5XG4gICAqIGBMb2dnZXIucHJvdG90eXBlLnN0YXJ0VGltZXJgLiBXaGVuIGRvbmUgaXMgY2FsbGVkIHRoZSB0aW1lciB3aWxsIGZpbmlzaFxuICAgKiBhbmQgbG9nIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHshTG9nZ2VyfSBsb2dnZXIgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBjb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuICAgIGlmICh0eXBlb2YgbG9nZ2VyICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGxvZ2dlcikgfHwgIShsb2dnZXIgaW5zdGFuY2VvZiBMb2dnZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2dlciBpcyByZXF1aXJlZCBmb3IgcHJvZmlsaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgdGhpcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuZHMgdGhlIGN1cnJlbnQgdGltZXIgKGkuZS4gUHJvZmlsZXIpIGluc3RhbmNlIGFuZCBsb2dzIHRoZSBgbXNnYCBhbG9uZ1xuICAgKiB3aXRoIHRoZSBkdXJhdGlvbiBzaW5jZSBjcmVhdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb25lKC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignQ2FsbGJhY2sgZnVuY3Rpb24gbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBvZiB3aW5zdG9uQDMuMC4wJyk7XG4gICAgICBhcmdzLnBvcCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZm8gPSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnb2JqZWN0JyA/IGFyZ3MucG9wKCkgOiB7fTtcbiAgICBpbmZvLmxldmVsID0gaW5mby5sZXZlbCB8fCAnaW5mbyc7XG4gICAgaW5mby5kdXJhdGlvbk1zID0gKERhdGUubm93KCkpIC0gdGhpcy5zdGFydDtcblxuICAgIHJldHVybiB0aGlzLmxvZ2dlci53cml0ZShpbmZvKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9maWxlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/profiler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/rejection-handler.js":
/*!***************************************************************!*\
  !*** ./node_modules/winston/lib/winston/rejection-handler.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * exception-handler.js: Object for handling uncaughtException events.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst asyncForEach = __webpack_require__(/*! async/forEach */ \"(rsc)/./node_modules/async/forEach.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:rejection');\nconst once = __webpack_require__(/*! one-time */ \"(rsc)/./node_modules/one-time/index.js\");\nconst stackTrace = __webpack_require__(/*! stack-trace */ \"(rsc)/./node_modules/stack-trace/lib/stack-trace.js\");\nconst RejectionStream = __webpack_require__(/*! ./rejection-stream */ \"(rsc)/./node_modules/winston/lib/winston/rejection-stream.js\");\n\n/**\n * Object for handling unhandledRejection events.\n * @type {RejectionHandler}\n */\nmodule.exports = class RejectionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger} logger - TODO: add param description\n   */\n  constructor(logger) {\n    if (!logger) {\n      throw new Error('Logger is required to handle rejections');\n    }\n\n    this.logger = logger;\n    this.handlers = new Map();\n  }\n\n  /**\n   * Handles `unhandledRejection` events for the current process by adding any\n   * handlers passed in.\n   * @returns {undefined}\n   */\n  handle(...args) {\n    args.forEach(arg => {\n      if (Array.isArray(arg)) {\n        return arg.forEach(handler => this._addHandler(handler));\n      }\n\n      this._addHandler(arg);\n    });\n\n    if (!this.catcher) {\n      this.catcher = this._unhandledRejection.bind(this);\n      process.on('unhandledRejection', this.catcher);\n    }\n  }\n\n  /**\n   * Removes any handlers to `unhandledRejection` events for the current\n   * process. This does not modify the state of the `this.handlers` set.\n   * @returns {undefined}\n   */\n  unhandle() {\n    if (this.catcher) {\n      process.removeListener('unhandledRejection', this.catcher);\n      this.catcher = false;\n\n      Array.from(this.handlers.values()).forEach(wrapper =>\n        this.logger.unpipe(wrapper)\n      );\n    }\n  }\n\n  /**\n   * TODO: add method description\n   * @param {Error} err - Error to get information about.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getAllInfo(err) {\n    let message = null;\n    if (err) {\n      message = typeof err === 'string' ? err : err.message;\n    }\n\n    return {\n      error: err,\n      // TODO (indexzero): how do we configure this?\n      level: 'error',\n      message: [\n        `unhandledRejection: ${message || '(no error message)'}`,\n        err && err.stack || '  No stack trace'\n      ].join('\\n'),\n      stack: err && err.stack,\n      rejection: true,\n      date: new Date().toString(),\n      process: this.getProcessInfo(),\n      os: this.getOsInfo(),\n      trace: this.getTrace(err)\n    };\n  }\n\n  /**\n   * Gets all relevant process information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getProcessInfo() {\n    return {\n      pid: process.pid,\n      uid: process.getuid ? process.getuid() : null,\n      gid: process.getgid ? process.getgid() : null,\n      cwd: process.cwd(),\n      execPath: process.execPath,\n      version: process.version,\n      argv: process.argv,\n      memoryUsage: process.memoryUsage()\n    };\n  }\n\n  /**\n   * Gets all relevant OS information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getOsInfo() {\n    return {\n      loadavg: os.loadavg(),\n      uptime: os.uptime()\n    };\n  }\n\n  /**\n   * Gets a stack trace for the specified error.\n   * @param {mixed} err - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getTrace(err) {\n    const trace = err ? stackTrace.parse(err) : stackTrace.get();\n    return trace.map(site => {\n      return {\n        column: site.getColumnNumber(),\n        file: site.getFileName(),\n        function: site.getFunctionName(),\n        line: site.getLineNumber(),\n        method: site.getMethodName(),\n        native: site.isNative()\n      };\n    });\n  }\n\n  /**\n   * Helper method to add a transport as an exception handler.\n   * @param {Transport} handler - The transport to add as an exception handler.\n   * @returns {void}\n   */\n  _addHandler(handler) {\n    if (!this.handlers.has(handler)) {\n      handler.handleRejections = true;\n      const wrapper = new RejectionStream(handler);\n      this.handlers.set(handler, wrapper);\n      this.logger.pipe(wrapper);\n    }\n  }\n\n  /**\n   * Logs all relevant information around the `err` and exits the current\n   * process.\n   * @param {Error} err - Error to handle\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _unhandledRejection(err) {\n    const info = this.getAllInfo(err);\n    const handlers = this._getRejectionHandlers();\n    // Calculate if we should exit on this error\n    let doExit =\n      typeof this.logger.exitOnError === 'function'\n        ? this.logger.exitOnError(err)\n        : this.logger.exitOnError;\n    let timeout;\n\n    if (!handlers.length && doExit) {\n      // eslint-disable-next-line no-console\n      console.warn('winston: exitOnError cannot be true with no rejection handlers.');\n      // eslint-disable-next-line no-console\n      console.warn('winston: not exiting process.');\n      doExit = false;\n    }\n\n    function gracefulExit() {\n      debug('doExit', doExit);\n      debug('process._exiting', process._exiting);\n\n      if (doExit && !process._exiting) {\n        // Remark: Currently ignoring any rejections from transports when\n        // catching unhandled rejections.\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }\n    }\n\n    if (!handlers || handlers.length === 0) {\n      return process.nextTick(gracefulExit);\n    }\n\n    // Log to all transports attempting to listen for when they are completed.\n    asyncForEach(\n      handlers,\n      (handler, next) => {\n        const done = once(next);\n        const transport = handler.transport || handler;\n\n        // Debug wrapping so that we can inspect what's going on under the covers.\n        function onDone(event) {\n          return () => {\n            debug(event);\n            done();\n          };\n        }\n\n        transport._ending = true;\n        transport.once('finish', onDone('finished'));\n        transport.once('error', onDone('error'));\n      },\n      () => doExit && gracefulExit()\n    );\n\n    this.logger.log(info);\n\n    // If exitOnError is true, then only allow the logging of exceptions to\n    // take up to `3000ms`.\n    if (doExit) {\n      timeout = setTimeout(gracefulExit, 3000);\n    }\n  }\n\n  /**\n   * Returns the list of transports and exceptionHandlers for this instance.\n   * @returns {Array} - List of transports and exceptionHandlers for this\n   * instance.\n   * @private\n   */\n  _getRejectionHandlers() {\n    // Remark (indexzero): since `logger.transports` returns all of the pipes\n    // from the _readableState of the stream we actually get the join of the\n    // explicit handlers and the implicit transports with\n    // `handleRejections: true`\n    return this.logger.transports.filter(wrap => {\n      const transport = wrap.transport || wrap;\n      return transport.handleRejections;\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9yZWplY3Rpb24taGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCLG1CQUFPLENBQUMsNERBQWU7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLCtFQUFtQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsd0RBQVU7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWE7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQW9COztBQUVwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vcmVqZWN0aW9uLWhhbmRsZXIuanM/ZGE3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGV4Y2VwdGlvbi1oYW5kbGVyLmpzOiBPYmplY3QgZm9yIGhhbmRsaW5nIHVuY2F1Z2h0RXhjZXB0aW9uIGV2ZW50cy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBhc3luY0ZvckVhY2ggPSByZXF1aXJlKCdhc3luYy9mb3JFYWNoJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ0BkYWJoL2RpYWdub3N0aWNzJykoJ3dpbnN0b246cmVqZWN0aW9uJyk7XG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25lLXRpbWUnKTtcbmNvbnN0IHN0YWNrVHJhY2UgPSByZXF1aXJlKCdzdGFjay10cmFjZScpO1xuY29uc3QgUmVqZWN0aW9uU3RyZWFtID0gcmVxdWlyZSgnLi9yZWplY3Rpb24tc3RyZWFtJyk7XG5cbi8qKlxuICogT2JqZWN0IGZvciBoYW5kbGluZyB1bmhhbmRsZWRSZWplY3Rpb24gZXZlbnRzLlxuICogQHR5cGUge1JlamVjdGlvbkhhbmRsZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVqZWN0aW9uSGFuZGxlciB7XG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgY29udHJ1Y3RvciBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0geyFMb2dnZXJ9IGxvZ2dlciAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9nZ2VyIGlzIHJlcXVpcmVkIHRvIGhhbmRsZSByZWplY3Rpb25zJyk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5oYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGB1bmhhbmRsZWRSZWplY3Rpb25gIGV2ZW50cyBmb3IgdGhlIGN1cnJlbnQgcHJvY2VzcyBieSBhZGRpbmcgYW55XG4gICAqIGhhbmRsZXJzIHBhc3NlZCBpbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGhhbmRsZSguLi5hcmdzKSB7XG4gICAgYXJncy5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIHJldHVybiBhcmcuZm9yRWFjaChoYW5kbGVyID0+IHRoaXMuX2FkZEhhbmRsZXIoaGFuZGxlcikpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hZGRIYW5kbGVyKGFyZyk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuY2F0Y2hlcikge1xuICAgICAgdGhpcy5jYXRjaGVyID0gdGhpcy5fdW5oYW5kbGVkUmVqZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICBwcm9jZXNzLm9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzLmNhdGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFueSBoYW5kbGVycyB0byBgdW5oYW5kbGVkUmVqZWN0aW9uYCBldmVudHMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHByb2Nlc3MuIFRoaXMgZG9lcyBub3QgbW9kaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgYHRoaXMuaGFuZGxlcnNgIHNldC5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHVuaGFuZGxlKCkge1xuICAgIGlmICh0aGlzLmNhdGNoZXIpIHtcbiAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHRoaXMuY2F0Y2hlcik7XG4gICAgICB0aGlzLmNhdGNoZXIgPSBmYWxzZTtcblxuICAgICAgQXJyYXkuZnJvbSh0aGlzLmhhbmRsZXJzLnZhbHVlcygpKS5mb3JFYWNoKHdyYXBwZXIgPT5cbiAgICAgICAgdGhpcy5sb2dnZXIudW5waXBlKHdyYXBwZXIpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgbWV0aG9kIGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dC5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBnZXRBbGxJbmZvKGVycikge1xuICAgIGxldCBtZXNzYWdlID0gbnVsbDtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBtZXNzYWdlID0gdHlwZW9mIGVyciA9PT0gJ3N0cmluZycgPyBlcnIgOiBlcnIubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycixcbiAgICAgIC8vIFRPRE8gKGluZGV4emVybyk6IGhvdyBkbyB3ZSBjb25maWd1cmUgdGhpcz9cbiAgICAgIGxldmVsOiAnZXJyb3InLFxuICAgICAgbWVzc2FnZTogW1xuICAgICAgICBgdW5oYW5kbGVkUmVqZWN0aW9uOiAke21lc3NhZ2UgfHwgJyhubyBlcnJvciBtZXNzYWdlKSd9YCxcbiAgICAgICAgZXJyICYmIGVyci5zdGFjayB8fCAnICBObyBzdGFjayB0cmFjZSdcbiAgICAgIF0uam9pbignXFxuJyksXG4gICAgICBzdGFjazogZXJyICYmIGVyci5zdGFjayxcbiAgICAgIHJlamVjdGlvbjogdHJ1ZSxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKSxcbiAgICAgIHByb2Nlc3M6IHRoaXMuZ2V0UHJvY2Vzc0luZm8oKSxcbiAgICAgIG9zOiB0aGlzLmdldE9zSW5mbygpLFxuICAgICAgdHJhY2U6IHRoaXMuZ2V0VHJhY2UoZXJyKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgcmVsZXZhbnQgcHJvY2VzcyBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0UHJvY2Vzc0luZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpZDogcHJvY2Vzcy5waWQsXG4gICAgICB1aWQ6IHByb2Nlc3MuZ2V0dWlkID8gcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGwsXG4gICAgICBnaWQ6IHByb2Nlc3MuZ2V0Z2lkID8gcHJvY2Vzcy5nZXRnaWQoKSA6IG51bGwsXG4gICAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgICBleGVjUGF0aDogcHJvY2Vzcy5leGVjUGF0aCxcbiAgICAgIHZlcnNpb246IHByb2Nlc3MudmVyc2lvbixcbiAgICAgIGFyZ3Y6IHByb2Nlc3MuYXJndixcbiAgICAgIG1lbW9yeVVzYWdlOiBwcm9jZXNzLm1lbW9yeVVzYWdlKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHJlbGV2YW50IE9TIGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgcHJvY2Vzcy5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBnZXRPc0luZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRhdmc6IG9zLmxvYWRhdmcoKSxcbiAgICAgIHVwdGltZTogb3MudXB0aW1lKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzdGFjayB0cmFjZSBmb3IgdGhlIHNwZWNpZmllZCBlcnJvci5cbiAgICogQHBhcmFtIHttaXhlZH0gZXJyIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldFRyYWNlKGVycikge1xuICAgIGNvbnN0IHRyYWNlID0gZXJyID8gc3RhY2tUcmFjZS5wYXJzZShlcnIpIDogc3RhY2tUcmFjZS5nZXQoKTtcbiAgICByZXR1cm4gdHJhY2UubWFwKHNpdGUgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1uOiBzaXRlLmdldENvbHVtbk51bWJlcigpLFxuICAgICAgICBmaWxlOiBzaXRlLmdldEZpbGVOYW1lKCksXG4gICAgICAgIGZ1bmN0aW9uOiBzaXRlLmdldEZ1bmN0aW9uTmFtZSgpLFxuICAgICAgICBsaW5lOiBzaXRlLmdldExpbmVOdW1iZXIoKSxcbiAgICAgICAgbWV0aG9kOiBzaXRlLmdldE1ldGhvZE5hbWUoKSxcbiAgICAgICAgbmF0aXZlOiBzaXRlLmlzTmF0aXZlKClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSB0cmFuc3BvcnQgYXMgYW4gZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7VHJhbnNwb3J0fSBoYW5kbGVyIC0gVGhlIHRyYW5zcG9ydCB0byBhZGQgYXMgYW4gZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2FkZEhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5oYW5kbGVycy5oYXMoaGFuZGxlcikpIHtcbiAgICAgIGhhbmRsZXIuaGFuZGxlUmVqZWN0aW9ucyA9IHRydWU7XG4gICAgICBjb25zdCB3cmFwcGVyID0gbmV3IFJlamVjdGlvblN0cmVhbShoYW5kbGVyKTtcbiAgICAgIHRoaXMuaGFuZGxlcnMuc2V0KGhhbmRsZXIsIHdyYXBwZXIpO1xuICAgICAgdGhpcy5sb2dnZXIucGlwZSh3cmFwcGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhbGwgcmVsZXZhbnQgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBgZXJyYCBhbmQgZXhpdHMgdGhlIGN1cnJlbnRcbiAgICogcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgdG8gaGFuZGxlXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VuaGFuZGxlZFJlamVjdGlvbihlcnIpIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5nZXRBbGxJbmZvKGVycik7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLl9nZXRSZWplY3Rpb25IYW5kbGVycygpO1xuICAgIC8vIENhbGN1bGF0ZSBpZiB3ZSBzaG91bGQgZXhpdCBvbiB0aGlzIGVycm9yXG4gICAgbGV0IGRvRXhpdCA9XG4gICAgICB0eXBlb2YgdGhpcy5sb2dnZXIuZXhpdE9uRXJyb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB0aGlzLmxvZ2dlci5leGl0T25FcnJvcihlcnIpXG4gICAgICAgIDogdGhpcy5sb2dnZXIuZXhpdE9uRXJyb3I7XG4gICAgbGV0IHRpbWVvdXQ7XG5cbiAgICBpZiAoIWhhbmRsZXJzLmxlbmd0aCAmJiBkb0V4aXQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ3dpbnN0b246IGV4aXRPbkVycm9yIGNhbm5vdCBiZSB0cnVlIHdpdGggbm8gcmVqZWN0aW9uIGhhbmRsZXJzLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybignd2luc3Rvbjogbm90IGV4aXRpbmcgcHJvY2Vzcy4nKTtcbiAgICAgIGRvRXhpdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyYWNlZnVsRXhpdCgpIHtcbiAgICAgIGRlYnVnKCdkb0V4aXQnLCBkb0V4aXQpO1xuICAgICAgZGVidWcoJ3Byb2Nlc3MuX2V4aXRpbmcnLCBwcm9jZXNzLl9leGl0aW5nKTtcblxuICAgICAgaWYgKGRvRXhpdCAmJiAhcHJvY2Vzcy5fZXhpdGluZykge1xuICAgICAgICAvLyBSZW1hcms6IEN1cnJlbnRseSBpZ25vcmluZyBhbnkgcmVqZWN0aW9ucyBmcm9tIHRyYW5zcG9ydHMgd2hlblxuICAgICAgICAvLyBjYXRjaGluZyB1bmhhbmRsZWQgcmVqZWN0aW9ucy5cbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZXhpdFxuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYW5kbGVycyB8fCBoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGdyYWNlZnVsRXhpdCk7XG4gICAgfVxuXG4gICAgLy8gTG9nIHRvIGFsbCB0cmFuc3BvcnRzIGF0dGVtcHRpbmcgdG8gbGlzdGVuIGZvciB3aGVuIHRoZXkgYXJlIGNvbXBsZXRlZC5cbiAgICBhc3luY0ZvckVhY2goXG4gICAgICBoYW5kbGVycyxcbiAgICAgIChoYW5kbGVyLCBuZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSBvbmNlKG5leHQpO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBoYW5kbGVyLnRyYW5zcG9ydCB8fCBoYW5kbGVyO1xuXG4gICAgICAgIC8vIERlYnVnIHdyYXBwaW5nIHNvIHRoYXQgd2UgY2FuIGluc3BlY3Qgd2hhdCdzIGdvaW5nIG9uIHVuZGVyIHRoZSBjb3ZlcnMuXG4gICAgICAgIGZ1bmN0aW9uIG9uRG9uZShldmVudCkge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhldmVudCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zcG9ydC5fZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoJ2ZpbmlzaCcsIG9uRG9uZSgnZmluaXNoZWQnKSk7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uRG9uZSgnZXJyb3InKSk7XG4gICAgICB9LFxuICAgICAgKCkgPT4gZG9FeGl0ICYmIGdyYWNlZnVsRXhpdCgpXG4gICAgKTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZyhpbmZvKTtcblxuICAgIC8vIElmIGV4aXRPbkVycm9yIGlzIHRydWUsIHRoZW4gb25seSBhbGxvdyB0aGUgbG9nZ2luZyBvZiBleGNlcHRpb25zIHRvXG4gICAgLy8gdGFrZSB1cCB0byBgMzAwMG1zYC5cbiAgICBpZiAoZG9FeGl0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChncmFjZWZ1bEV4aXQsIDMwMDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHRyYW5zcG9ydHMgYW5kIGV4Y2VwdGlvbkhhbmRsZXJzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gTGlzdCBvZiB0cmFuc3BvcnRzIGFuZCBleGNlcHRpb25IYW5kbGVycyBmb3IgdGhpc1xuICAgKiBpbnN0YW5jZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSZWplY3Rpb25IYW5kbGVycygpIHtcbiAgICAvLyBSZW1hcmsgKGluZGV4emVybyk6IHNpbmNlIGBsb2dnZXIudHJhbnNwb3J0c2AgcmV0dXJucyBhbGwgb2YgdGhlIHBpcGVzXG4gICAgLy8gZnJvbSB0aGUgX3JlYWRhYmxlU3RhdGUgb2YgdGhlIHN0cmVhbSB3ZSBhY3R1YWxseSBnZXQgdGhlIGpvaW4gb2YgdGhlXG4gICAgLy8gZXhwbGljaXQgaGFuZGxlcnMgYW5kIHRoZSBpbXBsaWNpdCB0cmFuc3BvcnRzIHdpdGhcbiAgICAvLyBgaGFuZGxlUmVqZWN0aW9uczogdHJ1ZWBcbiAgICByZXR1cm4gdGhpcy5sb2dnZXIudHJhbnNwb3J0cy5maWx0ZXIod3JhcCA9PiB7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSB3cmFwLnRyYW5zcG9ydCB8fCB3cmFwO1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydC5oYW5kbGVSZWplY3Rpb25zO1xuICAgIH0pO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/rejection-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/rejection-stream.js":
/*!**************************************************************!*\
  !*** ./node_modules/winston/lib/winston/rejection-stream.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * rejection-stream.js: TODO: add file header handler.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { Writable } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\n\n/**\n * TODO: add class description.\n * @type {RejectionStream}\n * @extends {Writable}\n */\nmodule.exports = class RejectionStream extends Writable {\n  /**\n   * Constructor function for the RejectionStream responsible for wrapping a\n   * TransportStream; only allowing writes of `info` objects with\n   * `info.rejection` set to true.\n   * @param {!TransportStream} transport - Stream to filter to rejections\n   */\n  constructor(transport) {\n    super({ objectMode: true });\n\n    if (!transport) {\n      throw new Error('RejectionStream requires a TransportStream instance.');\n    }\n\n    this.handleRejections = true;\n    this.transport = transport;\n  }\n\n  /**\n   * Writes the info object to our transport instance if (and only if) the\n   * `rejection` property is set on the info.\n   * @param {mixed} info - TODO: add param description.\n   * @param {mixed} enc - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _write(info, enc, callback) {\n    if (info.rejection) {\n      return this.transport.log(info, callback);\n    }\n\n    callback();\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9yZWplY3Rpb24tc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHlFQUFpQjs7QUFFOUM7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vcmVqZWN0aW9uLXN0cmVhbS5qcz9iOWU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVqZWN0aW9uLXN0cmVhbS5qczogVE9ETzogYWRkIGZpbGUgaGVhZGVyIGhhbmRsZXIuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5cbi8qKlxuICogVE9ETzogYWRkIGNsYXNzIGRlc2NyaXB0aW9uLlxuICogQHR5cGUge1JlamVjdGlvblN0cmVhbX1cbiAqIEBleHRlbmRzIHtXcml0YWJsZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZWplY3Rpb25TdHJlYW0gZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIFJlamVjdGlvblN0cmVhbSByZXNwb25zaWJsZSBmb3Igd3JhcHBpbmcgYVxuICAgKiBUcmFuc3BvcnRTdHJlYW07IG9ubHkgYWxsb3dpbmcgd3JpdGVzIG9mIGBpbmZvYCBvYmplY3RzIHdpdGhcbiAgICogYGluZm8ucmVqZWN0aW9uYCBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHshVHJhbnNwb3J0U3RyZWFtfSB0cmFuc3BvcnQgLSBTdHJlYW0gdG8gZmlsdGVyIHRvIHJlamVjdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcblxuICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlamVjdGlvblN0cmVhbSByZXF1aXJlcyBhIFRyYW5zcG9ydFN0cmVhbSBpbnN0YW5jZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZVJlamVjdGlvbnMgPSB0cnVlO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgaW5mbyBvYmplY3QgdG8gb3VyIHRyYW5zcG9ydCBpbnN0YW5jZSBpZiAoYW5kIG9ubHkgaWYpIHRoZVxuICAgKiBgcmVqZWN0aW9uYCBwcm9wZXJ0eSBpcyBzZXQgb24gdGhlIGluZm8uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGluZm8gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGVuYyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dyaXRlKGluZm8sIGVuYywgY2FsbGJhY2spIHtcbiAgICBpZiAoaW5mby5yZWplY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/rejection-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/tail-file.js":
/*!*******************************************************!*\
  !*** ./node_modules/winston/lib/winston/tail-file.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * tail-file.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst { Stream } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\n\n/**\n * Simple no-op function.\n * @returns {undefined}\n */\nfunction noop() {}\n\n/**\n * TODO: add function description.\n * @param {Object} options - Options for tail.\n * @param {function} iter - Iterator function to execute on every line.\n* `tail -f` a file. Options must include file.\n * @returns {mixed} - TODO: add return description.\n */\nmodule.exports = (options, iter) => {\n  const buffer = Buffer.alloc(64 * 1024);\n  const decode = new StringDecoder('utf8');\n  const stream = new Stream();\n  let buff = '';\n  let pos = 0;\n  let row = 0;\n\n  if (options.start === -1) {\n    delete options.start;\n  }\n\n  stream.readable = true;\n  stream.destroy = () => {\n    stream.destroyed = true;\n    stream.emit('end');\n    stream.emit('close');\n  };\n\n  fs.open(options.file, 'a+', '0644', (err, fd) => {\n    if (err) {\n      if (!iter) {\n        stream.emit('error', err);\n      } else {\n        iter(err);\n      }\n      stream.destroy();\n      return;\n    }\n\n    (function read() {\n      if (stream.destroyed) {\n        fs.close(fd, noop);\n        return;\n      }\n\n      return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {\n        if (error) {\n          if (!iter) {\n            stream.emit('error', error);\n          } else {\n            iter(error);\n          }\n          stream.destroy();\n          return;\n        }\n\n        if (!bytes) {\n          if (buff) {\n            // eslint-disable-next-line eqeqeq\n            if (options.start == null || row > options.start) {\n              if (!iter) {\n                stream.emit('line', buff);\n              } else {\n                iter(null, buff);\n              }\n            }\n            row++;\n            buff = '';\n          }\n          return setTimeout(read, 1000);\n        }\n\n        let data = decode.write(buffer.slice(0, bytes));\n        if (!iter) {\n          stream.emit('data', data);\n        }\n\n        data = (buff + data).split(/\\n+/);\n\n        const l = data.length - 1;\n        let i = 0;\n\n        for (; i < l; i++) {\n          // eslint-disable-next-line eqeqeq\n          if (options.start == null || row > options.start) {\n            if (!iter) {\n              stream.emit('line', data[i]);\n            } else {\n              iter(null, data[i]);\n            }\n          }\n          row++;\n        }\n\n        buff = data[l];\n        pos += bytes;\n        return read();\n      });\n    }());\n  });\n\n  if (!iter) {\n    return stream;\n  }\n\n  return stream.destroy;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90YWlsLWZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzQ0FBZ0I7QUFDbEQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7O0FBRTVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3RhaWwtZmlsZS5qcz83OGFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdGFpbC1maWxlLmpzOiBUT0RPOiBhZGQgZmlsZSBoZWFkZXIgZGVzY3JpcHRpb24uXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBTdHJpbmdEZWNvZGVyIH0gPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpO1xuY29uc3QgeyBTdHJlYW0gfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpO1xuXG4vKipcbiAqIFNpbXBsZSBuby1vcCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIFRPRE86IGFkZCBmdW5jdGlvbiBkZXNjcmlwdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGFpbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXIgLSBJdGVyYXRvciBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGxpbmUuXG4qIGB0YWlsIC1mYCBhIGZpbGUuIE9wdGlvbnMgbXVzdCBpbmNsdWRlIGZpbGUuXG4gKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAob3B0aW9ucywgaXRlcikgPT4ge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoNjQgKiAxMDI0KTtcbiAgY29uc3QgZGVjb2RlID0gbmV3IFN0cmluZ0RlY29kZXIoJ3V0ZjgnKTtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSgpO1xuICBsZXQgYnVmZiA9ICcnO1xuICBsZXQgcG9zID0gMDtcbiAgbGV0IHJvdyA9IDA7XG5cbiAgaWYgKG9wdGlvbnMuc3RhcnQgPT09IC0xKSB7XG4gICAgZGVsZXRlIG9wdGlvbnMuc3RhcnQ7XG4gIH1cblxuICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICBzdHJlYW0uZGVzdHJveSA9ICgpID0+IHtcbiAgICBzdHJlYW0uZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG4gIH07XG5cbiAgZnMub3BlbihvcHRpb25zLmZpbGUsICdhKycsICcwNjQ0JywgKGVyciwgZmQpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoIWl0ZXIpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXIoZXJyKTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgKGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICBmcy5jbG9zZShmZCwgbm9vcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCwgcG9zLCAoZXJyb3IsIGJ5dGVzKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGlmICghaXRlcikge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJ5dGVzKSB7XG4gICAgICAgICAgaWYgKGJ1ZmYpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0ID09IG51bGwgfHwgcm93ID4gb3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgICBpZiAoIWl0ZXIpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnbGluZScsIGJ1ZmYpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXIobnVsbCwgYnVmZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgYnVmZiA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZWFkLCAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhID0gZGVjb2RlLndyaXRlKGJ1ZmZlci5zbGljZSgwLCBieXRlcykpO1xuICAgICAgICBpZiAoIWl0ZXIpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSA9IChidWZmICsgZGF0YSkuc3BsaXQoL1xcbisvKTtcblxuICAgICAgICBjb25zdCBsID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgaSA9IDA7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQgPT0gbnVsbCB8fCByb3cgPiBvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoIWl0ZXIpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2xpbmUnLCBkYXRhW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZXIobnVsbCwgZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZiA9IGRhdGFbbF07XG4gICAgICAgIHBvcyArPSBieXRlcztcbiAgICAgICAgcmV0dXJuIHJlYWQoKTtcbiAgICAgIH0pO1xuICAgIH0oKSk7XG4gIH0pO1xuXG4gIGlmICghaXRlcikge1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICByZXR1cm4gc3RyZWFtLmRlc3Ryb3k7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/tail-file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/console.js":
/*!****************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/console.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-console */\n/*\n * console.js: Transport for outputting to the console.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst { LEVEL, MESSAGE } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\n\n/**\n * Transport for outputting to the console.\n * @type {Console}\n * @extends {TransportStream}\n */\nmodule.exports = class Console extends TransportStream {\n  /**\n   * Constructor function for the Console transport object responsible for\n   * persisting log messages and metadata to a terminal or TTY.\n   * @param {!Object} [options={}] - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // Expose the name of this Transport on the prototype\n    this.name = options.name || 'console';\n    this.stderrLevels = this._stringArrayToSet(options.stderrLevels);\n    this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);\n    this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;\n    this.forceConsole = options.forceConsole || false;\n\n    // Keep a reference to the log, warn, and error console methods\n    // in case they get redirected to this transport after the logger is\n    // instantiated. This prevents a circular reference issue.\n    this._consoleLog = console.log.bind(console);\n    this._consoleWarn = console.warn.bind(console);\n    this._consoleError = console.error.bind(console);\n\n    this.setMaxListeners(30);\n  }\n\n  /**\n   * Core logging method exposed to Winston.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback) {\n    setImmediate(() => this.emit('logged', info));\n\n    // Remark: what if there is no raw...?\n    if (this.stderrLevels[info[LEVEL]]) {\n      if (console._stderr && !this.forceConsole) {\n        // Node.js maps `process.stderr` to `console._stderr`.\n        console._stderr.write(`${info[MESSAGE]}${this.eol}`);\n      } else {\n        // console.error adds a newline\n        this._consoleError(info[MESSAGE]);\n      }\n\n      if (callback) {\n        callback(); // eslint-disable-line callback-return\n      }\n      return;\n    } else if (this.consoleWarnLevels[info[LEVEL]]) {\n      if (console._stderr && !this.forceConsole) {\n        // Node.js maps `process.stderr` to `console._stderr`.\n        // in Node.js console.warn is an alias for console.error\n        console._stderr.write(`${info[MESSAGE]}${this.eol}`);\n      } else {\n        // console.warn adds a newline\n        this._consoleWarn(info[MESSAGE]);\n      }\n\n      if (callback) {\n        callback(); // eslint-disable-line callback-return\n      }\n      return;\n    }\n\n    if (console._stdout && !this.forceConsole) {\n      // Node.js maps `process.stdout` to `console._stdout`.\n      console._stdout.write(`${info[MESSAGE]}${this.eol}`);\n    } else {\n      // console.log adds a newline.\n      this._consoleLog(info[MESSAGE]);\n    }\n\n    if (callback) {\n      callback(); // eslint-disable-line callback-return\n    }\n  }\n\n  /**\n   * Returns a Set-like object with strArray's elements as keys (each with the\n   * value true).\n   * @param {Array} strArray - Array of Set-elements as strings.\n   * @param {?string} [errMsg] - Custom error message thrown on invalid input.\n   * @returns {Object} - TODO: add return description.\n   * @private\n   */\n  _stringArrayToSet(strArray, errMsg) {\n    if (!strArray) return {};\n\n    errMsg =\n      errMsg || 'Cannot make set from type other than Array of string elements';\n\n    if (!Array.isArray(strArray)) {\n      throw new Error(errMsg);\n    }\n\n    return strArray.reduce((set, el) => {\n      if (typeof el !== 'string') {\n        throw new Error(errMsg);\n      }\n      set[el] = true;\n\n      return set;\n    }, {});\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2NvbnNvbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLDBFQUFtQjs7QUFFbkQ7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxXQUFXO0FBQ2pDO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWMsRUFBRSxTQUFTO0FBQzFELFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYyxFQUFFLFNBQVM7QUFDMUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixjQUFjLEVBQUUsU0FBUztBQUN4RCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2Nlc3Nvcnktc2FsZXMtc3VtbWFyeS8uL25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3RyYW5zcG9ydHMvY29uc29sZS5qcz9iMzY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbi8qXG4gKiBjb25zb2xlLmpzOiBUcmFuc3BvcnQgZm9yIG91dHB1dHRpbmcgdG8gdGhlIGNvbnNvbGUuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgeyBMRVZFTCwgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcbmNvbnN0IFRyYW5zcG9ydFN0cmVhbSA9IHJlcXVpcmUoJ3dpbnN0b24tdHJhbnNwb3J0Jyk7XG5cbi8qKlxuICogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIHRoZSBjb25zb2xlLlxuICogQHR5cGUge0NvbnNvbGV9XG4gKiBAZXh0ZW5kcyB7VHJhbnNwb3J0U3RyZWFtfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENvbnNvbGUgZXh0ZW5kcyBUcmFuc3BvcnRTdHJlYW0ge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBDb25zb2xlIHRyYW5zcG9ydCBvYmplY3QgcmVzcG9uc2libGUgZm9yXG4gICAqIHBlcnNpc3RpbmcgbG9nIG1lc3NhZ2VzIGFuZCBtZXRhZGF0YSB0byBhIHRlcm1pbmFsIG9yIFRUWS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAvLyBFeHBvc2UgdGhlIG5hbWUgb2YgdGhpcyBUcmFuc3BvcnQgb24gdGhlIHByb3RvdHlwZVxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnY29uc29sZSc7XG4gICAgdGhpcy5zdGRlcnJMZXZlbHMgPSB0aGlzLl9zdHJpbmdBcnJheVRvU2V0KG9wdGlvbnMuc3RkZXJyTGV2ZWxzKTtcbiAgICB0aGlzLmNvbnNvbGVXYXJuTGV2ZWxzID0gdGhpcy5fc3RyaW5nQXJyYXlUb1NldChvcHRpb25zLmNvbnNvbGVXYXJuTGV2ZWxzKTtcbiAgICB0aGlzLmVvbCA9IHR5cGVvZiBvcHRpb25zLmVvbCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmVvbCA6IG9zLkVPTDtcbiAgICB0aGlzLmZvcmNlQ29uc29sZSA9IG9wdGlvbnMuZm9yY2VDb25zb2xlIHx8IGZhbHNlO1xuXG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbG9nLCB3YXJuLCBhbmQgZXJyb3IgY29uc29sZSBtZXRob2RzXG4gICAgLy8gaW4gY2FzZSB0aGV5IGdldCByZWRpcmVjdGVkIHRvIHRoaXMgdHJhbnNwb3J0IGFmdGVyIHRoZSBsb2dnZXIgaXNcbiAgICAvLyBpbnN0YW50aWF0ZWQuIFRoaXMgcHJldmVudHMgYSBjaXJjdWxhciByZWZlcmVuY2UgaXNzdWUuXG4gICAgdGhpcy5fY29uc29sZUxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgdGhpcy5fY29uc29sZVdhcm4gPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICB0aGlzLl9jb25zb2xlRXJyb3IgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5cbiAgICB0aGlzLnNldE1heExpc3RlbmVycygzMCk7XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb2dnaW5nIG1ldGhvZCBleHBvc2VkIHRvIFdpbnN0b24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGxvZyhpbmZvLCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmVtaXQoJ2xvZ2dlZCcsIGluZm8pKTtcblxuICAgIC8vIFJlbWFyazogd2hhdCBpZiB0aGVyZSBpcyBubyByYXcuLi4/XG4gICAgaWYgKHRoaXMuc3RkZXJyTGV2ZWxzW2luZm9bTEVWRUxdXSkge1xuICAgICAgaWYgKGNvbnNvbGUuX3N0ZGVyciAmJiAhdGhpcy5mb3JjZUNvbnNvbGUpIHtcbiAgICAgICAgLy8gTm9kZS5qcyBtYXBzIGBwcm9jZXNzLnN0ZGVycmAgdG8gYGNvbnNvbGUuX3N0ZGVycmAuXG4gICAgICAgIGNvbnNvbGUuX3N0ZGVyci53cml0ZShgJHtpbmZvW01FU1NBR0VdfSR7dGhpcy5lb2x9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yIGFkZHMgYSBuZXdsaW5lXG4gICAgICAgIHRoaXMuX2NvbnNvbGVFcnJvcihpbmZvW01FU1NBR0VdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbnNvbGVXYXJuTGV2ZWxzW2luZm9bTEVWRUxdXSkge1xuICAgICAgaWYgKGNvbnNvbGUuX3N0ZGVyciAmJiAhdGhpcy5mb3JjZUNvbnNvbGUpIHtcbiAgICAgICAgLy8gTm9kZS5qcyBtYXBzIGBwcm9jZXNzLnN0ZGVycmAgdG8gYGNvbnNvbGUuX3N0ZGVycmAuXG4gICAgICAgIC8vIGluIE5vZGUuanMgY29uc29sZS53YXJuIGlzIGFuIGFsaWFzIGZvciBjb25zb2xlLmVycm9yXG4gICAgICAgIGNvbnNvbGUuX3N0ZGVyci53cml0ZShgJHtpbmZvW01FU1NBR0VdfSR7dGhpcy5lb2x9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4gYWRkcyBhIG5ld2xpbmVcbiAgICAgICAgdGhpcy5fY29uc29sZVdhcm4oaW5mb1tNRVNTQUdFXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb25zb2xlLl9zdGRvdXQgJiYgIXRoaXMuZm9yY2VDb25zb2xlKSB7XG4gICAgICAvLyBOb2RlLmpzIG1hcHMgYHByb2Nlc3Muc3Rkb3V0YCB0byBgY29uc29sZS5fc3Rkb3V0YC5cbiAgICAgIGNvbnNvbGUuX3N0ZG91dC53cml0ZShgJHtpbmZvW01FU1NBR0VdfSR7dGhpcy5lb2x9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nIGFkZHMgYSBuZXdsaW5lLlxuICAgICAgdGhpcy5fY29uc29sZUxvZyhpbmZvW01FU1NBR0VdKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBTZXQtbGlrZSBvYmplY3Qgd2l0aCBzdHJBcnJheSdzIGVsZW1lbnRzIGFzIGtleXMgKGVhY2ggd2l0aCB0aGVcbiAgICogdmFsdWUgdHJ1ZSkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0ckFycmF5IC0gQXJyYXkgb2YgU2V0LWVsZW1lbnRzIGFzIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gW2Vyck1zZ10gLSBDdXN0b20gZXJyb3IgbWVzc2FnZSB0aHJvd24gb24gaW52YWxpZCBpbnB1dC5cbiAgICogQHJldHVybnMge09iamVjdH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0cmluZ0FycmF5VG9TZXQoc3RyQXJyYXksIGVyck1zZykge1xuICAgIGlmICghc3RyQXJyYXkpIHJldHVybiB7fTtcblxuICAgIGVyck1zZyA9XG4gICAgICBlcnJNc2cgfHwgJ0Nhbm5vdCBtYWtlIHNldCBmcm9tIHR5cGUgb3RoZXIgdGhhbiBBcnJheSBvZiBzdHJpbmcgZWxlbWVudHMnO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN0ckFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ckFycmF5LnJlZHVjZSgoc2V0LCBlbCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICB9XG4gICAgICBzZXRbZWxdID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9LCB7fSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/console.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/file.js":
/*!*************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/file.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable complexity,max-statements */\n/**\n * file.js: Transport for outputting to a local log file.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst asyncSeries = __webpack_require__(/*! async/series */ \"(rsc)/./node_modules/async/series.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst { MESSAGE } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst { Stream, PassThrough } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:file');\nconst os = __webpack_require__(/*! os */ \"os\");\nconst tailFile = __webpack_require__(/*! ../tail-file */ \"(rsc)/./node_modules/winston/lib/winston/tail-file.js\");\n\n/**\n * Transport for outputting to a local log file.\n * @type {File}\n * @extends {TransportStream}\n */\nmodule.exports = class File extends TransportStream {\n  /**\n   * Constructor function for the File transport object responsible for\n   * persisting log messages and metadata to one or more files.\n   * @param {Object} options - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // Expose the name of this Transport on the prototype.\n    this.name = options.name || 'file';\n\n    // Helper function which throws an `Error` in the event that any of the\n    // rest of the arguments is present in `options`.\n    function throwIf(target, ...args) {\n      args.slice(1).forEach(name => {\n        if (options[name]) {\n          throw new Error(`Cannot set ${name} and ${target} together`);\n        }\n      });\n    }\n\n    // Setup the base stream that always gets piped to to handle buffering.\n    this._stream = new PassThrough();\n    this._stream.setMaxListeners(30);\n\n    // Bind this context for listener methods.\n    this._onError = this._onError.bind(this);\n\n    if (options.filename || options.dirname) {\n      throwIf('filename or dirname', 'stream');\n      this._basename = this.filename = options.filename\n        ? path.basename(options.filename)\n        : 'winston.log';\n\n      this.dirname = options.dirname || path.dirname(options.filename);\n      this.options = options.options || { flags: 'a' };\n    } else if (options.stream) {\n      // eslint-disable-next-line no-console\n      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');\n      throwIf('stream', 'filename', 'maxsize');\n      this._dest = this._stream.pipe(this._setupStream(options.stream));\n      this.dirname = path.dirname(this._dest.path);\n      // We need to listen for drain events when write() returns false. This\n      // can make node mad at times.\n    } else {\n      throw new Error('Cannot log to file without filename or stream.');\n    }\n\n    this.maxsize = options.maxsize || null;\n    this.rotationFormat = options.rotationFormat || false;\n    this.zippedArchive = options.zippedArchive || false;\n    this.maxFiles = options.maxFiles || null;\n    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;\n    this.tailable = options.tailable || false;\n    this.lazy = options.lazy || false;\n\n    // Internal state variables representing the number of files this instance\n    // has created and the current size (in bytes) of the current logfile.\n    this._size = 0;\n    this._pendingSize = 0;\n    this._created = 0;\n    this._drain = false;\n    this._opening = false;\n    this._ending = false;\n    this._fileExist = false;\n\n    if (this.dirname) this._createLogDirIfNotExist(this.dirname);\n    if (!this.lazy) this.open();\n  }\n\n  finishIfEnding() {\n    if (this._ending) {\n      if (this._opening) {\n        this.once('open', () => {\n          this._stream.once('finish', () => this.emit('finish'));\n          setImmediate(() => this._stream.end());\n        });\n      } else {\n        this._stream.once('finish', () => this.emit('finish'));\n        setImmediate(() => this._stream.end());\n      }\n    }\n  }\n\n  /**\n   * Core logging method exposed to Winston. Metadata is optional.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback = () => { }) {\n    // Remark: (jcrugzz) What is necessary about this callback(null, true) now\n    // when thinking about 3.x? Should silent be handled in the base\n    // TransportStream _write method?\n    if (this.silent) {\n      callback();\n      return true;\n    }\n\n\n    // Output stream buffer is full and has asked us to wait for the drain event\n    if (this._drain) {\n      this._stream.once('drain', () => {\n        this._drain = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this._rotate) {\n      this._stream.once('rotate', () => {\n        this._rotate = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this.lazy) {\n      if (!this._fileExist) {\n        if (!this._opening) {\n          this.open();\n        }\n        this.once('open', () => {\n          this._fileExist = true;\n          this.log(info, callback);\n          return;\n        });\n        return;\n      }\n      if (this._needsNewFile(this._pendingSize)) {\n        this._dest.once('close', () => {\n          if (!this._opening) {\n            this.open();\n          }\n          this.once('open', () => {\n            this.log(info, callback);\n            return;\n          });\n          return;\n        });\n        return;\n      }\n    }\n\n    // Grab the raw string and append the expected EOL.\n    const output = `${info[MESSAGE]}${this.eol}`;\n    const bytes = Buffer.byteLength(output);\n\n    // After we have written to the PassThrough check to see if we need\n    // to rotate to the next file.\n    //\n    // Remark: This gets called too early and does not depict when data\n    // has been actually flushed to disk.\n    function logged() {\n      this._size += bytes;\n      this._pendingSize -= bytes;\n\n      debug('logged %s %s', this._size, output);\n      this.emit('logged', info);\n\n      // Do not attempt to rotate files while rotating\n      if (this._rotate) {\n        return;\n      }\n\n      // Do not attempt to rotate files while opening\n      if (this._opening) {\n        return;\n      }\n\n      // Check to see if we need to end the stream and create a new one.\n      if (!this._needsNewFile()) {\n        return;\n      }\n      if (this.lazy) {\n        this._endStream(() => {this.emit('fileclosed');});\n        return;\n      }\n\n      // End the current stream, ensure it flushes and create a new one.\n      // This could potentially be optimized to not run a stat call but its\n      // the safest way since we are supporting `maxFiles`.\n      this._rotate = true;\n      this._endStream(() => this._rotateFile());\n    }\n\n    // Keep track of the pending bytes being written while files are opening\n    // in order to properly rotate the PassThrough this._stream when the file\n    // eventually does open.\n    this._pendingSize += bytes;\n    if (this._opening\n      && !this.rotatedWhileOpening\n      && this._needsNewFile(this._size + this._pendingSize)) {\n      this.rotatedWhileOpening = true;\n    }\n\n    const written = this._stream.write(output, logged.bind(this));\n    if (!written) {\n      this._drain = true;\n      this._stream.once('drain', () => {\n        this._drain = false;\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n\n    debug('written', written, this._drain);\n\n    this.finishIfEnding();\n\n    return written;\n  }\n\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options - Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * TODO: Refactor me.\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = normalizeQuery(options);\n    const file = path.join(this.dirname, this.filename);\n    let buff = '';\n    let results = [];\n    let row = 0;\n\n    const stream = fs.createReadStream(file, {\n      encoding: 'utf8'\n    });\n\n    stream.on('error', err => {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      if (!callback) {\n        return;\n      }\n\n      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n    });\n\n    stream.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n      let i = 0;\n\n      for (; i < l; i++) {\n        if (!options.start || row >= options.start) {\n          add(data[i]);\n        }\n        row++;\n      }\n\n      buff = data[l];\n    });\n\n    stream.on('close', () => {\n      if (buff) {\n        add(buff, true);\n      }\n      if (options.order === 'desc') {\n        results = results.reverse();\n      }\n\n      // eslint-disable-next-line callback-return\n      if (callback) callback(null, results);\n    });\n\n    function add(buff, attempt) {\n      try {\n        const log = JSON.parse(buff);\n        if (check(log)) {\n          push(log);\n        }\n      } catch (e) {\n        if (!attempt) {\n          stream.emit('error', e);\n        }\n      }\n    }\n\n    function push(log) {\n      if (\n        options.rows &&\n        results.length >= options.rows &&\n        options.order !== 'desc'\n      ) {\n        if (stream.readable) {\n          stream.destroy();\n        }\n        return;\n      }\n\n      if (options.fields) {\n        log = options.fields.reduce((obj, key) => {\n          obj[key] = log[key];\n          return obj;\n        }, {});\n      }\n\n      if (options.order === 'desc') {\n        if (results.length >= options.rows) {\n          results.shift();\n        }\n      }\n      results.push(log);\n    }\n\n    function check(log) {\n      if (!log) {\n        return;\n      }\n\n      if (typeof log !== 'object') {\n        return;\n      }\n\n      const time = new Date(log.timestamp);\n      if (\n        (options.from && time < options.from) ||\n        (options.until && time > options.until) ||\n        (options.level && options.level !== log.level)\n      ) {\n        return;\n      }\n\n      return true;\n    }\n\n    function normalizeQuery(options) {\n      options = options || {};\n\n      // limit\n      options.rows = options.rows || options.limit || 10;\n\n      // starting row offset\n      options.start = options.start || 0;\n\n      // now\n      options.until = options.until || new Date();\n      if (typeof options.until !== 'object') {\n        options.until = new Date(options.until);\n      }\n\n      // now - 24\n      options.from = options.from || (options.until - (24 * 60 * 60 * 1000));\n      if (typeof options.from !== 'object') {\n        options.from = new Date(options.from);\n      }\n\n      // 'asc' or 'desc'\n      options.order = options.order || 'desc';\n\n      return options;\n    }\n  }\n\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   * TODO: Refactor me.\n   */\n  stream(options = {}) {\n    const file = path.join(this.dirname, this.filename);\n    const stream = new Stream();\n    const tail = {\n      file,\n      start: options.start\n    };\n\n    stream.destroy = tailFile(tail, (err, line) => {\n      if (err) {\n        return stream.emit('error', err);\n      }\n\n      try {\n        stream.emit('data', line);\n        line = JSON.parse(line);\n        stream.emit('log', line);\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    });\n\n    return stream;\n  }\n\n  /**\n   * Checks to see the filesize of.\n   * @returns {undefined}\n   */\n  open() {\n    // If we do not have a filename then we were passed a stream and\n    // don't need to keep track of size.\n    if (!this.filename) return;\n    if (this._opening) return;\n\n    this._opening = true;\n\n    // Stat the target file to get the size and create the stream.\n    this.stat((err, size) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n      debug('stat done: %s { size: %s }', this.filename, size);\n      this._size = size;\n      this._dest = this._createStream(this._stream);\n      this._opening = false;\n      this.once('open', () => {\n        if (!this._stream.emit('rotate')) {\n          this._rotate = false;\n        }\n      });\n    });\n  }\n\n  /**\n   * Stat the file and assess information in order to create the proper stream.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  stat(callback) {\n    const target = this._getFile();\n    const fullpath = path.join(this.dirname, target);\n\n    fs.stat(fullpath, (err, stat) => {\n      if (err && err.code === 'ENOENT') {\n        debug('ENOENTok', fullpath);\n        // Update internally tracked filename with the new target name.\n        this.filename = target;\n        return callback(null, 0);\n      }\n\n      if (err) {\n        debug(`err ${err.code} ${fullpath}`);\n        return callback(err);\n      }\n\n      if (!stat || this._needsNewFile(stat.size)) {\n        // If `stats.size` is greater than the `maxsize` for this\n        // instance then try again.\n        return this._incFile(() => this.stat(callback));\n      }\n\n      // Once we have figured out what the filename is, set it\n      // and return the size.\n      this.filename = target;\n      callback(null, stat.size);\n    });\n  }\n\n  /**\n   * Closes the stream associated with this instance.\n   * @param {function} cb - TODO: add param description.\n   * @returns {undefined}\n   */\n  close(cb) {\n    if (!this._stream) {\n      return;\n    }\n\n    this._stream.end(() => {\n      if (cb) {\n        cb(); // eslint-disable-line callback-return\n      }\n      this.emit('flush');\n      this.emit('closed');\n    });\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {number} size - TODO: add param description.\n   * @returns {undefined}\n   */\n  _needsNewFile(size) {\n    size = size || this._size;\n    return this.maxsize && size >= this.maxsize;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Error} err - TODO: add param description.\n   * @returns {undefined}\n   */\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _setupStream(stream) {\n    stream.on('error', this._onError);\n\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _cleanupStream(stream) {\n    stream.removeListener('error', this._onError);\n    stream.destroy();\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   */\n  _rotateFile() {\n    this._incFile(() => this.open());\n  }\n\n  /**\n   * Unpipe from the stream that has been marked as full and end it so it\n   * flushes to disk.\n   *\n   * @param {function} callback - Callback for when the current file has closed.\n   * @private\n   */\n  _endStream(callback = () => { }) {\n    if (this._dest) {\n      this._stream.unpipe(this._dest);\n      this._dest.end(() => {\n        this._cleanupStream(this._dest);\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n  }\n\n  /**\n   * Returns the WritableStream for the active file on this instance. If we\n   * should gzip the file then a zlib stream is returned.\n   *\n   * @param {ReadableStream} source PassThrough to pipe to the file when open.\n   * @returns {WritableStream} Stream that writes to disk for the active file.\n   */\n  _createStream(source) {\n    const fullpath = path.join(this.dirname, this.filename);\n\n    debug('create stream start', fullpath, this.options);\n    const dest = fs.createWriteStream(fullpath, this.options)\n      // TODO: What should we do with errors here?\n      .on('error', err => debug(err))\n      .on('close', () => debug('close', dest.path, dest.bytesWritten))\n      .on('open', () => {\n        debug('file open ok', fullpath);\n        this.emit('open', fullpath);\n        source.pipe(dest);\n\n        // If rotation occured during the open operation then we immediately\n        // start writing to a new PassThrough, begin opening the next file\n        // and cleanup the previous source and dest once the source has drained.\n        if (this.rotatedWhileOpening) {\n          this._stream = new PassThrough();\n          this._stream.setMaxListeners(30);\n          this._rotateFile();\n          this.rotatedWhileOpening = false;\n          this._cleanupStream(dest);\n          source.end();\n        }\n      });\n\n    debug('create stream ok', fullpath);\n    return dest;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  _incFile(callback) {\n    debug('_incFile', this.filename);\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const tasks = [];\n\n    if (this.zippedArchive) {\n      tasks.push(\n        function (cb) {\n          const num = this._created > 0 && !this.tailable ? this._created : '';\n          this._compressFile(\n            path.join(this.dirname, `${basename}${num}${ext}`),\n            path.join(this.dirname, `${basename}${num}${ext}.gz`),\n            cb\n          );\n        }.bind(this)\n      );\n    }\n\n    tasks.push(\n      function (cb) {\n        if (!this.tailable) {\n          this._created += 1;\n          this._checkMaxFilesIncrementing(ext, basename, cb);\n        } else {\n          this._checkMaxFilesTailable(ext, basename, cb);\n        }\n      }.bind(this)\n    );\n\n    asyncSeries(tasks, callback);\n  }\n\n  /**\n   * Gets the next filename to use for this instance in the case that log\n   * filesizes are being capped.\n   * @returns {string} - TODO: add return description.\n   * @private\n   */\n  _getFile() {\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const isRotation = this.rotationFormat\n      ? this.rotationFormat()\n      : this._created;\n\n    // Caveat emptor (indexzero): rotationFormat() was broken by design When\n    // combined with max files because the set of files to unlink is never\n    // stored.\n    return !this.tailable && this._created\n      ? `${basename}${isRotation}${ext}`\n      : `${basename}${ext}`;\n  }\n\n  /**\n   * Increment the number of files created or checked by this instance.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesIncrementing(ext, basename, callback) {\n    // Check for maxFiles option and delete file.\n    if (!this.maxFiles || this._created < this.maxFiles) {\n      return setImmediate(callback);\n    }\n\n    const oldest = this._created - this.maxFiles;\n    const isOldest = oldest !== 0 ? oldest : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    const filePath = `${basename}${isOldest}${ext}${isZipped}`;\n    const target = path.join(this.dirname, filePath);\n\n    fs.unlink(target, callback);\n  }\n\n  /**\n   * Roll files forward based on integer, up to maxFiles. e.g. if base if\n   * file.log and it becomes oversized, roll to file1.log, and allow file.log\n   * to be re-used. If file is oversized again, roll file1.log to file2.log,\n   * roll file.log to file1.log, and so on.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesTailable(ext, basename, callback) {\n    const tasks = [];\n    if (!this.maxFiles) {\n      return;\n    }\n\n    // const isZipped = this.zippedArchive ? '.gz' : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    for (let x = this.maxFiles - 1; x > 1; x--) {\n      tasks.push(function (i, cb) {\n        let fileName = `${basename}${(i - 1)}${ext}${isZipped}`;\n        const tmppath = path.join(this.dirname, fileName);\n\n        fs.exists(tmppath, exists => {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fileName = `${basename}${i}${ext}${isZipped}`;\n          fs.rename(tmppath, path.join(this.dirname, fileName), cb);\n        });\n      }.bind(this, x));\n    }\n\n    asyncSeries(tasks, () => {\n      fs.rename(\n        path.join(this.dirname, `${basename}${ext}${isZipped}`),\n        path.join(this.dirname, `${basename}1${ext}${isZipped}`),\n        callback\n      );\n    });\n  }\n\n  /**\n   * Compresses src to dest with gzip and unlinks src\n   * @param {string} src - path to source file.\n   * @param {string} dest - path to zipped destination file.\n   * @param {Function} callback - callback called after file has been compressed.\n   * @returns {undefined}\n   * @private\n   */\n  _compressFile(src, dest, callback) {\n    fs.access(src, fs.F_OK, (err) => {\n      if (err) {\n        return callback();\n      }\n      var gzip = zlib.createGzip();\n      var inp = fs.createReadStream(src);\n      var out = fs.createWriteStream(dest);\n      out.on('finish', () => {\n        fs.unlink(src, callback);\n      });\n      inp.pipe(gzip).pipe(out);\n    });\n  }\n\n  _createLogDirIfNotExist(dirPath) {\n    /* eslint-disable no-sync */\n    if (!fs.existsSync(dirPath)) {\n      fs.mkdirSync(dirPath, { recursive: true });\n    }\n    /* eslint-enable no-sync */\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLDBEQUFjO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3pDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsMEVBQW1CO0FBQ25ELGNBQWMsbUJBQU8sQ0FBQywrRUFBbUI7QUFDekMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWM7O0FBRXZDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU0sTUFBTSxRQUFRO0FBQzVEO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixjQUFjLEVBQUUsU0FBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsVUFBVSxFQUFFLFNBQVM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUk7QUFDNUQsdUNBQXVDLFNBQVMsRUFBRSxJQUFJLEVBQUUsSUFBSTtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsRUFBRSxXQUFXLEVBQUUsSUFBSTtBQUN2QyxXQUFXLFNBQVMsRUFBRSxJQUFJO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVM7QUFDN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLDBCQUEwQixTQUFTLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixTQUFTLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTO0FBQ3REO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUztBQUM3RCxtQ0FBbUMsU0FBUyxHQUFHLElBQUksRUFBRSxTQUFTO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vdHJhbnNwb3J0cy9maWxlLmpzPzFiODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSxtYXgtc3RhdGVtZW50cyAqL1xuLyoqXG4gKiBmaWxlLmpzOiBUcmFuc3BvcnQgZm9yIG91dHB1dHRpbmcgdG8gYSBsb2NhbCBsb2cgZmlsZS5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgYXN5bmNTZXJpZXMgPSByZXF1aXJlKCdhc3luYy9zZXJpZXMnKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5jb25zdCB7IE1FU1NBR0UgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5jb25zdCB7IFN0cmVhbSwgUGFzc1Rocm91Z2ggfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpO1xuY29uc3QgVHJhbnNwb3J0U3RyZWFtID0gcmVxdWlyZSgnd2luc3Rvbi10cmFuc3BvcnQnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnQGRhYmgvZGlhZ25vc3RpY3MnKSgnd2luc3RvbjpmaWxlJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCB0YWlsRmlsZSA9IHJlcXVpcmUoJy4uL3RhaWwtZmlsZScpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byBhIGxvY2FsIGxvZyBmaWxlLlxuICogQHR5cGUge0ZpbGV9XG4gKiBAZXh0ZW5kcyB7VHJhbnNwb3J0U3RyZWFtfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZpbGUgZXh0ZW5kcyBUcmFuc3BvcnRTdHJlYW0ge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBGaWxlIHRyYW5zcG9ydCBvYmplY3QgcmVzcG9uc2libGUgZm9yXG4gICAqIHBlcnNpc3RpbmcgbG9nIG1lc3NhZ2VzIGFuZCBtZXRhZGF0YSB0byBvbmUgb3IgbW9yZSBmaWxlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAvLyBFeHBvc2UgdGhlIG5hbWUgb2YgdGhpcyBUcmFuc3BvcnQgb24gdGhlIHByb3RvdHlwZS5cbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgJ2ZpbGUnO1xuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHdoaWNoIHRocm93cyBhbiBgRXJyb3JgIGluIHRoZSBldmVudCB0aGF0IGFueSBvZiB0aGVcbiAgICAvLyByZXN0IG9mIHRoZSBhcmd1bWVudHMgaXMgcHJlc2VudCBpbiBgb3B0aW9uc2AuXG4gICAgZnVuY3Rpb24gdGhyb3dJZih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgICAgIGFyZ3Muc2xpY2UoMSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgJHtuYW1lfSBhbmQgJHt0YXJnZXR9IHRvZ2V0aGVyYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHRoZSBiYXNlIHN0cmVhbSB0aGF0IGFsd2F5cyBnZXRzIHBpcGVkIHRvIHRvIGhhbmRsZSBidWZmZXJpbmcuXG4gICAgdGhpcy5fc3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgdGhpcy5fc3RyZWFtLnNldE1heExpc3RlbmVycygzMCk7XG5cbiAgICAvLyBCaW5kIHRoaXMgY29udGV4dCBmb3IgbGlzdGVuZXIgbWV0aG9kcy5cbiAgICB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuZmlsZW5hbWUgfHwgb3B0aW9ucy5kaXJuYW1lKSB7XG4gICAgICB0aHJvd0lmKCdmaWxlbmFtZSBvciBkaXJuYW1lJywgJ3N0cmVhbScpO1xuICAgICAgdGhpcy5fYmFzZW5hbWUgPSB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZVxuICAgICAgICA/IHBhdGguYmFzZW5hbWUob3B0aW9ucy5maWxlbmFtZSlcbiAgICAgICAgOiAnd2luc3Rvbi5sb2cnO1xuXG4gICAgICB0aGlzLmRpcm5hbWUgPSBvcHRpb25zLmRpcm5hbWUgfHwgcGF0aC5kaXJuYW1lKG9wdGlvbnMuZmlsZW5hbWUpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5vcHRpb25zIHx8IHsgZmxhZ3M6ICdhJyB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHJlYW0pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ29wdGlvbnMuc3RyZWFtIHdpbGwgYmUgcmVtb3ZlZCBpbiB3aW5zdG9uQDQuIFVzZSB3aW5zdG9uLnRyYW5zcG9ydHMuU3RyZWFtJyk7XG4gICAgICB0aHJvd0lmKCdzdHJlYW0nLCAnZmlsZW5hbWUnLCAnbWF4c2l6ZScpO1xuICAgICAgdGhpcy5fZGVzdCA9IHRoaXMuX3N0cmVhbS5waXBlKHRoaXMuX3NldHVwU3RyZWFtKG9wdGlvbnMuc3RyZWFtKSk7XG4gICAgICB0aGlzLmRpcm5hbWUgPSBwYXRoLmRpcm5hbWUodGhpcy5fZGVzdC5wYXRoKTtcbiAgICAgIC8vIFdlIG5lZWQgdG8gbGlzdGVuIGZvciBkcmFpbiBldmVudHMgd2hlbiB3cml0ZSgpIHJldHVybnMgZmFsc2UuIFRoaXNcbiAgICAgIC8vIGNhbiBtYWtlIG5vZGUgbWFkIGF0IHRpbWVzLlxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2cgdG8gZmlsZSB3aXRob3V0IGZpbGVuYW1lIG9yIHN0cmVhbS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLm1heHNpemUgPSBvcHRpb25zLm1heHNpemUgfHwgbnVsbDtcbiAgICB0aGlzLnJvdGF0aW9uRm9ybWF0ID0gb3B0aW9ucy5yb3RhdGlvbkZvcm1hdCB8fCBmYWxzZTtcbiAgICB0aGlzLnppcHBlZEFyY2hpdmUgPSBvcHRpb25zLnppcHBlZEFyY2hpdmUgfHwgZmFsc2U7XG4gICAgdGhpcy5tYXhGaWxlcyA9IG9wdGlvbnMubWF4RmlsZXMgfHwgbnVsbDtcbiAgICB0aGlzLmVvbCA9ICh0eXBlb2Ygb3B0aW9ucy5lb2wgPT09ICdzdHJpbmcnKSA/IG9wdGlvbnMuZW9sIDogb3MuRU9MO1xuICAgIHRoaXMudGFpbGFibGUgPSBvcHRpb25zLnRhaWxhYmxlIHx8IGZhbHNlO1xuICAgIHRoaXMubGF6eSA9IG9wdGlvbnMubGF6eSB8fCBmYWxzZTtcblxuICAgIC8vIEludGVybmFsIHN0YXRlIHZhcmlhYmxlcyByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBmaWxlcyB0aGlzIGluc3RhbmNlXG4gICAgLy8gaGFzIGNyZWF0ZWQgYW5kIHRoZSBjdXJyZW50IHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgY3VycmVudCBsb2dmaWxlLlxuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHRoaXMuX3BlbmRpbmdTaXplID0gMDtcbiAgICB0aGlzLl9jcmVhdGVkID0gMDtcbiAgICB0aGlzLl9kcmFpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wZW5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9maWxlRXhpc3QgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmRpcm5hbWUpIHRoaXMuX2NyZWF0ZUxvZ0RpcklmTm90RXhpc3QodGhpcy5kaXJuYW1lKTtcbiAgICBpZiAoIXRoaXMubGF6eSkgdGhpcy5vcGVuKCk7XG4gIH1cblxuICBmaW5pc2hJZkVuZGluZygpIHtcbiAgICBpZiAodGhpcy5fZW5kaW5nKSB7XG4gICAgICBpZiAodGhpcy5fb3BlbmluZykge1xuICAgICAgICB0aGlzLm9uY2UoJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHRoaXMuZW1pdCgnZmluaXNoJykpO1xuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zdHJlYW0uZW5kKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5vbmNlKCdmaW5pc2gnLCAoKSA9PiB0aGlzLmVtaXQoJ2ZpbmlzaCcpKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3N0cmVhbS5lbmQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvcmUgbG9nZ2luZyBtZXRob2QgZXhwb3NlZCB0byBXaW5zdG9uLiBNZXRhZGF0YSBpcyBvcHRpb25hbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgbG9nKGluZm8sIGNhbGxiYWNrID0gKCkgPT4geyB9KSB7XG4gICAgLy8gUmVtYXJrOiAoamNydWd6eikgV2hhdCBpcyBuZWNlc3NhcnkgYWJvdXQgdGhpcyBjYWxsYmFjayhudWxsLCB0cnVlKSBub3dcbiAgICAvLyB3aGVuIHRoaW5raW5nIGFib3V0IDMueD8gU2hvdWxkIHNpbGVudCBiZSBoYW5kbGVkIGluIHRoZSBiYXNlXG4gICAgLy8gVHJhbnNwb3J0U3RyZWFtIF93cml0ZSBtZXRob2Q/XG4gICAgaWYgKHRoaXMuc2lsZW50KSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbiAgICAvLyBPdXRwdXQgc3RyZWFtIGJ1ZmZlciBpcyBmdWxsIGFuZCBoYXMgYXNrZWQgdXMgdG8gd2FpdCBmb3IgdGhlIGRyYWluIGV2ZW50XG4gICAgaWYgKHRoaXMuX2RyYWluKSB7XG4gICAgICB0aGlzLl9zdHJlYW0ub25jZSgnZHJhaW4nLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RyYWluID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nKGluZm8sIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcm90YXRlKSB7XG4gICAgICB0aGlzLl9zdHJlYW0ub25jZSgncm90YXRlJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9yb3RhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgIGlmICghdGhpcy5fZmlsZUV4aXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5fb3BlbmluZykge1xuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9maWxlRXhpc3QgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9nKGluZm8sIGNhbGxiYWNrKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbmVlZHNOZXdGaWxlKHRoaXMuX3BlbmRpbmdTaXplKSkge1xuICAgICAgICB0aGlzLl9kZXN0Lm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5fb3BlbmluZykge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKGluZm8sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR3JhYiB0aGUgcmF3IHN0cmluZyBhbmQgYXBwZW5kIHRoZSBleHBlY3RlZCBFT0wuXG4gICAgY29uc3Qgb3V0cHV0ID0gYCR7aW5mb1tNRVNTQUdFXX0ke3RoaXMuZW9sfWA7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuYnl0ZUxlbmd0aChvdXRwdXQpO1xuXG4gICAgLy8gQWZ0ZXIgd2UgaGF2ZSB3cml0dGVuIHRvIHRoZSBQYXNzVGhyb3VnaCBjaGVjayB0byBzZWUgaWYgd2UgbmVlZFxuICAgIC8vIHRvIHJvdGF0ZSB0byB0aGUgbmV4dCBmaWxlLlxuICAgIC8vXG4gICAgLy8gUmVtYXJrOiBUaGlzIGdldHMgY2FsbGVkIHRvbyBlYXJseSBhbmQgZG9lcyBub3QgZGVwaWN0IHdoZW4gZGF0YVxuICAgIC8vIGhhcyBiZWVuIGFjdHVhbGx5IGZsdXNoZWQgdG8gZGlzay5cbiAgICBmdW5jdGlvbiBsb2dnZWQoKSB7XG4gICAgICB0aGlzLl9zaXplICs9IGJ5dGVzO1xuICAgICAgdGhpcy5fcGVuZGluZ1NpemUgLT0gYnl0ZXM7XG5cbiAgICAgIGRlYnVnKCdsb2dnZWQgJXMgJXMnLCB0aGlzLl9zaXplLCBvdXRwdXQpO1xuICAgICAgdGhpcy5lbWl0KCdsb2dnZWQnLCBpbmZvKTtcblxuICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcm90YXRlIGZpbGVzIHdoaWxlIHJvdGF0aW5nXG4gICAgICBpZiAodGhpcy5fcm90YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcm90YXRlIGZpbGVzIHdoaWxlIG9wZW5pbmdcbiAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gZW5kIHRoZSBzdHJlYW0gYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICBpZiAoIXRoaXMuX25lZWRzTmV3RmlsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgICAgdGhpcy5fZW5kU3RyZWFtKCgpID0+IHt0aGlzLmVtaXQoJ2ZpbGVjbG9zZWQnKTt9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBFbmQgdGhlIGN1cnJlbnQgc3RyZWFtLCBlbnN1cmUgaXQgZmx1c2hlcyBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgIC8vIFRoaXMgY291bGQgcG90ZW50aWFsbHkgYmUgb3B0aW1pemVkIHRvIG5vdCBydW4gYSBzdGF0IGNhbGwgYnV0IGl0c1xuICAgICAgLy8gdGhlIHNhZmVzdCB3YXkgc2luY2Ugd2UgYXJlIHN1cHBvcnRpbmcgYG1heEZpbGVzYC5cbiAgICAgIHRoaXMuX3JvdGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLl9lbmRTdHJlYW0oKCkgPT4gdGhpcy5fcm90YXRlRmlsZSgpKTtcbiAgICB9XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwZW5kaW5nIGJ5dGVzIGJlaW5nIHdyaXR0ZW4gd2hpbGUgZmlsZXMgYXJlIG9wZW5pbmdcbiAgICAvLyBpbiBvcmRlciB0byBwcm9wZXJseSByb3RhdGUgdGhlIFBhc3NUaHJvdWdoIHRoaXMuX3N0cmVhbSB3aGVuIHRoZSBmaWxlXG4gICAgLy8gZXZlbnR1YWxseSBkb2VzIG9wZW4uXG4gICAgdGhpcy5fcGVuZGluZ1NpemUgKz0gYnl0ZXM7XG4gICAgaWYgKHRoaXMuX29wZW5pbmdcbiAgICAgICYmICF0aGlzLnJvdGF0ZWRXaGlsZU9wZW5pbmdcbiAgICAgICYmIHRoaXMuX25lZWRzTmV3RmlsZSh0aGlzLl9zaXplICsgdGhpcy5fcGVuZGluZ1NpemUpKSB7XG4gICAgICB0aGlzLnJvdGF0ZWRXaGlsZU9wZW5pbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHdyaXR0ZW4gPSB0aGlzLl9zdHJlYW0ud3JpdGUob3V0cHV0LCBsb2dnZWQuYmluZCh0aGlzKSk7XG4gICAgaWYgKCF3cml0dGVuKSB7XG4gICAgICB0aGlzLl9kcmFpbiA9IHRydWU7XG4gICAgICB0aGlzLl9zdHJlYW0ub25jZSgnZHJhaW4nLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RyYWluID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICB9XG5cbiAgICBkZWJ1Zygnd3JpdHRlbicsIHdyaXR0ZW4sIHRoaXMuX2RyYWluKTtcblxuICAgIHRoaXMuZmluaXNoSWZFbmRpbmcoKTtcblxuICAgIHJldHVybiB3cml0dGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IHRoZSB0cmFuc3BvcnQuIE9wdGlvbnMgb2JqZWN0IGlzIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIExvZ2dseS1saWtlIHF1ZXJ5IG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICogVE9ETzogUmVmYWN0b3IgbWUuXG4gICAqL1xuICBxdWVyeShvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBub3JtYWxpemVRdWVyeShvcHRpb25zKTtcbiAgICBjb25zdCBmaWxlID0gcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgdGhpcy5maWxlbmFtZSk7XG4gICAgbGV0IGJ1ZmYgPSAnJztcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGxldCByb3cgPSAwO1xuXG4gICAgY29uc3Qgc3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlLCB7XG4gICAgICBlbmNvZGluZzogJ3V0ZjgnXG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgIGlmIChzdHJlYW0ucmVhZGFibGUpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyLmNvZGUgIT09ICdFTk9FTlQnID8gY2FsbGJhY2soZXJyKSA6IGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgIH0pO1xuXG4gICAgc3RyZWFtLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICBkYXRhID0gKGJ1ZmYgKyBkYXRhKS5zcGxpdCgvXFxuKy8pO1xuICAgICAgY29uc3QgbCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0YXJ0IHx8IHJvdyA+PSBvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgYWRkKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuXG4gICAgICBidWZmID0gZGF0YVtsXTtcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBpZiAoYnVmZikge1xuICAgICAgICBhZGQoYnVmZiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vcmRlciA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZChidWZmLCBhdHRlbXB0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsb2cgPSBKU09OLnBhcnNlKGJ1ZmYpO1xuICAgICAgICBpZiAoY2hlY2sobG9nKSkge1xuICAgICAgICAgIHB1c2gobG9nKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIWF0dGVtcHQpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2gobG9nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMucm93cyAmJlxuICAgICAgICByZXN1bHRzLmxlbmd0aCA+PSBvcHRpb25zLnJvd3MgJiZcbiAgICAgICAgb3B0aW9ucy5vcmRlciAhPT0gJ2Rlc2MnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHN0cmVhbS5yZWFkYWJsZSkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICAgICAgbG9nID0gb3B0aW9ucy5maWVsZHMucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICAgIG9ialtrZXldID0gbG9nW2tleV07XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vcmRlciA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+PSBvcHRpb25zLnJvd3MpIHtcbiAgICAgICAgICByZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdHMucHVzaChsb2cpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrKGxvZykge1xuICAgICAgaWYgKCFsb2cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxvZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aW1lID0gbmV3IERhdGUobG9nLnRpbWVzdGFtcCk7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRpb25zLmZyb20gJiYgdGltZSA8IG9wdGlvbnMuZnJvbSkgfHxcbiAgICAgICAgKG9wdGlvbnMudW50aWwgJiYgdGltZSA+IG9wdGlvbnMudW50aWwpIHx8XG4gICAgICAgIChvcHRpb25zLmxldmVsICYmIG9wdGlvbnMubGV2ZWwgIT09IGxvZy5sZXZlbClcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVF1ZXJ5KG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBsaW1pdFxuICAgICAgb3B0aW9ucy5yb3dzID0gb3B0aW9ucy5yb3dzIHx8IG9wdGlvbnMubGltaXQgfHwgMTA7XG5cbiAgICAgIC8vIHN0YXJ0aW5nIHJvdyBvZmZzZXRcbiAgICAgIG9wdGlvbnMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IDA7XG5cbiAgICAgIC8vIG5vd1xuICAgICAgb3B0aW9ucy51bnRpbCA9IG9wdGlvbnMudW50aWwgfHwgbmV3IERhdGUoKTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy51bnRpbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucy51bnRpbCA9IG5ldyBEYXRlKG9wdGlvbnMudW50aWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBub3cgLSAyNFxuICAgICAgb3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tIHx8IChvcHRpb25zLnVudGlsIC0gKDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mcm9tICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zLmZyb20gPSBuZXcgRGF0ZShvcHRpb25zLmZyb20pO1xuICAgICAgfVxuXG4gICAgICAvLyAnYXNjJyBvciAnZGVzYydcbiAgICAgIG9wdGlvbnMub3JkZXIgPSBvcHRpb25zLm9yZGVyIHx8ICdkZXNjJztcblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2cgc3RyZWFtIGZvciB0aGlzIHRyYW5zcG9ydC4gT3B0aW9ucyBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU3RyZWFtIG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtTdHJlYW19IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICogVE9ETzogUmVmYWN0b3IgbWUuXG4gICAqL1xuICBzdHJlYW0ob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZmlsZSA9IHBhdGguam9pbih0aGlzLmRpcm5hbWUsIHRoaXMuZmlsZW5hbWUpO1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0oKTtcbiAgICBjb25zdCB0YWlsID0ge1xuICAgICAgZmlsZSxcbiAgICAgIHN0YXJ0OiBvcHRpb25zLnN0YXJ0XG4gICAgfTtcblxuICAgIHN0cmVhbS5kZXN0cm95ID0gdGFpbEZpbGUodGFpbCwgKGVyciwgbGluZSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBsaW5lKTtcbiAgICAgICAgbGluZSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdsb2cnLCBsaW5lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgdGhlIGZpbGVzaXplIG9mLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgb3BlbigpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGZpbGVuYW1lIHRoZW4gd2Ugd2VyZSBwYXNzZWQgYSBzdHJlYW0gYW5kXG4gICAgLy8gZG9uJ3QgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHNpemUuXG4gICAgaWYgKCF0aGlzLmZpbGVuYW1lKSByZXR1cm47XG4gICAgaWYgKHRoaXMuX29wZW5pbmcpIHJldHVybjtcblxuICAgIHRoaXMuX29wZW5pbmcgPSB0cnVlO1xuXG4gICAgLy8gU3RhdCB0aGUgdGFyZ2V0IGZpbGUgdG8gZ2V0IHRoZSBzaXplIGFuZCBjcmVhdGUgdGhlIHN0cmVhbS5cbiAgICB0aGlzLnN0YXQoKGVyciwgc2l6ZSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgICBkZWJ1Zygnc3RhdCBkb25lOiAlcyB7IHNpemU6ICVzIH0nLCB0aGlzLmZpbGVuYW1lLCBzaXplKTtcbiAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgICAgdGhpcy5fZGVzdCA9IHRoaXMuX2NyZWF0ZVN0cmVhbSh0aGlzLl9zdHJlYW0pO1xuICAgICAgdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3N0cmVhbS5lbWl0KCdyb3RhdGUnKSkge1xuICAgICAgICAgIHRoaXMuX3JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0IHRoZSBmaWxlIGFuZCBhc3Nlc3MgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBwcm9wZXIgc3RyZWFtLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHN0YXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRGaWxlKCk7XG4gICAgY29uc3QgZnVsbHBhdGggPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCB0YXJnZXQpO1xuXG4gICAgZnMuc3RhdChmdWxscGF0aCwgKGVyciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgZGVidWcoJ0VOT0VOVMKgb2snLCBmdWxscGF0aCk7XG4gICAgICAgIC8vIFVwZGF0ZSBpbnRlcm5hbGx5IHRyYWNrZWQgZmlsZW5hbWUgd2l0aCB0aGUgbmV3IHRhcmdldCBuYW1lLlxuICAgICAgICB0aGlzLmZpbGVuYW1lID0gdGFyZ2V0O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVidWcoYGVyciAke2Vyci5jb2RlfSAke2Z1bGxwYXRofWApO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdGF0IHx8IHRoaXMuX25lZWRzTmV3RmlsZShzdGF0LnNpemUpKSB7XG4gICAgICAgIC8vIElmIGBzdGF0cy5zaXplYCBpcyBncmVhdGVyIHRoYW4gdGhlIGBtYXhzaXplYCBmb3IgdGhpc1xuICAgICAgICAvLyBpbnN0YW5jZSB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luY0ZpbGUoKCkgPT4gdGhpcy5zdGF0KGNhbGxiYWNrKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9uY2Ugd2UgaGF2ZSBmaWd1cmVkIG91dCB3aGF0IHRoZSBmaWxlbmFtZSBpcywgc2V0IGl0XG4gICAgICAvLyBhbmQgcmV0dXJuIHRoZSBzaXplLlxuICAgICAgdGhpcy5maWxlbmFtZSA9IHRhcmdldDtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXQuc2l6ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzdHJlYW0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuX3N0cmVhbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3N0cmVhbS5lbmQoKCkgPT4ge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgX25lZWRzTmV3RmlsZShzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5fc2l6ZTtcbiAgICByZXR1cm4gdGhpcy5tYXhzaXplICYmIHNpemUgPj0gdGhpcy5tYXhzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIF9vbkVycm9yKGVycikge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgX3NldHVwU3RyZWFtKHN0cmVhbSkge1xuICAgIHN0cmVhbS5vbignZXJyb3InLCB0aGlzLl9vbkVycm9yKTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBfY2xlYW51cFN0cmVhbShzdHJlYW0pIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25FcnJvcik7XG4gICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb24uXG4gICAqL1xuICBfcm90YXRlRmlsZSgpIHtcbiAgICB0aGlzLl9pbmNGaWxlKCgpID0+IHRoaXMub3BlbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBpcGUgZnJvbSB0aGUgc3RyZWFtIHRoYXQgaGFzIGJlZW4gbWFya2VkIGFzIGZ1bGwgYW5kIGVuZCBpdCBzbyBpdFxuICAgKiBmbHVzaGVzIHRvIGRpc2suXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIGN1cnJlbnQgZmlsZSBoYXMgY2xvc2VkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2VuZFN0cmVhbShjYWxsYmFjayA9ICgpID0+IHsgfSkge1xuICAgIGlmICh0aGlzLl9kZXN0KSB7XG4gICAgICB0aGlzLl9zdHJlYW0udW5waXBlKHRoaXMuX2Rlc3QpO1xuICAgICAgdGhpcy5fZGVzdC5lbmQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9jbGVhbnVwU3RyZWFtKHRoaXMuX2Rlc3QpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFdyaXRhYmxlU3RyZWFtIGZvciB0aGUgYWN0aXZlIGZpbGUgb24gdGhpcyBpbnN0YW5jZS4gSWYgd2VcbiAgICogc2hvdWxkIGd6aXAgdGhlIGZpbGUgdGhlbiBhIHpsaWIgc3RyZWFtIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtfSBzb3VyY2Ug4oCTUGFzc1Rocm91Z2ggdG8gcGlwZSB0byB0aGUgZmlsZSB3aGVuIG9wZW4uXG4gICAqIEByZXR1cm5zIHtXcml0YWJsZVN0cmVhbX0gU3RyZWFtIHRoYXQgd3JpdGVzIHRvIGRpc2sgZm9yIHRoZSBhY3RpdmUgZmlsZS5cbiAgICovXG4gIF9jcmVhdGVTdHJlYW0oc291cmNlKSB7XG4gICAgY29uc3QgZnVsbHBhdGggPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCB0aGlzLmZpbGVuYW1lKTtcblxuICAgIGRlYnVnKCdjcmVhdGUgc3RyZWFtIHN0YXJ0JywgZnVsbHBhdGgsIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgZGVzdCA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZ1bGxwYXRoLCB0aGlzLm9wdGlvbnMpXG4gICAgICAvLyBUT0RPOiBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIGVycm9ycyBoZXJlP1xuICAgICAgLm9uKCdlcnJvcicsIGVyciA9PiBkZWJ1ZyhlcnIpKVxuICAgICAgLm9uKCdjbG9zZScsICgpID0+IGRlYnVnKCdjbG9zZScsIGRlc3QucGF0aCwgZGVzdC5ieXRlc1dyaXR0ZW4pKVxuICAgICAgLm9uKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICBkZWJ1ZygnZmlsZSBvcGVuIG9rJywgZnVsbHBhdGgpO1xuICAgICAgICB0aGlzLmVtaXQoJ29wZW4nLCBmdWxscGF0aCk7XG4gICAgICAgIHNvdXJjZS5waXBlKGRlc3QpO1xuXG4gICAgICAgIC8vIElmIHJvdGF0aW9uIG9jY3VyZWQgZHVyaW5nIHRoZSBvcGVuIG9wZXJhdGlvbiB0aGVuIHdlIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIHN0YXJ0IHdyaXRpbmcgdG8gYSBuZXcgUGFzc1Rocm91Z2gsIGJlZ2luIG9wZW5pbmcgdGhlIG5leHQgZmlsZVxuICAgICAgICAvLyBhbmQgY2xlYW51cCB0aGUgcHJldmlvdXMgc291cmNlIGFuZCBkZXN0IG9uY2UgdGhlIHNvdXJjZSBoYXMgZHJhaW5lZC5cbiAgICAgICAgaWYgKHRoaXMucm90YXRlZFdoaWxlT3BlbmluZykge1xuICAgICAgICAgIHRoaXMuX3N0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgICAgICAgIHRoaXMuX3N0cmVhbS5zZXRNYXhMaXN0ZW5lcnMoMzApO1xuICAgICAgICAgIHRoaXMuX3JvdGF0ZUZpbGUoKTtcbiAgICAgICAgICB0aGlzLnJvdGF0ZWRXaGlsZU9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9jbGVhbnVwU3RyZWFtKGRlc3QpO1xuICAgICAgICAgIHNvdXJjZS5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBkZWJ1ZygnY3JlYXRlIHN0cmVhbSBvaycsIGZ1bGxwYXRoKTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgbWV0aG9kIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIF9pbmNGaWxlKGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ19pbmNGaWxlJywgdGhpcy5maWxlbmFtZSk7XG4gICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKHRoaXMuX2Jhc2VuYW1lKTtcbiAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUodGhpcy5fYmFzZW5hbWUsIGV4dCk7XG4gICAgY29uc3QgdGFza3MgPSBbXTtcblxuICAgIGlmICh0aGlzLnppcHBlZEFyY2hpdmUpIHtcbiAgICAgIHRhc2tzLnB1c2goXG4gICAgICAgIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIGNvbnN0IG51bSA9IHRoaXMuX2NyZWF0ZWQgPiAwICYmICF0aGlzLnRhaWxhYmxlID8gdGhpcy5fY3JlYXRlZCA6ICcnO1xuICAgICAgICAgIHRoaXMuX2NvbXByZXNzRmlsZShcbiAgICAgICAgICAgIHBhdGguam9pbih0aGlzLmRpcm5hbWUsIGAke2Jhc2VuYW1lfSR7bnVtfSR7ZXh0fWApLFxuICAgICAgICAgICAgcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgYCR7YmFzZW5hbWV9JHtudW19JHtleHR9Lmd6YCksXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0YXNrcy5wdXNoKFxuICAgICAgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIGlmICghdGhpcy50YWlsYWJsZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZWQgKz0gMTtcbiAgICAgICAgICB0aGlzLl9jaGVja01heEZpbGVzSW5jcmVtZW50aW5nKGV4dCwgYmFzZW5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9jaGVja01heEZpbGVzVGFpbGFibGUoZXh0LCBiYXNlbmFtZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcylcbiAgICApO1xuXG4gICAgYXN5bmNTZXJpZXModGFza3MsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IGZpbGVuYW1lIHRvIHVzZSBmb3IgdGhpcyBpbnN0YW5jZSBpbiB0aGUgY2FzZSB0aGF0IGxvZ1xuICAgKiBmaWxlc2l6ZXMgYXJlIGJlaW5nIGNhcHBlZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEZpbGUoKSB7XG4gICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKHRoaXMuX2Jhc2VuYW1lKTtcbiAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUodGhpcy5fYmFzZW5hbWUsIGV4dCk7XG4gICAgY29uc3QgaXNSb3RhdGlvbiA9IHRoaXMucm90YXRpb25Gb3JtYXRcbiAgICAgID8gdGhpcy5yb3RhdGlvbkZvcm1hdCgpXG4gICAgICA6IHRoaXMuX2NyZWF0ZWQ7XG5cbiAgICAvLyBDYXZlYXQgZW1wdG9yIChpbmRleHplcm8pOiByb3RhdGlvbkZvcm1hdCgpIHdhcyBicm9rZW4gYnkgZGVzaWduIFdoZW5cbiAgICAvLyBjb21iaW5lZCB3aXRoIG1heCBmaWxlcyBiZWNhdXNlIHRoZSBzZXQgb2YgZmlsZXMgdG8gdW5saW5rIGlzIG5ldmVyXG4gICAgLy8gc3RvcmVkLlxuICAgIHJldHVybiAhdGhpcy50YWlsYWJsZSAmJiB0aGlzLl9jcmVhdGVkXG4gICAgICA/IGAke2Jhc2VuYW1lfSR7aXNSb3RhdGlvbn0ke2V4dH1gXG4gICAgICA6IGAke2Jhc2VuYW1lfSR7ZXh0fWA7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgZmlsZXMgY3JlYXRlZCBvciBjaGVja2VkIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGV4dCAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gYmFzZW5hbWUgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrTWF4RmlsZXNJbmNyZW1lbnRpbmcoZXh0LCBiYXNlbmFtZSwgY2FsbGJhY2spIHtcbiAgICAvLyBDaGVjayBmb3IgbWF4RmlsZXMgb3B0aW9uIGFuZCBkZWxldGUgZmlsZS5cbiAgICBpZiAoIXRoaXMubWF4RmlsZXMgfHwgdGhpcy5fY3JlYXRlZCA8IHRoaXMubWF4RmlsZXMpIHtcbiAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZGVzdCA9IHRoaXMuX2NyZWF0ZWQgLSB0aGlzLm1heEZpbGVzO1xuICAgIGNvbnN0IGlzT2xkZXN0ID0gb2xkZXN0ICE9PSAwID8gb2xkZXN0IDogJyc7XG4gICAgY29uc3QgaXNaaXBwZWQgPSB0aGlzLnppcHBlZEFyY2hpdmUgPyAnLmd6JyA6ICcnO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7YmFzZW5hbWV9JHtpc09sZGVzdH0ke2V4dH0ke2lzWmlwcGVkfWA7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgZmlsZVBhdGgpO1xuXG4gICAgZnMudW5saW5rKHRhcmdldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvbGwgZmlsZXMgZm9yd2FyZCBiYXNlZCBvbiBpbnRlZ2VyLCB1cCB0byBtYXhGaWxlcy4gZS5nLiBpZiBiYXNlIGlmXG4gICAqIGZpbGUubG9nIGFuZCBpdCBiZWNvbWVzIG92ZXJzaXplZCwgcm9sbCB0byBmaWxlMS5sb2csIGFuZCBhbGxvdyBmaWxlLmxvZ1xuICAgKiB0byBiZSByZS11c2VkLiBJZiBmaWxlIGlzIG92ZXJzaXplZCBhZ2Fpbiwgcm9sbCBmaWxlMS5sb2cgdG8gZmlsZTIubG9nLFxuICAgKiByb2xsIGZpbGUubG9nIHRvIGZpbGUxLmxvZywgYW5kIHNvIG9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBleHQgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGJhc2VuYW1lIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja01heEZpbGVzVGFpbGFibGUoZXh0LCBiYXNlbmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgIGlmICghdGhpcy5tYXhGaWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNvbnN0IGlzWmlwcGVkID0gdGhpcy56aXBwZWRBcmNoaXZlID8gJy5neicgOiAnJztcbiAgICBjb25zdCBpc1ppcHBlZCA9IHRoaXMuemlwcGVkQXJjaGl2ZSA/ICcuZ3onIDogJyc7XG4gICAgZm9yIChsZXQgeCA9IHRoaXMubWF4RmlsZXMgLSAxOyB4ID4gMTsgeC0tKSB7XG4gICAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChpLCBjYikge1xuICAgICAgICBsZXQgZmlsZU5hbWUgPSBgJHtiYXNlbmFtZX0keyhpIC0gMSl9JHtleHR9JHtpc1ppcHBlZH1gO1xuICAgICAgICBjb25zdCB0bXBwYXRoID0gcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgZmlsZU5hbWUpO1xuXG4gICAgICAgIGZzLmV4aXN0cyh0bXBwYXRoLCBleGlzdHMgPT4ge1xuICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsZU5hbWUgPSBgJHtiYXNlbmFtZX0ke2l9JHtleHR9JHtpc1ppcHBlZH1gO1xuICAgICAgICAgIGZzLnJlbmFtZSh0bXBwYXRoLCBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCBmaWxlTmFtZSksIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9LmJpbmQodGhpcywgeCkpO1xuICAgIH1cblxuICAgIGFzeW5jU2VyaWVzKHRhc2tzLCAoKSA9PiB7XG4gICAgICBmcy5yZW5hbWUoXG4gICAgICAgIHBhdGguam9pbih0aGlzLmRpcm5hbWUsIGAke2Jhc2VuYW1lfSR7ZXh0fSR7aXNaaXBwZWR9YCksXG4gICAgICAgIHBhdGguam9pbih0aGlzLmRpcm5hbWUsIGAke2Jhc2VuYW1lfTEke2V4dH0ke2lzWmlwcGVkfWApLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzc2VzIHNyYyB0byBkZXN0IHdpdGggZ3ppcCBhbmQgdW5saW5rcyBzcmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyAtIHBhdGggdG8gc291cmNlIGZpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0IC0gcGF0aCB0byB6aXBwZWQgZGVzdGluYXRpb24gZmlsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsYmFjayBjYWxsZWQgYWZ0ZXIgZmlsZSBoYXMgYmVlbiBjb21wcmVzc2VkLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzRmlsZShzcmMsIGRlc3QsIGNhbGxiYWNrKSB7XG4gICAgZnMuYWNjZXNzKHNyYywgZnMuRl9PSywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHZhciBnemlwID0gemxpYi5jcmVhdGVHemlwKCk7XG4gICAgICB2YXIgaW5wID0gZnMuY3JlYXRlUmVhZFN0cmVhbShzcmMpO1xuICAgICAgdmFyIG91dCA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRlc3QpO1xuICAgICAgb3V0Lm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIGZzLnVubGluayhzcmMsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgaW5wLnBpcGUoZ3ppcCkucGlwZShvdXQpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUxvZ0RpcklmTm90RXhpc3QoZGlyUGF0aCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXN5bmMgKi9cbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyUGF0aCkpIHtcbiAgICAgIGZzLm1rZGlyU3luYyhkaXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1zeW5jICovXG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/http.js":
/*!*************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/http.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * http.js: Transport for outputting to a json-rpcserver.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst { Stream } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\nconst { configure } = __webpack_require__(/*! safe-stable-stringify */ \"(rsc)/./node_modules/safe-stable-stringify/index.js\");\n\n/**\n * Transport for outputting to a json-rpc server.\n * @type {Stream}\n * @extends {TransportStream}\n */\nmodule.exports = class Http extends TransportStream {\n  /**\n   * Constructor function for the Http transport object responsible for\n   * persisting log messages and metadata to a terminal or TTY.\n   * @param {!Object} [options={}] - Options for this instance.\n   */\n  // eslint-disable-next-line max-statements\n  constructor(options = {}) {\n    super(options);\n\n    this.options = options;\n    this.name = options.name || 'http';\n    this.ssl = !!options.ssl;\n    this.host = options.host || 'localhost';\n    this.port = options.port;\n    this.auth = options.auth;\n    this.path = options.path || '';\n    this.maximumDepth = options.maximumDepth;\n    this.agent = options.agent;\n    this.headers = options.headers || {};\n    this.headers['content-type'] = 'application/json';\n    this.batch = options.batch || false;\n    this.batchInterval = options.batchInterval || 5000;\n    this.batchCount = options.batchCount || 10;\n    this.batchOptions = [];\n    this.batchTimeoutID = -1;\n    this.batchCallback = {};\n\n    if (!this.port) {\n      this.port = this.ssl ? 443 : 80;\n    }\n  }\n\n  /**\n   * Core logging method exposed to Winston.\n   * @param {Object} info - TODO: add param description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback) {\n    this._request(info, null, null, (err, res) => {\n      if (res && res.statusCode !== 200) {\n        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);\n      }\n\n      if (err) {\n        this.emit('warn', err);\n      } else {\n        this.emit('logged', info);\n      }\n    });\n\n    // Remark: (jcrugzz) Fire and forget here so requests dont cause buffering\n    // and block more requests from happening?\n    if (callback) {\n      setImmediate(callback);\n    }\n  }\n\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options -  Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * @returns {undefined}\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = {\n      method: 'query',\n      params: this.normalizeQuery(options)\n    };\n\n    const auth = options.params.auth || null;\n    delete options.params.auth;\n\n    const path = options.params.path || null;\n    delete options.params.path;\n\n    this._request(options, auth, path, (err, res, body) => {\n      if (res && res.statusCode !== 200) {\n        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);\n      }\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (typeof body === 'string') {\n        try {\n          body = JSON.parse(body);\n        } catch (e) {\n          return callback(e);\n        }\n      }\n\n      callback(null, body);\n    });\n  }\n\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description\n   */\n  stream(options = {}) {\n    const stream = new Stream();\n    options = {\n      method: 'stream',\n      params: options\n    };\n\n    const path = options.params.path || null;\n    delete options.params.path;\n\n    const auth = options.params.auth || null;\n    delete options.params.auth;\n\n    let buff = '';\n    const req = this._request(options, auth, path);\n\n    stream.destroy = () => req.destroy();\n    req.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n\n      let i = 0;\n      for (; i < l; i++) {\n        try {\n          stream.emit('log', JSON.parse(data[i]));\n        } catch (e) {\n          stream.emit('error', e);\n        }\n      }\n\n      buff = data[l];\n    });\n    req.on('error', err => stream.emit('error', err));\n\n    return stream;\n  }\n\n  /**\n   * Make a request to a winstond server or any http server which can\n   * handle json-rpc.\n   * @param {function} options - Options to sent the request.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   * @param {function} callback - Continuation to respond to when complete.\n   */\n  _request(options, auth, path, callback) {\n    options = options || {};\n\n    auth = auth || this.auth;\n    path = path || this.path || '';\n\n    if (this.batch) {\n      this._doBatch(options, callback, auth, path);\n    } else {\n      this._doRequest(options, callback, auth, path);\n    }\n  }\n\n  /**\n   * Send or memorize the options according to batch configuration\n   * @param {function} options - Options to sent the request.\n   * @param {function} callback - Continuation to respond to when complete.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   */\n  _doBatch(options, callback, auth, path) {\n    this.batchOptions.push(options);\n    if (this.batchOptions.length === 1) {\n      // First message stored, it's time to start the timeout!\n      const me = this;\n      this.batchCallback = callback;\n      this.batchTimeoutID = setTimeout(function () {\n        // timeout is reached, send all messages to endpoint\n        me.batchTimeoutID = -1;\n        me._doBatchRequest(me.batchCallback, auth, path);\n      }, this.batchInterval);\n    }\n    if (this.batchOptions.length === this.batchCount) {\n      // max batch count is reached, send all messages to endpoint\n      this._doBatchRequest(this.batchCallback, auth, path);\n    }\n  }\n\n  /**\n   * Initiate a request with the memorized batch options, stop the batch timeout\n   * @param {function} callback - Continuation to respond to when complete.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   */\n  _doBatchRequest(callback, auth, path) {\n    if (this.batchTimeoutID > 0) {\n      clearTimeout(this.batchTimeoutID);\n      this.batchTimeoutID = -1;\n    }\n    const batchOptionsCopy = this.batchOptions.slice();\n    this.batchOptions = [];\n    this._doRequest(batchOptionsCopy, callback, auth, path);\n  }\n\n  /**\n   * Make a request to a winstond server or any http server which can\n   * handle json-rpc.\n   * @param {function} options - Options to sent the request.\n   * @param {function} callback - Continuation to respond to when complete.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   */\n  _doRequest(options, callback, auth, path) {\n    // Prepare options for outgoing HTTP request\n    const headers = Object.assign({}, this.headers);\n    if (auth && auth.bearer) {\n      headers.Authorization = `Bearer ${auth.bearer}`;\n    }\n    const req = (this.ssl ? https : http).request({\n      ...this.options,\n      method: 'POST',\n      host: this.host,\n      port: this.port,\n      path: `/${path.replace(/^\\//, '')}`,\n      headers: headers,\n      auth: (auth && auth.username && auth.password) ? (`${auth.username}:${auth.password}`) : '',\n      agent: this.agent\n    });\n\n    req.on('error', callback);\n    req.on('response', res => (\n      res.on('end', () => callback(null, res)).resume()\n    ));\n    const jsonStringify = configure({\n      ...(this.maximumDepth && { maximumDepth: this.maximumDepth })\n    });\n    req.end(Buffer.from(jsonStringify(options, this.options.replacer), 'utf8'));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2h0dHAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsMEVBQW1CO0FBQ25ELFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0ZBQXVCOztBQUVyRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLFdBQVc7QUFDakM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0EsMkRBQTJELGNBQWMsR0FBRyxjQUFjO0FBQzFGO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQztBQUNsRSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2h0dHAuanM/MWE3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHAuanM6IFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byBhIGpzb24tcnBjc2VydmVyLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCB7IFN0cmVhbSB9ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5jb25zdCBUcmFuc3BvcnRTdHJlYW0gPSByZXF1aXJlKCd3aW5zdG9uLXRyYW5zcG9ydCcpO1xuY29uc3QgeyBjb25maWd1cmUgfSA9IHJlcXVpcmUoJ3NhZmUtc3RhYmxlLXN0cmluZ2lmeScpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byBhIGpzb24tcnBjIHNlcnZlci5cbiAqIEB0eXBlIHtTdHJlYW19XG4gKiBAZXh0ZW5kcyB7VHJhbnNwb3J0U3RyZWFtfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEh0dHAgZXh0ZW5kcyBUcmFuc3BvcnRTdHJlYW0ge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBIdHRwIHRyYW5zcG9ydCBvYmplY3QgcmVzcG9uc2libGUgZm9yXG4gICAqIHBlcnNpc3RpbmcgbG9nIG1lc3NhZ2VzIGFuZCBtZXRhZGF0YSB0byBhIHRlcm1pbmFsIG9yIFRUWS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgJ2h0dHAnO1xuICAgIHRoaXMuc3NsID0gISFvcHRpb25zLnNzbDtcbiAgICB0aGlzLmhvc3QgPSBvcHRpb25zLmhvc3QgfHwgJ2xvY2FsaG9zdCc7XG4gICAgdGhpcy5wb3J0ID0gb3B0aW9ucy5wb3J0O1xuICAgIHRoaXMuYXV0aCA9IG9wdGlvbnMuYXV0aDtcbiAgICB0aGlzLnBhdGggPSBvcHRpb25zLnBhdGggfHwgJyc7XG4gICAgdGhpcy5tYXhpbXVtRGVwdGggPSBvcHRpb25zLm1heGltdW1EZXB0aDtcbiAgICB0aGlzLmFnZW50ID0gb3B0aW9ucy5hZ2VudDtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgdGhpcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICB0aGlzLmJhdGNoID0gb3B0aW9ucy5iYXRjaCB8fCBmYWxzZTtcbiAgICB0aGlzLmJhdGNoSW50ZXJ2YWwgPSBvcHRpb25zLmJhdGNoSW50ZXJ2YWwgfHwgNTAwMDtcbiAgICB0aGlzLmJhdGNoQ291bnQgPSBvcHRpb25zLmJhdGNoQ291bnQgfHwgMTA7XG4gICAgdGhpcy5iYXRjaE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmJhdGNoVGltZW91dElEID0gLTE7XG4gICAgdGhpcy5iYXRjaENhbGxiYWNrID0ge307XG5cbiAgICBpZiAoIXRoaXMucG9ydCkge1xuICAgICAgdGhpcy5wb3J0ID0gdGhpcy5zc2wgPyA0NDMgOiA4MDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb2dnaW5nIG1ldGhvZCBleHBvc2VkIHRvIFdpbnN0b24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGxvZyhpbmZvLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlcXVlc3QoaW5mbywgbnVsbCwgbnVsbCwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAocmVzICYmIHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKGBJbnZhbGlkIEhUVFAgU3RhdHVzIENvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd3YXJuJywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbG9nZ2VkJywgaW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZW1hcms6IChqY3J1Z3p6KSBGaXJlIGFuZCBmb3JnZXQgaGVyZSBzbyByZXF1ZXN0cyBkb250IGNhdXNlIGJ1ZmZlcmluZ1xuICAgIC8vIGFuZCBibG9jayBtb3JlIHJlcXVlc3RzIGZyb20gaGFwcGVuaW5nP1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVlcnkgdGhlIHRyYW5zcG9ydC4gT3B0aW9ucyBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gIExvZ2dseS1saWtlIHF1ZXJ5IG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHF1ZXJ5KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ3F1ZXJ5JyxcbiAgICAgIHBhcmFtczogdGhpcy5ub3JtYWxpemVRdWVyeShvcHRpb25zKVxuICAgIH07XG5cbiAgICBjb25zdCBhdXRoID0gb3B0aW9ucy5wYXJhbXMuYXV0aCB8fCBudWxsO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtcy5hdXRoO1xuXG4gICAgY29uc3QgcGF0aCA9IG9wdGlvbnMucGFyYW1zLnBhdGggfHwgbnVsbDtcbiAgICBkZWxldGUgb3B0aW9ucy5wYXJhbXMucGF0aDtcblxuICAgIHRoaXMuX3JlcXVlc3Qob3B0aW9ucywgYXV0aCwgcGF0aCwgKGVyciwgcmVzLCBib2R5KSA9PiB7XG4gICAgICBpZiAocmVzICYmIHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKGBJbnZhbGlkIEhUVFAgU3RhdHVzIENvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9nIHN0cmVhbSBmb3IgdGhpcyB0cmFuc3BvcnQuIE9wdGlvbnMgb2JqZWN0IGlzIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFN0cmVhbSBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7U3RyZWFtfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb25cbiAgICovXG4gIHN0cmVhbShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKCk7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ3N0cmVhbScsXG4gICAgICBwYXJhbXM6IG9wdGlvbnNcbiAgICB9O1xuXG4gICAgY29uc3QgcGF0aCA9IG9wdGlvbnMucGFyYW1zLnBhdGggfHwgbnVsbDtcbiAgICBkZWxldGUgb3B0aW9ucy5wYXJhbXMucGF0aDtcblxuICAgIGNvbnN0IGF1dGggPSBvcHRpb25zLnBhcmFtcy5hdXRoIHx8IG51bGw7XG4gICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zLmF1dGg7XG5cbiAgICBsZXQgYnVmZiA9ICcnO1xuICAgIGNvbnN0IHJlcSA9IHRoaXMuX3JlcXVlc3Qob3B0aW9ucywgYXV0aCwgcGF0aCk7XG5cbiAgICBzdHJlYW0uZGVzdHJveSA9ICgpID0+IHJlcS5kZXN0cm95KCk7XG4gICAgcmVxLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICBkYXRhID0gKGJ1ZmYgKyBkYXRhKS5zcGxpdCgvXFxuKy8pO1xuICAgICAgY29uc3QgbCA9IGRhdGEubGVuZ3RoIC0gMTtcblxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnbG9nJywgSlNPTi5wYXJzZShkYXRhW2ldKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWZmID0gZGF0YVtsXTtcbiAgICB9KTtcbiAgICByZXEub24oJ2Vycm9yJywgZXJyID0+IHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycikpO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcmVxdWVzdCB0byBhIHdpbnN0b25kIHNlcnZlciBvciBhbnkgaHR0cCBzZXJ2ZXIgd2hpY2ggY2FuXG4gICAqIGhhbmRsZSBqc29uLXJwYy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2VudCB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3Q/fSBhdXRoIC0gYXV0aGVudGljYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHJlcXVlc3QgcGF0aFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqL1xuICBfcmVxdWVzdChvcHRpb25zLCBhdXRoLCBwYXRoLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgYXV0aCA9IGF1dGggfHwgdGhpcy5hdXRoO1xuICAgIHBhdGggPSBwYXRoIHx8IHRoaXMucGF0aCB8fCAnJztcblxuICAgIGlmICh0aGlzLmJhdGNoKSB7XG4gICAgICB0aGlzLl9kb0JhdGNoKG9wdGlvbnMsIGNhbGxiYWNrLCBhdXRoLCBwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZG9SZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCBhdXRoLCBwYXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBvciBtZW1vcml6ZSB0aGUgb3B0aW9ucyBhY2NvcmRpbmcgdG8gYmF0Y2ggY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZW50IHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0P30gYXV0aCAtIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSByZXF1ZXN0IHBhdGhcbiAgICovXG4gIF9kb0JhdGNoKG9wdGlvbnMsIGNhbGxiYWNrLCBhdXRoLCBwYXRoKSB7XG4gICAgdGhpcy5iYXRjaE9wdGlvbnMucHVzaChvcHRpb25zKTtcbiAgICBpZiAodGhpcy5iYXRjaE9wdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBGaXJzdCBtZXNzYWdlIHN0b3JlZCwgaXQncyB0aW1lIHRvIHN0YXJ0IHRoZSB0aW1lb3V0IVxuICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgdGhpcy5iYXRjaENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLmJhdGNoVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRpbWVvdXQgaXMgcmVhY2hlZCwgc2VuZCBhbGwgbWVzc2FnZXMgdG8gZW5kcG9pbnRcbiAgICAgICAgbWUuYmF0Y2hUaW1lb3V0SUQgPSAtMTtcbiAgICAgICAgbWUuX2RvQmF0Y2hSZXF1ZXN0KG1lLmJhdGNoQ2FsbGJhY2ssIGF1dGgsIHBhdGgpO1xuICAgICAgfSwgdGhpcy5iYXRjaEludGVydmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmF0Y2hPcHRpb25zLmxlbmd0aCA9PT0gdGhpcy5iYXRjaENvdW50KSB7XG4gICAgICAvLyBtYXggYmF0Y2ggY291bnQgaXMgcmVhY2hlZCwgc2VuZCBhbGwgbWVzc2FnZXMgdG8gZW5kcG9pbnRcbiAgICAgIHRoaXMuX2RvQmF0Y2hSZXF1ZXN0KHRoaXMuYmF0Y2hDYWxsYmFjaywgYXV0aCwgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgcmVxdWVzdCB3aXRoIHRoZSBtZW1vcml6ZWQgYmF0Y2ggb3B0aW9ucywgc3RvcCB0aGUgYmF0Y2ggdGltZW91dFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0P30gYXV0aCAtIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSByZXF1ZXN0IHBhdGhcbiAgICovXG4gIF9kb0JhdGNoUmVxdWVzdChjYWxsYmFjaywgYXV0aCwgcGF0aCkge1xuICAgIGlmICh0aGlzLmJhdGNoVGltZW91dElEID4gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYmF0Y2hUaW1lb3V0SUQpO1xuICAgICAgdGhpcy5iYXRjaFRpbWVvdXRJRCA9IC0xO1xuICAgIH1cbiAgICBjb25zdCBiYXRjaE9wdGlvbnNDb3B5ID0gdGhpcy5iYXRjaE9wdGlvbnMuc2xpY2UoKTtcbiAgICB0aGlzLmJhdGNoT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2RvUmVxdWVzdChiYXRjaE9wdGlvbnNDb3B5LCBjYWxsYmFjaywgYXV0aCwgcGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHJlcXVlc3QgdG8gYSB3aW5zdG9uZCBzZXJ2ZXIgb3IgYW55IGh0dHAgc2VydmVyIHdoaWNoIGNhblxuICAgKiBoYW5kbGUganNvbi1ycGMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMgLSBPcHRpb25zIHRvIHNlbnQgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtPYmplY3Q/fSBhdXRoIC0gYXV0aGVudGljYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHJlcXVlc3QgcGF0aFxuICAgKi9cbiAgX2RvUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgYXV0aCwgcGF0aCkge1xuICAgIC8vIFByZXBhcmUgb3B0aW9ucyBmb3Igb3V0Z29pbmcgSFRUUCByZXF1ZXN0XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyk7XG4gICAgaWYgKGF1dGggJiYgYXV0aC5iZWFyZXIpIHtcbiAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHthdXRoLmJlYXJlcn1gO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSAodGhpcy5zc2wgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Qoe1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBob3N0OiB0aGlzLmhvc3QsXG4gICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICBwYXRoOiBgLyR7cGF0aC5yZXBsYWNlKC9eXFwvLywgJycpfWAsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYXV0aDogKGF1dGggJiYgYXV0aC51c2VybmFtZSAmJiBhdXRoLnBhc3N3b3JkKSA/IChgJHthdXRoLnVzZXJuYW1lfToke2F1dGgucGFzc3dvcmR9YCkgOiAnJyxcbiAgICAgIGFnZW50OiB0aGlzLmFnZW50XG4gICAgfSk7XG5cbiAgICByZXEub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgIHJlcS5vbigncmVzcG9uc2UnLCByZXMgPT4gKFxuICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiBjYWxsYmFjayhudWxsLCByZXMpKS5yZXN1bWUoKVxuICAgICkpO1xuICAgIGNvbnN0IGpzb25TdHJpbmdpZnkgPSBjb25maWd1cmUoe1xuICAgICAgLi4uKHRoaXMubWF4aW11bURlcHRoICYmIHsgbWF4aW11bURlcHRoOiB0aGlzLm1heGltdW1EZXB0aCB9KVxuICAgIH0pO1xuICAgIHJlcS5lbmQoQnVmZmVyLmZyb20oanNvblN0cmluZ2lmeShvcHRpb25zLCB0aGlzLm9wdGlvbnMucmVwbGFjZXIpLCAndXRmOCcpKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/http.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * transports.js: Set of all transports Winston knows about.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\n/**\n * TODO: add property description.\n * @type {Console}\n */\nObject.defineProperty(exports, \"Console\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./console */ \"(rsc)/./node_modules/winston/lib/winston/transports/console.js\");\n  }\n}));\n\n/**\n * TODO: add property description.\n * @type {File}\n */\nObject.defineProperty(exports, \"File\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./file */ \"(rsc)/./node_modules/winston/lib/winston/transports/file.js\");\n  }\n}));\n\n/**\n * TODO: add property description.\n * @type {Http}\n */\nObject.defineProperty(exports, \"Http\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./http */ \"(rsc)/./node_modules/winston/lib/winston/transports/http.js\");\n  }\n}));\n\n/**\n * TODO: add property description.\n * @type {Stream}\n */\nObject.defineProperty(exports, \"Stream\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./stream */ \"(rsc)/./node_modules/winston/lib/winston/transports/stream.js\");\n  }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxpRkFBVztBQUM5QjtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQywyRUFBUTtBQUMzQjtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQywyRUFBUTtBQUMzQjtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQywrRUFBVTtBQUM3QjtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FjY2Vzc29yeS1zYWxlcy1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vdHJhbnNwb3J0cy9pbmRleC5qcz80MWIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdHJhbnNwb3J0cy5qczogU2V0IG9mIGFsbCB0cmFuc3BvcnRzIFdpbnN0b24ga25vd3MgYWJvdXQuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUT0RPOiBhZGQgcHJvcGVydHkgZGVzY3JpcHRpb24uXG4gKiBAdHlwZSB7Q29uc29sZX1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDb25zb2xlJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnLi9jb25zb2xlJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRPRE86IGFkZCBwcm9wZXJ0eSBkZXNjcmlwdGlvbi5cbiAqIEB0eXBlIHtGaWxlfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZpbGUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiByZXF1aXJlKCcuL2ZpbGUnKTtcbiAgfVxufSk7XG5cbi8qKlxuICogVE9ETzogYWRkIHByb3BlcnR5IGRlc2NyaXB0aW9uLlxuICogQHR5cGUge0h0dHB9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnSHR0cCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4vaHR0cCcpO1xuICB9XG59KTtcblxuLyoqXG4gKiBUT0RPOiBhZGQgcHJvcGVydHkgZGVzY3JpcHRpb24uXG4gKiBAdHlwZSB7U3RyZWFtfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1N0cmVhbScsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4vc3RyZWFtJyk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/stream.js":
/*!***************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/stream.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * stream.js: Transport for outputting to any arbitrary stream.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst isStream = __webpack_require__(/*! is-stream */ \"(rsc)/./node_modules/is-stream/index.js\");\nconst { MESSAGE } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\n\n/**\n * Transport for outputting to any arbitrary stream.\n * @type {Stream}\n * @extends {TransportStream}\n */\nmodule.exports = class Stream extends TransportStream {\n  /**\n   * Constructor function for the Console transport object responsible for\n   * persisting log messages and metadata to a terminal or TTY.\n   * @param {!Object} [options={}] - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    if (!options.stream || !isStream(options.stream)) {\n      throw new Error('options.stream is required.');\n    }\n\n    // We need to listen for drain events when write() returns false. This can\n    // make node mad at times.\n    this._stream = options.stream;\n    this._stream.setMaxListeners(Infinity);\n    this.isObjectMode = options.stream._writableState.objectMode;\n    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;\n  }\n\n  /**\n   * Core logging method exposed to Winston.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback) {\n    setImmediate(() => this.emit('logged', info));\n    if (this.isObjectMode) {\n      this._stream.write(info);\n      if (callback) {\n        callback(); // eslint-disable-line callback-return\n      }\n      return;\n    }\n\n    this._stream.write(`${info[MESSAGE]}${this.eol}`);\n    if (callback) {\n      callback(); // eslint-disable-line callback-return\n    }\n    return;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsMERBQVc7QUFDcEMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyw4REFBYTtBQUN6QyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2Qix3QkFBd0IsbUJBQU8sQ0FBQywwRUFBbUI7O0FBRW5EO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsV0FBVztBQUNqQztBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGNBQWMsRUFBRSxTQUFTO0FBQ25EO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNjZXNzb3J5LXNhbGVzLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL3N0cmVhbS5qcz9iMzE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogc3RyZWFtLmpzOiBUcmFuc3BvcnQgZm9yIG91dHB1dHRpbmcgdG8gYW55IGFyYml0cmFyeSBzdHJlYW0uXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbmNvbnN0IHsgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IFRyYW5zcG9ydFN0cmVhbSA9IHJlcXVpcmUoJ3dpbnN0b24tdHJhbnNwb3J0Jyk7XG5cbi8qKlxuICogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIGFueSBhcmJpdHJhcnkgc3RyZWFtLlxuICogQHR5cGUge1N0cmVhbX1cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnRTdHJlYW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU3RyZWFtIGV4dGVuZHMgVHJhbnNwb3J0U3RyZWFtIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgQ29uc29sZSB0cmFuc3BvcnQgb2JqZWN0IHJlc3BvbnNpYmxlIGZvclxuICAgKiBwZXJzaXN0aW5nIGxvZyBtZXNzYWdlcyBhbmQgbWV0YWRhdGEgdG8gYSB0ZXJtaW5hbCBvciBUVFkuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgaWYgKCFvcHRpb25zLnN0cmVhbSB8fCAhaXNTdHJlYW0ob3B0aW9ucy5zdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyZWFtIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gbGlzdGVuIGZvciBkcmFpbiBldmVudHMgd2hlbiB3cml0ZSgpIHJldHVybnMgZmFsc2UuIFRoaXMgY2FuXG4gICAgLy8gbWFrZSBub2RlIG1hZCBhdCB0aW1lcy5cbiAgICB0aGlzLl9zdHJlYW0gPSBvcHRpb25zLnN0cmVhbTtcbiAgICB0aGlzLl9zdHJlYW0uc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KTtcbiAgICB0aGlzLmlzT2JqZWN0TW9kZSA9IG9wdGlvbnMuc3RyZWFtLl93cml0YWJsZVN0YXRlLm9iamVjdE1vZGU7XG4gICAgdGhpcy5lb2wgPSAodHlwZW9mIG9wdGlvbnMuZW9sID09PSAnc3RyaW5nJykgPyBvcHRpb25zLmVvbCA6IG9zLkVPTDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGxvZ2dpbmcgbWV0aG9kIGV4cG9zZWQgdG8gV2luc3Rvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgbG9nKGluZm8sIGNhbGxiYWNrKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuZW1pdCgnbG9nZ2VkJywgaW5mbykpO1xuICAgIGlmICh0aGlzLmlzT2JqZWN0TW9kZSkge1xuICAgICAgdGhpcy5fc3RyZWFtLndyaXRlKGluZm8pO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyZWFtLndyaXRlKGAke2luZm9bTUVTU0FHRV19JHt0aGlzLmVvbH1gKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/package.json":
/*!*******************************************!*\
  !*** ./node_modules/winston/package.json ***!
  \*******************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"winston","description":"A logger for just about everything.","version":"3.18.3","author":"Charlie Robbins <charlie.robbins@gmail.com>","maintainers":["David Hyde <dabh@alumni.stanford.edu>"],"repository":{"type":"git","url":"https://github.com/winstonjs/winston.git"},"keywords":["winston","logger","logging","logs","sysadmin","bunyan","pino","loglevel","tools","json","stream"],"dependencies":{"@dabh/diagnostics":"^2.0.8","@colors/colors":"^1.6.0","async":"^3.2.3","is-stream":"^2.0.0","logform":"^2.7.0","one-time":"^1.0.0","readable-stream":"^3.4.0","safe-stable-stringify":"^2.3.1","stack-trace":"0.0.x","triple-beam":"^1.3.0","winston-transport":"^4.9.0"},"devDependencies":{"@babel/cli":"^7.23.9","@babel/core":"^7.24.0","@babel/preset-env":"^7.24.0","@dabh/eslint-config-populist":"^4.4.0","@types/node":"^20.11.24","abstract-winston-transport":"^0.5.1","assume":"^2.2.0","cross-spawn-async":"^2.2.5","eslint":"^8.57.0","hock":"^1.4.1","mocha":"^10.3.0","nyc":"^17.1.0","rimraf":"5.0.1","split2":"^4.1.0","std-mocks":"^2.0.0","through2":"^4.0.2","winston-compat":"^0.1.5"},"main":"./lib/winston.js","browser":"./dist/winston","types":"./index.d.ts","scripts":{"lint":"eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist","test":"rimraf test/fixtures/logs/* && mocha","test:coverage":"nyc npm run test:unit","test:unit":"mocha test/unit","test:integration":"mocha test/integration","build":"rimraf dist && babel lib -d dist","prepublishOnly":"npm run build"},"engines":{"node":">= 12.0.0"},"license":"MIT"}');

/***/ })

};
;